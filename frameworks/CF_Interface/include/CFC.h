// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:150

#ifndef _TAO_IDL_CFC_4LMNJP_H_
#define _TAO_IDL_CFC_4LMNJP_H_


#include /**/ "ace/config-all.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */


#include "tao/AnyTypeCode/AnyTypeCode_methods.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/ORB.h"
#include "tao/SystemException.h"
#include "tao/UserException.h"
#include "tao/Basic_Types.h"
#include "tao/ORB_Constants.h"
#include "tao/Object.h"
#include "tao/AnyTypeCode/TypeCode.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/String_Manager_T.h"
#include "tao/Sequence_T.h"
#include "tao/Objref_VarOut_T.h"
#include "tao/Seq_Var_T.h"
#include "tao/Seq_Out_T.h"
#include "tao/VarOut_T.h"
#include "tao/Arg_Traits_T.h"
#include "tao/Basic_Arguments.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/Any_Insert_Policy_T.h"
#include "tao/Basic_Argument_T.h"
#include "tao/Fixed_Size_Argument_T.h"
#include "tao/Var_Size_Argument_T.h"
#include "tao/Object_Argument_T.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include /**/ "tao/Version.h"
#include /**/ "tao/Versioned_Namespace.h"

#if TAO_MAJOR_VERSION != 2 || TAO_MINOR_VERSION != 0 || TAO_BETA_VERSION != 4
#error This file should be regenerated with TAO_IDL from version 2.0a
#endif

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO 

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_root/root_ch.cpp:162
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


namespace TAO
{
  class Collocation_Proxy_Broker;
  template<typename T> class Narrow_Utils;
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_module/module_ch.cpp:41

namespace CF
{

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_FILE__VAR_OUT_CH_)
#define _CF_FILE__VAR_OUT_CH_

  class File;
  typedef File *File_ptr;

  typedef
    TAO_Objref_Var_T<
        File
      >
    File_var;
  
  typedef
    TAO_Objref_Out_T<
        File
      >
    File_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_RESOURCE__VAR_OUT_CH_)
#define _CF_RESOURCE__VAR_OUT_CH_

  class Resource;
  typedef Resource *Resource_ptr;

  typedef
    TAO_Objref_Var_T<
        Resource
      >
    Resource_var;
  
  typedef
    TAO_Objref_Out_T<
        Resource
      >
    Resource_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_APPLICATION__VAR_OUT_CH_)
#define _CF_APPLICATION__VAR_OUT_CH_

  class Application;
  typedef Application *Application_ptr;

  typedef
    TAO_Objref_Var_T<
        Application
      >
    Application_var;
  
  typedef
    TAO_Objref_Out_T<
        Application
      >
    Application_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_DEVICE__VAR_OUT_CH_)
#define _CF_DEVICE__VAR_OUT_CH_

  class Device;
  typedef Device *Device_ptr;

  typedef
    TAO_Objref_Var_T<
        Device
      >
    Device_var;
  
  typedef
    TAO_Objref_Out_T<
        Device
      >
    Device_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_APPLICATIONFACTORY__VAR_OUT_CH_)
#define _CF_APPLICATIONFACTORY__VAR_OUT_CH_

  class ApplicationFactory;
  typedef ApplicationFactory *ApplicationFactory_ptr;

  typedef
    TAO_Objref_Var_T<
        ApplicationFactory
      >
    ApplicationFactory_var;
  
  typedef
    TAO_Objref_Out_T<
        ApplicationFactory
      >
    ApplicationFactory_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_DEVICEMANAGER__VAR_OUT_CH_)
#define _CF_DEVICEMANAGER__VAR_OUT_CH_

  class DeviceManager;
  typedef DeviceManager *DeviceManager_ptr;

  typedef
    TAO_Objref_Var_T<
        DeviceManager
      >
    DeviceManager_var;
  
  typedef
    TAO_Objref_Out_T<
        DeviceManager
      >
    DeviceManager_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_type.cpp:261

  struct DataType;

  typedef
    ::TAO_Var_Var_T<
        DataType
      >
    DataType_var;
  
  typedef
    ::TAO_Out_T<
        DataType
      >
    DataType_out;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_ch.cpp:49

  struct  DataType
  {

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef DataType_var _var_type;
    typedef DataType_out _out_type;

    static void _tao_any_destructor (void *);
    
    ::TAO::String_Manager id;
    ::CORBA::Any value;
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_DataType;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

  class  InvalidProfile : public ::CORBA::UserException
  {
  public:
    
    InvalidProfile (void);
    InvalidProfile (const InvalidProfile &);
    ~InvalidProfile (void);

    InvalidProfile &operator= (const InvalidProfile &);

    static void _tao_any_destructor (void *);

    static InvalidProfile *_downcast ( ::CORBA::Exception *);
    static const InvalidProfile *_downcast ( ::CORBA::Exception const *);

    static ::CORBA::Exception *_alloc (void);

    virtual ::CORBA::Exception *_tao_duplicate (void) const;

    virtual void _raise (void) const;

    virtual void _tao_encode (TAO_OutputCDR &cdr) const;
    virtual void _tao_decode (TAO_InputCDR &cdr);
    

    virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_InvalidProfile;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:100

#if !defined (_CF_PROPERTIES_CH_)
#define _CF_PROPERTIES_CH_

  class Properties;

  typedef
    ::TAO_VarSeq_Var_T<
        Properties
      >
    Properties_var;

  typedef
    ::TAO_Seq_Out_T<
        Properties
      >
    Properties_out;

  class  Properties
    : public
        ::TAO::unbounded_value_sequence<
            DataType
          >
  {
  public:
    Properties (void);
    Properties ( ::CORBA::ULong max);
    Properties (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      DataType* buffer, 
      ::CORBA::Boolean release = false);
    Properties (const Properties &);
    virtual ~Properties (void);
    

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef Properties_var _var_type;
    typedef Properties_out _out_type;

    static void _tao_any_destructor (void *);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_Properties;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

  class  InvalidObjectReference : public ::CORBA::UserException
  {
  public:
    
    ::TAO::String_Manager msg;
    InvalidObjectReference (void);
    InvalidObjectReference (const InvalidObjectReference &);
    ~InvalidObjectReference (void);

    InvalidObjectReference &operator= (const InvalidObjectReference &);

    static void _tao_any_destructor (void *);

    static InvalidObjectReference *_downcast ( ::CORBA::Exception *);
    static const InvalidObjectReference *_downcast ( ::CORBA::Exception const *);

    static ::CORBA::Exception *_alloc (void);

    virtual ::CORBA::Exception *_tao_duplicate (void) const;

    virtual void _raise (void) const;

    virtual void _tao_encode (TAO_OutputCDR &cdr) const;
    virtual void _tao_decode (TAO_InputCDR &cdr);
    

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

    InvalidObjectReference (
        const char * _tao_msg);

    virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_InvalidObjectReference;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:100

#if !defined (_CF_OCTETSEQUENCE_CH_)
#define _CF_OCTETSEQUENCE_CH_

  class OctetSequence;

  typedef
    ::TAO_FixedSeq_Var_T<
        OctetSequence
      >
    OctetSequence_var;

  typedef
    ::TAO_Seq_Out_T<
        OctetSequence
      >
    OctetSequence_out;

  class  OctetSequence
    : public
        ::TAO::unbounded_value_sequence<
            ::CORBA::Octet
          >
  {
  public:
    OctetSequence (void);
    OctetSequence ( ::CORBA::ULong max);
    OctetSequence (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      ::CORBA::Octet* buffer, 
      ::CORBA::Boolean release = false);
    OctetSequence (const OctetSequence &);
    virtual ~OctetSequence (void);
    

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef OctetSequence_var _var_type;
    typedef OctetSequence_out _out_type;

    static void _tao_any_destructor (void *);

    

#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
    OctetSequence (
        ::CORBA::ULong length,
        const ACE_Message_Block* mb
      )
      : ::TAO::unbounded_value_sequence< ::CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE == 1 */
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_OctetSequence;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:100

#if !defined (_CF_STRINGSEQUENCE_CH_)
#define _CF_STRINGSEQUENCE_CH_

  class StringSequence;

  typedef
    ::TAO_VarSeq_Var_T<
        StringSequence
      >
    StringSequence_var;

  typedef
    ::TAO_Seq_Out_T<
        StringSequence
      >
    StringSequence_out;

  class  StringSequence
    : public
        ::TAO::unbounded_basic_string_sequence<char>
  {
  public:
    StringSequence (void);
    StringSequence ( ::CORBA::ULong max);
    StringSequence (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      ::CORBA::Char ** buffer, 
      ::CORBA::Boolean release = false);
    StringSequence (const StringSequence &);
    virtual ~StringSequence (void);
    

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef StringSequence_var _var_type;
    typedef StringSequence_out _out_type;

    static void _tao_any_destructor (void *);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_StringSequence;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

  class  UnknownProperties : public ::CORBA::UserException
  {
  public:
    
    CF::Properties invalidProperties;
    UnknownProperties (void);
    UnknownProperties (const UnknownProperties &);
    ~UnknownProperties (void);

    UnknownProperties &operator= (const UnknownProperties &);

    static void _tao_any_destructor (void *);

    static UnknownProperties *_downcast ( ::CORBA::Exception *);
    static const UnknownProperties *_downcast ( ::CORBA::Exception const *);

    static ::CORBA::Exception *_alloc (void);

    virtual ::CORBA::Exception *_tao_duplicate (void) const;

    virtual void _raise (void) const;

    virtual void _tao_encode (TAO_OutputCDR &cdr) const;
    virtual void _tao_decode (TAO_InputCDR &cdr);
    

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

    UnknownProperties (
        const CF::Properties & _tao_invalidProperties);

    virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_UnknownProperties;

  // TAO_IDL - Generated from
  // .\be\be_type.cpp:261

  struct DeviceAssignmentType;

  typedef
    ::TAO_Var_Var_T<
        DeviceAssignmentType
      >
    DeviceAssignmentType_var;
  
  typedef
    ::TAO_Out_T<
        DeviceAssignmentType
      >
    DeviceAssignmentType_out;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_ch.cpp:49

  struct  DeviceAssignmentType
  {

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef DeviceAssignmentType_var _var_type;
    typedef DeviceAssignmentType_out _out_type;

    static void _tao_any_destructor (void *);
    
    ::TAO::String_Manager componentId;
    ::TAO::String_Manager assignedDeviceId;
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_DeviceAssignmentType;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:100

#if !defined (_CF_DEVICEASSIGNMENTSEQUENCE_CH_)
#define _CF_DEVICEASSIGNMENTSEQUENCE_CH_

  class DeviceAssignmentSequence;

  typedef
    ::TAO_VarSeq_Var_T<
        DeviceAssignmentSequence
      >
    DeviceAssignmentSequence_var;

  typedef
    ::TAO_Seq_Out_T<
        DeviceAssignmentSequence
      >
    DeviceAssignmentSequence_out;

  class  DeviceAssignmentSequence
    : public
        ::TAO::unbounded_value_sequence<
            DeviceAssignmentType
          >
  {
  public:
    DeviceAssignmentSequence (void);
    DeviceAssignmentSequence ( ::CORBA::ULong max);
    DeviceAssignmentSequence (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      DeviceAssignmentType* buffer, 
      ::CORBA::Boolean release = false);
    DeviceAssignmentSequence (const DeviceAssignmentSequence &);
    virtual ~DeviceAssignmentSequence (void);
    

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef DeviceAssignmentSequence_var _var_type;
    typedef DeviceAssignmentSequence_out _out_type;

    static void _tao_any_destructor (void *);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_DeviceAssignmentSequence;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/enum_ch.cpp:47

  enum ErrorNumberType
  {
    CFNOTSET,
    CFE2BIG,
    CFEACCES,
    CFEAGAIN,
    CFEBADF,
    CFEBADMSG,
    CFEBUSY,
    CFECANCELED,
    CFECHILD,
    CFEDEADLK,
    CFEDOM,
    CFEEXIST,
    CFEFAULT,
    CFEFBIG,
    CFEINPROGRESS,
    CFEINTR,
    CFEINVAL,
    CFEIO,
    CFEISDIR,
    CFEMFILE,
    CFEMLINK,
    CFEMSGSIZE,
    CFENAMETOOLONG,
    CFENFILE,
    CFENODEV,
    CFENOENT,
    CFENOEXEC,
    CFENOLCK,
    CFENOMEM,
    CFENOSPC,
    CFENOSYS,
    CFENOTDIR,
    CFENOTEMPTY,
    CFENOTSUP,
    CFENOTTY,
    CFENXIO,
    CFEPERM,
    CFEPIPE,
    CFERANGE,
    CFEROFS,
    CFESPIPE,
    CFESRCH,
    CFETIMEDOUT,
    CFEXDEV
  };

  typedef ErrorNumberType &ErrorNumberType_out;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_ErrorNumberType;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

  class  InvalidFileName : public ::CORBA::UserException
  {
  public:
    
    CF::ErrorNumberType errorNumber;
    ::TAO::String_Manager msg;
    InvalidFileName (void);
    InvalidFileName (const InvalidFileName &);
    ~InvalidFileName (void);

    InvalidFileName &operator= (const InvalidFileName &);

    static void _tao_any_destructor (void *);

    static InvalidFileName *_downcast ( ::CORBA::Exception *);
    static const InvalidFileName *_downcast ( ::CORBA::Exception const *);

    static ::CORBA::Exception *_alloc (void);

    virtual ::CORBA::Exception *_tao_duplicate (void) const;

    virtual void _raise (void) const;

    virtual void _tao_encode (TAO_OutputCDR &cdr) const;
    virtual void _tao_decode (TAO_InputCDR &cdr);
    

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

    InvalidFileName (
        CF::ErrorNumberType _tao_errorNumber,
        const char * _tao_msg);

    virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_InvalidFileName;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

  class  FileException : public ::CORBA::UserException
  {
  public:
    
    CF::ErrorNumberType errorNumber;
    ::TAO::String_Manager msg;
    FileException (void);
    FileException (const FileException &);
    ~FileException (void);

    FileException &operator= (const FileException &);

    static void _tao_any_destructor (void *);

    static FileException *_downcast ( ::CORBA::Exception *);
    static const FileException *_downcast ( ::CORBA::Exception const *);

    static ::CORBA::Exception *_alloc (void);

    virtual ::CORBA::Exception *_tao_duplicate (void) const;

    virtual void _raise (void) const;

    virtual void _tao_encode (TAO_OutputCDR &cdr) const;
    virtual void _tao_decode (TAO_InputCDR &cdr);
    

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

    FileException (
        CF::ErrorNumberType _tao_errorNumber,
        const char * _tao_msg);

    virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_FileException;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:100

#if !defined (_CF_DEVICESEQUENCE_CH_)
#define _CF_DEVICESEQUENCE_CH_

  class DeviceSequence;

  typedef
    ::TAO_VarSeq_Var_T<
        DeviceSequence
      >
    DeviceSequence_var;

  typedef
    ::TAO_Seq_Out_T<
        DeviceSequence
      >
    DeviceSequence_out;

  class  DeviceSequence
    : public
        ::TAO::unbounded_object_reference_sequence<
            Device,
            Device_var
          >
  {
  public:
    DeviceSequence (void);
    DeviceSequence ( ::CORBA::ULong max);
    DeviceSequence (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      Device_ptr* buffer, 
      ::CORBA::Boolean release = false);
    DeviceSequence (const DeviceSequence &);
    virtual ~DeviceSequence (void);
    

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef DeviceSequence_var _var_type;
    typedef DeviceSequence_out _out_type;

    static void _tao_any_destructor (void *);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_DeviceSequence;

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_AGGREGATEDEVICE__VAR_OUT_CH_)
#define _CF_AGGREGATEDEVICE__VAR_OUT_CH_

  class AggregateDevice;
  typedef AggregateDevice *AggregateDevice_ptr;

  typedef
    TAO_Objref_Var_T<
        AggregateDevice
      >
    AggregateDevice_var;
  
  typedef
    TAO_Objref_Out_T<
        AggregateDevice
      >
    AggregateDevice_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  AggregateDevice
    : public virtual ::CORBA::Object
  {
  public:
    friend class TAO::Narrow_Utils<AggregateDevice>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef AggregateDevice_ptr _ptr_type;
    typedef AggregateDevice_var _var_type;
    typedef AggregateDevice_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static AggregateDevice_ptr _duplicate (AggregateDevice_ptr obj);

    static void _tao_release (AggregateDevice_ptr obj);

    static AggregateDevice_ptr _narrow (::CORBA::Object_ptr obj);
    static AggregateDevice_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static AggregateDevice_ptr _nil (void);

    virtual ::CF::DeviceSequence * devices (
      void);

    virtual void addDevice (
      ::CF::Device_ptr associatedDevice);

    virtual void removeDevice (
      ::CF::Device_ptr associatedDevice);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_AggregateDevice_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    AggregateDevice (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_AggregateDevice_setup_collocation (void);

    // Concrete non-local interface only.
    AggregateDevice (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    AggregateDevice (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~AggregateDevice (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    AggregateDevice (const AggregateDevice &);

    void operator= (const AggregateDevice &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_AggregateDevice;

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_FILESYSTEM__VAR_OUT_CH_)
#define _CF_FILESYSTEM__VAR_OUT_CH_

  class FileSystem;
  typedef FileSystem *FileSystem_ptr;

  typedef
    TAO_Objref_Var_T<
        FileSystem
      >
    FileSystem_var;
  
  typedef
    TAO_Objref_Out_T<
        FileSystem
      >
    FileSystem_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  FileSystem
    : public virtual ::CORBA::Object
  {
  public:
    friend class TAO::Narrow_Utils<FileSystem>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef FileSystem_ptr _ptr_type;
    typedef FileSystem_var _var_type;
    typedef FileSystem_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static FileSystem_ptr _duplicate (FileSystem_ptr obj);

    static void _tao_release (FileSystem_ptr obj);

    static FileSystem_ptr _narrow (::CORBA::Object_ptr obj);
    static FileSystem_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static FileSystem_ptr _nil (void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  UnknownFileSystemProperties : public ::CORBA::UserException
    {
    public:
      
      CF::Properties invalidProperties;
      UnknownFileSystemProperties (void);
      UnknownFileSystemProperties (const UnknownFileSystemProperties &);
      ~UnknownFileSystemProperties (void);

      UnknownFileSystemProperties &operator= (const UnknownFileSystemProperties &);

      static void _tao_any_destructor (void *);

      static UnknownFileSystemProperties *_downcast ( ::CORBA::Exception *);
      static const UnknownFileSystemProperties *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      UnknownFileSystemProperties (
          const CF::Properties & _tao_invalidProperties);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_UnknownFileSystemProperties;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_constant/constant_ch.cpp:41

    static const char *const SIZE;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_constant/constant_ch.cpp:41

    static const char *const AVAILABLE_SIZE;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/enum_ch.cpp:47

    enum FileType
    {
      PLAIN,
      DIRECTORY,
      FILE_SYSTEM
    };

    typedef FileType &FileType_out;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_FileType;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:261

    struct FileInformationType;

    typedef
      ::TAO_Var_Var_T<
          FileInformationType
        >
      FileInformationType_var;
    
    typedef
      ::TAO_Out_T<
          FileInformationType
        >
      FileInformationType_out;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_ch.cpp:49

    struct  FileInformationType
    {

      // TAO_IDL - Generated from
      // .\be\be_type.cpp:307
      
      typedef FileInformationType_var _var_type;
      typedef FileInformationType_out _out_type;

      static void _tao_any_destructor (void *);
      
      ::TAO::String_Manager name;
      CF::FileSystem::FileType kind;
      ::CORBA::ULongLong size;
      CF::Properties fileProperties;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_FileInformationType;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:100

#if !defined (_CF_FILESYSTEM_FILEINFORMATIONSEQUENCE_CH_)
#define _CF_FILESYSTEM_FILEINFORMATIONSEQUENCE_CH_

    class FileInformationSequence;

    typedef
      ::TAO_VarSeq_Var_T<
          FileInformationSequence
        >
      FileInformationSequence_var;

    typedef
      ::TAO_Seq_Out_T<
          FileInformationSequence
        >
      FileInformationSequence_out;

    class  FileInformationSequence
      : public
          ::TAO::unbounded_value_sequence<
              FileInformationType
            >
    {
    public:
      FileInformationSequence (void);
      FileInformationSequence ( ::CORBA::ULong max);
      FileInformationSequence (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        FileInformationType* buffer, 
        ::CORBA::Boolean release = false);
      FileInformationSequence (const FileInformationSequence &);
      virtual ~FileInformationSequence (void);
      

      // TAO_IDL - Generated from
      // .\be\be_type.cpp:307
      
      typedef FileInformationSequence_var _var_type;
      typedef FileInformationSequence_out _out_type;

      static void _tao_any_destructor (void *);
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_FileInformationSequence;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_constant/constant_ch.cpp:41

    static const char *const CREATED_TIME_ID;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_constant/constant_ch.cpp:41

    static const char *const MODIFIED_TIME_ID;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_constant/constant_ch.cpp:41

    static const char *const LAST_ACCESS_TIME_ID;

    virtual void remove (
      const char * fileName);

    virtual void copy (
      const char * sourceFileName,
      const char * destinationFileName);

    virtual ::CORBA::Boolean exists (
      const char * fileName);

    virtual ::CF::FileSystem::FileInformationSequence * list (
      const char * pattern);

    virtual ::CF::File_ptr create (
      const char * fileName);

    virtual ::CF::File_ptr open (
      const char * fileName,
      ::CORBA::Boolean read_Only);

    virtual void mkdir (
      const char * directoryName);

    virtual void rmdir (
      const char * directoryName);

    virtual void query (
      ::CF::Properties & fileSystemProperties);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_FileSystem_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    FileSystem (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_FileSystem_setup_collocation (void);

    // Concrete non-local interface only.
    FileSystem (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    FileSystem (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~FileSystem (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    FileSystem (const FileSystem &);

    void operator= (const FileSystem &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_FileSystem;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  File
    : public virtual ::CORBA::Object
  {
  public:
    friend class TAO::Narrow_Utils<File>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef File_ptr _ptr_type;
    typedef File_var _var_type;
    typedef File_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static File_ptr _duplicate (File_ptr obj);

    static void _tao_release (File_ptr obj);

    static File_ptr _narrow (::CORBA::Object_ptr obj);
    static File_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static File_ptr _nil (void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  IOException : public ::CORBA::UserException
    {
    public:
      
      CF::ErrorNumberType errorNumber;
      ::TAO::String_Manager msg;
      IOException (void);
      IOException (const IOException &);
      ~IOException (void);

      IOException &operator= (const IOException &);

      static void _tao_any_destructor (void *);

      static IOException *_downcast ( ::CORBA::Exception *);
      static const IOException *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      IOException (
          CF::ErrorNumberType _tao_errorNumber,
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_IOException;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidFilePointer : public ::CORBA::UserException
    {
    public:
      
      InvalidFilePointer (void);
      InvalidFilePointer (const InvalidFilePointer &);
      ~InvalidFilePointer (void);

      InvalidFilePointer &operator= (const InvalidFilePointer &);

      static void _tao_any_destructor (void *);

      static InvalidFilePointer *_downcast ( ::CORBA::Exception *);
      static const InvalidFilePointer *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidFilePointer;

    virtual char * fileName (
      void);

    virtual ::CORBA::ULong filePointer (
      void);

    virtual void read (
      ::CF::OctetSequence_out data,
      ::CORBA::ULong length);

    virtual void write (
      const ::CF::OctetSequence & data);

    virtual ::CORBA::ULong sizeOf (
      void);

    virtual void close (
      void);

    virtual void setFilePointer (
      ::CORBA::ULong filePointer);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_File_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    File (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_File_setup_collocation (void);

    // Concrete non-local interface only.
    File (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    File (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~File (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    File (const File &);

    void operator= (const File &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_File;

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_RESOURCEFACTORY__VAR_OUT_CH_)
#define _CF_RESOURCEFACTORY__VAR_OUT_CH_

  class ResourceFactory;
  typedef ResourceFactory *ResourceFactory_ptr;

  typedef
    TAO_Objref_Var_T<
        ResourceFactory
      >
    ResourceFactory_var;
  
  typedef
    TAO_Objref_Out_T<
        ResourceFactory
      >
    ResourceFactory_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  ResourceFactory
    : public virtual ::CORBA::Object
  {
  public:
    friend class TAO::Narrow_Utils<ResourceFactory>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef ResourceFactory_ptr _ptr_type;
    typedef ResourceFactory_var _var_type;
    typedef ResourceFactory_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static ResourceFactory_ptr _duplicate (ResourceFactory_ptr obj);

    static void _tao_release (ResourceFactory_ptr obj);

    static ResourceFactory_ptr _narrow (::CORBA::Object_ptr obj);
    static ResourceFactory_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static ResourceFactory_ptr _nil (void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidResourceId : public ::CORBA::UserException
    {
    public:
      
      InvalidResourceId (void);
      InvalidResourceId (const InvalidResourceId &);
      ~InvalidResourceId (void);

      InvalidResourceId &operator= (const InvalidResourceId &);

      static void _tao_any_destructor (void *);

      static InvalidResourceId *_downcast ( ::CORBA::Exception *);
      static const InvalidResourceId *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidResourceId;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  ShutdownFailure : public ::CORBA::UserException
    {
    public:
      
      ::TAO::String_Manager msg;
      ShutdownFailure (void);
      ShutdownFailure (const ShutdownFailure &);
      ~ShutdownFailure (void);

      ShutdownFailure &operator= (const ShutdownFailure &);

      static void _tao_any_destructor (void *);

      static ShutdownFailure *_downcast ( ::CORBA::Exception *);
      static const ShutdownFailure *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      ShutdownFailure (
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_ShutdownFailure;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  CreateResourceFailure : public ::CORBA::UserException
    {
    public:
      
      CF::ErrorNumberType errorNumber;
      ::TAO::String_Manager msg;
      CreateResourceFailure (void);
      CreateResourceFailure (const CreateResourceFailure &);
      ~CreateResourceFailure (void);

      CreateResourceFailure &operator= (const CreateResourceFailure &);

      static void _tao_any_destructor (void *);

      static CreateResourceFailure *_downcast ( ::CORBA::Exception *);
      static const CreateResourceFailure *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      CreateResourceFailure (
          CF::ErrorNumberType _tao_errorNumber,
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_CreateResourceFailure;

    virtual char * identifier (
      void);

    virtual ::CF::Resource_ptr createResource (
      const char * resourceId,
      const ::CF::Properties & qualifiers);

    virtual void releaseResource (
      const char * resourceId);

    virtual void shutdown (
      void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_ResourceFactory_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    ResourceFactory (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_ResourceFactory_setup_collocation (void);

    // Concrete non-local interface only.
    ResourceFactory (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    ResourceFactory (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~ResourceFactory (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    ResourceFactory (const ResourceFactory &);

    void operator= (const ResourceFactory &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_ResourceFactory;

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_FILEMANAGER__VAR_OUT_CH_)
#define _CF_FILEMANAGER__VAR_OUT_CH_

  class FileManager;
  typedef FileManager *FileManager_ptr;

  typedef
    TAO_Objref_Var_T<
        FileManager
      >
    FileManager_var;
  
  typedef
    TAO_Objref_Out_T<
        FileManager
      >
    FileManager_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  FileManager
    : public virtual ::CF::FileSystem
  
  {
  public:
    friend class TAO::Narrow_Utils<FileManager>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef FileManager_ptr _ptr_type;
    typedef FileManager_var _var_type;
    typedef FileManager_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static FileManager_ptr _duplicate (FileManager_ptr obj);

    static void _tao_release (FileManager_ptr obj);

    static FileManager_ptr _narrow (::CORBA::Object_ptr obj);
    static FileManager_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static FileManager_ptr _nil (void);

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:261

    struct MountType;

    typedef
      ::TAO_Var_Var_T<
          MountType
        >
      MountType_var;
    
    typedef
      ::TAO_Out_T<
          MountType
        >
      MountType_out;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_ch.cpp:49

    struct  MountType
    {

      // TAO_IDL - Generated from
      // .\be\be_type.cpp:307
      
      typedef MountType_var _var_type;
      typedef MountType_out _out_type;

      static void _tao_any_destructor (void *);
      
      ::TAO::String_Manager mountPoint;
      CF::FileSystem_var fs;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_MountType;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:100

#if !defined (_CF_FILEMANAGER_MOUNTSEQUENCE_CH_)
#define _CF_FILEMANAGER_MOUNTSEQUENCE_CH_

    class MountSequence;

    typedef
      ::TAO_VarSeq_Var_T<
          MountSequence
        >
      MountSequence_var;

    typedef
      ::TAO_Seq_Out_T<
          MountSequence
        >
      MountSequence_out;

    class  MountSequence
      : public
          ::TAO::unbounded_value_sequence<
              MountType
            >
    {
    public:
      MountSequence (void);
      MountSequence ( ::CORBA::ULong max);
      MountSequence (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        MountType* buffer, 
        ::CORBA::Boolean release = false);
      MountSequence (const MountSequence &);
      virtual ~MountSequence (void);
      

      // TAO_IDL - Generated from
      // .\be\be_type.cpp:307
      
      typedef MountSequence_var _var_type;
      typedef MountSequence_out _out_type;

      static void _tao_any_destructor (void *);
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_MountSequence;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  NonExistentMount : public ::CORBA::UserException
    {
    public:
      
      NonExistentMount (void);
      NonExistentMount (const NonExistentMount &);
      ~NonExistentMount (void);

      NonExistentMount &operator= (const NonExistentMount &);

      static void _tao_any_destructor (void *);

      static NonExistentMount *_downcast ( ::CORBA::Exception *);
      static const NonExistentMount *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_NonExistentMount;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidFileSystem : public ::CORBA::UserException
    {
    public:
      
      InvalidFileSystem (void);
      InvalidFileSystem (const InvalidFileSystem &);
      ~InvalidFileSystem (void);

      InvalidFileSystem &operator= (const InvalidFileSystem &);

      static void _tao_any_destructor (void *);

      static InvalidFileSystem *_downcast ( ::CORBA::Exception *);
      static const InvalidFileSystem *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidFileSystem;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  MountPointAlreadyExists : public ::CORBA::UserException
    {
    public:
      
      MountPointAlreadyExists (void);
      MountPointAlreadyExists (const MountPointAlreadyExists &);
      ~MountPointAlreadyExists (void);

      MountPointAlreadyExists &operator= (const MountPointAlreadyExists &);

      static void _tao_any_destructor (void *);

      static MountPointAlreadyExists *_downcast ( ::CORBA::Exception *);
      static const MountPointAlreadyExists *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_MountPointAlreadyExists;

    virtual void mount (
      const char * mountPoint,
      ::CF::FileSystem_ptr file_System);

    virtual void unmount (
      const char * mountPoint);

    virtual ::CF::FileManager::MountSequence * getMounts (
      void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_FileManager_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    FileManager (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_FileManager_setup_collocation (void);

    // Concrete non-local interface only.
    FileManager (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    FileManager (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~FileManager (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    FileManager (const FileManager &);

    void operator= (const FileManager &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_FileManager;

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_PPORT__VAR_OUT_CH_)
#define _CF_PPORT__VAR_OUT_CH_

  class PPort;
  typedef PPort *PPort_ptr;

  typedef
    TAO_Objref_Var_T<
        PPort
      >
    PPort_var;
  
  typedef
    TAO_Objref_Out_T<
        PPort
      >
    PPort_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  PPort
    : public virtual ::CORBA::Object
  {
  public:
    friend class TAO::Narrow_Utils<PPort>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef PPort_ptr _ptr_type;
    typedef PPort_var _var_type;
    typedef PPort_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static PPort_ptr _duplicate (PPort_ptr obj);

    static void _tao_release (PPort_ptr obj);

    static PPort_ptr _narrow (::CORBA::Object_ptr obj);
    static PPort_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static PPort_ptr _nil (void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidPort : public ::CORBA::UserException
    {
    public:
      
      ::CORBA::UShort errorCode;
      ::TAO::String_Manager msg;
      InvalidPort (void);
      InvalidPort (const InvalidPort &);
      ~InvalidPort (void);

      InvalidPort &operator= (const InvalidPort &);

      static void _tao_any_destructor (void *);

      static InvalidPort *_downcast ( ::CORBA::Exception *);
      static const InvalidPort *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      InvalidPort (
          ::CORBA::UShort _tao_errorCode,
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidPort;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  OccupiedPort : public ::CORBA::UserException
    {
    public:
      
      OccupiedPort (void);
      OccupiedPort (const OccupiedPort &);
      ~OccupiedPort (void);

      OccupiedPort &operator= (const OccupiedPort &);

      static void _tao_any_destructor (void *);

      static OccupiedPort *_downcast ( ::CORBA::Exception *);
      static const OccupiedPort *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_OccupiedPort;

    virtual void connectPort (
      ::CORBA::Object_ptr connection,
      const char * connectionId);

    virtual void disconnectPort (
      const char * connectionId);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_PPort_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    PPort (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_PPort_setup_collocation (void);

    // Concrete non-local interface only.
    PPort (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    PPort (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~PPort (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    PPort (const PPort &);

    void operator= (const PPort &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_PPort;

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_LIFECYCLE__VAR_OUT_CH_)
#define _CF_LIFECYCLE__VAR_OUT_CH_

  class LifeCycle;
  typedef LifeCycle *LifeCycle_ptr;

  typedef
    TAO_Objref_Var_T<
        LifeCycle
      >
    LifeCycle_var;
  
  typedef
    TAO_Objref_Out_T<
        LifeCycle
      >
    LifeCycle_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  LifeCycle
    : public virtual ::CORBA::Object
  {
  public:
    friend class TAO::Narrow_Utils<LifeCycle>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef LifeCycle_ptr _ptr_type;
    typedef LifeCycle_var _var_type;
    typedef LifeCycle_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static LifeCycle_ptr _duplicate (LifeCycle_ptr obj);

    static void _tao_release (LifeCycle_ptr obj);

    static LifeCycle_ptr _narrow (::CORBA::Object_ptr obj);
    static LifeCycle_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static LifeCycle_ptr _nil (void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InitializeError : public ::CORBA::UserException
    {
    public:
      
      CF::StringSequence errorMessages;
      InitializeError (void);
      InitializeError (const InitializeError &);
      ~InitializeError (void);

      InitializeError &operator= (const InitializeError &);

      static void _tao_any_destructor (void *);

      static InitializeError *_downcast ( ::CORBA::Exception *);
      static const InitializeError *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      InitializeError (
          const CF::StringSequence & _tao_errorMessages);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InitializeError;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  ReleaseError : public ::CORBA::UserException
    {
    public:
      
      CF::StringSequence errorMessages;
      ReleaseError (void);
      ReleaseError (const ReleaseError &);
      ~ReleaseError (void);

      ReleaseError &operator= (const ReleaseError &);

      static void _tao_any_destructor (void *);

      static ReleaseError *_downcast ( ::CORBA::Exception *);
      static const ReleaseError *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      ReleaseError (
          const CF::StringSequence & _tao_errorMessages);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_ReleaseError;

    virtual void initialize (
      void);

    virtual void releaseObject (
      void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_LifeCycle_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    LifeCycle (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_LifeCycle_setup_collocation (void);

    // Concrete non-local interface only.
    LifeCycle (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    LifeCycle (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~LifeCycle (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    LifeCycle (const LifeCycle &);

    void operator= (const LifeCycle &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_LifeCycle;

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_TESTABLEOBJECT__VAR_OUT_CH_)
#define _CF_TESTABLEOBJECT__VAR_OUT_CH_

  class TestableObject;
  typedef TestableObject *TestableObject_ptr;

  typedef
    TAO_Objref_Var_T<
        TestableObject
      >
    TestableObject_var;
  
  typedef
    TAO_Objref_Out_T<
        TestableObject
      >
    TestableObject_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  TestableObject
    : public virtual ::CORBA::Object
  {
  public:
    friend class TAO::Narrow_Utils<TestableObject>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef TestableObject_ptr _ptr_type;
    typedef TestableObject_var _var_type;
    typedef TestableObject_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static TestableObject_ptr _duplicate (TestableObject_ptr obj);

    static void _tao_release (TestableObject_ptr obj);

    static TestableObject_ptr _narrow (::CORBA::Object_ptr obj);
    static TestableObject_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static TestableObject_ptr _nil (void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  UnknownTest : public ::CORBA::UserException
    {
    public:
      
      UnknownTest (void);
      UnknownTest (const UnknownTest &);
      ~UnknownTest (void);

      UnknownTest &operator= (const UnknownTest &);

      static void _tao_any_destructor (void *);

      static UnknownTest *_downcast ( ::CORBA::Exception *);
      static const UnknownTest *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_UnknownTest;

    virtual void runTest (
      ::CORBA::ULong testid,
      ::CF::Properties & testValues);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_TestableObject_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    TestableObject (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_TestableObject_setup_collocation (void);

    // Concrete non-local interface only.
    TestableObject (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    TestableObject (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~TestableObject (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    TestableObject (const TestableObject &);

    void operator= (const TestableObject &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_TestableObject;

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_PROPERTYSET__VAR_OUT_CH_)
#define _CF_PROPERTYSET__VAR_OUT_CH_

  class PropertySet;
  typedef PropertySet *PropertySet_ptr;

  typedef
    TAO_Objref_Var_T<
        PropertySet
      >
    PropertySet_var;
  
  typedef
    TAO_Objref_Out_T<
        PropertySet
      >
    PropertySet_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  PropertySet
    : public virtual ::CORBA::Object
  {
  public:
    friend class TAO::Narrow_Utils<PropertySet>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef PropertySet_ptr _ptr_type;
    typedef PropertySet_var _var_type;
    typedef PropertySet_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static PropertySet_ptr _duplicate (PropertySet_ptr obj);

    static void _tao_release (PropertySet_ptr obj);

    static PropertySet_ptr _narrow (::CORBA::Object_ptr obj);
    static PropertySet_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static PropertySet_ptr _nil (void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidConfiguration : public ::CORBA::UserException
    {
    public:
      
      ::TAO::String_Manager msg;
      CF::Properties invalidProperties;
      InvalidConfiguration (void);
      InvalidConfiguration (const InvalidConfiguration &);
      ~InvalidConfiguration (void);

      InvalidConfiguration &operator= (const InvalidConfiguration &);

      static void _tao_any_destructor (void *);

      static InvalidConfiguration *_downcast ( ::CORBA::Exception *);
      static const InvalidConfiguration *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      InvalidConfiguration (
          const char * _tao_msg,
          const CF::Properties & _tao_invalidProperties);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidConfiguration;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  PartialConfiguration : public ::CORBA::UserException
    {
    public:
      
      CF::Properties invalidProperties;
      PartialConfiguration (void);
      PartialConfiguration (const PartialConfiguration &);
      ~PartialConfiguration (void);

      PartialConfiguration &operator= (const PartialConfiguration &);

      static void _tao_any_destructor (void *);

      static PartialConfiguration *_downcast ( ::CORBA::Exception *);
      static const PartialConfiguration *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      PartialConfiguration (
          const CF::Properties & _tao_invalidProperties);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_PartialConfiguration;

    virtual void configure (
      const ::CF::Properties & configProperties);

    virtual void query (
      ::CF::Properties & configProperties);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_PropertySet_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    PropertySet (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_PropertySet_setup_collocation (void);

    // Concrete non-local interface only.
    PropertySet (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    PropertySet (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~PropertySet (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    PropertySet (const PropertySet &);

    void operator= (const PropertySet &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_PropertySet;

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_DOMAINMANAGER__VAR_OUT_CH_)
#define _CF_DOMAINMANAGER__VAR_OUT_CH_

  class DomainManager;
  typedef DomainManager *DomainManager_ptr;

  typedef
    TAO_Objref_Var_T<
        DomainManager
      >
    DomainManager_var;
  
  typedef
    TAO_Objref_Out_T<
        DomainManager
      >
    DomainManager_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  DomainManager
    : public virtual ::CF::PropertySet
  
  {
  public:
    friend class TAO::Narrow_Utils<DomainManager>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef DomainManager_ptr _ptr_type;
    typedef DomainManager_var _var_type;
    typedef DomainManager_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static DomainManager_ptr _duplicate (DomainManager_ptr obj);

    static void _tao_release (DomainManager_ptr obj);

    static DomainManager_ptr _narrow (::CORBA::Object_ptr obj);
    static DomainManager_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static DomainManager_ptr _nil (void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  ApplicationInstallationError : public ::CORBA::UserException
    {
    public:
      
      CF::ErrorNumberType errorNumber;
      ::TAO::String_Manager msg;
      ApplicationInstallationError (void);
      ApplicationInstallationError (const ApplicationInstallationError &);
      ~ApplicationInstallationError (void);

      ApplicationInstallationError &operator= (const ApplicationInstallationError &);

      static void _tao_any_destructor (void *);

      static ApplicationInstallationError *_downcast ( ::CORBA::Exception *);
      static const ApplicationInstallationError *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      ApplicationInstallationError (
          CF::ErrorNumberType _tao_errorNumber,
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_ApplicationInstallationError;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:100

#if !defined (_CF_DOMAINMANAGER_APPLICATIONSEQUENCE_CH_)
#define _CF_DOMAINMANAGER_APPLICATIONSEQUENCE_CH_

    class ApplicationSequence;

    typedef
      ::TAO_VarSeq_Var_T<
          ApplicationSequence
        >
      ApplicationSequence_var;

    typedef
      ::TAO_Seq_Out_T<
          ApplicationSequence
        >
      ApplicationSequence_out;

    class  ApplicationSequence
      : public
          ::TAO::unbounded_object_reference_sequence<
              CF::Application,
              CF::Application_var
            >
    {
    public:
      ApplicationSequence (void);
      ApplicationSequence ( ::CORBA::ULong max);
      ApplicationSequence (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        CF::Application_ptr* buffer, 
        ::CORBA::Boolean release = false);
      ApplicationSequence (const ApplicationSequence &);
      virtual ~ApplicationSequence (void);
      

      // TAO_IDL - Generated from
      // .\be\be_type.cpp:307
      
      typedef ApplicationSequence_var _var_type;
      typedef ApplicationSequence_out _out_type;

      static void _tao_any_destructor (void *);
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_ApplicationSequence;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:100

#if !defined (_CF_DOMAINMANAGER_APPLICATIONFACTORYSEQUENCE_CH_)
#define _CF_DOMAINMANAGER_APPLICATIONFACTORYSEQUENCE_CH_

    class ApplicationFactorySequence;

    typedef
      ::TAO_VarSeq_Var_T<
          ApplicationFactorySequence
        >
      ApplicationFactorySequence_var;

    typedef
      ::TAO_Seq_Out_T<
          ApplicationFactorySequence
        >
      ApplicationFactorySequence_out;

    class  ApplicationFactorySequence
      : public
          ::TAO::unbounded_object_reference_sequence<
              CF::ApplicationFactory,
              CF::ApplicationFactory_var
            >
    {
    public:
      ApplicationFactorySequence (void);
      ApplicationFactorySequence ( ::CORBA::ULong max);
      ApplicationFactorySequence (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        CF::ApplicationFactory_ptr* buffer, 
        ::CORBA::Boolean release = false);
      ApplicationFactorySequence (const ApplicationFactorySequence &);
      virtual ~ApplicationFactorySequence (void);
      

      // TAO_IDL - Generated from
      // .\be\be_type.cpp:307
      
      typedef ApplicationFactorySequence_var _var_type;
      typedef ApplicationFactorySequence_out _out_type;

      static void _tao_any_destructor (void *);
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_ApplicationFactorySequence;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:100

#if !defined (_CF_DOMAINMANAGER_DEVICEMANAGERSEQUENCE_CH_)
#define _CF_DOMAINMANAGER_DEVICEMANAGERSEQUENCE_CH_

    class DeviceManagerSequence;

    typedef
      ::TAO_VarSeq_Var_T<
          DeviceManagerSequence
        >
      DeviceManagerSequence_var;

    typedef
      ::TAO_Seq_Out_T<
          DeviceManagerSequence
        >
      DeviceManagerSequence_out;

    class  DeviceManagerSequence
      : public
          ::TAO::unbounded_object_reference_sequence<
              CF::DeviceManager,
              CF::DeviceManager_var
            >
    {
    public:
      DeviceManagerSequence (void);
      DeviceManagerSequence ( ::CORBA::ULong max);
      DeviceManagerSequence (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        CF::DeviceManager_ptr* buffer, 
        ::CORBA::Boolean release = false);
      DeviceManagerSequence (const DeviceManagerSequence &);
      virtual ~DeviceManagerSequence (void);
      

      // TAO_IDL - Generated from
      // .\be\be_type.cpp:307
      
      typedef DeviceManagerSequence_var _var_type;
      typedef DeviceManagerSequence_out _out_type;

      static void _tao_any_destructor (void *);
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_DeviceManagerSequence;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidIdentifier : public ::CORBA::UserException
    {
    public:
      
      InvalidIdentifier (void);
      InvalidIdentifier (const InvalidIdentifier &);
      ~InvalidIdentifier (void);

      InvalidIdentifier &operator= (const InvalidIdentifier &);

      static void _tao_any_destructor (void *);

      static InvalidIdentifier *_downcast ( ::CORBA::Exception *);
      static const InvalidIdentifier *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidIdentifier;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  DeviceManagerNotRegistered : public ::CORBA::UserException
    {
    public:
      
      DeviceManagerNotRegistered (void);
      DeviceManagerNotRegistered (const DeviceManagerNotRegistered &);
      ~DeviceManagerNotRegistered (void);

      DeviceManagerNotRegistered &operator= (const DeviceManagerNotRegistered &);

      static void _tao_any_destructor (void *);

      static DeviceManagerNotRegistered *_downcast ( ::CORBA::Exception *);
      static const DeviceManagerNotRegistered *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_DeviceManagerNotRegistered;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  ApplicationUninstallationError : public ::CORBA::UserException
    {
    public:
      
      CF::ErrorNumberType errorNumber;
      ::TAO::String_Manager msg;
      ApplicationUninstallationError (void);
      ApplicationUninstallationError (const ApplicationUninstallationError &);
      ~ApplicationUninstallationError (void);

      ApplicationUninstallationError &operator= (const ApplicationUninstallationError &);

      static void _tao_any_destructor (void *);

      static ApplicationUninstallationError *_downcast ( ::CORBA::Exception *);
      static const ApplicationUninstallationError *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      ApplicationUninstallationError (
          CF::ErrorNumberType _tao_errorNumber,
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_ApplicationUninstallationError;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  RegisterError : public ::CORBA::UserException
    {
    public:
      
      CF::ErrorNumberType errorNumber;
      ::TAO::String_Manager msg;
      RegisterError (void);
      RegisterError (const RegisterError &);
      ~RegisterError (void);

      RegisterError &operator= (const RegisterError &);

      static void _tao_any_destructor (void *);

      static RegisterError *_downcast ( ::CORBA::Exception *);
      static const RegisterError *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      RegisterError (
          CF::ErrorNumberType _tao_errorNumber,
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_RegisterError;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  UnregisterError : public ::CORBA::UserException
    {
    public:
      
      CF::ErrorNumberType errorNumber;
      ::TAO::String_Manager msg;
      UnregisterError (void);
      UnregisterError (const UnregisterError &);
      ~UnregisterError (void);

      UnregisterError &operator= (const UnregisterError &);

      static void _tao_any_destructor (void *);

      static UnregisterError *_downcast ( ::CORBA::Exception *);
      static const UnregisterError *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      UnregisterError (
          CF::ErrorNumberType _tao_errorNumber,
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_UnregisterError;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  AlreadyConnected : public ::CORBA::UserException
    {
    public:
      
      AlreadyConnected (void);
      AlreadyConnected (const AlreadyConnected &);
      ~AlreadyConnected (void);

      AlreadyConnected &operator= (const AlreadyConnected &);

      static void _tao_any_destructor (void *);

      static AlreadyConnected *_downcast ( ::CORBA::Exception *);
      static const AlreadyConnected *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_AlreadyConnected;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidEventChannelName : public ::CORBA::UserException
    {
    public:
      
      InvalidEventChannelName (void);
      InvalidEventChannelName (const InvalidEventChannelName &);
      ~InvalidEventChannelName (void);

      InvalidEventChannelName &operator= (const InvalidEventChannelName &);

      static void _tao_any_destructor (void *);

      static InvalidEventChannelName *_downcast ( ::CORBA::Exception *);
      static const InvalidEventChannelName *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidEventChannelName;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  NotConnected : public ::CORBA::UserException
    {
    public:
      
      NotConnected (void);
      NotConnected (const NotConnected &);
      ~NotConnected (void);

      NotConnected &operator= (const NotConnected &);

      static void _tao_any_destructor (void *);

      static NotConnected *_downcast ( ::CORBA::Exception *);
      static const NotConnected *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_NotConnected;

    virtual char * domainManagerProfile (
      void);

    virtual ::CF::DomainManager::DeviceManagerSequence * deviceManagers (
      void);

    virtual ::CF::DomainManager::ApplicationSequence * applications (
      void);

    virtual ::CF::DomainManager::ApplicationFactorySequence * applicationFactories (
      void);

    virtual ::CF::FileManager_ptr fileMgr (
      void);

    virtual char * identifier (
      void);

    virtual void registerDevice (
      ::CF::Device_ptr registeringDevice,
      ::CF::DeviceManager_ptr registeredDeviceMgr);

    virtual void registerDeviceManager (
      ::CF::DeviceManager_ptr deviceMgr);

    virtual void unregisterDeviceManager (
      ::CF::DeviceManager_ptr deviceMgr);

    virtual void unregisterDevice (
      ::CF::Device_ptr unregisteringDevice);

    virtual void installApplication (
      const char * profileFileName);

    virtual void uninstallApplication (
      const char * applicationId);

    virtual void registerService (
      ::CORBA::Object_ptr registeringService,
      ::CF::DeviceManager_ptr registeredDeviceMgr,
      const char * name);

    virtual void unregisterService (
      ::CORBA::Object_ptr unregisteringService,
      const char * name);

    virtual void registerWithEventChannel (
      ::CORBA::Object_ptr registeringObject,
      const char * registeringId,
      const char * eventChannelName);

    virtual void unregisterFromEventChannel (
      const char * unregisteringId,
      const char * eventChannelName);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_DomainManager_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    DomainManager (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_DomainManager_setup_collocation (void);

    // Concrete non-local interface only.
    DomainManager (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    DomainManager (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~DomainManager (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    DomainManager (const DomainManager &);

    void operator= (const DomainManager &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_DomainManager;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  ApplicationFactory
    : public virtual ::CORBA::Object
  {
  public:
    friend class TAO::Narrow_Utils<ApplicationFactory>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef ApplicationFactory_ptr _ptr_type;
    typedef ApplicationFactory_var _var_type;
    typedef ApplicationFactory_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static ApplicationFactory_ptr _duplicate (ApplicationFactory_ptr obj);

    static void _tao_release (ApplicationFactory_ptr obj);

    static ApplicationFactory_ptr _narrow (::CORBA::Object_ptr obj);
    static ApplicationFactory_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static ApplicationFactory_ptr _nil (void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  CreateApplicationRequestError : public ::CORBA::UserException
    {
    public:
      
      CF::DeviceAssignmentSequence invalidAssignments;
      CreateApplicationRequestError (void);
      CreateApplicationRequestError (const CreateApplicationRequestError &);
      ~CreateApplicationRequestError (void);

      CreateApplicationRequestError &operator= (const CreateApplicationRequestError &);

      static void _tao_any_destructor (void *);

      static CreateApplicationRequestError *_downcast ( ::CORBA::Exception *);
      static const CreateApplicationRequestError *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      CreateApplicationRequestError (
          const CF::DeviceAssignmentSequence & _tao_invalidAssignments);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_CreateApplicationRequestError;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  CreateApplicationError : public ::CORBA::UserException
    {
    public:
      
      CF::ErrorNumberType errorNumber;
      ::TAO::String_Manager msg;
      CreateApplicationError (void);
      CreateApplicationError (const CreateApplicationError &);
      ~CreateApplicationError (void);

      CreateApplicationError &operator= (const CreateApplicationError &);

      static void _tao_any_destructor (void *);

      static CreateApplicationError *_downcast ( ::CORBA::Exception *);
      static const CreateApplicationError *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      CreateApplicationError (
          CF::ErrorNumberType _tao_errorNumber,
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_CreateApplicationError;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidInitConfiguration : public ::CORBA::UserException
    {
    public:
      
      CF::Properties invalidProperties;
      InvalidInitConfiguration (void);
      InvalidInitConfiguration (const InvalidInitConfiguration &);
      ~InvalidInitConfiguration (void);

      InvalidInitConfiguration &operator= (const InvalidInitConfiguration &);

      static void _tao_any_destructor (void *);

      static InvalidInitConfiguration *_downcast ( ::CORBA::Exception *);
      static const InvalidInitConfiguration *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      InvalidInitConfiguration (
          const CF::Properties & _tao_invalidProperties);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidInitConfiguration;

    virtual char * name (
      void);

    virtual char * identifier (
      void);

    virtual char * softwareProfile (
      void);

    virtual ::CF::Application_ptr create (
      const char * name,
      const ::CF::Properties & initConfiguration,
      const ::CF::DeviceAssignmentSequence & deviceAssignments);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_ApplicationFactory_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    ApplicationFactory (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_ApplicationFactory_setup_collocation (void);

    // Concrete non-local interface only.
    ApplicationFactory (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    ApplicationFactory (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~ApplicationFactory (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    ApplicationFactory (const ApplicationFactory &);

    void operator= (const ApplicationFactory &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_ApplicationFactory;

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_PORTSUPPLIER__VAR_OUT_CH_)
#define _CF_PORTSUPPLIER__VAR_OUT_CH_

  class PortSupplier;
  typedef PortSupplier *PortSupplier_ptr;

  typedef
    TAO_Objref_Var_T<
        PortSupplier
      >
    PortSupplier_var;
  
  typedef
    TAO_Objref_Out_T<
        PortSupplier
      >
    PortSupplier_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  PortSupplier
    : public virtual ::CORBA::Object
  {
  public:
    friend class TAO::Narrow_Utils<PortSupplier>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef PortSupplier_ptr _ptr_type;
    typedef PortSupplier_var _var_type;
    typedef PortSupplier_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static PortSupplier_ptr _duplicate (PortSupplier_ptr obj);

    static void _tao_release (PortSupplier_ptr obj);

    static PortSupplier_ptr _narrow (::CORBA::Object_ptr obj);
    static PortSupplier_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static PortSupplier_ptr _nil (void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  UnknownPort : public ::CORBA::UserException
    {
    public:
      
      UnknownPort (void);
      UnknownPort (const UnknownPort &);
      ~UnknownPort (void);

      UnknownPort &operator= (const UnknownPort &);

      static void _tao_any_destructor (void *);

      static UnknownPort *_downcast ( ::CORBA::Exception *);
      static const UnknownPort *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_UnknownPort;

    virtual ::CORBA::Object_ptr getPort (
      const char * name);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_PortSupplier_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    PortSupplier (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_PortSupplier_setup_collocation (void);

    // Concrete non-local interface only.
    PortSupplier (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    PortSupplier (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~PortSupplier (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    PortSupplier (const PortSupplier &);

    void operator= (const PortSupplier &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_PortSupplier;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  Resource
    : public virtual ::CF::LifeCycle,
      public virtual ::CF::TestableObject,
      public virtual ::CF::PropertySet,
      public virtual ::CF::PortSupplier
  
  {
  public:
    friend class TAO::Narrow_Utils<Resource>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef Resource_ptr _ptr_type;
    typedef Resource_var _var_type;
    typedef Resource_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static Resource_ptr _duplicate (Resource_ptr obj);

    static void _tao_release (Resource_ptr obj);

    static Resource_ptr _narrow (::CORBA::Object_ptr obj);
    static Resource_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static Resource_ptr _nil (void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  StartError : public ::CORBA::UserException
    {
    public:
      
      CF::ErrorNumberType errorNumber;
      ::TAO::String_Manager msg;
      StartError (void);
      StartError (const StartError &);
      ~StartError (void);

      StartError &operator= (const StartError &);

      static void _tao_any_destructor (void *);

      static StartError *_downcast ( ::CORBA::Exception *);
      static const StartError *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      StartError (
          CF::ErrorNumberType _tao_errorNumber,
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_StartError;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  StopError : public ::CORBA::UserException
    {
    public:
      
      CF::ErrorNumberType errorNumber;
      ::TAO::String_Manager msg;
      StopError (void);
      StopError (const StopError &);
      ~StopError (void);

      StopError &operator= (const StopError &);

      static void _tao_any_destructor (void *);

      static StopError *_downcast ( ::CORBA::Exception *);
      static const StopError *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      StopError (
          CF::ErrorNumberType _tao_errorNumber,
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_StopError;

    virtual char * identifier (
      void);

    virtual void start (
      void);

    virtual void stop (
      void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_Resource_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    Resource (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_Resource_setup_collocation (void);

    // Concrete non-local interface only.
    Resource (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    Resource (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~Resource (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    Resource (const Resource &);

    void operator= (const Resource &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_Resource;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  Device
    : public virtual ::CF::Resource
  
  {
  public:
    friend class TAO::Narrow_Utils<Device>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef Device_ptr _ptr_type;
    typedef Device_var _var_type;
    typedef Device_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static Device_ptr _duplicate (Device_ptr obj);

    static void _tao_release (Device_ptr obj);

    static Device_ptr _narrow (::CORBA::Object_ptr obj);
    static Device_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static Device_ptr _nil (void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidState : public ::CORBA::UserException
    {
    public:
      
      ::TAO::String_Manager msg;
      InvalidState (void);
      InvalidState (const InvalidState &);
      ~InvalidState (void);

      InvalidState &operator= (const InvalidState &);

      static void _tao_any_destructor (void *);

      static InvalidState *_downcast ( ::CORBA::Exception *);
      static const InvalidState *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      InvalidState (
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidState;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidCapacity : public ::CORBA::UserException
    {
    public:
      
      ::TAO::String_Manager msg;
      CF::Properties capacities;
      InvalidCapacity (void);
      InvalidCapacity (const InvalidCapacity &);
      ~InvalidCapacity (void);

      InvalidCapacity &operator= (const InvalidCapacity &);

      static void _tao_any_destructor (void *);

      static InvalidCapacity *_downcast ( ::CORBA::Exception *);
      static const InvalidCapacity *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      InvalidCapacity (
          const char * _tao_msg,
          const CF::Properties & _tao_capacities);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidCapacity;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/enum_ch.cpp:47

    enum AdminType
    {
      LOCKED,
      SHUTTING_DOWN,
      UNLOCKED
    };

    typedef AdminType &AdminType_out;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_AdminType;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/enum_ch.cpp:47

    enum OperationalType
    {
      ENABLED,
      DISABLED
    };

    typedef OperationalType &OperationalType_out;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_OperationalType;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/enum_ch.cpp:47

    enum UsageType
    {
      IDLE,
      ACTIVE,
      BUSY
    };

    typedef UsageType &UsageType_out;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_UsageType;

    virtual ::CF::Device::UsageType usageState (
      void);

    virtual ::CF::Device::AdminType adminState (
      void);

    virtual void adminState (
      ::CF::Device::AdminType adminState);

    virtual ::CF::Device::OperationalType operationalState (
      void);

    virtual char * softwareProfile (
      void);

    virtual char * label (
      void);

    virtual ::CF::AggregateDevice_ptr compositeDevice (
      void);

    virtual ::CORBA::Boolean allocateCapacity (
      const ::CF::Properties & capacities);

    virtual void deallocateCapacity (
      const ::CF::Properties & capacities);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_Device_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    Device (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_Device_setup_collocation (void);

    // Concrete non-local interface only.
    Device (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    Device (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~Device (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    Device (const Device &);

    void operator= (const Device &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_Device;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  Application
    : public virtual ::CF::Resource
  
  {
  public:
    friend class TAO::Narrow_Utils<Application>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef Application_ptr _ptr_type;
    typedef Application_var _var_type;
    typedef Application_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static Application_ptr _duplicate (Application_ptr obj);

    static void _tao_release (Application_ptr obj);

    static Application_ptr _narrow (::CORBA::Object_ptr obj);
    static Application_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static Application_ptr _nil (void);

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:261

    struct ComponentProcessIdType;

    typedef
      ::TAO_Var_Var_T<
          ComponentProcessIdType
        >
      ComponentProcessIdType_var;
    
    typedef
      ::TAO_Out_T<
          ComponentProcessIdType
        >
      ComponentProcessIdType_out;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_ch.cpp:49

    struct  ComponentProcessIdType
    {

      // TAO_IDL - Generated from
      // .\be\be_type.cpp:307
      
      typedef ComponentProcessIdType_var _var_type;
      typedef ComponentProcessIdType_out _out_type;

      static void _tao_any_destructor (void *);
      
      ::TAO::String_Manager componentId;
      ::CORBA::ULong processId;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_ComponentProcessIdType;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:100

#if !defined (_CF_APPLICATION_COMPONENTPROCESSIDSEQUENCE_CH_)
#define _CF_APPLICATION_COMPONENTPROCESSIDSEQUENCE_CH_

    class ComponentProcessIdSequence;

    typedef
      ::TAO_VarSeq_Var_T<
          ComponentProcessIdSequence
        >
      ComponentProcessIdSequence_var;

    typedef
      ::TAO_Seq_Out_T<
          ComponentProcessIdSequence
        >
      ComponentProcessIdSequence_out;

    class  ComponentProcessIdSequence
      : public
          ::TAO::unbounded_value_sequence<
              ComponentProcessIdType
            >
    {
    public:
      ComponentProcessIdSequence (void);
      ComponentProcessIdSequence ( ::CORBA::ULong max);
      ComponentProcessIdSequence (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        ComponentProcessIdType* buffer, 
        ::CORBA::Boolean release = false);
      ComponentProcessIdSequence (const ComponentProcessIdSequence &);
      virtual ~ComponentProcessIdSequence (void);
      

      // TAO_IDL - Generated from
      // .\be\be_type.cpp:307
      
      typedef ComponentProcessIdSequence_var _var_type;
      typedef ComponentProcessIdSequence_out _out_type;

      static void _tao_any_destructor (void *);
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_ComponentProcessIdSequence;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:261

    struct ComponentElementType;

    typedef
      ::TAO_Var_Var_T<
          ComponentElementType
        >
      ComponentElementType_var;
    
    typedef
      ::TAO_Out_T<
          ComponentElementType
        >
      ComponentElementType_out;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_ch.cpp:49

    struct  ComponentElementType
    {

      // TAO_IDL - Generated from
      // .\be\be_type.cpp:307
      
      typedef ComponentElementType_var _var_type;
      typedef ComponentElementType_out _out_type;

      static void _tao_any_destructor (void *);
      
      ::TAO::String_Manager componentId;
      ::TAO::String_Manager elementId;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_ComponentElementType;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:100

#if !defined (_CF_APPLICATION_COMPONENTELEMENTSEQUENCE_CH_)
#define _CF_APPLICATION_COMPONENTELEMENTSEQUENCE_CH_

    class ComponentElementSequence;

    typedef
      ::TAO_VarSeq_Var_T<
          ComponentElementSequence
        >
      ComponentElementSequence_var;

    typedef
      ::TAO_Seq_Out_T<
          ComponentElementSequence
        >
      ComponentElementSequence_out;

    class  ComponentElementSequence
      : public
          ::TAO::unbounded_value_sequence<
              ComponentElementType
            >
    {
    public:
      ComponentElementSequence (void);
      ComponentElementSequence ( ::CORBA::ULong max);
      ComponentElementSequence (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        ComponentElementType* buffer, 
        ::CORBA::Boolean release = false);
      ComponentElementSequence (const ComponentElementSequence &);
      virtual ~ComponentElementSequence (void);
      

      // TAO_IDL - Generated from
      // .\be\be_type.cpp:307
      
      typedef ComponentElementSequence_var _var_type;
      typedef ComponentElementSequence_out _out_type;

      static void _tao_any_destructor (void *);
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_ComponentElementSequence;

    virtual ::CF::Application::ComponentElementSequence * componentNamingContexts (
      void);

    virtual ::CF::Application::ComponentProcessIdSequence * componentProcessIds (
      void);

    virtual ::CF::DeviceAssignmentSequence * componentDevices (
      void);

    virtual ::CF::Application::ComponentElementSequence * componentImplementations (
      void);

    virtual char * profile (
      void);

    virtual char * name (
      void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_Application_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    Application (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_Application_setup_collocation (void);

    // Concrete non-local interface only.
    Application (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    Application (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~Application (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    Application (const Application &);

    void operator= (const Application &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_Application;

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_LOADABLEDEVICE__VAR_OUT_CH_)
#define _CF_LOADABLEDEVICE__VAR_OUT_CH_

  class LoadableDevice;
  typedef LoadableDevice *LoadableDevice_ptr;

  typedef
    TAO_Objref_Var_T<
        LoadableDevice
      >
    LoadableDevice_var;
  
  typedef
    TAO_Objref_Out_T<
        LoadableDevice
      >
    LoadableDevice_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  LoadableDevice
    : public virtual ::CF::Device
  
  {
  public:
    friend class TAO::Narrow_Utils<LoadableDevice>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef LoadableDevice_ptr _ptr_type;
    typedef LoadableDevice_var _var_type;
    typedef LoadableDevice_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static LoadableDevice_ptr _duplicate (LoadableDevice_ptr obj);

    static void _tao_release (LoadableDevice_ptr obj);

    static LoadableDevice_ptr _narrow (::CORBA::Object_ptr obj);
    static LoadableDevice_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static LoadableDevice_ptr _nil (void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/enum_ch.cpp:47

    enum LoadType
    {
      KERNEL_MODULE,
      DRIVER,
      SHARED_LIBRARY,
      EXECUTABLE
    };

    typedef LoadType &LoadType_out;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_LoadType;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidLoadKind : public ::CORBA::UserException
    {
    public:
      
      InvalidLoadKind (void);
      InvalidLoadKind (const InvalidLoadKind &);
      ~InvalidLoadKind (void);

      InvalidLoadKind &operator= (const InvalidLoadKind &);

      static void _tao_any_destructor (void *);

      static InvalidLoadKind *_downcast ( ::CORBA::Exception *);
      static const InvalidLoadKind *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidLoadKind;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  LoadFail : public ::CORBA::UserException
    {
    public:
      
      CF::ErrorNumberType errorNumber;
      ::TAO::String_Manager msg;
      LoadFail (void);
      LoadFail (const LoadFail &);
      ~LoadFail (void);

      LoadFail &operator= (const LoadFail &);

      static void _tao_any_destructor (void *);

      static LoadFail *_downcast ( ::CORBA::Exception *);
      static const LoadFail *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      LoadFail (
          CF::ErrorNumberType _tao_errorNumber,
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_LoadFail;

    virtual void load (
      ::CF::FileSystem_ptr fs,
      const char * fileName,
      ::CF::LoadableDevice::LoadType loadKind);

    virtual void unload (
      const char * fileName);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_LoadableDevice_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    LoadableDevice (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_LoadableDevice_setup_collocation (void);

    // Concrete non-local interface only.
    LoadableDevice (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    LoadableDevice (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~LoadableDevice (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    LoadableDevice (const LoadableDevice &);

    void operator= (const LoadableDevice &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_LoadableDevice;

  // TAO_IDL - Generated from
  // .\be\be_interface.cpp:784

#if !defined (_CF_EXECUTABLEDEVICE__VAR_OUT_CH_)
#define _CF_EXECUTABLEDEVICE__VAR_OUT_CH_

  class ExecutableDevice;
  typedef ExecutableDevice *ExecutableDevice_ptr;

  typedef
    TAO_Objref_Var_T<
        ExecutableDevice
      >
    ExecutableDevice_var;
  
  typedef
    TAO_Objref_Out_T<
        ExecutableDevice
      >
    ExecutableDevice_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  ExecutableDevice
    : public virtual ::CF::LoadableDevice
  
  {
  public:
    friend class TAO::Narrow_Utils<ExecutableDevice>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef ExecutableDevice_ptr _ptr_type;
    typedef ExecutableDevice_var _var_type;
    typedef ExecutableDevice_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static ExecutableDevice_ptr _duplicate (ExecutableDevice_ptr obj);

    static void _tao_release (ExecutableDevice_ptr obj);

    static ExecutableDevice_ptr _narrow (::CORBA::Object_ptr obj);
    static ExecutableDevice_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static ExecutableDevice_ptr _nil (void);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidProcess : public ::CORBA::UserException
    {
    public:
      
      CF::ErrorNumberType errorNumber;
      ::TAO::String_Manager msg;
      InvalidProcess (void);
      InvalidProcess (const InvalidProcess &);
      ~InvalidProcess (void);

      InvalidProcess &operator= (const InvalidProcess &);

      static void _tao_any_destructor (void *);

      static InvalidProcess *_downcast ( ::CORBA::Exception *);
      static const InvalidProcess *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      InvalidProcess (
          CF::ErrorNumberType _tao_errorNumber,
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidProcess;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidFunction : public ::CORBA::UserException
    {
    public:
      
      InvalidFunction (void);
      InvalidFunction (const InvalidFunction &);
      ~InvalidFunction (void);

      InvalidFunction &operator= (const InvalidFunction &);

      static void _tao_any_destructor (void *);

      static InvalidFunction *_downcast ( ::CORBA::Exception *);
      static const InvalidFunction *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidFunction;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typedef/typedef_ch.cpp:369

    typedef ::CORBA::ULong ProcessID_Type;
    typedef ::CORBA::ULong_out ProcessID_Type_out;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_ProcessID_Type;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidParameters : public ::CORBA::UserException
    {
    public:
      
      CF::Properties invalidParms;
      InvalidParameters (void);
      InvalidParameters (const InvalidParameters &);
      ~InvalidParameters (void);

      InvalidParameters &operator= (const InvalidParameters &);

      static void _tao_any_destructor (void *);

      static InvalidParameters *_downcast ( ::CORBA::Exception *);
      static const InvalidParameters *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      InvalidParameters (
          const CF::Properties & _tao_invalidParms);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidParameters;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  InvalidOptions : public ::CORBA::UserException
    {
    public:
      
      CF::Properties invalidOpts;
      InvalidOptions (void);
      InvalidOptions (const InvalidOptions &);
      ~InvalidOptions (void);

      InvalidOptions &operator= (const InvalidOptions &);

      static void _tao_any_destructor (void *);

      static InvalidOptions *_downcast ( ::CORBA::Exception *);
      static const InvalidOptions *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      InvalidOptions (
          const CF::Properties & _tao_invalidOpts);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_InvalidOptions;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_constant/constant_ch.cpp:41

    static const char *const STACK_SIZE;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_constant/constant_ch.cpp:41

    static const char *const PRIORITY_ID;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ch.cpp:43

    class  ExecuteFail : public ::CORBA::UserException
    {
    public:
      
      CF::ErrorNumberType errorNumber;
      ::TAO::String_Manager msg;
      ExecuteFail (void);
      ExecuteFail (const ExecuteFail &);
      ~ExecuteFail (void);

      ExecuteFail &operator= (const ExecuteFail &);

      static void _tao_any_destructor (void *);

      static ExecuteFail *_downcast ( ::CORBA::Exception *);
      static const ExecuteFail *_downcast ( ::CORBA::Exception const *);

      static ::CORBA::Exception *_alloc (void);

      virtual ::CORBA::Exception *_tao_duplicate (void) const;

      virtual void _raise (void) const;

      virtual void _tao_encode (TAO_OutputCDR &cdr) const;
      virtual void _tao_decode (TAO_InputCDR &cdr);
      

      // TAO_IDL - Generated from
      // c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

      ExecuteFail (
          CF::ErrorNumberType _tao_errorNumber,
          const char * _tao_msg);

      virtual ::CORBA::TypeCode_ptr _tao_type (void) const;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_ExecuteFail;

    virtual void terminate (
      ::CF::ExecutableDevice::ProcessID_Type processId);

    virtual ::CF::ExecutableDevice::ProcessID_Type execute (
      const char * name,
      const ::CF::Properties & options,
      const ::CF::Properties & parameters);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_ExecutableDevice_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    ExecutableDevice (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_ExecutableDevice_setup_collocation (void);

    // Concrete non-local interface only.
    ExecutableDevice (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    ExecutableDevice (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~ExecutableDevice (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    ExecutableDevice (const ExecutableDevice &);

    void operator= (const ExecutableDevice &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_ExecutableDevice;

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:45

  class  DeviceManager
    : public virtual ::CF::PropertySet,
      public virtual ::CF::PortSupplier
  
  {
  public:
    friend class TAO::Narrow_Utils<DeviceManager>;

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:307
    
    typedef DeviceManager_ptr _ptr_type;
    typedef DeviceManager_var _var_type;
    typedef DeviceManager_out _out_type;

    static void _tao_any_destructor (void *);

    // The static operations.
    static DeviceManager_ptr _duplicate (DeviceManager_ptr obj);

    static void _tao_release (DeviceManager_ptr obj);

    static DeviceManager_ptr _narrow (::CORBA::Object_ptr obj);
    static DeviceManager_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static DeviceManager_ptr _nil (void);

    // TAO_IDL - Generated from
    // .\be\be_type.cpp:261

    struct ServiceType;

    typedef
      ::TAO_Var_Var_T<
          ServiceType
        >
      ServiceType_var;
    
    typedef
      ::TAO_Out_T<
          ServiceType
        >
      ServiceType_out;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_ch.cpp:49

    struct  ServiceType
    {

      // TAO_IDL - Generated from
      // .\be\be_type.cpp:307
      
      typedef ServiceType_var _var_type;
      typedef ServiceType_out _out_type;

      static void _tao_any_destructor (void *);
      
      ::CORBA::Object_var serviceObject;
      ::TAO::String_Manager serviceName;
    };

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_ServiceType;

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:100

#if !defined (_CF_DEVICEMANAGER_SERVICESEQUENCE_CH_)
#define _CF_DEVICEMANAGER_SERVICESEQUENCE_CH_

    class ServiceSequence;

    typedef
      ::TAO_VarSeq_Var_T<
          ServiceSequence
        >
      ServiceSequence_var;

    typedef
      ::TAO_Seq_Out_T<
          ServiceSequence
        >
      ServiceSequence_out;

    class  ServiceSequence
      : public
          ::TAO::unbounded_value_sequence<
              ServiceType
            >
    {
    public:
      ServiceSequence (void);
      ServiceSequence ( ::CORBA::ULong max);
      ServiceSequence (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        ServiceType* buffer, 
        ::CORBA::Boolean release = false);
      ServiceSequence (const ServiceSequence &);
      virtual ~ServiceSequence (void);
      

      // TAO_IDL - Generated from
      // .\be\be_type.cpp:307
      
      typedef ServiceSequence_var _var_type;
      typedef ServiceSequence_out _out_type;

      static void _tao_any_destructor (void *);
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

    static ::CORBA::TypeCode_ptr const _tc_ServiceSequence;

    virtual char * deviceConfigurationProfile (
      void);

    virtual ::CF::FileSystem_ptr fileSys (
      void);

    virtual char * identifier (
      void);

    virtual char * label (
      void);

    virtual ::CF::DeviceSequence * registeredDevices (
      void);

    virtual ::CF::DeviceManager::ServiceSequence * registeredServices (
      void);

    virtual void registerDevice (
      ::CF::Device_ptr registeringDevice);

    virtual void unregisterDevice (
      ::CF::Device_ptr registeredDevice);

    virtual void shutdown (
      void);

    virtual void registerService (
      ::CORBA::Object_ptr registeringService,
      const char * name);

    virtual void unregisterService (
      ::CORBA::Object_ptr registeredService,
      const char * name);

    virtual char * getComponentImplementationId (
      const char * componentInstantiationId);

    // TAO_IDL - Generated from
    // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:156

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  private:
    TAO::Collocation_Proxy_Broker *the_TAO_DeviceManager_Proxy_Broker_;
  
  protected:
    // Concrete interface only.
    DeviceManager (void);

    // These methods traverse the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void CF_DeviceManager_setup_collocation (void);

    // Concrete non-local interface only.
    DeviceManager (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    DeviceManager (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~DeviceManager (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    DeviceManager (const DeviceManager &);

    void operator= (const DeviceManager &);
  };

  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_decl.cpp:39

  extern  ::CORBA::TypeCode_ptr const _tc_DeviceManager;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_module/module_ch.cpp:70

} // module CF

// TAO_IDL - Generated from
// .\be\be_visitor_arg_traits.cpp:68

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_FILE__ARG_TRAITS_)
#define _CF_FILE__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::File>
    : public
        Object_Arg_Traits_T<
            ::CF::File_ptr,
            ::CF::File_var,
            ::CF::File_out,
            TAO::Objref_Traits<CF::File>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_RESOURCE__ARG_TRAITS_)
#define _CF_RESOURCE__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::Resource>
    : public
        Object_Arg_Traits_T<
            ::CF::Resource_ptr,
            ::CF::Resource_var,
            ::CF::Resource_out,
            TAO::Objref_Traits<CF::Resource>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_APPLICATION__ARG_TRAITS_)
#define _CF_APPLICATION__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::Application>
    : public
        Object_Arg_Traits_T<
            ::CF::Application_ptr,
            ::CF::Application_var,
            ::CF::Application_out,
            TAO::Objref_Traits<CF::Application>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:941

  template<>
  class Arg_Traits< ::CF::Application::ComponentProcessIdType>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::Application::ComponentProcessIdType,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:679

  template<>
  class Arg_Traits< ::CF::Application::ComponentProcessIdSequence>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::Application::ComponentProcessIdSequence,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:941

  template<>
  class Arg_Traits< ::CF::Application::ComponentElementType>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::Application::ComponentElementType,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:679

  template<>
  class Arg_Traits< ::CF::Application::ComponentElementSequence>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::Application::ComponentElementSequence,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_DEVICE__ARG_TRAITS_)
#define _CF_DEVICE__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::Device>
    : public
        Object_Arg_Traits_T<
            ::CF::Device_ptr,
            ::CF::Device_var,
            ::CF::Device_out,
            TAO::Objref_Traits<CF::Device>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:898

  template<>
  class Arg_Traits< ::CF::Device::AdminType>
    : public
        Basic_Arg_Traits_T<
            ::CF::Device::AdminType,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:898

  template<>
  class Arg_Traits< ::CF::Device::OperationalType>
    : public
        Basic_Arg_Traits_T<
            ::CF::Device::OperationalType,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:898

  template<>
  class Arg_Traits< ::CF::Device::UsageType>
    : public
        Basic_Arg_Traits_T<
            ::CF::Device::UsageType,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_APPLICATIONFACTORY__ARG_TRAITS_)
#define _CF_APPLICATIONFACTORY__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::ApplicationFactory>
    : public
        Object_Arg_Traits_T<
            ::CF::ApplicationFactory_ptr,
            ::CF::ApplicationFactory_var,
            ::CF::ApplicationFactory_out,
            TAO::Objref_Traits<CF::ApplicationFactory>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_DEVICEMANAGER__ARG_TRAITS_)
#define _CF_DEVICEMANAGER__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::DeviceManager>
    : public
        Object_Arg_Traits_T<
            ::CF::DeviceManager_ptr,
            ::CF::DeviceManager_var,
            ::CF::DeviceManager_out,
            TAO::Objref_Traits<CF::DeviceManager>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:941

  template<>
  class Arg_Traits< ::CF::DeviceManager::ServiceType>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::DeviceManager::ServiceType,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:679

  template<>
  class Arg_Traits< ::CF::DeviceManager::ServiceSequence>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::DeviceManager::ServiceSequence,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:941

  template<>
  class Arg_Traits< ::CF::DataType>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::DataType,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:679

  template<>
  class Arg_Traits< ::CF::Properties>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::Properties,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:679

  template<>
  class Arg_Traits< ::CF::OctetSequence>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::OctetSequence,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:679

  template<>
  class Arg_Traits< ::CF::StringSequence>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::StringSequence,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:941

  template<>
  class Arg_Traits< ::CF::DeviceAssignmentType>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::DeviceAssignmentType,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:679

  template<>
  class Arg_Traits< ::CF::DeviceAssignmentSequence>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::DeviceAssignmentSequence,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:898

  template<>
  class Arg_Traits< ::CF::ErrorNumberType>
    : public
        Basic_Arg_Traits_T<
            ::CF::ErrorNumberType,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:679

  template<>
  class Arg_Traits< ::CF::DeviceSequence>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::DeviceSequence,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_AGGREGATEDEVICE__ARG_TRAITS_)
#define _CF_AGGREGATEDEVICE__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::AggregateDevice>
    : public
        Object_Arg_Traits_T<
            ::CF::AggregateDevice_ptr,
            ::CF::AggregateDevice_var,
            ::CF::AggregateDevice_out,
            TAO::Objref_Traits<CF::AggregateDevice>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_FILESYSTEM__ARG_TRAITS_)
#define _CF_FILESYSTEM__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::FileSystem>
    : public
        Object_Arg_Traits_T<
            ::CF::FileSystem_ptr,
            ::CF::FileSystem_var,
            ::CF::FileSystem_out,
            TAO::Objref_Traits<CF::FileSystem>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:898

  template<>
  class Arg_Traits< ::CF::FileSystem::FileType>
    : public
        Basic_Arg_Traits_T<
            ::CF::FileSystem::FileType,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:941

  template<>
  class Arg_Traits< ::CF::FileSystem::FileInformationType>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::FileSystem::FileInformationType,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:679

  template<>
  class Arg_Traits< ::CF::FileSystem::FileInformationSequence>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::FileSystem::FileInformationSequence,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_RESOURCEFACTORY__ARG_TRAITS_)
#define _CF_RESOURCEFACTORY__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::ResourceFactory>
    : public
        Object_Arg_Traits_T<
            ::CF::ResourceFactory_ptr,
            ::CF::ResourceFactory_var,
            ::CF::ResourceFactory_out,
            TAO::Objref_Traits<CF::ResourceFactory>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_FILEMANAGER__ARG_TRAITS_)
#define _CF_FILEMANAGER__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::FileManager>
    : public
        Object_Arg_Traits_T<
            ::CF::FileManager_ptr,
            ::CF::FileManager_var,
            ::CF::FileManager_out,
            TAO::Objref_Traits<CF::FileManager>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:941

  template<>
  class Arg_Traits< ::CF::FileManager::MountType>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::FileManager::MountType,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:679

  template<>
  class Arg_Traits< ::CF::FileManager::MountSequence>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::FileManager::MountSequence,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_PPORT__ARG_TRAITS_)
#define _CF_PPORT__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::PPort>
    : public
        Object_Arg_Traits_T<
            ::CF::PPort_ptr,
            ::CF::PPort_var,
            ::CF::PPort_out,
            TAO::Objref_Traits<CF::PPort>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_LIFECYCLE__ARG_TRAITS_)
#define _CF_LIFECYCLE__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::LifeCycle>
    : public
        Object_Arg_Traits_T<
            ::CF::LifeCycle_ptr,
            ::CF::LifeCycle_var,
            ::CF::LifeCycle_out,
            TAO::Objref_Traits<CF::LifeCycle>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_TESTABLEOBJECT__ARG_TRAITS_)
#define _CF_TESTABLEOBJECT__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::TestableObject>
    : public
        Object_Arg_Traits_T<
            ::CF::TestableObject_ptr,
            ::CF::TestableObject_var,
            ::CF::TestableObject_out,
            TAO::Objref_Traits<CF::TestableObject>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_PROPERTYSET__ARG_TRAITS_)
#define _CF_PROPERTYSET__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::PropertySet>
    : public
        Object_Arg_Traits_T<
            ::CF::PropertySet_ptr,
            ::CF::PropertySet_var,
            ::CF::PropertySet_out,
            TAO::Objref_Traits<CF::PropertySet>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_DOMAINMANAGER__ARG_TRAITS_)
#define _CF_DOMAINMANAGER__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::DomainManager>
    : public
        Object_Arg_Traits_T<
            ::CF::DomainManager_ptr,
            ::CF::DomainManager_var,
            ::CF::DomainManager_out,
            TAO::Objref_Traits<CF::DomainManager>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:679

  template<>
  class Arg_Traits< ::CF::DomainManager::ApplicationSequence>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::DomainManager::ApplicationSequence,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:679

  template<>
  class Arg_Traits< ::CF::DomainManager::ApplicationFactorySequence>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::DomainManager::ApplicationFactorySequence,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:679

  template<>
  class Arg_Traits< ::CF::DomainManager::DeviceManagerSequence>
    : public
        Var_Size_Arg_Traits_T<
            ::CF::DomainManager::DeviceManagerSequence,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_PORTSUPPLIER__ARG_TRAITS_)
#define _CF_PORTSUPPLIER__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::PortSupplier>
    : public
        Object_Arg_Traits_T<
            ::CF::PortSupplier_ptr,
            ::CF::PortSupplier_var,
            ::CF::PortSupplier_out,
            TAO::Objref_Traits<CF::PortSupplier>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_LOADABLEDEVICE__ARG_TRAITS_)
#define _CF_LOADABLEDEVICE__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::LoadableDevice>
    : public
        Object_Arg_Traits_T<
            ::CF::LoadableDevice_ptr,
            ::CF::LoadableDevice_var,
            ::CF::LoadableDevice_out,
            TAO::Objref_Traits<CF::LoadableDevice>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:898

  template<>
  class Arg_Traits< ::CF::LoadableDevice::LoadType>
    : public
        Basic_Arg_Traits_T<
            ::CF::LoadableDevice::LoadType,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:147

#if !defined (_CF_EXECUTABLEDEVICE__ARG_TRAITS_)
#define _CF_EXECUTABLEDEVICE__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::CF::ExecutableDevice>
    : public
        Object_Arg_Traits_T<
            ::CF::ExecutableDevice_ptr,
            ::CF::ExecutableDevice_var,
            ::CF::ExecutableDevice_out,
            TAO::Objref_Traits<CF::ExecutableDevice>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL



// Proxy Broker Factory function pointer declarations.

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_root/root_ch.cpp:204

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_AggregateDevice_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_FileSystem_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_File_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_ResourceFactory_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_FileManager_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_PPort_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_LifeCycle_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_TestableObject_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_PropertySet_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_DomainManager_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_ApplicationFactory_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_PortSupplier_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_Resource_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_Device_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_Application_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_LoadableDevice_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_ExecutableDevice_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

extern 
TAO::Collocation_Proxy_Broker *
(*CF__TAO_DeviceManager_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj);

// TAO_IDL - Generated from
// .\be\be_visitor_traits.cpp:62

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations.
namespace TAO
{

#if !defined (_CF_AGGREGATEDEVICE__TRAITS_)
#define _CF_AGGREGATEDEVICE__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::AggregateDevice>
  {
    static ::CF::AggregateDevice_ptr duplicate (
        ::CF::AggregateDevice_ptr p);
    static void release (
        ::CF::AggregateDevice_ptr p);
    static ::CF::AggregateDevice_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::AggregateDevice_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_FILESYSTEM__TRAITS_)
#define _CF_FILESYSTEM__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::FileSystem>
  {
    static ::CF::FileSystem_ptr duplicate (
        ::CF::FileSystem_ptr p);
    static void release (
        ::CF::FileSystem_ptr p);
    static ::CF::FileSystem_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::FileSystem_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_FILE__TRAITS_)
#define _CF_FILE__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::File>
  {
    static ::CF::File_ptr duplicate (
        ::CF::File_ptr p);
    static void release (
        ::CF::File_ptr p);
    static ::CF::File_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::File_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_RESOURCEFACTORY__TRAITS_)
#define _CF_RESOURCEFACTORY__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::ResourceFactory>
  {
    static ::CF::ResourceFactory_ptr duplicate (
        ::CF::ResourceFactory_ptr p);
    static void release (
        ::CF::ResourceFactory_ptr p);
    static ::CF::ResourceFactory_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::ResourceFactory_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_FILEMANAGER__TRAITS_)
#define _CF_FILEMANAGER__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::FileManager>
  {
    static ::CF::FileManager_ptr duplicate (
        ::CF::FileManager_ptr p);
    static void release (
        ::CF::FileManager_ptr p);
    static ::CF::FileManager_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::FileManager_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_PPORT__TRAITS_)
#define _CF_PPORT__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::PPort>
  {
    static ::CF::PPort_ptr duplicate (
        ::CF::PPort_ptr p);
    static void release (
        ::CF::PPort_ptr p);
    static ::CF::PPort_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::PPort_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_LIFECYCLE__TRAITS_)
#define _CF_LIFECYCLE__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::LifeCycle>
  {
    static ::CF::LifeCycle_ptr duplicate (
        ::CF::LifeCycle_ptr p);
    static void release (
        ::CF::LifeCycle_ptr p);
    static ::CF::LifeCycle_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::LifeCycle_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_TESTABLEOBJECT__TRAITS_)
#define _CF_TESTABLEOBJECT__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::TestableObject>
  {
    static ::CF::TestableObject_ptr duplicate (
        ::CF::TestableObject_ptr p);
    static void release (
        ::CF::TestableObject_ptr p);
    static ::CF::TestableObject_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::TestableObject_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_PROPERTYSET__TRAITS_)
#define _CF_PROPERTYSET__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::PropertySet>
  {
    static ::CF::PropertySet_ptr duplicate (
        ::CF::PropertySet_ptr p);
    static void release (
        ::CF::PropertySet_ptr p);
    static ::CF::PropertySet_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::PropertySet_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_DOMAINMANAGER__TRAITS_)
#define _CF_DOMAINMANAGER__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::DomainManager>
  {
    static ::CF::DomainManager_ptr duplicate (
        ::CF::DomainManager_ptr p);
    static void release (
        ::CF::DomainManager_ptr p);
    static ::CF::DomainManager_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::DomainManager_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_APPLICATIONFACTORY__TRAITS_)
#define _CF_APPLICATIONFACTORY__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::ApplicationFactory>
  {
    static ::CF::ApplicationFactory_ptr duplicate (
        ::CF::ApplicationFactory_ptr p);
    static void release (
        ::CF::ApplicationFactory_ptr p);
    static ::CF::ApplicationFactory_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::ApplicationFactory_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_PORTSUPPLIER__TRAITS_)
#define _CF_PORTSUPPLIER__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::PortSupplier>
  {
    static ::CF::PortSupplier_ptr duplicate (
        ::CF::PortSupplier_ptr p);
    static void release (
        ::CF::PortSupplier_ptr p);
    static ::CF::PortSupplier_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::PortSupplier_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_RESOURCE__TRAITS_)
#define _CF_RESOURCE__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::Resource>
  {
    static ::CF::Resource_ptr duplicate (
        ::CF::Resource_ptr p);
    static void release (
        ::CF::Resource_ptr p);
    static ::CF::Resource_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::Resource_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_DEVICE__TRAITS_)
#define _CF_DEVICE__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::Device>
  {
    static ::CF::Device_ptr duplicate (
        ::CF::Device_ptr p);
    static void release (
        ::CF::Device_ptr p);
    static ::CF::Device_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::Device_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_APPLICATION__TRAITS_)
#define _CF_APPLICATION__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::Application>
  {
    static ::CF::Application_ptr duplicate (
        ::CF::Application_ptr p);
    static void release (
        ::CF::Application_ptr p);
    static ::CF::Application_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::Application_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_LOADABLEDEVICE__TRAITS_)
#define _CF_LOADABLEDEVICE__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::LoadableDevice>
  {
    static ::CF::LoadableDevice_ptr duplicate (
        ::CF::LoadableDevice_ptr p);
    static void release (
        ::CF::LoadableDevice_ptr p);
    static ::CF::LoadableDevice_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::LoadableDevice_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_EXECUTABLEDEVICE__TRAITS_)
#define _CF_EXECUTABLEDEVICE__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::ExecutableDevice>
  {
    static ::CF::ExecutableDevice_ptr duplicate (
        ::CF::ExecutableDevice_ptr p);
    static void release (
        ::CF::ExecutableDevice_ptr p);
    static ::CF::ExecutableDevice_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::ExecutableDevice_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_CF_DEVICEMANAGER__TRAITS_)
#define _CF_DEVICEMANAGER__TRAITS_

  template<>
  struct  Objref_Traits< ::CF::DeviceManager>
  {
    static ::CF::DeviceManager_ptr duplicate (
        ::CF::DeviceManager_ptr p);
    static void release (
        ::CF::DeviceManager_ptr p);
    static ::CF::DeviceManager_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CF::DeviceManager_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_ch.cpp:44



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= (::CORBA::Any &, const ::CF::DataType &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::DataType*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DataType *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DataType *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, const CF::DataType &); // copying version
 void operator<<= (::CORBA::Any &, CF::DataType*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DataType *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DataType *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::InvalidProfile &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::InvalidProfile*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::InvalidProfile *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::InvalidProfile *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::InvalidProfile &); // copying version
 void operator<<= (::CORBA::Any &, CF::InvalidProfile*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::InvalidProfile *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::InvalidProfile *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_ch.cpp:47



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, const ::CF::Properties &); // copying version
   void operator<<= ( ::CORBA::Any &, ::CF::Properties*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::Properties *&); // deprecated
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::Properties *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= ( ::CORBA::Any &, const CF::Properties &); // copying version
 void operator<<= ( ::CORBA::Any &, CF::Properties*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Properties *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::Properties *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::InvalidObjectReference &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::InvalidObjectReference*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::InvalidObjectReference *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::InvalidObjectReference *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::InvalidObjectReference &); // copying version
 void operator<<= (::CORBA::Any &, CF::InvalidObjectReference*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::InvalidObjectReference *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::InvalidObjectReference *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_ch.cpp:47



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, const ::CF::OctetSequence &); // copying version
   void operator<<= ( ::CORBA::Any &, ::CF::OctetSequence*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::OctetSequence *&); // deprecated
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::OctetSequence *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= ( ::CORBA::Any &, const CF::OctetSequence &); // copying version
 void operator<<= ( ::CORBA::Any &, CF::OctetSequence*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::OctetSequence *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::OctetSequence *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_ch.cpp:47



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, const ::CF::StringSequence &); // copying version
   void operator<<= ( ::CORBA::Any &, ::CF::StringSequence*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::StringSequence *&); // deprecated
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::StringSequence *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= ( ::CORBA::Any &, const CF::StringSequence &); // copying version
 void operator<<= ( ::CORBA::Any &, CF::StringSequence*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::StringSequence *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::StringSequence *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::UnknownProperties &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::UnknownProperties*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::UnknownProperties *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::UnknownProperties *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::UnknownProperties &); // copying version
 void operator<<= (::CORBA::Any &, CF::UnknownProperties*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::UnknownProperties *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::UnknownProperties *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_ch.cpp:44



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= (::CORBA::Any &, const ::CF::DeviceAssignmentType &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::DeviceAssignmentType*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DeviceAssignmentType *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DeviceAssignmentType *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, const CF::DeviceAssignmentType &); // copying version
 void operator<<= (::CORBA::Any &, CF::DeviceAssignmentType*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DeviceAssignmentType *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DeviceAssignmentType *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_ch.cpp:47



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, const ::CF::DeviceAssignmentSequence &); // copying version
   void operator<<= ( ::CORBA::Any &, ::CF::DeviceAssignmentSequence*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DeviceAssignmentSequence *&); // deprecated
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DeviceAssignmentSequence *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= ( ::CORBA::Any &, const CF::DeviceAssignmentSequence &); // copying version
 void operator<<= ( ::CORBA::Any &, CF::DeviceAssignmentSequence*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DeviceAssignmentSequence *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DeviceAssignmentSequence *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_ch.cpp:43

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, ::CF::ErrorNumberType);
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::ErrorNumberType &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, CF::ErrorNumberType);
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ErrorNumberType &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::InvalidFileName &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::InvalidFileName*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::InvalidFileName *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::InvalidFileName *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::InvalidFileName &); // copying version
 void operator<<= (::CORBA::Any &, CF::InvalidFileName*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::InvalidFileName *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::InvalidFileName *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::FileException &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::FileException*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::FileException *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::FileException *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::FileException &); // copying version
 void operator<<= (::CORBA::Any &, CF::FileException*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::FileException *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::FileException *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_ch.cpp:47



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, const ::CF::DeviceSequence &); // copying version
   void operator<<= ( ::CORBA::Any &, ::CF::DeviceSequence*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DeviceSequence *&); // deprecated
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DeviceSequence *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= ( ::CORBA::Any &, const CF::DeviceSequence &); // copying version
 void operator<<= ( ::CORBA::Any &, CF::DeviceSequence*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DeviceSequence *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DeviceSequence *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, AggregateDevice_ptr); // copying
   void operator<<= ( ::CORBA::Any &, AggregateDevice_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, AggregateDevice_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::AggregateDevice_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::AggregateDevice_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::AggregateDevice_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, FileSystem_ptr); // copying
   void operator<<= ( ::CORBA::Any &, FileSystem_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, FileSystem_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::FileSystem_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::FileSystem_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::FileSystem_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::FileSystem::UnknownFileSystemProperties &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::FileSystem::UnknownFileSystemProperties*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::FileSystem::UnknownFileSystemProperties *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::FileSystem::UnknownFileSystemProperties *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::FileSystem::UnknownFileSystemProperties &); // copying version
 void operator<<= (::CORBA::Any &, CF::FileSystem::UnknownFileSystemProperties*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::FileSystem::UnknownFileSystemProperties *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::FileSystem::UnknownFileSystemProperties *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_ch.cpp:43

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, ::CF::FileSystem::FileType);
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::FileSystem::FileType &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, CF::FileSystem::FileType);
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::FileSystem::FileType &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_ch.cpp:44



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= (::CORBA::Any &, const ::CF::FileSystem::FileInformationType &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::FileSystem::FileInformationType*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::FileSystem::FileInformationType *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::FileSystem::FileInformationType *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, const CF::FileSystem::FileInformationType &); // copying version
 void operator<<= (::CORBA::Any &, CF::FileSystem::FileInformationType*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::FileSystem::FileInformationType *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::FileSystem::FileInformationType *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_ch.cpp:47



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, const ::CF::FileSystem::FileInformationSequence &); // copying version
   void operator<<= ( ::CORBA::Any &, ::CF::FileSystem::FileInformationSequence*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::FileSystem::FileInformationSequence *&); // deprecated
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::FileSystem::FileInformationSequence *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= ( ::CORBA::Any &, const CF::FileSystem::FileInformationSequence &); // copying version
 void operator<<= ( ::CORBA::Any &, CF::FileSystem::FileInformationSequence*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::FileSystem::FileInformationSequence *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::FileSystem::FileInformationSequence *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, File_ptr); // copying
   void operator<<= ( ::CORBA::Any &, File_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, File_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::File_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::File_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::File_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::File::IOException &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::File::IOException*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::File::IOException *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::File::IOException *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::File::IOException &); // copying version
 void operator<<= (::CORBA::Any &, CF::File::IOException*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::File::IOException *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::File::IOException *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::File::InvalidFilePointer &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::File::InvalidFilePointer*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::File::InvalidFilePointer *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::File::InvalidFilePointer *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::File::InvalidFilePointer &); // copying version
 void operator<<= (::CORBA::Any &, CF::File::InvalidFilePointer*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::File::InvalidFilePointer *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::File::InvalidFilePointer *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, ResourceFactory_ptr); // copying
   void operator<<= ( ::CORBA::Any &, ResourceFactory_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ResourceFactory_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::ResourceFactory_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::ResourceFactory_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ResourceFactory_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::ResourceFactory::InvalidResourceId &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::ResourceFactory::InvalidResourceId*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::ResourceFactory::InvalidResourceId *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::ResourceFactory::InvalidResourceId *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::ResourceFactory::InvalidResourceId &); // copying version
 void operator<<= (::CORBA::Any &, CF::ResourceFactory::InvalidResourceId*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ResourceFactory::InvalidResourceId *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::ResourceFactory::InvalidResourceId *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::ResourceFactory::ShutdownFailure &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::ResourceFactory::ShutdownFailure*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::ResourceFactory::ShutdownFailure *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::ResourceFactory::ShutdownFailure *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::ResourceFactory::ShutdownFailure &); // copying version
 void operator<<= (::CORBA::Any &, CF::ResourceFactory::ShutdownFailure*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ResourceFactory::ShutdownFailure *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::ResourceFactory::ShutdownFailure *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::ResourceFactory::CreateResourceFailure &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::ResourceFactory::CreateResourceFailure*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::ResourceFactory::CreateResourceFailure *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::ResourceFactory::CreateResourceFailure *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::ResourceFactory::CreateResourceFailure &); // copying version
 void operator<<= (::CORBA::Any &, CF::ResourceFactory::CreateResourceFailure*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ResourceFactory::CreateResourceFailure *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::ResourceFactory::CreateResourceFailure *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, FileManager_ptr); // copying
   void operator<<= ( ::CORBA::Any &, FileManager_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, FileManager_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::FileManager_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::FileManager_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::FileManager_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_ch.cpp:44



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= (::CORBA::Any &, const ::CF::FileManager::MountType &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::FileManager::MountType*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::FileManager::MountType *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::FileManager::MountType *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, const CF::FileManager::MountType &); // copying version
 void operator<<= (::CORBA::Any &, CF::FileManager::MountType*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::FileManager::MountType *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::FileManager::MountType *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_ch.cpp:47



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, const ::CF::FileManager::MountSequence &); // copying version
   void operator<<= ( ::CORBA::Any &, ::CF::FileManager::MountSequence*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::FileManager::MountSequence *&); // deprecated
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::FileManager::MountSequence *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= ( ::CORBA::Any &, const CF::FileManager::MountSequence &); // copying version
 void operator<<= ( ::CORBA::Any &, CF::FileManager::MountSequence*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::FileManager::MountSequence *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::FileManager::MountSequence *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::FileManager::NonExistentMount &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::FileManager::NonExistentMount*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::FileManager::NonExistentMount *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::FileManager::NonExistentMount *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::FileManager::NonExistentMount &); // copying version
 void operator<<= (::CORBA::Any &, CF::FileManager::NonExistentMount*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::FileManager::NonExistentMount *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::FileManager::NonExistentMount *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::FileManager::InvalidFileSystem &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::FileManager::InvalidFileSystem*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::FileManager::InvalidFileSystem *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::FileManager::InvalidFileSystem *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::FileManager::InvalidFileSystem &); // copying version
 void operator<<= (::CORBA::Any &, CF::FileManager::InvalidFileSystem*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::FileManager::InvalidFileSystem *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::FileManager::InvalidFileSystem *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::FileManager::MountPointAlreadyExists &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::FileManager::MountPointAlreadyExists*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::FileManager::MountPointAlreadyExists *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::FileManager::MountPointAlreadyExists *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::FileManager::MountPointAlreadyExists &); // copying version
 void operator<<= (::CORBA::Any &, CF::FileManager::MountPointAlreadyExists*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::FileManager::MountPointAlreadyExists *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::FileManager::MountPointAlreadyExists *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, PPort_ptr); // copying
   void operator<<= ( ::CORBA::Any &, PPort_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, PPort_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::PPort_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::PPort_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::PPort_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::PPort::InvalidPort &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::PPort::InvalidPort*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::PPort::InvalidPort *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::PPort::InvalidPort *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::PPort::InvalidPort &); // copying version
 void operator<<= (::CORBA::Any &, CF::PPort::InvalidPort*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::PPort::InvalidPort *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::PPort::InvalidPort *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::PPort::OccupiedPort &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::PPort::OccupiedPort*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::PPort::OccupiedPort *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::PPort::OccupiedPort *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::PPort::OccupiedPort &); // copying version
 void operator<<= (::CORBA::Any &, CF::PPort::OccupiedPort*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::PPort::OccupiedPort *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::PPort::OccupiedPort *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, LifeCycle_ptr); // copying
   void operator<<= ( ::CORBA::Any &, LifeCycle_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, LifeCycle_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::LifeCycle_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::LifeCycle_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::LifeCycle_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::LifeCycle::InitializeError &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::LifeCycle::InitializeError*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::LifeCycle::InitializeError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::LifeCycle::InitializeError *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::LifeCycle::InitializeError &); // copying version
 void operator<<= (::CORBA::Any &, CF::LifeCycle::InitializeError*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::LifeCycle::InitializeError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::LifeCycle::InitializeError *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::LifeCycle::ReleaseError &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::LifeCycle::ReleaseError*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::LifeCycle::ReleaseError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::LifeCycle::ReleaseError *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::LifeCycle::ReleaseError &); // copying version
 void operator<<= (::CORBA::Any &, CF::LifeCycle::ReleaseError*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::LifeCycle::ReleaseError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::LifeCycle::ReleaseError *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, TestableObject_ptr); // copying
   void operator<<= ( ::CORBA::Any &, TestableObject_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, TestableObject_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::TestableObject_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::TestableObject_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::TestableObject_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::TestableObject::UnknownTest &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::TestableObject::UnknownTest*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::TestableObject::UnknownTest *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::TestableObject::UnknownTest *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::TestableObject::UnknownTest &); // copying version
 void operator<<= (::CORBA::Any &, CF::TestableObject::UnknownTest*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::TestableObject::UnknownTest *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::TestableObject::UnknownTest *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, PropertySet_ptr); // copying
   void operator<<= ( ::CORBA::Any &, PropertySet_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, PropertySet_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::PropertySet_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::PropertySet_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::PropertySet_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::PropertySet::InvalidConfiguration &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::PropertySet::InvalidConfiguration*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::PropertySet::InvalidConfiguration *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::PropertySet::InvalidConfiguration *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::PropertySet::InvalidConfiguration &); // copying version
 void operator<<= (::CORBA::Any &, CF::PropertySet::InvalidConfiguration*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::PropertySet::InvalidConfiguration *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::PropertySet::InvalidConfiguration *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::PropertySet::PartialConfiguration &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::PropertySet::PartialConfiguration*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::PropertySet::PartialConfiguration *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::PropertySet::PartialConfiguration *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::PropertySet::PartialConfiguration &); // copying version
 void operator<<= (::CORBA::Any &, CF::PropertySet::PartialConfiguration*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::PropertySet::PartialConfiguration *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::PropertySet::PartialConfiguration *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, DomainManager_ptr); // copying
   void operator<<= ( ::CORBA::Any &, DomainManager_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, DomainManager_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::DomainManager_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::DomainManager_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DomainManager_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::DomainManager::ApplicationInstallationError &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::DomainManager::ApplicationInstallationError*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DomainManager::ApplicationInstallationError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DomainManager::ApplicationInstallationError *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::DomainManager::ApplicationInstallationError &); // copying version
 void operator<<= (::CORBA::Any &, CF::DomainManager::ApplicationInstallationError*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DomainManager::ApplicationInstallationError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DomainManager::ApplicationInstallationError *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_ch.cpp:47



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, const ::CF::DomainManager::ApplicationSequence &); // copying version
   void operator<<= ( ::CORBA::Any &, ::CF::DomainManager::ApplicationSequence*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DomainManager::ApplicationSequence *&); // deprecated
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DomainManager::ApplicationSequence *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= ( ::CORBA::Any &, const CF::DomainManager::ApplicationSequence &); // copying version
 void operator<<= ( ::CORBA::Any &, CF::DomainManager::ApplicationSequence*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DomainManager::ApplicationSequence *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DomainManager::ApplicationSequence *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_ch.cpp:47



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, const ::CF::DomainManager::ApplicationFactorySequence &); // copying version
   void operator<<= ( ::CORBA::Any &, ::CF::DomainManager::ApplicationFactorySequence*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DomainManager::ApplicationFactorySequence *&); // deprecated
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DomainManager::ApplicationFactorySequence *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= ( ::CORBA::Any &, const CF::DomainManager::ApplicationFactorySequence &); // copying version
 void operator<<= ( ::CORBA::Any &, CF::DomainManager::ApplicationFactorySequence*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DomainManager::ApplicationFactorySequence *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DomainManager::ApplicationFactorySequence *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_ch.cpp:47



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, const ::CF::DomainManager::DeviceManagerSequence &); // copying version
   void operator<<= ( ::CORBA::Any &, ::CF::DomainManager::DeviceManagerSequence*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DomainManager::DeviceManagerSequence *&); // deprecated
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DomainManager::DeviceManagerSequence *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= ( ::CORBA::Any &, const CF::DomainManager::DeviceManagerSequence &); // copying version
 void operator<<= ( ::CORBA::Any &, CF::DomainManager::DeviceManagerSequence*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DomainManager::DeviceManagerSequence *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DomainManager::DeviceManagerSequence *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::DomainManager::InvalidIdentifier &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::DomainManager::InvalidIdentifier*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DomainManager::InvalidIdentifier *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DomainManager::InvalidIdentifier *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::DomainManager::InvalidIdentifier &); // copying version
 void operator<<= (::CORBA::Any &, CF::DomainManager::InvalidIdentifier*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DomainManager::InvalidIdentifier *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DomainManager::InvalidIdentifier *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::DomainManager::DeviceManagerNotRegistered &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::DomainManager::DeviceManagerNotRegistered*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DomainManager::DeviceManagerNotRegistered *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DomainManager::DeviceManagerNotRegistered *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::DomainManager::DeviceManagerNotRegistered &); // copying version
 void operator<<= (::CORBA::Any &, CF::DomainManager::DeviceManagerNotRegistered*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DomainManager::DeviceManagerNotRegistered *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DomainManager::DeviceManagerNotRegistered *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::DomainManager::ApplicationUninstallationError &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::DomainManager::ApplicationUninstallationError*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DomainManager::ApplicationUninstallationError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DomainManager::ApplicationUninstallationError *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::DomainManager::ApplicationUninstallationError &); // copying version
 void operator<<= (::CORBA::Any &, CF::DomainManager::ApplicationUninstallationError*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DomainManager::ApplicationUninstallationError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DomainManager::ApplicationUninstallationError *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::DomainManager::RegisterError &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::DomainManager::RegisterError*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DomainManager::RegisterError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DomainManager::RegisterError *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::DomainManager::RegisterError &); // copying version
 void operator<<= (::CORBA::Any &, CF::DomainManager::RegisterError*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DomainManager::RegisterError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DomainManager::RegisterError *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::DomainManager::UnregisterError &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::DomainManager::UnregisterError*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DomainManager::UnregisterError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DomainManager::UnregisterError *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::DomainManager::UnregisterError &); // copying version
 void operator<<= (::CORBA::Any &, CF::DomainManager::UnregisterError*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DomainManager::UnregisterError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DomainManager::UnregisterError *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::DomainManager::AlreadyConnected &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::DomainManager::AlreadyConnected*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DomainManager::AlreadyConnected *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DomainManager::AlreadyConnected *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::DomainManager::AlreadyConnected &); // copying version
 void operator<<= (::CORBA::Any &, CF::DomainManager::AlreadyConnected*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DomainManager::AlreadyConnected *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DomainManager::AlreadyConnected *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::DomainManager::InvalidEventChannelName &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::DomainManager::InvalidEventChannelName*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DomainManager::InvalidEventChannelName *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DomainManager::InvalidEventChannelName *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::DomainManager::InvalidEventChannelName &); // copying version
 void operator<<= (::CORBA::Any &, CF::DomainManager::InvalidEventChannelName*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DomainManager::InvalidEventChannelName *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DomainManager::InvalidEventChannelName *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::DomainManager::NotConnected &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::DomainManager::NotConnected*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DomainManager::NotConnected *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DomainManager::NotConnected *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::DomainManager::NotConnected &); // copying version
 void operator<<= (::CORBA::Any &, CF::DomainManager::NotConnected*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DomainManager::NotConnected *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DomainManager::NotConnected *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, ApplicationFactory_ptr); // copying
   void operator<<= ( ::CORBA::Any &, ApplicationFactory_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ApplicationFactory_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::ApplicationFactory_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::ApplicationFactory_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ApplicationFactory_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::ApplicationFactory::CreateApplicationRequestError &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::ApplicationFactory::CreateApplicationRequestError*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::ApplicationFactory::CreateApplicationRequestError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::ApplicationFactory::CreateApplicationRequestError *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::ApplicationFactory::CreateApplicationRequestError &); // copying version
 void operator<<= (::CORBA::Any &, CF::ApplicationFactory::CreateApplicationRequestError*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ApplicationFactory::CreateApplicationRequestError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::ApplicationFactory::CreateApplicationRequestError *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::ApplicationFactory::CreateApplicationError &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::ApplicationFactory::CreateApplicationError*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::ApplicationFactory::CreateApplicationError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::ApplicationFactory::CreateApplicationError *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::ApplicationFactory::CreateApplicationError &); // copying version
 void operator<<= (::CORBA::Any &, CF::ApplicationFactory::CreateApplicationError*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ApplicationFactory::CreateApplicationError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::ApplicationFactory::CreateApplicationError *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::ApplicationFactory::InvalidInitConfiguration &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::ApplicationFactory::InvalidInitConfiguration*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::ApplicationFactory::InvalidInitConfiguration *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::ApplicationFactory::InvalidInitConfiguration *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::ApplicationFactory::InvalidInitConfiguration &); // copying version
 void operator<<= (::CORBA::Any &, CF::ApplicationFactory::InvalidInitConfiguration*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ApplicationFactory::InvalidInitConfiguration *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::ApplicationFactory::InvalidInitConfiguration *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, PortSupplier_ptr); // copying
   void operator<<= ( ::CORBA::Any &, PortSupplier_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, PortSupplier_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::PortSupplier_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::PortSupplier_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::PortSupplier_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::PortSupplier::UnknownPort &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::PortSupplier::UnknownPort*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::PortSupplier::UnknownPort *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::PortSupplier::UnknownPort *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::PortSupplier::UnknownPort &); // copying version
 void operator<<= (::CORBA::Any &, CF::PortSupplier::UnknownPort*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::PortSupplier::UnknownPort *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::PortSupplier::UnknownPort *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, Resource_ptr); // copying
   void operator<<= ( ::CORBA::Any &, Resource_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, Resource_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::Resource_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::Resource_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Resource_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::Resource::StartError &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::Resource::StartError*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::Resource::StartError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::Resource::StartError *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::Resource::StartError &); // copying version
 void operator<<= (::CORBA::Any &, CF::Resource::StartError*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Resource::StartError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::Resource::StartError *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::Resource::StopError &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::Resource::StopError*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::Resource::StopError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::Resource::StopError *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::Resource::StopError &); // copying version
 void operator<<= (::CORBA::Any &, CF::Resource::StopError*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Resource::StopError *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::Resource::StopError *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, Device_ptr); // copying
   void operator<<= ( ::CORBA::Any &, Device_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, Device_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::Device_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::Device_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Device_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::Device::InvalidState &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::Device::InvalidState*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::Device::InvalidState *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::Device::InvalidState *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::Device::InvalidState &); // copying version
 void operator<<= (::CORBA::Any &, CF::Device::InvalidState*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Device::InvalidState *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::Device::InvalidState *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::Device::InvalidCapacity &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::Device::InvalidCapacity*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::Device::InvalidCapacity *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::Device::InvalidCapacity *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::Device::InvalidCapacity &); // copying version
 void operator<<= (::CORBA::Any &, CF::Device::InvalidCapacity*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Device::InvalidCapacity *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::Device::InvalidCapacity *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_ch.cpp:43

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, ::CF::Device::AdminType);
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::Device::AdminType &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, CF::Device::AdminType);
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Device::AdminType &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_ch.cpp:43

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, ::CF::Device::OperationalType);
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::Device::OperationalType &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, CF::Device::OperationalType);
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Device::OperationalType &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_ch.cpp:43

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, ::CF::Device::UsageType);
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::Device::UsageType &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, CF::Device::UsageType);
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Device::UsageType &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, Application_ptr); // copying
   void operator<<= ( ::CORBA::Any &, Application_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, Application_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::Application_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::Application_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Application_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_ch.cpp:44



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= (::CORBA::Any &, const ::CF::Application::ComponentProcessIdType &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::Application::ComponentProcessIdType*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::Application::ComponentProcessIdType *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::Application::ComponentProcessIdType *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, const CF::Application::ComponentProcessIdType &); // copying version
 void operator<<= (::CORBA::Any &, CF::Application::ComponentProcessIdType*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Application::ComponentProcessIdType *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::Application::ComponentProcessIdType *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_ch.cpp:47



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, const ::CF::Application::ComponentProcessIdSequence &); // copying version
   void operator<<= ( ::CORBA::Any &, ::CF::Application::ComponentProcessIdSequence*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::Application::ComponentProcessIdSequence *&); // deprecated
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::Application::ComponentProcessIdSequence *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= ( ::CORBA::Any &, const CF::Application::ComponentProcessIdSequence &); // copying version
 void operator<<= ( ::CORBA::Any &, CF::Application::ComponentProcessIdSequence*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Application::ComponentProcessIdSequence *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::Application::ComponentProcessIdSequence *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_ch.cpp:44



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= (::CORBA::Any &, const ::CF::Application::ComponentElementType &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::Application::ComponentElementType*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::Application::ComponentElementType *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::Application::ComponentElementType *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, const CF::Application::ComponentElementType &); // copying version
 void operator<<= (::CORBA::Any &, CF::Application::ComponentElementType*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Application::ComponentElementType *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::Application::ComponentElementType *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_ch.cpp:47



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, const ::CF::Application::ComponentElementSequence &); // copying version
   void operator<<= ( ::CORBA::Any &, ::CF::Application::ComponentElementSequence*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::Application::ComponentElementSequence *&); // deprecated
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::Application::ComponentElementSequence *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= ( ::CORBA::Any &, const CF::Application::ComponentElementSequence &); // copying version
 void operator<<= ( ::CORBA::Any &, CF::Application::ComponentElementSequence*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::Application::ComponentElementSequence *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::Application::ComponentElementSequence *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, LoadableDevice_ptr); // copying
   void operator<<= ( ::CORBA::Any &, LoadableDevice_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, LoadableDevice_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::LoadableDevice_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::LoadableDevice_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::LoadableDevice_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_ch.cpp:43

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, ::CF::LoadableDevice::LoadType);
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::LoadableDevice::LoadType &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, CF::LoadableDevice::LoadType);
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::LoadableDevice::LoadType &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::LoadableDevice::InvalidLoadKind &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::LoadableDevice::InvalidLoadKind*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::LoadableDevice::InvalidLoadKind *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::LoadableDevice::InvalidLoadKind *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::LoadableDevice::InvalidLoadKind &); // copying version
 void operator<<= (::CORBA::Any &, CF::LoadableDevice::InvalidLoadKind*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::LoadableDevice::InvalidLoadKind *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::LoadableDevice::InvalidLoadKind *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::LoadableDevice::LoadFail &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::LoadableDevice::LoadFail*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::LoadableDevice::LoadFail *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::LoadableDevice::LoadFail *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::LoadableDevice::LoadFail &); // copying version
 void operator<<= (::CORBA::Any &, CF::LoadableDevice::LoadFail*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::LoadableDevice::LoadFail *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::LoadableDevice::LoadFail *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, ExecutableDevice_ptr); // copying
   void operator<<= ( ::CORBA::Any &, ExecutableDevice_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ExecutableDevice_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::ExecutableDevice_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::ExecutableDevice_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ExecutableDevice_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::ExecutableDevice::InvalidProcess &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::ExecutableDevice::InvalidProcess*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::ExecutableDevice::InvalidProcess *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::ExecutableDevice::InvalidProcess *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::ExecutableDevice::InvalidProcess &); // copying version
 void operator<<= (::CORBA::Any &, CF::ExecutableDevice::InvalidProcess*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ExecutableDevice::InvalidProcess *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::ExecutableDevice::InvalidProcess *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::ExecutableDevice::InvalidFunction &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::ExecutableDevice::InvalidFunction*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::ExecutableDevice::InvalidFunction *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::ExecutableDevice::InvalidFunction *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::ExecutableDevice::InvalidFunction &); // copying version
 void operator<<= (::CORBA::Any &, CF::ExecutableDevice::InvalidFunction*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ExecutableDevice::InvalidFunction *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::ExecutableDevice::InvalidFunction *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::ExecutableDevice::InvalidParameters &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::ExecutableDevice::InvalidParameters*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::ExecutableDevice::InvalidParameters *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::ExecutableDevice::InvalidParameters *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::ExecutableDevice::InvalidParameters &); // copying version
 void operator<<= (::CORBA::Any &, CF::ExecutableDevice::InvalidParameters*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ExecutableDevice::InvalidParameters *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::ExecutableDevice::InvalidParameters *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::ExecutableDevice::InvalidOptions &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::ExecutableDevice::InvalidOptions*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::ExecutableDevice::InvalidOptions *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::ExecutableDevice::InvalidOptions *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::ExecutableDevice::InvalidOptions &); // copying version
 void operator<<= (::CORBA::Any &, CF::ExecutableDevice::InvalidOptions*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ExecutableDevice::InvalidOptions *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::ExecutableDevice::InvalidOptions *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_ch.cpp:44

#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

   void operator<<= (::CORBA::Any &, const ::CF::ExecutableDevice::ExecuteFail &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::ExecutableDevice::ExecuteFail*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::ExecutableDevice::ExecuteFail *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::ExecutableDevice::ExecuteFail *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 void operator<<= (::CORBA::Any &, const CF::ExecutableDevice::ExecuteFail &); // copying version
 void operator<<= (::CORBA::Any &, CF::ExecutableDevice::ExecuteFail*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::ExecutableDevice::ExecuteFail *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::ExecutableDevice::ExecuteFail *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_ch.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, DeviceManager_ptr); // copying
   void operator<<= ( ::CORBA::Any &, DeviceManager_ptr *); // non-copying
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, DeviceManager_ptr &);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, CF::DeviceManager_ptr); // copying
 void operator<<= (::CORBA::Any &, CF::DeviceManager_ptr *); // non-copying
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DeviceManager_ptr &);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_ch.cpp:44



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= (::CORBA::Any &, const ::CF::DeviceManager::ServiceType &); // copying version
   void operator<<= (::CORBA::Any &, ::CF::DeviceManager::ServiceType*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DeviceManager::ServiceType *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DeviceManager::ServiceType *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= (::CORBA::Any &, const CF::DeviceManager::ServiceType &); // copying version
 void operator<<= (::CORBA::Any &, CF::DeviceManager::ServiceType*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DeviceManager::ServiceType *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DeviceManager::ServiceType *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_ch.cpp:47



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
   void operator<<= ( ::CORBA::Any &, const ::CF::DeviceManager::ServiceSequence &); // copying version
   void operator<<= ( ::CORBA::Any &, ::CF::DeviceManager::ServiceSequence*); // noncopying version
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, ::CF::DeviceManager::ServiceSequence *&); // deprecated
   ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const ::CF::DeviceManager::ServiceSequence *&);
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 void operator<<= ( ::CORBA::Any &, const CF::DeviceManager::ServiceSequence &); // copying version
 void operator<<= ( ::CORBA::Any &, CF::DeviceManager::ServiceSequence*); // noncopying version
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, CF::DeviceManager::ServiceSequence *&); // deprecated
 ::CORBA::Boolean operator>>= (const ::CORBA::Any &, const CF::DeviceManager::ServiceSequence *&);
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ch.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::DataType &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::DataType &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::InvalidProfile &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::InvalidProfile &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:61

#if !defined _TAO_CDR_OP_CF_Properties_H_
#define _TAO_CDR_OP_CF_Properties_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Properties &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Properties &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_CF_Properties_H_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::InvalidObjectReference &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::InvalidObjectReference &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:61

#if !defined _TAO_CDR_OP_CF_OctetSequence_H_
#define _TAO_CDR_OP_CF_OctetSequence_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::OctetSequence &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::OctetSequence &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_CF_OctetSequence_H_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:61

#if !defined _TAO_CDR_OP_CF_StringSequence_H_
#define _TAO_CDR_OP_CF_StringSequence_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::StringSequence &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::StringSequence &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_CF_StringSequence_H_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::UnknownProperties &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::UnknownProperties &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ch.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::DeviceAssignmentType &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::DeviceAssignmentType &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:61

#if !defined _TAO_CDR_OP_CF_DeviceAssignmentSequence_H_
#define _TAO_CDR_OP_CF_DeviceAssignmentSequence_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DeviceAssignmentSequence &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DeviceAssignmentSequence &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_CF_DeviceAssignmentSequence_H_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_ch.cpp:40


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CF::ErrorNumberType _tao_enumerator);
 ::CORBA::Boolean operator>> (TAO_InputCDR &strm, CF::ErrorNumberType &_tao_enumerator);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::InvalidFileName &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::InvalidFileName &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::FileException &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::FileException &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:61

#if !defined _TAO_CDR_OP_CF_DeviceSequence_H_
#define _TAO_CDR_OP_CF_DeviceSequence_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DeviceSequence &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DeviceSequence &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_CF_DeviceSequence_H_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::AggregateDevice_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::AggregateDevice_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::FileSystem_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::FileSystem_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::FileSystem::UnknownFileSystemProperties &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::FileSystem::UnknownFileSystemProperties &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_ch.cpp:40


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CF::FileSystem::FileType _tao_enumerator);
 ::CORBA::Boolean operator>> (TAO_InputCDR &strm, CF::FileSystem::FileType &_tao_enumerator);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ch.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::FileSystem::FileInformationType &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::FileSystem::FileInformationType &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:61

#if !defined _TAO_CDR_OP_CF_FileSystem_FileInformationSequence_H_
#define _TAO_CDR_OP_CF_FileSystem_FileInformationSequence_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::FileSystem::FileInformationSequence &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::FileSystem::FileInformationSequence &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_CF_FileSystem_FileInformationSequence_H_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::File_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::File_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::File::IOException &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::File::IOException &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::File::InvalidFilePointer &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::File::InvalidFilePointer &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::ResourceFactory_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::ResourceFactory_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::ResourceFactory::InvalidResourceId &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::ResourceFactory::InvalidResourceId &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::ResourceFactory::ShutdownFailure &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::ResourceFactory::ShutdownFailure &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::ResourceFactory::CreateResourceFailure &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::ResourceFactory::CreateResourceFailure &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::FileManager_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::FileManager_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ch.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::FileManager::MountType &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::FileManager::MountType &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:61

#if !defined _TAO_CDR_OP_CF_FileManager_MountSequence_H_
#define _TAO_CDR_OP_CF_FileManager_MountSequence_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::FileManager::MountSequence &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::FileManager::MountSequence &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_CF_FileManager_MountSequence_H_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::FileManager::NonExistentMount &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::FileManager::NonExistentMount &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::FileManager::InvalidFileSystem &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::FileManager::InvalidFileSystem &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::FileManager::MountPointAlreadyExists &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::FileManager::MountPointAlreadyExists &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::PPort_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::PPort_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::PPort::InvalidPort &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::PPort::InvalidPort &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::PPort::OccupiedPort &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::PPort::OccupiedPort &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::LifeCycle_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::LifeCycle_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::LifeCycle::InitializeError &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::LifeCycle::InitializeError &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::LifeCycle::ReleaseError &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::LifeCycle::ReleaseError &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::TestableObject_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::TestableObject_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::TestableObject::UnknownTest &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::TestableObject::UnknownTest &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::PropertySet_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::PropertySet_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::PropertySet::InvalidConfiguration &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::PropertySet::InvalidConfiguration &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::PropertySet::PartialConfiguration &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::PropertySet::PartialConfiguration &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::DomainManager_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::DomainManager_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::DomainManager::ApplicationInstallationError &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::DomainManager::ApplicationInstallationError &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:61

#if !defined _TAO_CDR_OP_CF_DomainManager_ApplicationSequence_H_
#define _TAO_CDR_OP_CF_DomainManager_ApplicationSequence_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::ApplicationSequence &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DomainManager::ApplicationSequence &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_CF_DomainManager_ApplicationSequence_H_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:61

#if !defined _TAO_CDR_OP_CF_DomainManager_ApplicationFactorySequence_H_
#define _TAO_CDR_OP_CF_DomainManager_ApplicationFactorySequence_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::ApplicationFactorySequence &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DomainManager::ApplicationFactorySequence &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_CF_DomainManager_ApplicationFactorySequence_H_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:61

#if !defined _TAO_CDR_OP_CF_DomainManager_DeviceManagerSequence_H_
#define _TAO_CDR_OP_CF_DomainManager_DeviceManagerSequence_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::DeviceManagerSequence &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DomainManager::DeviceManagerSequence &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_CF_DomainManager_DeviceManagerSequence_H_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::DomainManager::InvalidIdentifier &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::DomainManager::InvalidIdentifier &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::DomainManager::DeviceManagerNotRegistered &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::DomainManager::DeviceManagerNotRegistered &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::DomainManager::ApplicationUninstallationError &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::DomainManager::ApplicationUninstallationError &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::DomainManager::RegisterError &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::DomainManager::RegisterError &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::DomainManager::UnregisterError &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::DomainManager::UnregisterError &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::DomainManager::AlreadyConnected &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::DomainManager::AlreadyConnected &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::DomainManager::InvalidEventChannelName &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::DomainManager::InvalidEventChannelName &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::DomainManager::NotConnected &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::DomainManager::NotConnected &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::ApplicationFactory_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::ApplicationFactory_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::ApplicationFactory::CreateApplicationRequestError &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::ApplicationFactory::CreateApplicationRequestError &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::ApplicationFactory::CreateApplicationError &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::ApplicationFactory::CreateApplicationError &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::ApplicationFactory::InvalidInitConfiguration &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::ApplicationFactory::InvalidInitConfiguration &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::PortSupplier_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::PortSupplier_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::PortSupplier::UnknownPort &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::PortSupplier::UnknownPort &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::Resource_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::Resource_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::Resource::StartError &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::Resource::StartError &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::Resource::StopError &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::Resource::StopError &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::Device_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::Device_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::Device::InvalidState &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::Device::InvalidState &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::Device::InvalidCapacity &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::Device::InvalidCapacity &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_ch.cpp:40


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CF::Device::AdminType _tao_enumerator);
 ::CORBA::Boolean operator>> (TAO_InputCDR &strm, CF::Device::AdminType &_tao_enumerator);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_ch.cpp:40


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CF::Device::OperationalType _tao_enumerator);
 ::CORBA::Boolean operator>> (TAO_InputCDR &strm, CF::Device::OperationalType &_tao_enumerator);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_ch.cpp:40


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CF::Device::UsageType _tao_enumerator);
 ::CORBA::Boolean operator>> (TAO_InputCDR &strm, CF::Device::UsageType &_tao_enumerator);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::Application_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::Application_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ch.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::Application::ComponentProcessIdType &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::Application::ComponentProcessIdType &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:61

#if !defined _TAO_CDR_OP_CF_Application_ComponentProcessIdSequence_H_
#define _TAO_CDR_OP_CF_Application_ComponentProcessIdSequence_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Application::ComponentProcessIdSequence &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Application::ComponentProcessIdSequence &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_CF_Application_ComponentProcessIdSequence_H_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ch.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::Application::ComponentElementType &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::Application::ComponentElementType &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:61

#if !defined _TAO_CDR_OP_CF_Application_ComponentElementSequence_H_
#define _TAO_CDR_OP_CF_Application_ComponentElementSequence_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Application::ComponentElementSequence &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Application::ComponentElementSequence &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_CF_Application_ComponentElementSequence_H_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::LoadableDevice_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::LoadableDevice_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_ch.cpp:40


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CF::LoadableDevice::LoadType _tao_enumerator);
 ::CORBA::Boolean operator>> (TAO_InputCDR &strm, CF::LoadableDevice::LoadType &_tao_enumerator);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::LoadableDevice::InvalidLoadKind &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::LoadableDevice::InvalidLoadKind &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::LoadableDevice::LoadFail &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::LoadableDevice::LoadFail &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::ExecutableDevice_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::ExecutableDevice_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::ExecutableDevice::InvalidProcess &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::ExecutableDevice::InvalidProcess &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::ExecutableDevice::InvalidFunction &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::ExecutableDevice::InvalidFunction &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::ExecutableDevice::InvalidParameters &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::ExecutableDevice::InvalidParameters &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::ExecutableDevice::InvalidOptions &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::ExecutableDevice::InvalidOptions &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_ch.cpp:43
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::ExecutableDevice::ExecuteFail &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::ExecutableDevice::ExecuteFail &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:47

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::DeviceManager_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::DeviceManager_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ch.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CF::DeviceManager::ServiceType &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, CF::DeviceManager::ServiceType &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:61

#if !defined _TAO_CDR_OP_CF_DeviceManager_ServiceSequence_H_
#define _TAO_CDR_OP_CF_DeviceManager_ServiceSequence_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DeviceManager::ServiceSequence &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DeviceManager::ServiceSequence &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_CF_DeviceManager_ServiceSequence_H_ */

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:1581
#if defined (__ACE_INLINE__)
#include "CFC.inl"
#endif /* defined INLINE */

#endif /* ifndef */

