// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "CFC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/ORB_Core.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "../include/CFC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_DataType[] =
      {
        { "id", &CORBA::_tc_string },
        { "value", &CORBA::_tc_any }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_DataType (
  ::CORBA::tk_struct,
  "IDL:CF/DataType:1.0",
  "DataType",
  _tao_fields_CF_DataType,
  2);


namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_DataType =
    &_tao_tc_CF_DataType;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CF::DataType::_tao_any_destructor (
    void *_tao_void_pointer)
{
  DataType *_tao_tmp_pointer =
    static_cast<DataType *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::InvalidProfile::InvalidProfile (void)
  : ::CORBA::UserException (
        "IDL:CF/InvalidProfile:1.0",
        "InvalidProfile"
      )
{
}

CF::InvalidProfile::~InvalidProfile (void)
{
}

CF::InvalidProfile::InvalidProfile (const ::CF::InvalidProfile &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::InvalidProfile&
CF::InvalidProfile::operator= (const ::CF::InvalidProfile &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::InvalidProfile::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidProfile *_tao_tmp_pointer =
    static_cast<InvalidProfile *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::InvalidProfile *
CF::InvalidProfile::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidProfile *> (_tao_excp);
}

const CF::InvalidProfile *
CF::InvalidProfile::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidProfile *> (_tao_excp);
}

::CORBA::Exception *CF::InvalidProfile::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::InvalidProfile, 0);
  return retval;
}

::CORBA::Exception *
CF::InvalidProfile::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::InvalidProfile (*this),
      0
    );
  return result;
}

void CF::InvalidProfile::_raise (void) const
{
  throw *this;
}

void CF::InvalidProfile::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::InvalidProfile::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::InvalidProfile::_tao_type (void) const
{
  return ::CF::_tc_InvalidProfile;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_InvalidProfile = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_InvalidProfile (
  ::CORBA::tk_except,
  "IDL:CF/InvalidProfile:1.0",
  "InvalidProfile",
  _tao_fields_CF_InvalidProfile,
  0);


namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_InvalidProfile =
    &_tao_tc_CF_InvalidProfile;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CF_PROPERTIES_CS_)
#define _CF_PROPERTIES_CS_

CF::Properties::Properties (void)
{}

CF::Properties::Properties (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        DataType
      > (max)
{}

CF::Properties::Properties (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CF::DataType * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        DataType
      >
    (max, length, buffer, release)
{}

CF::Properties::Properties (
    const Properties &seq)
  : ::TAO::unbounded_value_sequence<
        DataType
      > (seq)
{}

CF::Properties::~Properties (void)
{}

void CF::Properties::_tao_any_destructor (
    void * _tao_void_pointer)
{
  Properties * _tao_tmp_pointer =
    static_cast<Properties *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CF_Properties_GUARD
#define _TAO_TYPECODE_CF_Properties_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CF_Properties_0 (
          ::CORBA::tk_sequence,
          &CF::_tc_DataType,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CF_Properties_0 =
        &CF_Properties_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CF_Properties_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CF_Properties (
    ::CORBA::tk_alias,
    "IDL:CF/Properties:1.0",
    "Properties",
    &TAO::TypeCode::tc_CF_Properties_0);
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_Properties =
    &_tao_tc_CF_Properties;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::InvalidObjectReference::InvalidObjectReference (
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/InvalidObjectReference:1.0",
        "InvalidObjectReference"
      )
{
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::InvalidObjectReference::InvalidObjectReference (void)
  : ::CORBA::UserException (
        "IDL:CF/InvalidObjectReference:1.0",
        "InvalidObjectReference"
      )
{
}

CF::InvalidObjectReference::~InvalidObjectReference (void)
{
}

CF::InvalidObjectReference::InvalidObjectReference (const ::CF::InvalidObjectReference &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::InvalidObjectReference&
CF::InvalidObjectReference::operator= (const ::CF::InvalidObjectReference &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::InvalidObjectReference::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidObjectReference *_tao_tmp_pointer =
    static_cast<InvalidObjectReference *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::InvalidObjectReference *
CF::InvalidObjectReference::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidObjectReference *> (_tao_excp);
}

const CF::InvalidObjectReference *
CF::InvalidObjectReference::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidObjectReference *> (_tao_excp);
}

::CORBA::Exception *CF::InvalidObjectReference::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::InvalidObjectReference, 0);
  return retval;
}

::CORBA::Exception *
CF::InvalidObjectReference::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::InvalidObjectReference (*this),
      0
    );
  return result;
}

void CF::InvalidObjectReference::_raise (void) const
{
  throw *this;
}

void CF::InvalidObjectReference::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::InvalidObjectReference::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::InvalidObjectReference::_tao_type (void) const
{
  return ::CF::_tc_InvalidObjectReference;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_InvalidObjectReference[] =
      {
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_InvalidObjectReference (
  ::CORBA::tk_except,
  "IDL:CF/InvalidObjectReference:1.0",
  "InvalidObjectReference",
  _tao_fields_CF_InvalidObjectReference,
  1);


namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_InvalidObjectReference =
    &_tao_tc_CF_InvalidObjectReference;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CF_OCTETSEQUENCE_CS_)
#define _CF_OCTETSEQUENCE_CS_

CF::OctetSequence::OctetSequence (void)
{}

CF::OctetSequence::OctetSequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

CF::OctetSequence::OctetSequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

CF::OctetSequence::OctetSequence (
    const OctetSequence &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

CF::OctetSequence::~OctetSequence (void)
{}

void CF::OctetSequence::_tao_any_destructor (
    void * _tao_void_pointer)
{
  OctetSequence * _tao_tmp_pointer =
    static_cast<OctetSequence *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CF_OctetSequence_GUARD
#define _TAO_TYPECODE_CF_OctetSequence_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CF_OctetSequence_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CF_OctetSequence_0 =
        &CF_OctetSequence_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CF_OctetSequence_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CF_OctetSequence (
    ::CORBA::tk_alias,
    "IDL:CF/OctetSequence:1.0",
    "OctetSequence",
    &TAO::TypeCode::tc_CF_OctetSequence_0);
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_OctetSequence =
    &_tao_tc_CF_OctetSequence;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CF_STRINGSEQUENCE_CS_)
#define _CF_STRINGSEQUENCE_CS_

CF::StringSequence::StringSequence (void)
{}

CF::StringSequence::StringSequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_basic_string_sequence<char> (max)
{}

CF::StringSequence::StringSequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Char * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_basic_string_sequence<char>
    (max, length, buffer, release)
{}

CF::StringSequence::StringSequence (
    const StringSequence &seq)
  : ::TAO::unbounded_basic_string_sequence<char> (seq)
{}

CF::StringSequence::~StringSequence (void)
{}

void CF::StringSequence::_tao_any_destructor (
    void * _tao_void_pointer)
{
  StringSequence * _tao_tmp_pointer =
    static_cast<StringSequence *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CF_StringSequence_GUARD
#define _TAO_TYPECODE_CF_StringSequence_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CF_StringSequence_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_string,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CF_StringSequence_0 =
        &CF_StringSequence_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CF_StringSequence_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CF_StringSequence (
    ::CORBA::tk_alias,
    "IDL:CF/StringSequence:1.0",
    "StringSequence",
    &TAO::TypeCode::tc_CF_StringSequence_0);
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_StringSequence =
    &_tao_tc_CF_StringSequence;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::UnknownProperties::UnknownProperties (
    const CF::Properties & _tao_invalidProperties)
  : ::CORBA::UserException (
        "IDL:CF/UnknownProperties:1.0",
        "UnknownProperties"
      )
{
  this->invalidProperties = _tao_invalidProperties;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::UnknownProperties::UnknownProperties (void)
  : ::CORBA::UserException (
        "IDL:CF/UnknownProperties:1.0",
        "UnknownProperties"
      )
{
}

CF::UnknownProperties::~UnknownProperties (void)
{
}

CF::UnknownProperties::UnknownProperties (const ::CF::UnknownProperties &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->invalidProperties = _tao_excp.invalidProperties;
}

CF::UnknownProperties&
CF::UnknownProperties::operator= (const ::CF::UnknownProperties &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->invalidProperties = _tao_excp.invalidProperties;
  return *this;
}

void CF::UnknownProperties::_tao_any_destructor (void *_tao_void_pointer)
{
  UnknownProperties *_tao_tmp_pointer =
    static_cast<UnknownProperties *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::UnknownProperties *
CF::UnknownProperties::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UnknownProperties *> (_tao_excp);
}

const CF::UnknownProperties *
CF::UnknownProperties::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UnknownProperties *> (_tao_excp);
}

::CORBA::Exception *CF::UnknownProperties::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::UnknownProperties, 0);
  return retval;
}

::CORBA::Exception *
CF::UnknownProperties::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::UnknownProperties (*this),
      0
    );
  return result;
}

void CF::UnknownProperties::_raise (void) const
{
  throw *this;
}

void CF::UnknownProperties::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::UnknownProperties::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::UnknownProperties::_tao_type (void) const
{
  return ::CF::_tc_UnknownProperties;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_UnknownProperties[] =
      {
        { "invalidProperties", &CF::_tc_Properties }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_UnknownProperties (
  ::CORBA::tk_except,
  "IDL:CF/UnknownProperties:1.0",
  "UnknownProperties",
  _tao_fields_CF_UnknownProperties,
  1);


namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_UnknownProperties =
    &_tao_tc_CF_UnknownProperties;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_DeviceAssignmentType[] =
      {
        { "componentId", &CORBA::_tc_string },
        { "assignedDeviceId", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_DeviceAssignmentType (
  ::CORBA::tk_struct,
  "IDL:CF/DeviceAssignmentType:1.0",
  "DeviceAssignmentType",
  _tao_fields_CF_DeviceAssignmentType,
  2);


namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_DeviceAssignmentType =
    &_tao_tc_CF_DeviceAssignmentType;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CF::DeviceAssignmentType::_tao_any_destructor (
    void *_tao_void_pointer)
{
  DeviceAssignmentType *_tao_tmp_pointer =
    static_cast<DeviceAssignmentType *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CF_DEVICEASSIGNMENTSEQUENCE_CS_)
#define _CF_DEVICEASSIGNMENTSEQUENCE_CS_

CF::DeviceAssignmentSequence::DeviceAssignmentSequence (void)
{}

CF::DeviceAssignmentSequence::DeviceAssignmentSequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        DeviceAssignmentType
      > (max)
{}

CF::DeviceAssignmentSequence::DeviceAssignmentSequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CF::DeviceAssignmentType * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        DeviceAssignmentType
      >
    (max, length, buffer, release)
{}

CF::DeviceAssignmentSequence::DeviceAssignmentSequence (
    const DeviceAssignmentSequence &seq)
  : ::TAO::unbounded_value_sequence<
        DeviceAssignmentType
      > (seq)
{}

CF::DeviceAssignmentSequence::~DeviceAssignmentSequence (void)
{}

void CF::DeviceAssignmentSequence::_tao_any_destructor (
    void * _tao_void_pointer)
{
  DeviceAssignmentSequence * _tao_tmp_pointer =
    static_cast<DeviceAssignmentSequence *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CF_DeviceAssignmentSequence_GUARD
#define _TAO_TYPECODE_CF_DeviceAssignmentSequence_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CF_DeviceAssignmentSequence_0 (
          ::CORBA::tk_sequence,
          &CF::_tc_DeviceAssignmentType,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CF_DeviceAssignmentSequence_0 =
        &CF_DeviceAssignmentSequence_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CF_DeviceAssignmentSequence_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CF_DeviceAssignmentSequence (
    ::CORBA::tk_alias,
    "IDL:CF/DeviceAssignmentSequence:1.0",
    "DeviceAssignmentSequence",
    &TAO::TypeCode::tc_CF_DeviceAssignmentSequence_0);
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_DeviceAssignmentSequence =
    &_tao_tc_CF_DeviceAssignmentSequence;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_CF_ErrorNumberType[] =
  {
    "CFNOTSET",
    "CFE2BIG",
    "CFEACCES",
    "CFEAGAIN",
    "CFEBADF",
    "CFEBADMSG",
    "CFEBUSY",
    "CFECANCELED",
    "CFECHILD",
    "CFEDEADLK",
    "CFEDOM",
    "CFEEXIST",
    "CFEFAULT",
    "CFEFBIG",
    "CFEINPROGRESS",
    "CFEINTR",
    "CFEINVAL",
    "CFEIO",
    "CFEISDIR",
    "CFEMFILE",
    "CFEMLINK",
    "CFEMSGSIZE",
    "CFENAMETOOLONG",
    "CFENFILE",
    "CFENODEV",
    "CFENOENT",
    "CFENOEXEC",
    "CFENOLCK",
    "CFENOMEM",
    "CFENOSPC",
    "CFENOSYS",
    "CFENOTDIR",
    "CFENOTEMPTY",
    "CFENOTSUP",
    "CFENOTTY",
    "CFENXIO",
    "CFEPERM",
    "CFEPIPE",
    "CFERANGE",
    "CFEROFS",
    "CFESPIPE",
    "CFESRCH",
    "CFETIMEDOUT",
    "CFEXDEV"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_CF_ErrorNumberType (
    "IDL:CF/ErrorNumberType:1.0",
    "ErrorNumberType",
    _tao_enumerators_CF_ErrorNumberType,
    44);
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_ErrorNumberType =
    &_tao_tc_CF_ErrorNumberType;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::InvalidFileName::InvalidFileName (
    CF::ErrorNumberType _tao_errorNumber,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/InvalidFileName:1.0",
        "InvalidFileName"
      )
{
  this->errorNumber = _tao_errorNumber;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::InvalidFileName::InvalidFileName (void)
  : ::CORBA::UserException (
        "IDL:CF/InvalidFileName:1.0",
        "InvalidFileName"
      )
{
}

CF::InvalidFileName::~InvalidFileName (void)
{
}

CF::InvalidFileName::InvalidFileName (const ::CF::InvalidFileName &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::InvalidFileName&
CF::InvalidFileName::operator= (const ::CF::InvalidFileName &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::InvalidFileName::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidFileName *_tao_tmp_pointer =
    static_cast<InvalidFileName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::InvalidFileName *
CF::InvalidFileName::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidFileName *> (_tao_excp);
}

const CF::InvalidFileName *
CF::InvalidFileName::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidFileName *> (_tao_excp);
}

::CORBA::Exception *CF::InvalidFileName::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::InvalidFileName, 0);
  return retval;
}

::CORBA::Exception *
CF::InvalidFileName::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::InvalidFileName (*this),
      0
    );
  return result;
}

void CF::InvalidFileName::_raise (void) const
{
  throw *this;
}

void CF::InvalidFileName::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::InvalidFileName::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::InvalidFileName::_tao_type (void) const
{
  return ::CF::_tc_InvalidFileName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_InvalidFileName[] =
      {
        { "errorNumber", &CF::_tc_ErrorNumberType },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_InvalidFileName (
  ::CORBA::tk_except,
  "IDL:CF/InvalidFileName:1.0",
  "InvalidFileName",
  _tao_fields_CF_InvalidFileName,
  2);


namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_InvalidFileName =
    &_tao_tc_CF_InvalidFileName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::FileException::FileException (
    CF::ErrorNumberType _tao_errorNumber,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/FileException:1.0",
        "FileException"
      )
{
  this->errorNumber = _tao_errorNumber;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::FileException::FileException (void)
  : ::CORBA::UserException (
        "IDL:CF/FileException:1.0",
        "FileException"
      )
{
}

CF::FileException::~FileException (void)
{
}

CF::FileException::FileException (const ::CF::FileException &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::FileException&
CF::FileException::operator= (const ::CF::FileException &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::FileException::_tao_any_destructor (void *_tao_void_pointer)
{
  FileException *_tao_tmp_pointer =
    static_cast<FileException *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::FileException *
CF::FileException::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<FileException *> (_tao_excp);
}

const CF::FileException *
CF::FileException::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const FileException *> (_tao_excp);
}

::CORBA::Exception *CF::FileException::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::FileException, 0);
  return retval;
}

::CORBA::Exception *
CF::FileException::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::FileException (*this),
      0
    );
  return result;
}

void CF::FileException::_raise (void) const
{
  throw *this;
}

void CF::FileException::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::FileException::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::FileException::_tao_type (void) const
{
  return ::CF::_tc_FileException;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_FileException[] =
      {
        { "errorNumber", &CF::_tc_ErrorNumberType },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_FileException (
  ::CORBA::tk_except,
  "IDL:CF/FileException:1.0",
  "FileException",
  _tao_fields_CF_FileException,
  2);


namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_FileException =
    &_tao_tc_CF_FileException;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CF_DEVICESEQUENCE_CS_)
#define _CF_DEVICESEQUENCE_CS_

CF::DeviceSequence::DeviceSequence (void)
{}

CF::DeviceSequence::DeviceSequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        Device,
        Device_var
      > (max)
{}

CF::DeviceSequence::DeviceSequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CF::Device_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        Device,
        Device_var
      >
    (max, length, buffer, release)
{}

CF::DeviceSequence::DeviceSequence (
    const DeviceSequence &seq)
  : ::TAO::unbounded_object_reference_sequence<
        Device,
        Device_var
      > (seq)
{}

CF::DeviceSequence::~DeviceSequence (void)
{}

void CF::DeviceSequence::_tao_any_destructor (
    void * _tao_void_pointer)
{
  DeviceSequence * _tao_tmp_pointer =
    static_cast<DeviceSequence *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CF_DeviceSequence_GUARD
#define _TAO_TYPECODE_CF_DeviceSequence_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CF_DeviceSequence_0 (
          ::CORBA::tk_sequence,
          &CF::_tc_Device,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CF_DeviceSequence_0 =
        &CF_DeviceSequence_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CF_DeviceSequence_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CF_DeviceSequence (
    ::CORBA::tk_alias,
    "IDL:CF/DeviceSequence:1.0",
    "DeviceSequence",
    &TAO::TypeCode::tc_CF_DeviceSequence_0);
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_DeviceSequence =
    &_tao_tc_CF_DeviceSequence;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::AggregateDevice.

CF::AggregateDevice_ptr
TAO::Objref_Traits<CF::AggregateDevice>::duplicate (
    CF::AggregateDevice_ptr p)
{
  return CF::AggregateDevice::_duplicate (p);
}

void
TAO::Objref_Traits<CF::AggregateDevice>::release (
    CF::AggregateDevice_ptr p)
{
  ::CORBA::release (p);
}

CF::AggregateDevice_ptr
TAO::Objref_Traits<CF::AggregateDevice>::nil (void)
{
  return CF::AggregateDevice::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::AggregateDevice>::marshal (
    const CF::AggregateDevice_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_AggregateDevice_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::DeviceSequence *
CF::AggregateDevice::devices (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AggregateDevice_Proxy_Broker_ == 0)
    {
      CF_AggregateDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::DeviceSequence>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_devices",
      12,
      this->the_TAO_AggregateDevice_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::AggregateDevice::addDevice (
  ::CF::Device_ptr associatedDevice)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AggregateDevice_Proxy_Broker_ == 0)
    {
      CF_AggregateDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::Device>::in_arg_val _tao_associatedDevice (associatedDevice);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_associatedDevice
    };

  static TAO::Exception_Data
  _tao_CF_AggregateDevice_addDevice_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidObjectReference:1.0",
        CF::InvalidObjectReference::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidObjectReference
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "addDevice",
      9,
      this->the_TAO_AggregateDevice_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_AggregateDevice_addDevice_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::AggregateDevice::removeDevice (
  ::CF::Device_ptr associatedDevice)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AggregateDevice_Proxy_Broker_ == 0)
    {
      CF_AggregateDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::Device>::in_arg_val _tao_associatedDevice (associatedDevice);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_associatedDevice
    };

  static TAO::Exception_Data
  _tao_CF_AggregateDevice_removeDevice_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidObjectReference:1.0",
        CF::InvalidObjectReference::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidObjectReference
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "removeDevice",
      12,
      this->the_TAO_AggregateDevice_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_AggregateDevice_removeDevice_exceptiondata,
      1
    );
}

CF::AggregateDevice::AggregateDevice (void)
 : the_TAO_AggregateDevice_Proxy_Broker_ (0)
{
  this->CF_AggregateDevice_setup_collocation ();
}

void
CF::AggregateDevice::CF_AggregateDevice_setup_collocation ()
{
  if (::CF__TAO_AggregateDevice_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_AggregateDevice_Proxy_Broker_ =
        ::CF__TAO_AggregateDevice_Proxy_Broker_Factory_function_pointer (this);
    }
}

CF::AggregateDevice::~AggregateDevice (void)
{}

void 
CF::AggregateDevice::_tao_any_destructor (void *_tao_void_pointer)
{
  AggregateDevice *_tao_tmp_pointer =
    static_cast<AggregateDevice *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::AggregateDevice_ptr
CF::AggregateDevice::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AggregateDevice>::narrow (
        _tao_objref,
        "IDL:CF/AggregateDevice:1.0",
        CF__TAO_AggregateDevice_Proxy_Broker_Factory_function_pointer
      );
}

CF::AggregateDevice_ptr
CF::AggregateDevice::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AggregateDevice>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/AggregateDevice:1.0",
        CF__TAO_AggregateDevice_Proxy_Broker_Factory_function_pointer
      );
}

CF::AggregateDevice_ptr
CF::AggregateDevice::_nil (void)
{
  return 0;
}

CF::AggregateDevice_ptr
CF::AggregateDevice::_duplicate (AggregateDevice_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::AggregateDevice::_tao_release (AggregateDevice_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::AggregateDevice::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/AggregateDevice:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::AggregateDevice::_interface_repository_id (void) const
{
  return "IDL:CF/AggregateDevice:1.0";
}

::CORBA::Boolean
CF::AggregateDevice::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_AggregateDevice (
    ::CORBA::tk_objref,
    "IDL:CF/AggregateDevice:1.0",
    "AggregateDevice");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_AggregateDevice =
    &_tao_tc_CF_AggregateDevice;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::FileSystem.

CF::FileSystem_ptr
TAO::Objref_Traits<CF::FileSystem>::duplicate (
    CF::FileSystem_ptr p)
{
  return CF::FileSystem::_duplicate (p);
}

void
TAO::Objref_Traits<CF::FileSystem>::release (
    CF::FileSystem_ptr p)
{
  ::CORBA::release (p);
}

CF::FileSystem_ptr
TAO::Objref_Traits<CF::FileSystem>::nil (void)
{
  return CF::FileSystem::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::FileSystem>::marshal (
    const CF::FileSystem_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_FileSystem_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::FileSystem::UnknownFileSystemProperties::UnknownFileSystemProperties (
    const CF::Properties & _tao_invalidProperties)
  : ::CORBA::UserException (
        "IDL:CF/FileSystem/UnknownFileSystemProperties:1.0",
        "UnknownFileSystemProperties"
      )
{
  this->invalidProperties = _tao_invalidProperties;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::FileSystem::UnknownFileSystemProperties::UnknownFileSystemProperties (void)
  : ::CORBA::UserException (
        "IDL:CF/FileSystem/UnknownFileSystemProperties:1.0",
        "UnknownFileSystemProperties"
      )
{
}

CF::FileSystem::UnknownFileSystemProperties::~UnknownFileSystemProperties (void)
{
}

CF::FileSystem::UnknownFileSystemProperties::UnknownFileSystemProperties (const ::CF::FileSystem::UnknownFileSystemProperties &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->invalidProperties = _tao_excp.invalidProperties;
}

CF::FileSystem::UnknownFileSystemProperties&
CF::FileSystem::UnknownFileSystemProperties::operator= (const ::CF::FileSystem::UnknownFileSystemProperties &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->invalidProperties = _tao_excp.invalidProperties;
  return *this;
}

void CF::FileSystem::UnknownFileSystemProperties::_tao_any_destructor (void *_tao_void_pointer)
{
  UnknownFileSystemProperties *_tao_tmp_pointer =
    static_cast<UnknownFileSystemProperties *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::FileSystem::UnknownFileSystemProperties *
CF::FileSystem::UnknownFileSystemProperties::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UnknownFileSystemProperties *> (_tao_excp);
}

const CF::FileSystem::UnknownFileSystemProperties *
CF::FileSystem::UnknownFileSystemProperties::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UnknownFileSystemProperties *> (_tao_excp);
}

::CORBA::Exception *CF::FileSystem::UnknownFileSystemProperties::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::FileSystem::UnknownFileSystemProperties, 0);
  return retval;
}

::CORBA::Exception *
CF::FileSystem::UnknownFileSystemProperties::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::FileSystem::UnknownFileSystemProperties (*this),
      0
    );
  return result;
}

void CF::FileSystem::UnknownFileSystemProperties::_raise (void) const
{
  throw *this;
}

void CF::FileSystem::UnknownFileSystemProperties::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::FileSystem::UnknownFileSystemProperties::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::FileSystem::UnknownFileSystemProperties::_tao_type (void) const
{
  return ::CF::FileSystem::_tc_UnknownFileSystemProperties;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_FileSystem_UnknownFileSystemProperties[] =
      {
        { "invalidProperties", &CF::_tc_Properties }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_FileSystem_UnknownFileSystemProperties (
  ::CORBA::tk_except,
  "IDL:CF/FileSystem/UnknownFileSystemProperties:1.0",
  "UnknownFileSystemProperties",
  _tao_fields_CF_FileSystem_UnknownFileSystemProperties,
  1);

::CORBA::TypeCode_ptr const CF::FileSystem::_tc_UnknownFileSystemProperties =
  &_tao_tc_CF_FileSystem_UnknownFileSystemProperties;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_constant/constant_cs.cpp:61

const char *const CF::FileSystem::SIZE = "SIZE";

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_constant/constant_cs.cpp:61

const char *const CF::FileSystem::AVAILABLE_SIZE = "AVAILABLE_SPACE";

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_CF_FileSystem_FileType[] =
  {
    "PLAIN",
    "DIRECTORY",
    "FILE_SYSTEM"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_CF_FileSystem_FileType (
    "IDL:CF/FileSystem/FileType:1.0",
    "FileType",
    _tao_enumerators_CF_FileSystem_FileType,
    3);
  
::CORBA::TypeCode_ptr const CF::FileSystem::_tc_FileType =
  &_tao_tc_CF_FileSystem_FileType;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_FileSystem_FileInformationType[] =
      {
        { "name", &CORBA::_tc_string },
        { "kind", &CF::FileSystem::_tc_FileType },
        { "size", &CORBA::_tc_ulonglong },
        { "fileProperties", &CF::_tc_Properties }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_FileSystem_FileInformationType (
  ::CORBA::tk_struct,
  "IDL:CF/FileSystem/FileInformationType:1.0",
  "FileInformationType",
  _tao_fields_CF_FileSystem_FileInformationType,
  4);

::CORBA::TypeCode_ptr const CF::FileSystem::_tc_FileInformationType =
  &_tao_tc_CF_FileSystem_FileInformationType;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CF::FileSystem::FileInformationType::_tao_any_destructor (
    void *_tao_void_pointer)
{
  FileInformationType *_tao_tmp_pointer =
    static_cast<FileInformationType *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CF_FILESYSTEM_FILEINFORMATIONSEQUENCE_CS_)
#define _CF_FILESYSTEM_FILEINFORMATIONSEQUENCE_CS_

CF::FileSystem::FileInformationSequence::FileInformationSequence (void)
{}

CF::FileSystem::FileInformationSequence::FileInformationSequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        FileInformationType
      > (max)
{}

CF::FileSystem::FileInformationSequence::FileInformationSequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CF::FileSystem::FileInformationType * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        FileInformationType
      >
    (max, length, buffer, release)
{}

CF::FileSystem::FileInformationSequence::FileInformationSequence (
    const FileInformationSequence &seq)
  : ::TAO::unbounded_value_sequence<
        FileInformationType
      > (seq)
{}

CF::FileSystem::FileInformationSequence::~FileInformationSequence (void)
{}

void CF::FileSystem::FileInformationSequence::_tao_any_destructor (
    void * _tao_void_pointer)
{
  FileInformationSequence * _tao_tmp_pointer =
    static_cast<FileInformationSequence *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CF_FileSystem_FileInformationSequence_GUARD
#define _TAO_TYPECODE_CF_FileSystem_FileInformationSequence_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CF_FileSystem_FileInformationSequence_0 (
          ::CORBA::tk_sequence,
          &CF::FileSystem::_tc_FileInformationType,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CF_FileSystem_FileInformationSequence_0 =
        &CF_FileSystem_FileInformationSequence_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CF_FileSystem_FileInformationSequence_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CF_FileSystem_FileInformationSequence (
    ::CORBA::tk_alias,
    "IDL:CF/FileSystem/FileInformationSequence:1.0",
    "FileInformationSequence",
    &TAO::TypeCode::tc_CF_FileSystem_FileInformationSequence_0);
  
::CORBA::TypeCode_ptr const CF::FileSystem::_tc_FileInformationSequence =
  &_tao_tc_CF_FileSystem_FileInformationSequence;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_constant/constant_cs.cpp:61

const char *const CF::FileSystem::CREATED_TIME_ID = "CREATED_TIME";

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_constant/constant_cs.cpp:61

const char *const CF::FileSystem::MODIFIED_TIME_ID = "MODIFIED_TIME";

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_constant/constant_cs.cpp:61

const char *const CF::FileSystem::LAST_ACCESS_TIME_ID = "LAST_ACCESS_TIME";

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::FileSystem::remove (
  const char * fileName)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FileSystem_Proxy_Broker_ == 0)
    {
      CF_FileSystem_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_fileName (fileName);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_fileName
    };

  static TAO::Exception_Data
  _tao_CF_FileSystem_remove_exceptiondata [] = 
    {
      {
        "IDL:CF/FileException:1.0",
        CF::FileException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_FileException
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/InvalidFileName:1.0",
        CF::InvalidFileName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidFileName
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove",
      6,
      this->the_TAO_FileSystem_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_FileSystem_remove_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::FileSystem::copy (
  const char * sourceFileName,
  const char * destinationFileName)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FileSystem_Proxy_Broker_ == 0)
    {
      CF_FileSystem_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_sourceFileName (sourceFileName);
  TAO::Arg_Traits< char *>::in_arg_val _tao_destinationFileName (destinationFileName);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_sourceFileName,
      &_tao_destinationFileName
    };

  static TAO::Exception_Data
  _tao_CF_FileSystem_copy_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidFileName:1.0",
        CF::InvalidFileName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidFileName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/FileException:1.0",
        CF::FileException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_FileException
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "copy",
      4,
      this->the_TAO_FileSystem_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_FileSystem_copy_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CF::FileSystem::exists (
  const char * fileName)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FileSystem_Proxy_Broker_ == 0)
    {
      CF_FileSystem_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_fileName (fileName);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_fileName
    };

  static TAO::Exception_Data
  _tao_CF_FileSystem_exists_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidFileName:1.0",
        CF::InvalidFileName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidFileName
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "exists",
      6,
      this->the_TAO_FileSystem_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_FileSystem_exists_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::FileSystem::FileInformationSequence *
CF::FileSystem::list (
  const char * pattern)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FileSystem_Proxy_Broker_ == 0)
    {
      CF_FileSystem_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::FileSystem::FileInformationSequence>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_pattern (pattern);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_pattern
    };

  static TAO::Exception_Data
  _tao_CF_FileSystem_list_exceptiondata [] = 
    {
      {
        "IDL:CF/FileException:1.0",
        CF::FileException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_FileException
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/InvalidFileName:1.0",
        CF::InvalidFileName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidFileName
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "list",
      4,
      this->the_TAO_FileSystem_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_FileSystem_list_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::File_ptr
CF::FileSystem::create (
  const char * fileName)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FileSystem_Proxy_Broker_ == 0)
    {
      CF_FileSystem_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::File>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_fileName (fileName);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_fileName
    };

  static TAO::Exception_Data
  _tao_CF_FileSystem_create_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidFileName:1.0",
        CF::InvalidFileName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidFileName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/FileException:1.0",
        CF::FileException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_FileException
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "create",
      6,
      this->the_TAO_FileSystem_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_FileSystem_create_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::File_ptr
CF::FileSystem::open (
  const char * fileName,
  ::CORBA::Boolean read_Only)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FileSystem_Proxy_Broker_ == 0)
    {
      CF_FileSystem_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::File>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_fileName (fileName);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_read_Only (read_Only);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_fileName,
      &_tao_read_Only
    };

  static TAO::Exception_Data
  _tao_CF_FileSystem_open_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidFileName:1.0",
        CF::InvalidFileName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidFileName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/FileException:1.0",
        CF::FileException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_FileException
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "open",
      4,
      this->the_TAO_FileSystem_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_FileSystem_open_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::FileSystem::mkdir (
  const char * directoryName)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FileSystem_Proxy_Broker_ == 0)
    {
      CF_FileSystem_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_directoryName (directoryName);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_directoryName
    };

  static TAO::Exception_Data
  _tao_CF_FileSystem_mkdir_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidFileName:1.0",
        CF::InvalidFileName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidFileName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/FileException:1.0",
        CF::FileException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_FileException
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "mkdir",
      5,
      this->the_TAO_FileSystem_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_FileSystem_mkdir_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::FileSystem::rmdir (
  const char * directoryName)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FileSystem_Proxy_Broker_ == 0)
    {
      CF_FileSystem_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_directoryName (directoryName);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_directoryName
    };

  static TAO::Exception_Data
  _tao_CF_FileSystem_rmdir_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidFileName:1.0",
        CF::InvalidFileName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidFileName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/FileException:1.0",
        CF::FileException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_FileException
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "rmdir",
      5,
      this->the_TAO_FileSystem_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_FileSystem_rmdir_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::FileSystem::query (
  ::CF::Properties & fileSystemProperties)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FileSystem_Proxy_Broker_ == 0)
    {
      CF_FileSystem_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::Properties>::inout_arg_val _tao_fileSystemProperties (fileSystemProperties);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_fileSystemProperties
    };

  static TAO::Exception_Data
  _tao_CF_FileSystem_query_exceptiondata [] = 
    {
      {
        "IDL:CF/FileSystem/UnknownFileSystemProperties:1.0",
        CF::FileSystem::UnknownFileSystemProperties::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::FileSystem::_tc_UnknownFileSystemProperties
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "query",
      5,
      this->the_TAO_FileSystem_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_FileSystem_query_exceptiondata,
      1
    );
}

CF::FileSystem::FileSystem (void)
 : the_TAO_FileSystem_Proxy_Broker_ (0)
{
  this->CF_FileSystem_setup_collocation ();
}

void
CF::FileSystem::CF_FileSystem_setup_collocation ()
{
  if (::CF__TAO_FileSystem_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_FileSystem_Proxy_Broker_ =
        ::CF__TAO_FileSystem_Proxy_Broker_Factory_function_pointer (this);
    }
}

CF::FileSystem::~FileSystem (void)
{}

void 
CF::FileSystem::_tao_any_destructor (void *_tao_void_pointer)
{
  FileSystem *_tao_tmp_pointer =
    static_cast<FileSystem *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::FileSystem_ptr
CF::FileSystem::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FileSystem>::narrow (
        _tao_objref,
        "IDL:CF/FileSystem:1.0",
        CF__TAO_FileSystem_Proxy_Broker_Factory_function_pointer
      );
}

CF::FileSystem_ptr
CF::FileSystem::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FileSystem>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/FileSystem:1.0",
        CF__TAO_FileSystem_Proxy_Broker_Factory_function_pointer
      );
}

CF::FileSystem_ptr
CF::FileSystem::_nil (void)
{
  return 0;
}

CF::FileSystem_ptr
CF::FileSystem::_duplicate (FileSystem_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::FileSystem::_tao_release (FileSystem_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::FileSystem::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/FileSystem:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::FileSystem::_interface_repository_id (void) const
{
  return "IDL:CF/FileSystem:1.0";
}

::CORBA::Boolean
CF::FileSystem::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_FileSystem (
    ::CORBA::tk_objref,
    "IDL:CF/FileSystem:1.0",
    "FileSystem");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_FileSystem =
    &_tao_tc_CF_FileSystem;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::File.

CF::File_ptr
TAO::Objref_Traits<CF::File>::duplicate (
    CF::File_ptr p)
{
  return CF::File::_duplicate (p);
}

void
TAO::Objref_Traits<CF::File>::release (
    CF::File_ptr p)
{
  ::CORBA::release (p);
}

CF::File_ptr
TAO::Objref_Traits<CF::File>::nil (void)
{
  return CF::File::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::File>::marshal (
    const CF::File_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_File_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::File::IOException::IOException (
    CF::ErrorNumberType _tao_errorNumber,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/File/IOException:1.0",
        "IOException"
      )
{
  this->errorNumber = _tao_errorNumber;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::File::IOException::IOException (void)
  : ::CORBA::UserException (
        "IDL:CF/File/IOException:1.0",
        "IOException"
      )
{
}

CF::File::IOException::~IOException (void)
{
}

CF::File::IOException::IOException (const ::CF::File::IOException &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::File::IOException&
CF::File::IOException::operator= (const ::CF::File::IOException &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::File::IOException::_tao_any_destructor (void *_tao_void_pointer)
{
  IOException *_tao_tmp_pointer =
    static_cast<IOException *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::File::IOException *
CF::File::IOException::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<IOException *> (_tao_excp);
}

const CF::File::IOException *
CF::File::IOException::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const IOException *> (_tao_excp);
}

::CORBA::Exception *CF::File::IOException::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::File::IOException, 0);
  return retval;
}

::CORBA::Exception *
CF::File::IOException::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::File::IOException (*this),
      0
    );
  return result;
}

void CF::File::IOException::_raise (void) const
{
  throw *this;
}

void CF::File::IOException::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::File::IOException::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::File::IOException::_tao_type (void) const
{
  return ::CF::File::_tc_IOException;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_File_IOException[] =
      {
        { "errorNumber", &CF::_tc_ErrorNumberType },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_File_IOException (
  ::CORBA::tk_except,
  "IDL:CF/File/IOException:1.0",
  "IOException",
  _tao_fields_CF_File_IOException,
  2);

::CORBA::TypeCode_ptr const CF::File::_tc_IOException =
  &_tao_tc_CF_File_IOException;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::File::InvalidFilePointer::InvalidFilePointer (void)
  : ::CORBA::UserException (
        "IDL:CF/File/InvalidFilePointer:1.0",
        "InvalidFilePointer"
      )
{
}

CF::File::InvalidFilePointer::~InvalidFilePointer (void)
{
}

CF::File::InvalidFilePointer::InvalidFilePointer (const ::CF::File::InvalidFilePointer &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::File::InvalidFilePointer&
CF::File::InvalidFilePointer::operator= (const ::CF::File::InvalidFilePointer &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::File::InvalidFilePointer::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidFilePointer *_tao_tmp_pointer =
    static_cast<InvalidFilePointer *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::File::InvalidFilePointer *
CF::File::InvalidFilePointer::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidFilePointer *> (_tao_excp);
}

const CF::File::InvalidFilePointer *
CF::File::InvalidFilePointer::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidFilePointer *> (_tao_excp);
}

::CORBA::Exception *CF::File::InvalidFilePointer::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::File::InvalidFilePointer, 0);
  return retval;
}

::CORBA::Exception *
CF::File::InvalidFilePointer::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::File::InvalidFilePointer (*this),
      0
    );
  return result;
}

void CF::File::InvalidFilePointer::_raise (void) const
{
  throw *this;
}

void CF::File::InvalidFilePointer::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::File::InvalidFilePointer::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::File::InvalidFilePointer::_tao_type (void) const
{
  return ::CF::File::_tc_InvalidFilePointer;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_File_InvalidFilePointer = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_File_InvalidFilePointer (
  ::CORBA::tk_except,
  "IDL:CF/File/InvalidFilePointer:1.0",
  "InvalidFilePointer",
  _tao_fields_CF_File_InvalidFilePointer,
  0);

::CORBA::TypeCode_ptr const CF::File::_tc_InvalidFilePointer =
  &_tao_tc_CF_File_InvalidFilePointer;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::File::fileName (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_File_Proxy_Broker_ == 0)
    {
      CF_File_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_fileName",
      13,
      this->the_TAO_File_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CF::File::filePointer (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_File_Proxy_Broker_ == 0)
    {
      CF_File_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_filePointer",
      16,
      this->the_TAO_File_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::File::read (
  ::CF::OctetSequence_out data,
  ::CORBA::ULong length)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_File_Proxy_Broker_ == 0)
    {
      CF_File_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::OctetSequence>::out_arg_val _tao_data (data);
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_length (length);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_data,
      &_tao_length
    };

  static TAO::Exception_Data
  _tao_CF_File_read_exceptiondata [] = 
    {
      {
        "IDL:CF/File/IOException:1.0",
        CF::File::IOException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::File::_tc_IOException
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "read",
      4,
      this->the_TAO_File_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_File_read_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::File::write (
  const ::CF::OctetSequence & data)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_File_Proxy_Broker_ == 0)
    {
      CF_File_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::OctetSequence>::in_arg_val _tao_data (data);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_data
    };

  static TAO::Exception_Data
  _tao_CF_File_write_exceptiondata [] = 
    {
      {
        "IDL:CF/File/IOException:1.0",
        CF::File::IOException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::File::_tc_IOException
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "write",
      5,
      this->the_TAO_File_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_File_write_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CF::File::sizeOf (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_File_Proxy_Broker_ == 0)
    {
      CF_File_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CF_File_sizeOf_exceptiondata [] = 
    {
      {
        "IDL:CF/FileException:1.0",
        CF::FileException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_FileException
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "sizeOf",
      6,
      this->the_TAO_File_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_File_sizeOf_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::File::close (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_File_Proxy_Broker_ == 0)
    {
      CF_File_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CF_File_close_exceptiondata [] = 
    {
      {
        "IDL:CF/FileException:1.0",
        CF::FileException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_FileException
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "close",
      5,
      this->the_TAO_File_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_File_close_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::File::setFilePointer (
  ::CORBA::ULong filePointer)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_File_Proxy_Broker_ == 0)
    {
      CF_File_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_filePointer (filePointer);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_filePointer
    };

  static TAO::Exception_Data
  _tao_CF_File_setFilePointer_exceptiondata [] = 
    {
      {
        "IDL:CF/File/InvalidFilePointer:1.0",
        CF::File::InvalidFilePointer::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::File::_tc_InvalidFilePointer
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/FileException:1.0",
        CF::FileException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_FileException
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "setFilePointer",
      14,
      this->the_TAO_File_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_File_setFilePointer_exceptiondata,
      2
    );
}

CF::File::File (void)
 : the_TAO_File_Proxy_Broker_ (0)
{
  this->CF_File_setup_collocation ();
}

void
CF::File::CF_File_setup_collocation ()
{
  if (::CF__TAO_File_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_File_Proxy_Broker_ =
        ::CF__TAO_File_Proxy_Broker_Factory_function_pointer (this);
    }
}

CF::File::~File (void)
{}

void 
CF::File::_tao_any_destructor (void *_tao_void_pointer)
{
  File *_tao_tmp_pointer =
    static_cast<File *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::File_ptr
CF::File::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<File>::narrow (
        _tao_objref,
        "IDL:CF/File:1.0",
        CF__TAO_File_Proxy_Broker_Factory_function_pointer
      );
}

CF::File_ptr
CF::File::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<File>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/File:1.0",
        CF__TAO_File_Proxy_Broker_Factory_function_pointer
      );
}

CF::File_ptr
CF::File::_nil (void)
{
  return 0;
}

CF::File_ptr
CF::File::_duplicate (File_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::File::_tao_release (File_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::File::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/File:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::File::_interface_repository_id (void) const
{
  return "IDL:CF/File:1.0";
}

::CORBA::Boolean
CF::File::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_File (
    ::CORBA::tk_objref,
    "IDL:CF/File:1.0",
    "File");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_File =
    &_tao_tc_CF_File;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::ResourceFactory.

CF::ResourceFactory_ptr
TAO::Objref_Traits<CF::ResourceFactory>::duplicate (
    CF::ResourceFactory_ptr p)
{
  return CF::ResourceFactory::_duplicate (p);
}

void
TAO::Objref_Traits<CF::ResourceFactory>::release (
    CF::ResourceFactory_ptr p)
{
  ::CORBA::release (p);
}

CF::ResourceFactory_ptr
TAO::Objref_Traits<CF::ResourceFactory>::nil (void)
{
  return CF::ResourceFactory::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::ResourceFactory>::marshal (
    const CF::ResourceFactory_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_ResourceFactory_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::ResourceFactory::InvalidResourceId::InvalidResourceId (void)
  : ::CORBA::UserException (
        "IDL:CF/ResourceFactory/InvalidResourceId:1.0",
        "InvalidResourceId"
      )
{
}

CF::ResourceFactory::InvalidResourceId::~InvalidResourceId (void)
{
}

CF::ResourceFactory::InvalidResourceId::InvalidResourceId (const ::CF::ResourceFactory::InvalidResourceId &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::ResourceFactory::InvalidResourceId&
CF::ResourceFactory::InvalidResourceId::operator= (const ::CF::ResourceFactory::InvalidResourceId &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::ResourceFactory::InvalidResourceId::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidResourceId *_tao_tmp_pointer =
    static_cast<InvalidResourceId *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::ResourceFactory::InvalidResourceId *
CF::ResourceFactory::InvalidResourceId::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidResourceId *> (_tao_excp);
}

const CF::ResourceFactory::InvalidResourceId *
CF::ResourceFactory::InvalidResourceId::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidResourceId *> (_tao_excp);
}

::CORBA::Exception *CF::ResourceFactory::InvalidResourceId::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::ResourceFactory::InvalidResourceId, 0);
  return retval;
}

::CORBA::Exception *
CF::ResourceFactory::InvalidResourceId::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::ResourceFactory::InvalidResourceId (*this),
      0
    );
  return result;
}

void CF::ResourceFactory::InvalidResourceId::_raise (void) const
{
  throw *this;
}

void CF::ResourceFactory::InvalidResourceId::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::ResourceFactory::InvalidResourceId::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::ResourceFactory::InvalidResourceId::_tao_type (void) const
{
  return ::CF::ResourceFactory::_tc_InvalidResourceId;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_ResourceFactory_InvalidResourceId = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_ResourceFactory_InvalidResourceId (
  ::CORBA::tk_except,
  "IDL:CF/ResourceFactory/InvalidResourceId:1.0",
  "InvalidResourceId",
  _tao_fields_CF_ResourceFactory_InvalidResourceId,
  0);

::CORBA::TypeCode_ptr const CF::ResourceFactory::_tc_InvalidResourceId =
  &_tao_tc_CF_ResourceFactory_InvalidResourceId;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::ResourceFactory::ShutdownFailure::ShutdownFailure (
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/ResourceFactory/ShutdownFailure:1.0",
        "ShutdownFailure"
      )
{
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::ResourceFactory::ShutdownFailure::ShutdownFailure (void)
  : ::CORBA::UserException (
        "IDL:CF/ResourceFactory/ShutdownFailure:1.0",
        "ShutdownFailure"
      )
{
}

CF::ResourceFactory::ShutdownFailure::~ShutdownFailure (void)
{
}

CF::ResourceFactory::ShutdownFailure::ShutdownFailure (const ::CF::ResourceFactory::ShutdownFailure &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::ResourceFactory::ShutdownFailure&
CF::ResourceFactory::ShutdownFailure::operator= (const ::CF::ResourceFactory::ShutdownFailure &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::ResourceFactory::ShutdownFailure::_tao_any_destructor (void *_tao_void_pointer)
{
  ShutdownFailure *_tao_tmp_pointer =
    static_cast<ShutdownFailure *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::ResourceFactory::ShutdownFailure *
CF::ResourceFactory::ShutdownFailure::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ShutdownFailure *> (_tao_excp);
}

const CF::ResourceFactory::ShutdownFailure *
CF::ResourceFactory::ShutdownFailure::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ShutdownFailure *> (_tao_excp);
}

::CORBA::Exception *CF::ResourceFactory::ShutdownFailure::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::ResourceFactory::ShutdownFailure, 0);
  return retval;
}

::CORBA::Exception *
CF::ResourceFactory::ShutdownFailure::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::ResourceFactory::ShutdownFailure (*this),
      0
    );
  return result;
}

void CF::ResourceFactory::ShutdownFailure::_raise (void) const
{
  throw *this;
}

void CF::ResourceFactory::ShutdownFailure::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::ResourceFactory::ShutdownFailure::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::ResourceFactory::ShutdownFailure::_tao_type (void) const
{
  return ::CF::ResourceFactory::_tc_ShutdownFailure;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_ResourceFactory_ShutdownFailure[] =
      {
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_ResourceFactory_ShutdownFailure (
  ::CORBA::tk_except,
  "IDL:CF/ResourceFactory/ShutdownFailure:1.0",
  "ShutdownFailure",
  _tao_fields_CF_ResourceFactory_ShutdownFailure,
  1);

::CORBA::TypeCode_ptr const CF::ResourceFactory::_tc_ShutdownFailure =
  &_tao_tc_CF_ResourceFactory_ShutdownFailure;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::ResourceFactory::CreateResourceFailure::CreateResourceFailure (
    CF::ErrorNumberType _tao_errorNumber,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/ResourceFactory/CreateResourceFailure:1.0",
        "CreateResourceFailure"
      )
{
  this->errorNumber = _tao_errorNumber;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::ResourceFactory::CreateResourceFailure::CreateResourceFailure (void)
  : ::CORBA::UserException (
        "IDL:CF/ResourceFactory/CreateResourceFailure:1.0",
        "CreateResourceFailure"
      )
{
}

CF::ResourceFactory::CreateResourceFailure::~CreateResourceFailure (void)
{
}

CF::ResourceFactory::CreateResourceFailure::CreateResourceFailure (const ::CF::ResourceFactory::CreateResourceFailure &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::ResourceFactory::CreateResourceFailure&
CF::ResourceFactory::CreateResourceFailure::operator= (const ::CF::ResourceFactory::CreateResourceFailure &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::ResourceFactory::CreateResourceFailure::_tao_any_destructor (void *_tao_void_pointer)
{
  CreateResourceFailure *_tao_tmp_pointer =
    static_cast<CreateResourceFailure *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::ResourceFactory::CreateResourceFailure *
CF::ResourceFactory::CreateResourceFailure::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<CreateResourceFailure *> (_tao_excp);
}

const CF::ResourceFactory::CreateResourceFailure *
CF::ResourceFactory::CreateResourceFailure::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const CreateResourceFailure *> (_tao_excp);
}

::CORBA::Exception *CF::ResourceFactory::CreateResourceFailure::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::ResourceFactory::CreateResourceFailure, 0);
  return retval;
}

::CORBA::Exception *
CF::ResourceFactory::CreateResourceFailure::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::ResourceFactory::CreateResourceFailure (*this),
      0
    );
  return result;
}

void CF::ResourceFactory::CreateResourceFailure::_raise (void) const
{
  throw *this;
}

void CF::ResourceFactory::CreateResourceFailure::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::ResourceFactory::CreateResourceFailure::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::ResourceFactory::CreateResourceFailure::_tao_type (void) const
{
  return ::CF::ResourceFactory::_tc_CreateResourceFailure;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_ResourceFactory_CreateResourceFailure[] =
      {
        { "errorNumber", &CF::_tc_ErrorNumberType },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_ResourceFactory_CreateResourceFailure (
  ::CORBA::tk_except,
  "IDL:CF/ResourceFactory/CreateResourceFailure:1.0",
  "CreateResourceFailure",
  _tao_fields_CF_ResourceFactory_CreateResourceFailure,
  2);

::CORBA::TypeCode_ptr const CF::ResourceFactory::_tc_CreateResourceFailure =
  &_tao_tc_CF_ResourceFactory_CreateResourceFailure;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::ResourceFactory::identifier (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ResourceFactory_Proxy_Broker_ == 0)
    {
      CF_ResourceFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_identifier",
      15,
      this->the_TAO_ResourceFactory_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::Resource_ptr
CF::ResourceFactory::createResource (
  const char * resourceId,
  const ::CF::Properties & qualifiers)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ResourceFactory_Proxy_Broker_ == 0)
    {
      CF_ResourceFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::Resource>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_resourceId (resourceId);
  TAO::Arg_Traits< ::CF::Properties>::in_arg_val _tao_qualifiers (qualifiers);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_resourceId,
      &_tao_qualifiers
    };

  static TAO::Exception_Data
  _tao_CF_ResourceFactory_createResource_exceptiondata [] = 
    {
      {
        "IDL:CF/ResourceFactory/CreateResourceFailure:1.0",
        CF::ResourceFactory::CreateResourceFailure::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::ResourceFactory::_tc_CreateResourceFailure
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "createResource",
      14,
      this->the_TAO_ResourceFactory_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_ResourceFactory_createResource_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::ResourceFactory::releaseResource (
  const char * resourceId)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ResourceFactory_Proxy_Broker_ == 0)
    {
      CF_ResourceFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_resourceId (resourceId);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_resourceId
    };

  static TAO::Exception_Data
  _tao_CF_ResourceFactory_releaseResource_exceptiondata [] = 
    {
      {
        "IDL:CF/ResourceFactory/InvalidResourceId:1.0",
        CF::ResourceFactory::InvalidResourceId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::ResourceFactory::_tc_InvalidResourceId
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "releaseResource",
      15,
      this->the_TAO_ResourceFactory_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_ResourceFactory_releaseResource_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::ResourceFactory::shutdown (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ResourceFactory_Proxy_Broker_ == 0)
    {
      CF_ResourceFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CF_ResourceFactory_shutdown_exceptiondata [] = 
    {
      {
        "IDL:CF/ResourceFactory/ShutdownFailure:1.0",
        CF::ResourceFactory::ShutdownFailure::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::ResourceFactory::_tc_ShutdownFailure
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "shutdown",
      8,
      this->the_TAO_ResourceFactory_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_ResourceFactory_shutdown_exceptiondata,
      1
    );
}

CF::ResourceFactory::ResourceFactory (void)
 : the_TAO_ResourceFactory_Proxy_Broker_ (0)
{
  this->CF_ResourceFactory_setup_collocation ();
}

void
CF::ResourceFactory::CF_ResourceFactory_setup_collocation ()
{
  if (::CF__TAO_ResourceFactory_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_ResourceFactory_Proxy_Broker_ =
        ::CF__TAO_ResourceFactory_Proxy_Broker_Factory_function_pointer (this);
    }
}

CF::ResourceFactory::~ResourceFactory (void)
{}

void 
CF::ResourceFactory::_tao_any_destructor (void *_tao_void_pointer)
{
  ResourceFactory *_tao_tmp_pointer =
    static_cast<ResourceFactory *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::ResourceFactory_ptr
CF::ResourceFactory::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ResourceFactory>::narrow (
        _tao_objref,
        "IDL:CF/ResourceFactory:1.0",
        CF__TAO_ResourceFactory_Proxy_Broker_Factory_function_pointer
      );
}

CF::ResourceFactory_ptr
CF::ResourceFactory::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ResourceFactory>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/ResourceFactory:1.0",
        CF__TAO_ResourceFactory_Proxy_Broker_Factory_function_pointer
      );
}

CF::ResourceFactory_ptr
CF::ResourceFactory::_nil (void)
{
  return 0;
}

CF::ResourceFactory_ptr
CF::ResourceFactory::_duplicate (ResourceFactory_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::ResourceFactory::_tao_release (ResourceFactory_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::ResourceFactory::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/ResourceFactory:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::ResourceFactory::_interface_repository_id (void) const
{
  return "IDL:CF/ResourceFactory:1.0";
}

::CORBA::Boolean
CF::ResourceFactory::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_ResourceFactory (
    ::CORBA::tk_objref,
    "IDL:CF/ResourceFactory:1.0",
    "ResourceFactory");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_ResourceFactory =
    &_tao_tc_CF_ResourceFactory;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::FileManager.

CF::FileManager_ptr
TAO::Objref_Traits<CF::FileManager>::duplicate (
    CF::FileManager_ptr p)
{
  return CF::FileManager::_duplicate (p);
}

void
TAO::Objref_Traits<CF::FileManager>::release (
    CF::FileManager_ptr p)
{
  ::CORBA::release (p);
}

CF::FileManager_ptr
TAO::Objref_Traits<CF::FileManager>::nil (void)
{
  return CF::FileManager::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::FileManager>::marshal (
    const CF::FileManager_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_FileManager_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_FileManager_MountType[] =
      {
        { "mountPoint", &CORBA::_tc_string },
        { "fs", &CF::_tc_FileSystem }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_FileManager_MountType (
  ::CORBA::tk_struct,
  "IDL:CF/FileManager/MountType:1.0",
  "MountType",
  _tao_fields_CF_FileManager_MountType,
  2);

::CORBA::TypeCode_ptr const CF::FileManager::_tc_MountType =
  &_tao_tc_CF_FileManager_MountType;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CF::FileManager::MountType::_tao_any_destructor (
    void *_tao_void_pointer)
{
  MountType *_tao_tmp_pointer =
    static_cast<MountType *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CF_FILEMANAGER_MOUNTSEQUENCE_CS_)
#define _CF_FILEMANAGER_MOUNTSEQUENCE_CS_

CF::FileManager::MountSequence::MountSequence (void)
{}

CF::FileManager::MountSequence::MountSequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        MountType
      > (max)
{}

CF::FileManager::MountSequence::MountSequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CF::FileManager::MountType * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        MountType
      >
    (max, length, buffer, release)
{}

CF::FileManager::MountSequence::MountSequence (
    const MountSequence &seq)
  : ::TAO::unbounded_value_sequence<
        MountType
      > (seq)
{}

CF::FileManager::MountSequence::~MountSequence (void)
{}

void CF::FileManager::MountSequence::_tao_any_destructor (
    void * _tao_void_pointer)
{
  MountSequence * _tao_tmp_pointer =
    static_cast<MountSequence *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CF_FileManager_MountSequence_GUARD
#define _TAO_TYPECODE_CF_FileManager_MountSequence_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CF_FileManager_MountSequence_0 (
          ::CORBA::tk_sequence,
          &CF::FileManager::_tc_MountType,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CF_FileManager_MountSequence_0 =
        &CF_FileManager_MountSequence_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CF_FileManager_MountSequence_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CF_FileManager_MountSequence (
    ::CORBA::tk_alias,
    "IDL:CF/FileManager/MountSequence:1.0",
    "MountSequence",
    &TAO::TypeCode::tc_CF_FileManager_MountSequence_0);
  
::CORBA::TypeCode_ptr const CF::FileManager::_tc_MountSequence =
  &_tao_tc_CF_FileManager_MountSequence;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::FileManager::NonExistentMount::NonExistentMount (void)
  : ::CORBA::UserException (
        "IDL:CF/FileManager/NonExistentMount:1.0",
        "NonExistentMount"
      )
{
}

CF::FileManager::NonExistentMount::~NonExistentMount (void)
{
}

CF::FileManager::NonExistentMount::NonExistentMount (const ::CF::FileManager::NonExistentMount &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::FileManager::NonExistentMount&
CF::FileManager::NonExistentMount::operator= (const ::CF::FileManager::NonExistentMount &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::FileManager::NonExistentMount::_tao_any_destructor (void *_tao_void_pointer)
{
  NonExistentMount *_tao_tmp_pointer =
    static_cast<NonExistentMount *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::FileManager::NonExistentMount *
CF::FileManager::NonExistentMount::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NonExistentMount *> (_tao_excp);
}

const CF::FileManager::NonExistentMount *
CF::FileManager::NonExistentMount::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NonExistentMount *> (_tao_excp);
}

::CORBA::Exception *CF::FileManager::NonExistentMount::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::FileManager::NonExistentMount, 0);
  return retval;
}

::CORBA::Exception *
CF::FileManager::NonExistentMount::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::FileManager::NonExistentMount (*this),
      0
    );
  return result;
}

void CF::FileManager::NonExistentMount::_raise (void) const
{
  throw *this;
}

void CF::FileManager::NonExistentMount::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::FileManager::NonExistentMount::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::FileManager::NonExistentMount::_tao_type (void) const
{
  return ::CF::FileManager::_tc_NonExistentMount;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_FileManager_NonExistentMount = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_FileManager_NonExistentMount (
  ::CORBA::tk_except,
  "IDL:CF/FileManager/NonExistentMount:1.0",
  "NonExistentMount",
  _tao_fields_CF_FileManager_NonExistentMount,
  0);

::CORBA::TypeCode_ptr const CF::FileManager::_tc_NonExistentMount =
  &_tao_tc_CF_FileManager_NonExistentMount;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::FileManager::InvalidFileSystem::InvalidFileSystem (void)
  : ::CORBA::UserException (
        "IDL:CF/FileManager/InvalidFileSystem:1.0",
        "InvalidFileSystem"
      )
{
}

CF::FileManager::InvalidFileSystem::~InvalidFileSystem (void)
{
}

CF::FileManager::InvalidFileSystem::InvalidFileSystem (const ::CF::FileManager::InvalidFileSystem &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::FileManager::InvalidFileSystem&
CF::FileManager::InvalidFileSystem::operator= (const ::CF::FileManager::InvalidFileSystem &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::FileManager::InvalidFileSystem::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidFileSystem *_tao_tmp_pointer =
    static_cast<InvalidFileSystem *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::FileManager::InvalidFileSystem *
CF::FileManager::InvalidFileSystem::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidFileSystem *> (_tao_excp);
}

const CF::FileManager::InvalidFileSystem *
CF::FileManager::InvalidFileSystem::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidFileSystem *> (_tao_excp);
}

::CORBA::Exception *CF::FileManager::InvalidFileSystem::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::FileManager::InvalidFileSystem, 0);
  return retval;
}

::CORBA::Exception *
CF::FileManager::InvalidFileSystem::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::FileManager::InvalidFileSystem (*this),
      0
    );
  return result;
}

void CF::FileManager::InvalidFileSystem::_raise (void) const
{
  throw *this;
}

void CF::FileManager::InvalidFileSystem::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::FileManager::InvalidFileSystem::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::FileManager::InvalidFileSystem::_tao_type (void) const
{
  return ::CF::FileManager::_tc_InvalidFileSystem;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_FileManager_InvalidFileSystem = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_FileManager_InvalidFileSystem (
  ::CORBA::tk_except,
  "IDL:CF/FileManager/InvalidFileSystem:1.0",
  "InvalidFileSystem",
  _tao_fields_CF_FileManager_InvalidFileSystem,
  0);

::CORBA::TypeCode_ptr const CF::FileManager::_tc_InvalidFileSystem =
  &_tao_tc_CF_FileManager_InvalidFileSystem;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::FileManager::MountPointAlreadyExists::MountPointAlreadyExists (void)
  : ::CORBA::UserException (
        "IDL:CF/FileManager/MountPointAlreadyExists:1.0",
        "MountPointAlreadyExists"
      )
{
}

CF::FileManager::MountPointAlreadyExists::~MountPointAlreadyExists (void)
{
}

CF::FileManager::MountPointAlreadyExists::MountPointAlreadyExists (const ::CF::FileManager::MountPointAlreadyExists &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::FileManager::MountPointAlreadyExists&
CF::FileManager::MountPointAlreadyExists::operator= (const ::CF::FileManager::MountPointAlreadyExists &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::FileManager::MountPointAlreadyExists::_tao_any_destructor (void *_tao_void_pointer)
{
  MountPointAlreadyExists *_tao_tmp_pointer =
    static_cast<MountPointAlreadyExists *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::FileManager::MountPointAlreadyExists *
CF::FileManager::MountPointAlreadyExists::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<MountPointAlreadyExists *> (_tao_excp);
}

const CF::FileManager::MountPointAlreadyExists *
CF::FileManager::MountPointAlreadyExists::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const MountPointAlreadyExists *> (_tao_excp);
}

::CORBA::Exception *CF::FileManager::MountPointAlreadyExists::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::FileManager::MountPointAlreadyExists, 0);
  return retval;
}

::CORBA::Exception *
CF::FileManager::MountPointAlreadyExists::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::FileManager::MountPointAlreadyExists (*this),
      0
    );
  return result;
}

void CF::FileManager::MountPointAlreadyExists::_raise (void) const
{
  throw *this;
}

void CF::FileManager::MountPointAlreadyExists::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::FileManager::MountPointAlreadyExists::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::FileManager::MountPointAlreadyExists::_tao_type (void) const
{
  return ::CF::FileManager::_tc_MountPointAlreadyExists;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_FileManager_MountPointAlreadyExists = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_FileManager_MountPointAlreadyExists (
  ::CORBA::tk_except,
  "IDL:CF/FileManager/MountPointAlreadyExists:1.0",
  "MountPointAlreadyExists",
  _tao_fields_CF_FileManager_MountPointAlreadyExists,
  0);

::CORBA::TypeCode_ptr const CF::FileManager::_tc_MountPointAlreadyExists =
  &_tao_tc_CF_FileManager_MountPointAlreadyExists;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::FileManager::mount (
  const char * mountPoint,
  ::CF::FileSystem_ptr file_System)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FileManager_Proxy_Broker_ == 0)
    {
      CF_FileManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_mountPoint (mountPoint);
  TAO::Arg_Traits< ::CF::FileSystem>::in_arg_val _tao_file_System (file_System);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_mountPoint,
      &_tao_file_System
    };

  static TAO::Exception_Data
  _tao_CF_FileManager_mount_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidFileName:1.0",
        CF::InvalidFileName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidFileName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/FileManager/InvalidFileSystem:1.0",
        CF::FileManager::InvalidFileSystem::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::FileManager::_tc_InvalidFileSystem
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/FileManager/MountPointAlreadyExists:1.0",
        CF::FileManager::MountPointAlreadyExists::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::FileManager::_tc_MountPointAlreadyExists
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "mount",
      5,
      this->the_TAO_FileManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_FileManager_mount_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::FileManager::unmount (
  const char * mountPoint)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FileManager_Proxy_Broker_ == 0)
    {
      CF_FileManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_mountPoint (mountPoint);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_mountPoint
    };

  static TAO::Exception_Data
  _tao_CF_FileManager_unmount_exceptiondata [] = 
    {
      {
        "IDL:CF/FileManager/NonExistentMount:1.0",
        CF::FileManager::NonExistentMount::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::FileManager::_tc_NonExistentMount
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "unmount",
      7,
      this->the_TAO_FileManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_FileManager_unmount_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::FileManager::MountSequence *
CF::FileManager::getMounts (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FileManager_Proxy_Broker_ == 0)
    {
      CF_FileManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::FileManager::MountSequence>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "getMounts",
      9,
      this->the_TAO_FileManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

CF::FileManager::FileManager (void)
 : the_TAO_FileManager_Proxy_Broker_ (0)
{
  this->CF_FileManager_setup_collocation ();
}

void
CF::FileManager::CF_FileManager_setup_collocation ()
{
  if (::CF__TAO_FileManager_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_FileManager_Proxy_Broker_ =
        ::CF__TAO_FileManager_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CF_FileSystem_setup_collocation ();
}

CF::FileManager::~FileManager (void)
{}

void 
CF::FileManager::_tao_any_destructor (void *_tao_void_pointer)
{
  FileManager *_tao_tmp_pointer =
    static_cast<FileManager *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::FileManager_ptr
CF::FileManager::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FileManager>::narrow (
        _tao_objref,
        "IDL:CF/FileManager:1.0",
        CF__TAO_FileManager_Proxy_Broker_Factory_function_pointer
      );
}

CF::FileManager_ptr
CF::FileManager::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FileManager>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/FileManager:1.0",
        CF__TAO_FileManager_Proxy_Broker_Factory_function_pointer
      );
}

CF::FileManager_ptr
CF::FileManager::_nil (void)
{
  return 0;
}

CF::FileManager_ptr
CF::FileManager::_duplicate (FileManager_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::FileManager::_tao_release (FileManager_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::FileManager::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/FileSystem:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/FileManager:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::FileManager::_interface_repository_id (void) const
{
  return "IDL:CF/FileManager:1.0";
}

::CORBA::Boolean
CF::FileManager::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_FileManager (
    ::CORBA::tk_objref,
    "IDL:CF/FileManager:1.0",
    "FileManager");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_FileManager =
    &_tao_tc_CF_FileManager;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::PPort.

CF::PPort_ptr
TAO::Objref_Traits<CF::PPort>::duplicate (
    CF::PPort_ptr p)
{
  return CF::PPort::_duplicate (p);
}

void
TAO::Objref_Traits<CF::PPort>::release (
    CF::PPort_ptr p)
{
  ::CORBA::release (p);
}

CF::PPort_ptr
TAO::Objref_Traits<CF::PPort>::nil (void)
{
  return CF::PPort::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::PPort>::marshal (
    const CF::PPort_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_PPort_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::PPort::InvalidPort::InvalidPort (
    ::CORBA::UShort _tao_errorCode,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/PPort/InvalidPort:1.0",
        "InvalidPort"
      )
{
  this->errorCode = _tao_errorCode;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::PPort::InvalidPort::InvalidPort (void)
  : ::CORBA::UserException (
        "IDL:CF/PPort/InvalidPort:1.0",
        "InvalidPort"
      )
{
}

CF::PPort::InvalidPort::~InvalidPort (void)
{
}

CF::PPort::InvalidPort::InvalidPort (const ::CF::PPort::InvalidPort &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorCode = _tao_excp.errorCode;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::PPort::InvalidPort&
CF::PPort::InvalidPort::operator= (const ::CF::PPort::InvalidPort &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorCode = _tao_excp.errorCode;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::PPort::InvalidPort::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidPort *_tao_tmp_pointer =
    static_cast<InvalidPort *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::PPort::InvalidPort *
CF::PPort::InvalidPort::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidPort *> (_tao_excp);
}

const CF::PPort::InvalidPort *
CF::PPort::InvalidPort::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidPort *> (_tao_excp);
}

::CORBA::Exception *CF::PPort::InvalidPort::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::PPort::InvalidPort, 0);
  return retval;
}

::CORBA::Exception *
CF::PPort::InvalidPort::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::PPort::InvalidPort (*this),
      0
    );
  return result;
}

void CF::PPort::InvalidPort::_raise (void) const
{
  throw *this;
}

void CF::PPort::InvalidPort::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::PPort::InvalidPort::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::PPort::InvalidPort::_tao_type (void) const
{
  return ::CF::PPort::_tc_InvalidPort;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_PPort_InvalidPort[] =
      {
        { "errorCode", &CORBA::_tc_ushort },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_PPort_InvalidPort (
  ::CORBA::tk_except,
  "IDL:CF/PPort/InvalidPort:1.0",
  "InvalidPort",
  _tao_fields_CF_PPort_InvalidPort,
  2);

::CORBA::TypeCode_ptr const CF::PPort::_tc_InvalidPort =
  &_tao_tc_CF_PPort_InvalidPort;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::PPort::OccupiedPort::OccupiedPort (void)
  : ::CORBA::UserException (
        "IDL:CF/PPort/OccupiedPort:1.0",
        "OccupiedPort"
      )
{
}

CF::PPort::OccupiedPort::~OccupiedPort (void)
{
}

CF::PPort::OccupiedPort::OccupiedPort (const ::CF::PPort::OccupiedPort &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::PPort::OccupiedPort&
CF::PPort::OccupiedPort::operator= (const ::CF::PPort::OccupiedPort &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::PPort::OccupiedPort::_tao_any_destructor (void *_tao_void_pointer)
{
  OccupiedPort *_tao_tmp_pointer =
    static_cast<OccupiedPort *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::PPort::OccupiedPort *
CF::PPort::OccupiedPort::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<OccupiedPort *> (_tao_excp);
}

const CF::PPort::OccupiedPort *
CF::PPort::OccupiedPort::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const OccupiedPort *> (_tao_excp);
}

::CORBA::Exception *CF::PPort::OccupiedPort::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::PPort::OccupiedPort, 0);
  return retval;
}

::CORBA::Exception *
CF::PPort::OccupiedPort::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::PPort::OccupiedPort (*this),
      0
    );
  return result;
}

void CF::PPort::OccupiedPort::_raise (void) const
{
  throw *this;
}

void CF::PPort::OccupiedPort::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::PPort::OccupiedPort::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::PPort::OccupiedPort::_tao_type (void) const
{
  return ::CF::PPort::_tc_OccupiedPort;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_PPort_OccupiedPort = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_PPort_OccupiedPort (
  ::CORBA::tk_except,
  "IDL:CF/PPort/OccupiedPort:1.0",
  "OccupiedPort",
  _tao_fields_CF_PPort_OccupiedPort,
  0);

::CORBA::TypeCode_ptr const CF::PPort::_tc_OccupiedPort =
  &_tao_tc_CF_PPort_OccupiedPort;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::PPort::connectPort (
  ::CORBA::Object_ptr connection,
  const char * connectionId)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PPort_Proxy_Broker_ == 0)
    {
      CF_PPort_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_connection (connection);
  TAO::Arg_Traits< char *>::in_arg_val _tao_connectionId (connectionId);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_connection,
      &_tao_connectionId
    };

  static TAO::Exception_Data
  _tao_CF_PPort_connectPort_exceptiondata [] = 
    {
      {
        "IDL:CF/PPort/InvalidPort:1.0",
        CF::PPort::InvalidPort::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::PPort::_tc_InvalidPort
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/PPort/OccupiedPort:1.0",
        CF::PPort::OccupiedPort::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::PPort::_tc_OccupiedPort
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "connectPort",
      11,
      this->the_TAO_PPort_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_PPort_connectPort_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::PPort::disconnectPort (
  const char * connectionId)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PPort_Proxy_Broker_ == 0)
    {
      CF_PPort_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_connectionId (connectionId);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_connectionId
    };

  static TAO::Exception_Data
  _tao_CF_PPort_disconnectPort_exceptiondata [] = 
    {
      {
        "IDL:CF/PPort/InvalidPort:1.0",
        CF::PPort::InvalidPort::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::PPort::_tc_InvalidPort
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "disconnectPort",
      14,
      this->the_TAO_PPort_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_PPort_disconnectPort_exceptiondata,
      1
    );
}

CF::PPort::PPort (void)
 : the_TAO_PPort_Proxy_Broker_ (0)
{
  this->CF_PPort_setup_collocation ();
}

void
CF::PPort::CF_PPort_setup_collocation ()
{
  if (::CF__TAO_PPort_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_PPort_Proxy_Broker_ =
        ::CF__TAO_PPort_Proxy_Broker_Factory_function_pointer (this);
    }
}

CF::PPort::~PPort (void)
{}

void 
CF::PPort::_tao_any_destructor (void *_tao_void_pointer)
{
  PPort *_tao_tmp_pointer =
    static_cast<PPort *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::PPort_ptr
CF::PPort::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<PPort>::narrow (
        _tao_objref,
        "IDL:CF/PPort:1.0",
        CF__TAO_PPort_Proxy_Broker_Factory_function_pointer
      );
}

CF::PPort_ptr
CF::PPort::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<PPort>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/PPort:1.0",
        CF__TAO_PPort_Proxy_Broker_Factory_function_pointer
      );
}

CF::PPort_ptr
CF::PPort::_nil (void)
{
  return 0;
}

CF::PPort_ptr
CF::PPort::_duplicate (PPort_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::PPort::_tao_release (PPort_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::PPort::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/PPort:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::PPort::_interface_repository_id (void) const
{
  return "IDL:CF/PPort:1.0";
}

::CORBA::Boolean
CF::PPort::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_PPort (
    ::CORBA::tk_objref,
    "IDL:CF/PPort:1.0",
    "PPort");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_PPort =
    &_tao_tc_CF_PPort;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::LifeCycle.

CF::LifeCycle_ptr
TAO::Objref_Traits<CF::LifeCycle>::duplicate (
    CF::LifeCycle_ptr p)
{
  return CF::LifeCycle::_duplicate (p);
}

void
TAO::Objref_Traits<CF::LifeCycle>::release (
    CF::LifeCycle_ptr p)
{
  ::CORBA::release (p);
}

CF::LifeCycle_ptr
TAO::Objref_Traits<CF::LifeCycle>::nil (void)
{
  return CF::LifeCycle::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::LifeCycle>::marshal (
    const CF::LifeCycle_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_LifeCycle_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::LifeCycle::InitializeError::InitializeError (
    const CF::StringSequence & _tao_errorMessages)
  : ::CORBA::UserException (
        "IDL:CF/LifeCycle/InitializeError:1.0",
        "InitializeError"
      )
{
  this->errorMessages = _tao_errorMessages;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::LifeCycle::InitializeError::InitializeError (void)
  : ::CORBA::UserException (
        "IDL:CF/LifeCycle/InitializeError:1.0",
        "InitializeError"
      )
{
}

CF::LifeCycle::InitializeError::~InitializeError (void)
{
}

CF::LifeCycle::InitializeError::InitializeError (const ::CF::LifeCycle::InitializeError &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorMessages = _tao_excp.errorMessages;
}

CF::LifeCycle::InitializeError&
CF::LifeCycle::InitializeError::operator= (const ::CF::LifeCycle::InitializeError &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorMessages = _tao_excp.errorMessages;
  return *this;
}

void CF::LifeCycle::InitializeError::_tao_any_destructor (void *_tao_void_pointer)
{
  InitializeError *_tao_tmp_pointer =
    static_cast<InitializeError *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::LifeCycle::InitializeError *
CF::LifeCycle::InitializeError::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InitializeError *> (_tao_excp);
}

const CF::LifeCycle::InitializeError *
CF::LifeCycle::InitializeError::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InitializeError *> (_tao_excp);
}

::CORBA::Exception *CF::LifeCycle::InitializeError::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::LifeCycle::InitializeError, 0);
  return retval;
}

::CORBA::Exception *
CF::LifeCycle::InitializeError::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::LifeCycle::InitializeError (*this),
      0
    );
  return result;
}

void CF::LifeCycle::InitializeError::_raise (void) const
{
  throw *this;
}

void CF::LifeCycle::InitializeError::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::LifeCycle::InitializeError::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::LifeCycle::InitializeError::_tao_type (void) const
{
  return ::CF::LifeCycle::_tc_InitializeError;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_LifeCycle_InitializeError[] =
      {
        { "errorMessages", &CF::_tc_StringSequence }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_LifeCycle_InitializeError (
  ::CORBA::tk_except,
  "IDL:CF/LifeCycle/InitializeError:1.0",
  "InitializeError",
  _tao_fields_CF_LifeCycle_InitializeError,
  1);

::CORBA::TypeCode_ptr const CF::LifeCycle::_tc_InitializeError =
  &_tao_tc_CF_LifeCycle_InitializeError;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::LifeCycle::ReleaseError::ReleaseError (
    const CF::StringSequence & _tao_errorMessages)
  : ::CORBA::UserException (
        "IDL:CF/LifeCycle/ReleaseError:1.0",
        "ReleaseError"
      )
{
  this->errorMessages = _tao_errorMessages;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::LifeCycle::ReleaseError::ReleaseError (void)
  : ::CORBA::UserException (
        "IDL:CF/LifeCycle/ReleaseError:1.0",
        "ReleaseError"
      )
{
}

CF::LifeCycle::ReleaseError::~ReleaseError (void)
{
}

CF::LifeCycle::ReleaseError::ReleaseError (const ::CF::LifeCycle::ReleaseError &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorMessages = _tao_excp.errorMessages;
}

CF::LifeCycle::ReleaseError&
CF::LifeCycle::ReleaseError::operator= (const ::CF::LifeCycle::ReleaseError &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorMessages = _tao_excp.errorMessages;
  return *this;
}

void CF::LifeCycle::ReleaseError::_tao_any_destructor (void *_tao_void_pointer)
{
  ReleaseError *_tao_tmp_pointer =
    static_cast<ReleaseError *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::LifeCycle::ReleaseError *
CF::LifeCycle::ReleaseError::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ReleaseError *> (_tao_excp);
}

const CF::LifeCycle::ReleaseError *
CF::LifeCycle::ReleaseError::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ReleaseError *> (_tao_excp);
}

::CORBA::Exception *CF::LifeCycle::ReleaseError::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::LifeCycle::ReleaseError, 0);
  return retval;
}

::CORBA::Exception *
CF::LifeCycle::ReleaseError::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::LifeCycle::ReleaseError (*this),
      0
    );
  return result;
}

void CF::LifeCycle::ReleaseError::_raise (void) const
{
  throw *this;
}

void CF::LifeCycle::ReleaseError::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::LifeCycle::ReleaseError::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::LifeCycle::ReleaseError::_tao_type (void) const
{
  return ::CF::LifeCycle::_tc_ReleaseError;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_LifeCycle_ReleaseError[] =
      {
        { "errorMessages", &CF::_tc_StringSequence }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_LifeCycle_ReleaseError (
  ::CORBA::tk_except,
  "IDL:CF/LifeCycle/ReleaseError:1.0",
  "ReleaseError",
  _tao_fields_CF_LifeCycle_ReleaseError,
  1);

::CORBA::TypeCode_ptr const CF::LifeCycle::_tc_ReleaseError =
  &_tao_tc_CF_LifeCycle_ReleaseError;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::LifeCycle::initialize (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LifeCycle_Proxy_Broker_ == 0)
    {
      CF_LifeCycle_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CF_LifeCycle_initialize_exceptiondata [] = 
    {
      {
        "IDL:CF/LifeCycle/InitializeError:1.0",
        CF::LifeCycle::InitializeError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::LifeCycle::_tc_InitializeError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "initialize",
      10,
      this->the_TAO_LifeCycle_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_LifeCycle_initialize_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::LifeCycle::releaseObject (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LifeCycle_Proxy_Broker_ == 0)
    {
      CF_LifeCycle_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CF_LifeCycle_releaseObject_exceptiondata [] = 
    {
      {
        "IDL:CF/LifeCycle/ReleaseError:1.0",
        CF::LifeCycle::ReleaseError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::LifeCycle::_tc_ReleaseError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "releaseObject",
      13,
      this->the_TAO_LifeCycle_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_LifeCycle_releaseObject_exceptiondata,
      1
    );
}

CF::LifeCycle::LifeCycle (void)
 : the_TAO_LifeCycle_Proxy_Broker_ (0)
{
  this->CF_LifeCycle_setup_collocation ();
}

void
CF::LifeCycle::CF_LifeCycle_setup_collocation ()
{
  if (::CF__TAO_LifeCycle_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_LifeCycle_Proxy_Broker_ =
        ::CF__TAO_LifeCycle_Proxy_Broker_Factory_function_pointer (this);
    }
}

CF::LifeCycle::~LifeCycle (void)
{}

void 
CF::LifeCycle::_tao_any_destructor (void *_tao_void_pointer)
{
  LifeCycle *_tao_tmp_pointer =
    static_cast<LifeCycle *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::LifeCycle_ptr
CF::LifeCycle::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<LifeCycle>::narrow (
        _tao_objref,
        "IDL:CF/LifeCycle:1.0",
        CF__TAO_LifeCycle_Proxy_Broker_Factory_function_pointer
      );
}

CF::LifeCycle_ptr
CF::LifeCycle::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<LifeCycle>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/LifeCycle:1.0",
        CF__TAO_LifeCycle_Proxy_Broker_Factory_function_pointer
      );
}

CF::LifeCycle_ptr
CF::LifeCycle::_nil (void)
{
  return 0;
}

CF::LifeCycle_ptr
CF::LifeCycle::_duplicate (LifeCycle_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::LifeCycle::_tao_release (LifeCycle_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::LifeCycle::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/LifeCycle:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::LifeCycle::_interface_repository_id (void) const
{
  return "IDL:CF/LifeCycle:1.0";
}

::CORBA::Boolean
CF::LifeCycle::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_LifeCycle (
    ::CORBA::tk_objref,
    "IDL:CF/LifeCycle:1.0",
    "LifeCycle");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_LifeCycle =
    &_tao_tc_CF_LifeCycle;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::TestableObject.

CF::TestableObject_ptr
TAO::Objref_Traits<CF::TestableObject>::duplicate (
    CF::TestableObject_ptr p)
{
  return CF::TestableObject::_duplicate (p);
}

void
TAO::Objref_Traits<CF::TestableObject>::release (
    CF::TestableObject_ptr p)
{
  ::CORBA::release (p);
}

CF::TestableObject_ptr
TAO::Objref_Traits<CF::TestableObject>::nil (void)
{
  return CF::TestableObject::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::TestableObject>::marshal (
    const CF::TestableObject_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_TestableObject_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::TestableObject::UnknownTest::UnknownTest (void)
  : ::CORBA::UserException (
        "IDL:CF/TestableObject/UnknownTest:1.0",
        "UnknownTest"
      )
{
}

CF::TestableObject::UnknownTest::~UnknownTest (void)
{
}

CF::TestableObject::UnknownTest::UnknownTest (const ::CF::TestableObject::UnknownTest &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::TestableObject::UnknownTest&
CF::TestableObject::UnknownTest::operator= (const ::CF::TestableObject::UnknownTest &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::TestableObject::UnknownTest::_tao_any_destructor (void *_tao_void_pointer)
{
  UnknownTest *_tao_tmp_pointer =
    static_cast<UnknownTest *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::TestableObject::UnknownTest *
CF::TestableObject::UnknownTest::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UnknownTest *> (_tao_excp);
}

const CF::TestableObject::UnknownTest *
CF::TestableObject::UnknownTest::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UnknownTest *> (_tao_excp);
}

::CORBA::Exception *CF::TestableObject::UnknownTest::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::TestableObject::UnknownTest, 0);
  return retval;
}

::CORBA::Exception *
CF::TestableObject::UnknownTest::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::TestableObject::UnknownTest (*this),
      0
    );
  return result;
}

void CF::TestableObject::UnknownTest::_raise (void) const
{
  throw *this;
}

void CF::TestableObject::UnknownTest::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::TestableObject::UnknownTest::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::TestableObject::UnknownTest::_tao_type (void) const
{
  return ::CF::TestableObject::_tc_UnknownTest;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_TestableObject_UnknownTest = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_TestableObject_UnknownTest (
  ::CORBA::tk_except,
  "IDL:CF/TestableObject/UnknownTest:1.0",
  "UnknownTest",
  _tao_fields_CF_TestableObject_UnknownTest,
  0);

::CORBA::TypeCode_ptr const CF::TestableObject::_tc_UnknownTest =
  &_tao_tc_CF_TestableObject_UnknownTest;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::TestableObject::runTest (
  ::CORBA::ULong testid,
  ::CF::Properties & testValues)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_TestableObject_Proxy_Broker_ == 0)
    {
      CF_TestableObject_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_testid (testid);
  TAO::Arg_Traits< ::CF::Properties>::inout_arg_val _tao_testValues (testValues);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_testid,
      &_tao_testValues
    };

  static TAO::Exception_Data
  _tao_CF_TestableObject_runTest_exceptiondata [] = 
    {
      {
        "IDL:CF/TestableObject/UnknownTest:1.0",
        CF::TestableObject::UnknownTest::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::TestableObject::_tc_UnknownTest
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/UnknownProperties:1.0",
        CF::UnknownProperties::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_UnknownProperties
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "runTest",
      7,
      this->the_TAO_TestableObject_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_TestableObject_runTest_exceptiondata,
      2
    );
}

CF::TestableObject::TestableObject (void)
 : the_TAO_TestableObject_Proxy_Broker_ (0)
{
  this->CF_TestableObject_setup_collocation ();
}

void
CF::TestableObject::CF_TestableObject_setup_collocation ()
{
  if (::CF__TAO_TestableObject_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_TestableObject_Proxy_Broker_ =
        ::CF__TAO_TestableObject_Proxy_Broker_Factory_function_pointer (this);
    }
}

CF::TestableObject::~TestableObject (void)
{}

void 
CF::TestableObject::_tao_any_destructor (void *_tao_void_pointer)
{
  TestableObject *_tao_tmp_pointer =
    static_cast<TestableObject *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::TestableObject_ptr
CF::TestableObject::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<TestableObject>::narrow (
        _tao_objref,
        "IDL:CF/TestableObject:1.0",
        CF__TAO_TestableObject_Proxy_Broker_Factory_function_pointer
      );
}

CF::TestableObject_ptr
CF::TestableObject::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<TestableObject>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/TestableObject:1.0",
        CF__TAO_TestableObject_Proxy_Broker_Factory_function_pointer
      );
}

CF::TestableObject_ptr
CF::TestableObject::_nil (void)
{
  return 0;
}

CF::TestableObject_ptr
CF::TestableObject::_duplicate (TestableObject_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::TestableObject::_tao_release (TestableObject_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::TestableObject::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/TestableObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::TestableObject::_interface_repository_id (void) const
{
  return "IDL:CF/TestableObject:1.0";
}

::CORBA::Boolean
CF::TestableObject::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_TestableObject (
    ::CORBA::tk_objref,
    "IDL:CF/TestableObject:1.0",
    "TestableObject");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_TestableObject =
    &_tao_tc_CF_TestableObject;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::PropertySet.

CF::PropertySet_ptr
TAO::Objref_Traits<CF::PropertySet>::duplicate (
    CF::PropertySet_ptr p)
{
  return CF::PropertySet::_duplicate (p);
}

void
TAO::Objref_Traits<CF::PropertySet>::release (
    CF::PropertySet_ptr p)
{
  ::CORBA::release (p);
}

CF::PropertySet_ptr
TAO::Objref_Traits<CF::PropertySet>::nil (void)
{
  return CF::PropertySet::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::PropertySet>::marshal (
    const CF::PropertySet_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_PropertySet_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::PropertySet::InvalidConfiguration::InvalidConfiguration (
    const char * _tao_msg,
    const CF::Properties & _tao_invalidProperties)
  : ::CORBA::UserException (
        "IDL:CF/PropertySet/InvalidConfiguration:1.0",
        "InvalidConfiguration"
      )
{
  this->msg = ::CORBA::string_dup (_tao_msg);
  this->invalidProperties = _tao_invalidProperties;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::PropertySet::InvalidConfiguration::InvalidConfiguration (void)
  : ::CORBA::UserException (
        "IDL:CF/PropertySet/InvalidConfiguration:1.0",
        "InvalidConfiguration"
      )
{
}

CF::PropertySet::InvalidConfiguration::~InvalidConfiguration (void)
{
}

CF::PropertySet::InvalidConfiguration::InvalidConfiguration (const ::CF::PropertySet::InvalidConfiguration &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  this->invalidProperties = _tao_excp.invalidProperties;
}

CF::PropertySet::InvalidConfiguration&
CF::PropertySet::InvalidConfiguration::operator= (const ::CF::PropertySet::InvalidConfiguration &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  this->invalidProperties = _tao_excp.invalidProperties;
  return *this;
}

void CF::PropertySet::InvalidConfiguration::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidConfiguration *_tao_tmp_pointer =
    static_cast<InvalidConfiguration *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::PropertySet::InvalidConfiguration *
CF::PropertySet::InvalidConfiguration::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidConfiguration *> (_tao_excp);
}

const CF::PropertySet::InvalidConfiguration *
CF::PropertySet::InvalidConfiguration::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidConfiguration *> (_tao_excp);
}

::CORBA::Exception *CF::PropertySet::InvalidConfiguration::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::PropertySet::InvalidConfiguration, 0);
  return retval;
}

::CORBA::Exception *
CF::PropertySet::InvalidConfiguration::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::PropertySet::InvalidConfiguration (*this),
      0
    );
  return result;
}

void CF::PropertySet::InvalidConfiguration::_raise (void) const
{
  throw *this;
}

void CF::PropertySet::InvalidConfiguration::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::PropertySet::InvalidConfiguration::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::PropertySet::InvalidConfiguration::_tao_type (void) const
{
  return ::CF::PropertySet::_tc_InvalidConfiguration;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_PropertySet_InvalidConfiguration[] =
      {
        { "msg", &CORBA::_tc_string },
        { "invalidProperties", &CF::_tc_Properties }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_PropertySet_InvalidConfiguration (
  ::CORBA::tk_except,
  "IDL:CF/PropertySet/InvalidConfiguration:1.0",
  "InvalidConfiguration",
  _tao_fields_CF_PropertySet_InvalidConfiguration,
  2);

::CORBA::TypeCode_ptr const CF::PropertySet::_tc_InvalidConfiguration =
  &_tao_tc_CF_PropertySet_InvalidConfiguration;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::PropertySet::PartialConfiguration::PartialConfiguration (
    const CF::Properties & _tao_invalidProperties)
  : ::CORBA::UserException (
        "IDL:CF/PropertySet/PartialConfiguration:1.0",
        "PartialConfiguration"
      )
{
  this->invalidProperties = _tao_invalidProperties;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::PropertySet::PartialConfiguration::PartialConfiguration (void)
  : ::CORBA::UserException (
        "IDL:CF/PropertySet/PartialConfiguration:1.0",
        "PartialConfiguration"
      )
{
}

CF::PropertySet::PartialConfiguration::~PartialConfiguration (void)
{
}

CF::PropertySet::PartialConfiguration::PartialConfiguration (const ::CF::PropertySet::PartialConfiguration &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->invalidProperties = _tao_excp.invalidProperties;
}

CF::PropertySet::PartialConfiguration&
CF::PropertySet::PartialConfiguration::operator= (const ::CF::PropertySet::PartialConfiguration &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->invalidProperties = _tao_excp.invalidProperties;
  return *this;
}

void CF::PropertySet::PartialConfiguration::_tao_any_destructor (void *_tao_void_pointer)
{
  PartialConfiguration *_tao_tmp_pointer =
    static_cast<PartialConfiguration *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::PropertySet::PartialConfiguration *
CF::PropertySet::PartialConfiguration::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<PartialConfiguration *> (_tao_excp);
}

const CF::PropertySet::PartialConfiguration *
CF::PropertySet::PartialConfiguration::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const PartialConfiguration *> (_tao_excp);
}

::CORBA::Exception *CF::PropertySet::PartialConfiguration::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::PropertySet::PartialConfiguration, 0);
  return retval;
}

::CORBA::Exception *
CF::PropertySet::PartialConfiguration::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::PropertySet::PartialConfiguration (*this),
      0
    );
  return result;
}

void CF::PropertySet::PartialConfiguration::_raise (void) const
{
  throw *this;
}

void CF::PropertySet::PartialConfiguration::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::PropertySet::PartialConfiguration::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::PropertySet::PartialConfiguration::_tao_type (void) const
{
  return ::CF::PropertySet::_tc_PartialConfiguration;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_PropertySet_PartialConfiguration[] =
      {
        { "invalidProperties", &CF::_tc_Properties }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_PropertySet_PartialConfiguration (
  ::CORBA::tk_except,
  "IDL:CF/PropertySet/PartialConfiguration:1.0",
  "PartialConfiguration",
  _tao_fields_CF_PropertySet_PartialConfiguration,
  1);

::CORBA::TypeCode_ptr const CF::PropertySet::_tc_PartialConfiguration =
  &_tao_tc_CF_PropertySet_PartialConfiguration;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::PropertySet::configure (
  const ::CF::Properties & configProperties)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertySet_Proxy_Broker_ == 0)
    {
      CF_PropertySet_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::Properties>::in_arg_val _tao_configProperties (configProperties);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_configProperties
    };

  static TAO::Exception_Data
  _tao_CF_PropertySet_configure_exceptiondata [] = 
    {
      {
        "IDL:CF/PropertySet/InvalidConfiguration:1.0",
        CF::PropertySet::InvalidConfiguration::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::PropertySet::_tc_InvalidConfiguration
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/PropertySet/PartialConfiguration:1.0",
        CF::PropertySet::PartialConfiguration::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::PropertySet::_tc_PartialConfiguration
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "configure",
      9,
      this->the_TAO_PropertySet_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_PropertySet_configure_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::PropertySet::query (
  ::CF::Properties & configProperties)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertySet_Proxy_Broker_ == 0)
    {
      CF_PropertySet_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::Properties>::inout_arg_val _tao_configProperties (configProperties);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_configProperties
    };

  static TAO::Exception_Data
  _tao_CF_PropertySet_query_exceptiondata [] = 
    {
      {
        "IDL:CF/UnknownProperties:1.0",
        CF::UnknownProperties::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_UnknownProperties
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "query",
      5,
      this->the_TAO_PropertySet_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_PropertySet_query_exceptiondata,
      1
    );
}

CF::PropertySet::PropertySet (void)
 : the_TAO_PropertySet_Proxy_Broker_ (0)
{
  this->CF_PropertySet_setup_collocation ();
}

void
CF::PropertySet::CF_PropertySet_setup_collocation ()
{
  if (::CF__TAO_PropertySet_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_PropertySet_Proxy_Broker_ =
        ::CF__TAO_PropertySet_Proxy_Broker_Factory_function_pointer (this);
    }
}

CF::PropertySet::~PropertySet (void)
{}

void 
CF::PropertySet::_tao_any_destructor (void *_tao_void_pointer)
{
  PropertySet *_tao_tmp_pointer =
    static_cast<PropertySet *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::PropertySet_ptr
CF::PropertySet::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<PropertySet>::narrow (
        _tao_objref,
        "IDL:CF/PropertySet:1.0",
        CF__TAO_PropertySet_Proxy_Broker_Factory_function_pointer
      );
}

CF::PropertySet_ptr
CF::PropertySet::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<PropertySet>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/PropertySet:1.0",
        CF__TAO_PropertySet_Proxy_Broker_Factory_function_pointer
      );
}

CF::PropertySet_ptr
CF::PropertySet::_nil (void)
{
  return 0;
}

CF::PropertySet_ptr
CF::PropertySet::_duplicate (PropertySet_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::PropertySet::_tao_release (PropertySet_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::PropertySet::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::PropertySet::_interface_repository_id (void) const
{
  return "IDL:CF/PropertySet:1.0";
}

::CORBA::Boolean
CF::PropertySet::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_PropertySet (
    ::CORBA::tk_objref,
    "IDL:CF/PropertySet:1.0",
    "PropertySet");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_PropertySet =
    &_tao_tc_CF_PropertySet;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::DomainManager.

CF::DomainManager_ptr
TAO::Objref_Traits<CF::DomainManager>::duplicate (
    CF::DomainManager_ptr p)
{
  return CF::DomainManager::_duplicate (p);
}

void
TAO::Objref_Traits<CF::DomainManager>::release (
    CF::DomainManager_ptr p)
{
  ::CORBA::release (p);
}

CF::DomainManager_ptr
TAO::Objref_Traits<CF::DomainManager>::nil (void)
{
  return CF::DomainManager::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::DomainManager>::marshal (
    const CF::DomainManager_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_DomainManager_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::DomainManager::ApplicationInstallationError::ApplicationInstallationError (
    CF::ErrorNumberType _tao_errorNumber,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/DomainManager/ApplicationInstallationError:1.0",
        "ApplicationInstallationError"
      )
{
  this->errorNumber = _tao_errorNumber;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::DomainManager::ApplicationInstallationError::ApplicationInstallationError (void)
  : ::CORBA::UserException (
        "IDL:CF/DomainManager/ApplicationInstallationError:1.0",
        "ApplicationInstallationError"
      )
{
}

CF::DomainManager::ApplicationInstallationError::~ApplicationInstallationError (void)
{
}

CF::DomainManager::ApplicationInstallationError::ApplicationInstallationError (const ::CF::DomainManager::ApplicationInstallationError &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::DomainManager::ApplicationInstallationError&
CF::DomainManager::ApplicationInstallationError::operator= (const ::CF::DomainManager::ApplicationInstallationError &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::DomainManager::ApplicationInstallationError::_tao_any_destructor (void *_tao_void_pointer)
{
  ApplicationInstallationError *_tao_tmp_pointer =
    static_cast<ApplicationInstallationError *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::DomainManager::ApplicationInstallationError *
CF::DomainManager::ApplicationInstallationError::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ApplicationInstallationError *> (_tao_excp);
}

const CF::DomainManager::ApplicationInstallationError *
CF::DomainManager::ApplicationInstallationError::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ApplicationInstallationError *> (_tao_excp);
}

::CORBA::Exception *CF::DomainManager::ApplicationInstallationError::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::DomainManager::ApplicationInstallationError, 0);
  return retval;
}

::CORBA::Exception *
CF::DomainManager::ApplicationInstallationError::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::DomainManager::ApplicationInstallationError (*this),
      0
    );
  return result;
}

void CF::DomainManager::ApplicationInstallationError::_raise (void) const
{
  throw *this;
}

void CF::DomainManager::ApplicationInstallationError::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::DomainManager::ApplicationInstallationError::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::DomainManager::ApplicationInstallationError::_tao_type (void) const
{
  return ::CF::DomainManager::_tc_ApplicationInstallationError;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_DomainManager_ApplicationInstallationError[] =
      {
        { "errorNumber", &CF::_tc_ErrorNumberType },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_DomainManager_ApplicationInstallationError (
  ::CORBA::tk_except,
  "IDL:CF/DomainManager/ApplicationInstallationError:1.0",
  "ApplicationInstallationError",
  _tao_fields_CF_DomainManager_ApplicationInstallationError,
  2);

::CORBA::TypeCode_ptr const CF::DomainManager::_tc_ApplicationInstallationError =
  &_tao_tc_CF_DomainManager_ApplicationInstallationError;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CF_DOMAINMANAGER_APPLICATIONSEQUENCE_CS_)
#define _CF_DOMAINMANAGER_APPLICATIONSEQUENCE_CS_

CF::DomainManager::ApplicationSequence::ApplicationSequence (void)
{}

CF::DomainManager::ApplicationSequence::ApplicationSequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        CF::Application,
        CF::Application_var
      > (max)
{}

CF::DomainManager::ApplicationSequence::ApplicationSequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CF::Application_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        CF::Application,
        CF::Application_var
      >
    (max, length, buffer, release)
{}

CF::DomainManager::ApplicationSequence::ApplicationSequence (
    const ApplicationSequence &seq)
  : ::TAO::unbounded_object_reference_sequence<
        CF::Application,
        CF::Application_var
      > (seq)
{}

CF::DomainManager::ApplicationSequence::~ApplicationSequence (void)
{}

void CF::DomainManager::ApplicationSequence::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ApplicationSequence * _tao_tmp_pointer =
    static_cast<ApplicationSequence *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CF_DomainManager_ApplicationSequence_GUARD
#define _TAO_TYPECODE_CF_DomainManager_ApplicationSequence_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CF_DomainManager_ApplicationSequence_0 (
          ::CORBA::tk_sequence,
          &CF::_tc_Application,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CF_DomainManager_ApplicationSequence_0 =
        &CF_DomainManager_ApplicationSequence_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CF_DomainManager_ApplicationSequence_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CF_DomainManager_ApplicationSequence (
    ::CORBA::tk_alias,
    "IDL:CF/DomainManager/ApplicationSequence:1.0",
    "ApplicationSequence",
    &TAO::TypeCode::tc_CF_DomainManager_ApplicationSequence_0);
  
::CORBA::TypeCode_ptr const CF::DomainManager::_tc_ApplicationSequence =
  &_tao_tc_CF_DomainManager_ApplicationSequence;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CF_DOMAINMANAGER_APPLICATIONFACTORYSEQUENCE_CS_)
#define _CF_DOMAINMANAGER_APPLICATIONFACTORYSEQUENCE_CS_

CF::DomainManager::ApplicationFactorySequence::ApplicationFactorySequence (void)
{}

CF::DomainManager::ApplicationFactorySequence::ApplicationFactorySequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        CF::ApplicationFactory,
        CF::ApplicationFactory_var
      > (max)
{}

CF::DomainManager::ApplicationFactorySequence::ApplicationFactorySequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CF::ApplicationFactory_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        CF::ApplicationFactory,
        CF::ApplicationFactory_var
      >
    (max, length, buffer, release)
{}

CF::DomainManager::ApplicationFactorySequence::ApplicationFactorySequence (
    const ApplicationFactorySequence &seq)
  : ::TAO::unbounded_object_reference_sequence<
        CF::ApplicationFactory,
        CF::ApplicationFactory_var
      > (seq)
{}

CF::DomainManager::ApplicationFactorySequence::~ApplicationFactorySequence (void)
{}

void CF::DomainManager::ApplicationFactorySequence::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ApplicationFactorySequence * _tao_tmp_pointer =
    static_cast<ApplicationFactorySequence *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CF_DomainManager_ApplicationFactorySequence_GUARD
#define _TAO_TYPECODE_CF_DomainManager_ApplicationFactorySequence_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CF_DomainManager_ApplicationFactorySequence_0 (
          ::CORBA::tk_sequence,
          &CF::_tc_ApplicationFactory,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CF_DomainManager_ApplicationFactorySequence_0 =
        &CF_DomainManager_ApplicationFactorySequence_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CF_DomainManager_ApplicationFactorySequence_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CF_DomainManager_ApplicationFactorySequence (
    ::CORBA::tk_alias,
    "IDL:CF/DomainManager/ApplicationFactorySequence:1.0",
    "ApplicationFactorySequence",
    &TAO::TypeCode::tc_CF_DomainManager_ApplicationFactorySequence_0);
  
::CORBA::TypeCode_ptr const CF::DomainManager::_tc_ApplicationFactorySequence =
  &_tao_tc_CF_DomainManager_ApplicationFactorySequence;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CF_DOMAINMANAGER_DEVICEMANAGERSEQUENCE_CS_)
#define _CF_DOMAINMANAGER_DEVICEMANAGERSEQUENCE_CS_

CF::DomainManager::DeviceManagerSequence::DeviceManagerSequence (void)
{}

CF::DomainManager::DeviceManagerSequence::DeviceManagerSequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        CF::DeviceManager,
        CF::DeviceManager_var
      > (max)
{}

CF::DomainManager::DeviceManagerSequence::DeviceManagerSequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CF::DeviceManager_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        CF::DeviceManager,
        CF::DeviceManager_var
      >
    (max, length, buffer, release)
{}

CF::DomainManager::DeviceManagerSequence::DeviceManagerSequence (
    const DeviceManagerSequence &seq)
  : ::TAO::unbounded_object_reference_sequence<
        CF::DeviceManager,
        CF::DeviceManager_var
      > (seq)
{}

CF::DomainManager::DeviceManagerSequence::~DeviceManagerSequence (void)
{}

void CF::DomainManager::DeviceManagerSequence::_tao_any_destructor (
    void * _tao_void_pointer)
{
  DeviceManagerSequence * _tao_tmp_pointer =
    static_cast<DeviceManagerSequence *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CF_DomainManager_DeviceManagerSequence_GUARD
#define _TAO_TYPECODE_CF_DomainManager_DeviceManagerSequence_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CF_DomainManager_DeviceManagerSequence_0 (
          ::CORBA::tk_sequence,
          &CF::_tc_DeviceManager,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CF_DomainManager_DeviceManagerSequence_0 =
        &CF_DomainManager_DeviceManagerSequence_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CF_DomainManager_DeviceManagerSequence_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CF_DomainManager_DeviceManagerSequence (
    ::CORBA::tk_alias,
    "IDL:CF/DomainManager/DeviceManagerSequence:1.0",
    "DeviceManagerSequence",
    &TAO::TypeCode::tc_CF_DomainManager_DeviceManagerSequence_0);
  
::CORBA::TypeCode_ptr const CF::DomainManager::_tc_DeviceManagerSequence =
  &_tao_tc_CF_DomainManager_DeviceManagerSequence;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::DomainManager::InvalidIdentifier::InvalidIdentifier (void)
  : ::CORBA::UserException (
        "IDL:CF/DomainManager/InvalidIdentifier:1.0",
        "InvalidIdentifier"
      )
{
}

CF::DomainManager::InvalidIdentifier::~InvalidIdentifier (void)
{
}

CF::DomainManager::InvalidIdentifier::InvalidIdentifier (const ::CF::DomainManager::InvalidIdentifier &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::DomainManager::InvalidIdentifier&
CF::DomainManager::InvalidIdentifier::operator= (const ::CF::DomainManager::InvalidIdentifier &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::DomainManager::InvalidIdentifier::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidIdentifier *_tao_tmp_pointer =
    static_cast<InvalidIdentifier *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::DomainManager::InvalidIdentifier *
CF::DomainManager::InvalidIdentifier::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidIdentifier *> (_tao_excp);
}

const CF::DomainManager::InvalidIdentifier *
CF::DomainManager::InvalidIdentifier::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidIdentifier *> (_tao_excp);
}

::CORBA::Exception *CF::DomainManager::InvalidIdentifier::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::DomainManager::InvalidIdentifier, 0);
  return retval;
}

::CORBA::Exception *
CF::DomainManager::InvalidIdentifier::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::DomainManager::InvalidIdentifier (*this),
      0
    );
  return result;
}

void CF::DomainManager::InvalidIdentifier::_raise (void) const
{
  throw *this;
}

void CF::DomainManager::InvalidIdentifier::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::DomainManager::InvalidIdentifier::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::DomainManager::InvalidIdentifier::_tao_type (void) const
{
  return ::CF::DomainManager::_tc_InvalidIdentifier;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_DomainManager_InvalidIdentifier = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_DomainManager_InvalidIdentifier (
  ::CORBA::tk_except,
  "IDL:CF/DomainManager/InvalidIdentifier:1.0",
  "InvalidIdentifier",
  _tao_fields_CF_DomainManager_InvalidIdentifier,
  0);

::CORBA::TypeCode_ptr const CF::DomainManager::_tc_InvalidIdentifier =
  &_tao_tc_CF_DomainManager_InvalidIdentifier;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::DomainManager::DeviceManagerNotRegistered::DeviceManagerNotRegistered (void)
  : ::CORBA::UserException (
        "IDL:CF/DomainManager/DeviceManagerNotRegistered:1.0",
        "DeviceManagerNotRegistered"
      )
{
}

CF::DomainManager::DeviceManagerNotRegistered::~DeviceManagerNotRegistered (void)
{
}

CF::DomainManager::DeviceManagerNotRegistered::DeviceManagerNotRegistered (const ::CF::DomainManager::DeviceManagerNotRegistered &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::DomainManager::DeviceManagerNotRegistered&
CF::DomainManager::DeviceManagerNotRegistered::operator= (const ::CF::DomainManager::DeviceManagerNotRegistered &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::DomainManager::DeviceManagerNotRegistered::_tao_any_destructor (void *_tao_void_pointer)
{
  DeviceManagerNotRegistered *_tao_tmp_pointer =
    static_cast<DeviceManagerNotRegistered *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::DomainManager::DeviceManagerNotRegistered *
CF::DomainManager::DeviceManagerNotRegistered::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<DeviceManagerNotRegistered *> (_tao_excp);
}

const CF::DomainManager::DeviceManagerNotRegistered *
CF::DomainManager::DeviceManagerNotRegistered::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const DeviceManagerNotRegistered *> (_tao_excp);
}

::CORBA::Exception *CF::DomainManager::DeviceManagerNotRegistered::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::DomainManager::DeviceManagerNotRegistered, 0);
  return retval;
}

::CORBA::Exception *
CF::DomainManager::DeviceManagerNotRegistered::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::DomainManager::DeviceManagerNotRegistered (*this),
      0
    );
  return result;
}

void CF::DomainManager::DeviceManagerNotRegistered::_raise (void) const
{
  throw *this;
}

void CF::DomainManager::DeviceManagerNotRegistered::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::DomainManager::DeviceManagerNotRegistered::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::DomainManager::DeviceManagerNotRegistered::_tao_type (void) const
{
  return ::CF::DomainManager::_tc_DeviceManagerNotRegistered;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_DomainManager_DeviceManagerNotRegistered = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_DomainManager_DeviceManagerNotRegistered (
  ::CORBA::tk_except,
  "IDL:CF/DomainManager/DeviceManagerNotRegistered:1.0",
  "DeviceManagerNotRegistered",
  _tao_fields_CF_DomainManager_DeviceManagerNotRegistered,
  0);

::CORBA::TypeCode_ptr const CF::DomainManager::_tc_DeviceManagerNotRegistered =
  &_tao_tc_CF_DomainManager_DeviceManagerNotRegistered;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::DomainManager::ApplicationUninstallationError::ApplicationUninstallationError (
    CF::ErrorNumberType _tao_errorNumber,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/DomainManager/ApplicationUninstallationError:1.0",
        "ApplicationUninstallationError"
      )
{
  this->errorNumber = _tao_errorNumber;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::DomainManager::ApplicationUninstallationError::ApplicationUninstallationError (void)
  : ::CORBA::UserException (
        "IDL:CF/DomainManager/ApplicationUninstallationError:1.0",
        "ApplicationUninstallationError"
      )
{
}

CF::DomainManager::ApplicationUninstallationError::~ApplicationUninstallationError (void)
{
}

CF::DomainManager::ApplicationUninstallationError::ApplicationUninstallationError (const ::CF::DomainManager::ApplicationUninstallationError &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::DomainManager::ApplicationUninstallationError&
CF::DomainManager::ApplicationUninstallationError::operator= (const ::CF::DomainManager::ApplicationUninstallationError &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::DomainManager::ApplicationUninstallationError::_tao_any_destructor (void *_tao_void_pointer)
{
  ApplicationUninstallationError *_tao_tmp_pointer =
    static_cast<ApplicationUninstallationError *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::DomainManager::ApplicationUninstallationError *
CF::DomainManager::ApplicationUninstallationError::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ApplicationUninstallationError *> (_tao_excp);
}

const CF::DomainManager::ApplicationUninstallationError *
CF::DomainManager::ApplicationUninstallationError::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ApplicationUninstallationError *> (_tao_excp);
}

::CORBA::Exception *CF::DomainManager::ApplicationUninstallationError::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::DomainManager::ApplicationUninstallationError, 0);
  return retval;
}

::CORBA::Exception *
CF::DomainManager::ApplicationUninstallationError::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::DomainManager::ApplicationUninstallationError (*this),
      0
    );
  return result;
}

void CF::DomainManager::ApplicationUninstallationError::_raise (void) const
{
  throw *this;
}

void CF::DomainManager::ApplicationUninstallationError::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::DomainManager::ApplicationUninstallationError::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::DomainManager::ApplicationUninstallationError::_tao_type (void) const
{
  return ::CF::DomainManager::_tc_ApplicationUninstallationError;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_DomainManager_ApplicationUninstallationError[] =
      {
        { "errorNumber", &CF::_tc_ErrorNumberType },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_DomainManager_ApplicationUninstallationError (
  ::CORBA::tk_except,
  "IDL:CF/DomainManager/ApplicationUninstallationError:1.0",
  "ApplicationUninstallationError",
  _tao_fields_CF_DomainManager_ApplicationUninstallationError,
  2);

::CORBA::TypeCode_ptr const CF::DomainManager::_tc_ApplicationUninstallationError =
  &_tao_tc_CF_DomainManager_ApplicationUninstallationError;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::DomainManager::RegisterError::RegisterError (
    CF::ErrorNumberType _tao_errorNumber,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/DomainManager/RegisterError:1.0",
        "RegisterError"
      )
{
  this->errorNumber = _tao_errorNumber;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::DomainManager::RegisterError::RegisterError (void)
  : ::CORBA::UserException (
        "IDL:CF/DomainManager/RegisterError:1.0",
        "RegisterError"
      )
{
}

CF::DomainManager::RegisterError::~RegisterError (void)
{
}

CF::DomainManager::RegisterError::RegisterError (const ::CF::DomainManager::RegisterError &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::DomainManager::RegisterError&
CF::DomainManager::RegisterError::operator= (const ::CF::DomainManager::RegisterError &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::DomainManager::RegisterError::_tao_any_destructor (void *_tao_void_pointer)
{
  RegisterError *_tao_tmp_pointer =
    static_cast<RegisterError *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::DomainManager::RegisterError *
CF::DomainManager::RegisterError::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<RegisterError *> (_tao_excp);
}

const CF::DomainManager::RegisterError *
CF::DomainManager::RegisterError::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const RegisterError *> (_tao_excp);
}

::CORBA::Exception *CF::DomainManager::RegisterError::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::DomainManager::RegisterError, 0);
  return retval;
}

::CORBA::Exception *
CF::DomainManager::RegisterError::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::DomainManager::RegisterError (*this),
      0
    );
  return result;
}

void CF::DomainManager::RegisterError::_raise (void) const
{
  throw *this;
}

void CF::DomainManager::RegisterError::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::DomainManager::RegisterError::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::DomainManager::RegisterError::_tao_type (void) const
{
  return ::CF::DomainManager::_tc_RegisterError;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_DomainManager_RegisterError[] =
      {
        { "errorNumber", &CF::_tc_ErrorNumberType },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_DomainManager_RegisterError (
  ::CORBA::tk_except,
  "IDL:CF/DomainManager/RegisterError:1.0",
  "RegisterError",
  _tao_fields_CF_DomainManager_RegisterError,
  2);

::CORBA::TypeCode_ptr const CF::DomainManager::_tc_RegisterError =
  &_tao_tc_CF_DomainManager_RegisterError;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::DomainManager::UnregisterError::UnregisterError (
    CF::ErrorNumberType _tao_errorNumber,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/DomainManager/UnregisterError:1.0",
        "UnregisterError"
      )
{
  this->errorNumber = _tao_errorNumber;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::DomainManager::UnregisterError::UnregisterError (void)
  : ::CORBA::UserException (
        "IDL:CF/DomainManager/UnregisterError:1.0",
        "UnregisterError"
      )
{
}

CF::DomainManager::UnregisterError::~UnregisterError (void)
{
}

CF::DomainManager::UnregisterError::UnregisterError (const ::CF::DomainManager::UnregisterError &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::DomainManager::UnregisterError&
CF::DomainManager::UnregisterError::operator= (const ::CF::DomainManager::UnregisterError &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::DomainManager::UnregisterError::_tao_any_destructor (void *_tao_void_pointer)
{
  UnregisterError *_tao_tmp_pointer =
    static_cast<UnregisterError *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::DomainManager::UnregisterError *
CF::DomainManager::UnregisterError::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UnregisterError *> (_tao_excp);
}

const CF::DomainManager::UnregisterError *
CF::DomainManager::UnregisterError::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UnregisterError *> (_tao_excp);
}

::CORBA::Exception *CF::DomainManager::UnregisterError::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::DomainManager::UnregisterError, 0);
  return retval;
}

::CORBA::Exception *
CF::DomainManager::UnregisterError::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::DomainManager::UnregisterError (*this),
      0
    );
  return result;
}

void CF::DomainManager::UnregisterError::_raise (void) const
{
  throw *this;
}

void CF::DomainManager::UnregisterError::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::DomainManager::UnregisterError::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::DomainManager::UnregisterError::_tao_type (void) const
{
  return ::CF::DomainManager::_tc_UnregisterError;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_DomainManager_UnregisterError[] =
      {
        { "errorNumber", &CF::_tc_ErrorNumberType },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_DomainManager_UnregisterError (
  ::CORBA::tk_except,
  "IDL:CF/DomainManager/UnregisterError:1.0",
  "UnregisterError",
  _tao_fields_CF_DomainManager_UnregisterError,
  2);

::CORBA::TypeCode_ptr const CF::DomainManager::_tc_UnregisterError =
  &_tao_tc_CF_DomainManager_UnregisterError;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::DomainManager::AlreadyConnected::AlreadyConnected (void)
  : ::CORBA::UserException (
        "IDL:CF/DomainManager/AlreadyConnected:1.0",
        "AlreadyConnected"
      )
{
}

CF::DomainManager::AlreadyConnected::~AlreadyConnected (void)
{
}

CF::DomainManager::AlreadyConnected::AlreadyConnected (const ::CF::DomainManager::AlreadyConnected &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::DomainManager::AlreadyConnected&
CF::DomainManager::AlreadyConnected::operator= (const ::CF::DomainManager::AlreadyConnected &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::DomainManager::AlreadyConnected::_tao_any_destructor (void *_tao_void_pointer)
{
  AlreadyConnected *_tao_tmp_pointer =
    static_cast<AlreadyConnected *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::DomainManager::AlreadyConnected *
CF::DomainManager::AlreadyConnected::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<AlreadyConnected *> (_tao_excp);
}

const CF::DomainManager::AlreadyConnected *
CF::DomainManager::AlreadyConnected::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const AlreadyConnected *> (_tao_excp);
}

::CORBA::Exception *CF::DomainManager::AlreadyConnected::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::DomainManager::AlreadyConnected, 0);
  return retval;
}

::CORBA::Exception *
CF::DomainManager::AlreadyConnected::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::DomainManager::AlreadyConnected (*this),
      0
    );
  return result;
}

void CF::DomainManager::AlreadyConnected::_raise (void) const
{
  throw *this;
}

void CF::DomainManager::AlreadyConnected::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::DomainManager::AlreadyConnected::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::DomainManager::AlreadyConnected::_tao_type (void) const
{
  return ::CF::DomainManager::_tc_AlreadyConnected;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_DomainManager_AlreadyConnected = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_DomainManager_AlreadyConnected (
  ::CORBA::tk_except,
  "IDL:CF/DomainManager/AlreadyConnected:1.0",
  "AlreadyConnected",
  _tao_fields_CF_DomainManager_AlreadyConnected,
  0);

::CORBA::TypeCode_ptr const CF::DomainManager::_tc_AlreadyConnected =
  &_tao_tc_CF_DomainManager_AlreadyConnected;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::DomainManager::InvalidEventChannelName::InvalidEventChannelName (void)
  : ::CORBA::UserException (
        "IDL:CF/DomainManager/InvalidEventChannelName:1.0",
        "InvalidEventChannelName"
      )
{
}

CF::DomainManager::InvalidEventChannelName::~InvalidEventChannelName (void)
{
}

CF::DomainManager::InvalidEventChannelName::InvalidEventChannelName (const ::CF::DomainManager::InvalidEventChannelName &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::DomainManager::InvalidEventChannelName&
CF::DomainManager::InvalidEventChannelName::operator= (const ::CF::DomainManager::InvalidEventChannelName &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::DomainManager::InvalidEventChannelName::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidEventChannelName *_tao_tmp_pointer =
    static_cast<InvalidEventChannelName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::DomainManager::InvalidEventChannelName *
CF::DomainManager::InvalidEventChannelName::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidEventChannelName *> (_tao_excp);
}

const CF::DomainManager::InvalidEventChannelName *
CF::DomainManager::InvalidEventChannelName::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidEventChannelName *> (_tao_excp);
}

::CORBA::Exception *CF::DomainManager::InvalidEventChannelName::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::DomainManager::InvalidEventChannelName, 0);
  return retval;
}

::CORBA::Exception *
CF::DomainManager::InvalidEventChannelName::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::DomainManager::InvalidEventChannelName (*this),
      0
    );
  return result;
}

void CF::DomainManager::InvalidEventChannelName::_raise (void) const
{
  throw *this;
}

void CF::DomainManager::InvalidEventChannelName::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::DomainManager::InvalidEventChannelName::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::DomainManager::InvalidEventChannelName::_tao_type (void) const
{
  return ::CF::DomainManager::_tc_InvalidEventChannelName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_DomainManager_InvalidEventChannelName = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_DomainManager_InvalidEventChannelName (
  ::CORBA::tk_except,
  "IDL:CF/DomainManager/InvalidEventChannelName:1.0",
  "InvalidEventChannelName",
  _tao_fields_CF_DomainManager_InvalidEventChannelName,
  0);

::CORBA::TypeCode_ptr const CF::DomainManager::_tc_InvalidEventChannelName =
  &_tao_tc_CF_DomainManager_InvalidEventChannelName;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::DomainManager::NotConnected::NotConnected (void)
  : ::CORBA::UserException (
        "IDL:CF/DomainManager/NotConnected:1.0",
        "NotConnected"
      )
{
}

CF::DomainManager::NotConnected::~NotConnected (void)
{
}

CF::DomainManager::NotConnected::NotConnected (const ::CF::DomainManager::NotConnected &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::DomainManager::NotConnected&
CF::DomainManager::NotConnected::operator= (const ::CF::DomainManager::NotConnected &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::DomainManager::NotConnected::_tao_any_destructor (void *_tao_void_pointer)
{
  NotConnected *_tao_tmp_pointer =
    static_cast<NotConnected *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::DomainManager::NotConnected *
CF::DomainManager::NotConnected::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NotConnected *> (_tao_excp);
}

const CF::DomainManager::NotConnected *
CF::DomainManager::NotConnected::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NotConnected *> (_tao_excp);
}

::CORBA::Exception *CF::DomainManager::NotConnected::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::DomainManager::NotConnected, 0);
  return retval;
}

::CORBA::Exception *
CF::DomainManager::NotConnected::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::DomainManager::NotConnected (*this),
      0
    );
  return result;
}

void CF::DomainManager::NotConnected::_raise (void) const
{
  throw *this;
}

void CF::DomainManager::NotConnected::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::DomainManager::NotConnected::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::DomainManager::NotConnected::_tao_type (void) const
{
  return ::CF::DomainManager::_tc_NotConnected;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_DomainManager_NotConnected = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_DomainManager_NotConnected (
  ::CORBA::tk_except,
  "IDL:CF/DomainManager/NotConnected:1.0",
  "NotConnected",
  _tao_fields_CF_DomainManager_NotConnected,
  0);

::CORBA::TypeCode_ptr const CF::DomainManager::_tc_NotConnected =
  &_tao_tc_CF_DomainManager_NotConnected;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::DomainManager::domainManagerProfile (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_domainManagerProfile",
      25,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::DomainManager::DeviceManagerSequence *
CF::DomainManager::deviceManagers (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::DomainManager::DeviceManagerSequence>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_deviceManagers",
      19,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::DomainManager::ApplicationSequence *
CF::DomainManager::applications (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::DomainManager::ApplicationSequence>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_applications",
      17,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::DomainManager::ApplicationFactorySequence *
CF::DomainManager::applicationFactories (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::DomainManager::ApplicationFactorySequence>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_applicationFactories",
      25,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::FileManager_ptr
CF::DomainManager::fileMgr (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::FileManager>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_fileMgr",
      12,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::DomainManager::identifier (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_identifier",
      15,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DomainManager::registerDevice (
  ::CF::Device_ptr registeringDevice,
  ::CF::DeviceManager_ptr registeredDeviceMgr)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::Device>::in_arg_val _tao_registeringDevice (registeringDevice);
  TAO::Arg_Traits< ::CF::DeviceManager>::in_arg_val _tao_registeredDeviceMgr (registeredDeviceMgr);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_registeringDevice,
      &_tao_registeredDeviceMgr
    };

  static TAO::Exception_Data
  _tao_CF_DomainManager_registerDevice_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidObjectReference:1.0",
        CF::InvalidObjectReference::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidObjectReference
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/InvalidProfile:1.0",
        CF::InvalidProfile::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidProfile
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/DomainManager/DeviceManagerNotRegistered:1.0",
        CF::DomainManager::DeviceManagerNotRegistered::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_DeviceManagerNotRegistered
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/DomainManager/RegisterError:1.0",
        CF::DomainManager::RegisterError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_RegisterError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "registerDevice",
      14,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_DomainManager_registerDevice_exceptiondata,
      4
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DomainManager::registerDeviceManager (
  ::CF::DeviceManager_ptr deviceMgr)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::DeviceManager>::in_arg_val _tao_deviceMgr (deviceMgr);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_deviceMgr
    };

  static TAO::Exception_Data
  _tao_CF_DomainManager_registerDeviceManager_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidObjectReference:1.0",
        CF::InvalidObjectReference::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidObjectReference
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/InvalidProfile:1.0",
        CF::InvalidProfile::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidProfile
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/DomainManager/RegisterError:1.0",
        CF::DomainManager::RegisterError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_RegisterError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "registerDeviceManager",
      21,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_DomainManager_registerDeviceManager_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DomainManager::unregisterDeviceManager (
  ::CF::DeviceManager_ptr deviceMgr)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::DeviceManager>::in_arg_val _tao_deviceMgr (deviceMgr);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_deviceMgr
    };

  static TAO::Exception_Data
  _tao_CF_DomainManager_unregisterDeviceManager_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidObjectReference:1.0",
        CF::InvalidObjectReference::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidObjectReference
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/DomainManager/UnregisterError:1.0",
        CF::DomainManager::UnregisterError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_UnregisterError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "unregisterDeviceManager",
      23,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_DomainManager_unregisterDeviceManager_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DomainManager::unregisterDevice (
  ::CF::Device_ptr unregisteringDevice)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::Device>::in_arg_val _tao_unregisteringDevice (unregisteringDevice);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_unregisteringDevice
    };

  static TAO::Exception_Data
  _tao_CF_DomainManager_unregisterDevice_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidObjectReference:1.0",
        CF::InvalidObjectReference::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidObjectReference
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/DomainManager/UnregisterError:1.0",
        CF::DomainManager::UnregisterError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_UnregisterError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "unregisterDevice",
      16,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_DomainManager_unregisterDevice_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DomainManager::installApplication (
  const char * profileFileName)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_profileFileName (profileFileName);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_profileFileName
    };

  static TAO::Exception_Data
  _tao_CF_DomainManager_installApplication_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidProfile:1.0",
        CF::InvalidProfile::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidProfile
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/InvalidFileName:1.0",
        CF::InvalidFileName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidFileName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/DomainManager/ApplicationInstallationError:1.0",
        CF::DomainManager::ApplicationInstallationError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_ApplicationInstallationError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "installApplication",
      18,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_DomainManager_installApplication_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DomainManager::uninstallApplication (
  const char * applicationId)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_applicationId (applicationId);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_applicationId
    };

  static TAO::Exception_Data
  _tao_CF_DomainManager_uninstallApplication_exceptiondata [] = 
    {
      {
        "IDL:CF/DomainManager/InvalidIdentifier:1.0",
        CF::DomainManager::InvalidIdentifier::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_InvalidIdentifier
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/DomainManager/ApplicationUninstallationError:1.0",
        CF::DomainManager::ApplicationUninstallationError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_ApplicationUninstallationError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "uninstallApplication",
      20,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_DomainManager_uninstallApplication_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DomainManager::registerService (
  ::CORBA::Object_ptr registeringService,
  ::CF::DeviceManager_ptr registeredDeviceMgr,
  const char * name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_registeringService (registeringService);
  TAO::Arg_Traits< ::CF::DeviceManager>::in_arg_val _tao_registeredDeviceMgr (registeredDeviceMgr);
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_registeringService,
      &_tao_registeredDeviceMgr,
      &_tao_name
    };

  static TAO::Exception_Data
  _tao_CF_DomainManager_registerService_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidObjectReference:1.0",
        CF::InvalidObjectReference::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidObjectReference
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/InvalidProfile:1.0",
        CF::InvalidProfile::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidProfile
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/DomainManager/DeviceManagerNotRegistered:1.0",
        CF::DomainManager::DeviceManagerNotRegistered::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_DeviceManagerNotRegistered
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/DomainManager/RegisterError:1.0",
        CF::DomainManager::RegisterError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_RegisterError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "registerService",
      15,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_DomainManager_registerService_exceptiondata,
      4
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DomainManager::unregisterService (
  ::CORBA::Object_ptr unregisteringService,
  const char * name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_unregisteringService (unregisteringService);
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_unregisteringService,
      &_tao_name
    };

  static TAO::Exception_Data
  _tao_CF_DomainManager_unregisterService_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidObjectReference:1.0",
        CF::InvalidObjectReference::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidObjectReference
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/DomainManager/UnregisterError:1.0",
        CF::DomainManager::UnregisterError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_UnregisterError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "unregisterService",
      17,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_DomainManager_unregisterService_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DomainManager::registerWithEventChannel (
  ::CORBA::Object_ptr registeringObject,
  const char * registeringId,
  const char * eventChannelName)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_registeringObject (registeringObject);
  TAO::Arg_Traits< char *>::in_arg_val _tao_registeringId (registeringId);
  TAO::Arg_Traits< char *>::in_arg_val _tao_eventChannelName (eventChannelName);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_registeringObject,
      &_tao_registeringId,
      &_tao_eventChannelName
    };

  static TAO::Exception_Data
  _tao_CF_DomainManager_registerWithEventChannel_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidObjectReference:1.0",
        CF::InvalidObjectReference::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidObjectReference
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/DomainManager/InvalidEventChannelName:1.0",
        CF::DomainManager::InvalidEventChannelName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_InvalidEventChannelName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/DomainManager/AlreadyConnected:1.0",
        CF::DomainManager::AlreadyConnected::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_AlreadyConnected
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "registerWithEventChannel",
      24,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_DomainManager_registerWithEventChannel_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DomainManager::unregisterFromEventChannel (
  const char * unregisteringId,
  const char * eventChannelName)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DomainManager_Proxy_Broker_ == 0)
    {
      CF_DomainManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_unregisteringId (unregisteringId);
  TAO::Arg_Traits< char *>::in_arg_val _tao_eventChannelName (eventChannelName);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_unregisteringId,
      &_tao_eventChannelName
    };

  static TAO::Exception_Data
  _tao_CF_DomainManager_unregisterFromEventChannel_exceptiondata [] = 
    {
      {
        "IDL:CF/DomainManager/InvalidEventChannelName:1.0",
        CF::DomainManager::InvalidEventChannelName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_InvalidEventChannelName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/DomainManager/NotConnected:1.0",
        CF::DomainManager::NotConnected::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::DomainManager::_tc_NotConnected
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "unregisterFromEventChannel",
      26,
      this->the_TAO_DomainManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_DomainManager_unregisterFromEventChannel_exceptiondata,
      2
    );
}

CF::DomainManager::DomainManager (void)
 : the_TAO_DomainManager_Proxy_Broker_ (0)
{
  this->CF_DomainManager_setup_collocation ();
}

void
CF::DomainManager::CF_DomainManager_setup_collocation ()
{
  if (::CF__TAO_DomainManager_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_DomainManager_Proxy_Broker_ =
        ::CF__TAO_DomainManager_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CF_PropertySet_setup_collocation ();
}

CF::DomainManager::~DomainManager (void)
{}

void 
CF::DomainManager::_tao_any_destructor (void *_tao_void_pointer)
{
  DomainManager *_tao_tmp_pointer =
    static_cast<DomainManager *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::DomainManager_ptr
CF::DomainManager::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<DomainManager>::narrow (
        _tao_objref,
        "IDL:CF/DomainManager:1.0",
        CF__TAO_DomainManager_Proxy_Broker_Factory_function_pointer
      );
}

CF::DomainManager_ptr
CF::DomainManager::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<DomainManager>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/DomainManager:1.0",
        CF__TAO_DomainManager_Proxy_Broker_Factory_function_pointer
      );
}

CF::DomainManager_ptr
CF::DomainManager::_nil (void)
{
  return 0;
}

CF::DomainManager_ptr
CF::DomainManager::_duplicate (DomainManager_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::DomainManager::_tao_release (DomainManager_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::DomainManager::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/DomainManager:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::DomainManager::_interface_repository_id (void) const
{
  return "IDL:CF/DomainManager:1.0";
}

::CORBA::Boolean
CF::DomainManager::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_DomainManager (
    ::CORBA::tk_objref,
    "IDL:CF/DomainManager:1.0",
    "DomainManager");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_DomainManager =
    &_tao_tc_CF_DomainManager;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::ApplicationFactory.

CF::ApplicationFactory_ptr
TAO::Objref_Traits<CF::ApplicationFactory>::duplicate (
    CF::ApplicationFactory_ptr p)
{
  return CF::ApplicationFactory::_duplicate (p);
}

void
TAO::Objref_Traits<CF::ApplicationFactory>::release (
    CF::ApplicationFactory_ptr p)
{
  ::CORBA::release (p);
}

CF::ApplicationFactory_ptr
TAO::Objref_Traits<CF::ApplicationFactory>::nil (void)
{
  return CF::ApplicationFactory::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::ApplicationFactory>::marshal (
    const CF::ApplicationFactory_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_ApplicationFactory_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::ApplicationFactory::CreateApplicationRequestError::CreateApplicationRequestError (
    const CF::DeviceAssignmentSequence & _tao_invalidAssignments)
  : ::CORBA::UserException (
        "IDL:CF/ApplicationFactory/CreateApplicationRequestError:1.0",
        "CreateApplicationRequestError"
      )
{
  this->invalidAssignments = _tao_invalidAssignments;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::ApplicationFactory::CreateApplicationRequestError::CreateApplicationRequestError (void)
  : ::CORBA::UserException (
        "IDL:CF/ApplicationFactory/CreateApplicationRequestError:1.0",
        "CreateApplicationRequestError"
      )
{
}

CF::ApplicationFactory::CreateApplicationRequestError::~CreateApplicationRequestError (void)
{
}

CF::ApplicationFactory::CreateApplicationRequestError::CreateApplicationRequestError (const ::CF::ApplicationFactory::CreateApplicationRequestError &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->invalidAssignments = _tao_excp.invalidAssignments;
}

CF::ApplicationFactory::CreateApplicationRequestError&
CF::ApplicationFactory::CreateApplicationRequestError::operator= (const ::CF::ApplicationFactory::CreateApplicationRequestError &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->invalidAssignments = _tao_excp.invalidAssignments;
  return *this;
}

void CF::ApplicationFactory::CreateApplicationRequestError::_tao_any_destructor (void *_tao_void_pointer)
{
  CreateApplicationRequestError *_tao_tmp_pointer =
    static_cast<CreateApplicationRequestError *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::ApplicationFactory::CreateApplicationRequestError *
CF::ApplicationFactory::CreateApplicationRequestError::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<CreateApplicationRequestError *> (_tao_excp);
}

const CF::ApplicationFactory::CreateApplicationRequestError *
CF::ApplicationFactory::CreateApplicationRequestError::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const CreateApplicationRequestError *> (_tao_excp);
}

::CORBA::Exception *CF::ApplicationFactory::CreateApplicationRequestError::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::ApplicationFactory::CreateApplicationRequestError, 0);
  return retval;
}

::CORBA::Exception *
CF::ApplicationFactory::CreateApplicationRequestError::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::ApplicationFactory::CreateApplicationRequestError (*this),
      0
    );
  return result;
}

void CF::ApplicationFactory::CreateApplicationRequestError::_raise (void) const
{
  throw *this;
}

void CF::ApplicationFactory::CreateApplicationRequestError::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::ApplicationFactory::CreateApplicationRequestError::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::ApplicationFactory::CreateApplicationRequestError::_tao_type (void) const
{
  return ::CF::ApplicationFactory::_tc_CreateApplicationRequestError;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_ApplicationFactory_CreateApplicationRequestError[] =
      {
        { "invalidAssignments", &CF::_tc_DeviceAssignmentSequence }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_ApplicationFactory_CreateApplicationRequestError (
  ::CORBA::tk_except,
  "IDL:CF/ApplicationFactory/CreateApplicationRequestError:1.0",
  "CreateApplicationRequestError",
  _tao_fields_CF_ApplicationFactory_CreateApplicationRequestError,
  1);

::CORBA::TypeCode_ptr const CF::ApplicationFactory::_tc_CreateApplicationRequestError =
  &_tao_tc_CF_ApplicationFactory_CreateApplicationRequestError;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::ApplicationFactory::CreateApplicationError::CreateApplicationError (
    CF::ErrorNumberType _tao_errorNumber,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/ApplicationFactory/CreateApplicationError:1.0",
        "CreateApplicationError"
      )
{
  this->errorNumber = _tao_errorNumber;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::ApplicationFactory::CreateApplicationError::CreateApplicationError (void)
  : ::CORBA::UserException (
        "IDL:CF/ApplicationFactory/CreateApplicationError:1.0",
        "CreateApplicationError"
      )
{
}

CF::ApplicationFactory::CreateApplicationError::~CreateApplicationError (void)
{
}

CF::ApplicationFactory::CreateApplicationError::CreateApplicationError (const ::CF::ApplicationFactory::CreateApplicationError &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::ApplicationFactory::CreateApplicationError&
CF::ApplicationFactory::CreateApplicationError::operator= (const ::CF::ApplicationFactory::CreateApplicationError &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::ApplicationFactory::CreateApplicationError::_tao_any_destructor (void *_tao_void_pointer)
{
  CreateApplicationError *_tao_tmp_pointer =
    static_cast<CreateApplicationError *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::ApplicationFactory::CreateApplicationError *
CF::ApplicationFactory::CreateApplicationError::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<CreateApplicationError *> (_tao_excp);
}

const CF::ApplicationFactory::CreateApplicationError *
CF::ApplicationFactory::CreateApplicationError::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const CreateApplicationError *> (_tao_excp);
}

::CORBA::Exception *CF::ApplicationFactory::CreateApplicationError::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::ApplicationFactory::CreateApplicationError, 0);
  return retval;
}

::CORBA::Exception *
CF::ApplicationFactory::CreateApplicationError::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::ApplicationFactory::CreateApplicationError (*this),
      0
    );
  return result;
}

void CF::ApplicationFactory::CreateApplicationError::_raise (void) const
{
  throw *this;
}

void CF::ApplicationFactory::CreateApplicationError::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::ApplicationFactory::CreateApplicationError::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::ApplicationFactory::CreateApplicationError::_tao_type (void) const
{
  return ::CF::ApplicationFactory::_tc_CreateApplicationError;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_ApplicationFactory_CreateApplicationError[] =
      {
        { "errorNumber", &CF::_tc_ErrorNumberType },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_ApplicationFactory_CreateApplicationError (
  ::CORBA::tk_except,
  "IDL:CF/ApplicationFactory/CreateApplicationError:1.0",
  "CreateApplicationError",
  _tao_fields_CF_ApplicationFactory_CreateApplicationError,
  2);

::CORBA::TypeCode_ptr const CF::ApplicationFactory::_tc_CreateApplicationError =
  &_tao_tc_CF_ApplicationFactory_CreateApplicationError;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::ApplicationFactory::InvalidInitConfiguration::InvalidInitConfiguration (
    const CF::Properties & _tao_invalidProperties)
  : ::CORBA::UserException (
        "IDL:CF/ApplicationFactory/InvalidInitConfiguration:1.0",
        "InvalidInitConfiguration"
      )
{
  this->invalidProperties = _tao_invalidProperties;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::ApplicationFactory::InvalidInitConfiguration::InvalidInitConfiguration (void)
  : ::CORBA::UserException (
        "IDL:CF/ApplicationFactory/InvalidInitConfiguration:1.0",
        "InvalidInitConfiguration"
      )
{
}

CF::ApplicationFactory::InvalidInitConfiguration::~InvalidInitConfiguration (void)
{
}

CF::ApplicationFactory::InvalidInitConfiguration::InvalidInitConfiguration (const ::CF::ApplicationFactory::InvalidInitConfiguration &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->invalidProperties = _tao_excp.invalidProperties;
}

CF::ApplicationFactory::InvalidInitConfiguration&
CF::ApplicationFactory::InvalidInitConfiguration::operator= (const ::CF::ApplicationFactory::InvalidInitConfiguration &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->invalidProperties = _tao_excp.invalidProperties;
  return *this;
}

void CF::ApplicationFactory::InvalidInitConfiguration::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidInitConfiguration *_tao_tmp_pointer =
    static_cast<InvalidInitConfiguration *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::ApplicationFactory::InvalidInitConfiguration *
CF::ApplicationFactory::InvalidInitConfiguration::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidInitConfiguration *> (_tao_excp);
}

const CF::ApplicationFactory::InvalidInitConfiguration *
CF::ApplicationFactory::InvalidInitConfiguration::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidInitConfiguration *> (_tao_excp);
}

::CORBA::Exception *CF::ApplicationFactory::InvalidInitConfiguration::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::ApplicationFactory::InvalidInitConfiguration, 0);
  return retval;
}

::CORBA::Exception *
CF::ApplicationFactory::InvalidInitConfiguration::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::ApplicationFactory::InvalidInitConfiguration (*this),
      0
    );
  return result;
}

void CF::ApplicationFactory::InvalidInitConfiguration::_raise (void) const
{
  throw *this;
}

void CF::ApplicationFactory::InvalidInitConfiguration::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::ApplicationFactory::InvalidInitConfiguration::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::ApplicationFactory::InvalidInitConfiguration::_tao_type (void) const
{
  return ::CF::ApplicationFactory::_tc_InvalidInitConfiguration;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_ApplicationFactory_InvalidInitConfiguration[] =
      {
        { "invalidProperties", &CF::_tc_Properties }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_ApplicationFactory_InvalidInitConfiguration (
  ::CORBA::tk_except,
  "IDL:CF/ApplicationFactory/InvalidInitConfiguration:1.0",
  "InvalidInitConfiguration",
  _tao_fields_CF_ApplicationFactory_InvalidInitConfiguration,
  1);

::CORBA::TypeCode_ptr const CF::ApplicationFactory::_tc_InvalidInitConfiguration =
  &_tao_tc_CF_ApplicationFactory_InvalidInitConfiguration;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::ApplicationFactory::name (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ApplicationFactory_Proxy_Broker_ == 0)
    {
      CF_ApplicationFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_name",
      9,
      this->the_TAO_ApplicationFactory_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::ApplicationFactory::identifier (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ApplicationFactory_Proxy_Broker_ == 0)
    {
      CF_ApplicationFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_identifier",
      15,
      this->the_TAO_ApplicationFactory_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::ApplicationFactory::softwareProfile (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ApplicationFactory_Proxy_Broker_ == 0)
    {
      CF_ApplicationFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_softwareProfile",
      20,
      this->the_TAO_ApplicationFactory_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::Application_ptr
CF::ApplicationFactory::create (
  const char * name,
  const ::CF::Properties & initConfiguration,
  const ::CF::DeviceAssignmentSequence & deviceAssignments)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ApplicationFactory_Proxy_Broker_ == 0)
    {
      CF_ApplicationFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::Application>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);
  TAO::Arg_Traits< ::CF::Properties>::in_arg_val _tao_initConfiguration (initConfiguration);
  TAO::Arg_Traits< ::CF::DeviceAssignmentSequence>::in_arg_val _tao_deviceAssignments (deviceAssignments);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_name,
      &_tao_initConfiguration,
      &_tao_deviceAssignments
    };

  static TAO::Exception_Data
  _tao_CF_ApplicationFactory_create_exceptiondata [] = 
    {
      {
        "IDL:CF/ApplicationFactory/CreateApplicationError:1.0",
        CF::ApplicationFactory::CreateApplicationError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::ApplicationFactory::_tc_CreateApplicationError
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/ApplicationFactory/CreateApplicationRequestError:1.0",
        CF::ApplicationFactory::CreateApplicationRequestError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::ApplicationFactory::_tc_CreateApplicationRequestError
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/ApplicationFactory/InvalidInitConfiguration:1.0",
        CF::ApplicationFactory::InvalidInitConfiguration::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::ApplicationFactory::_tc_InvalidInitConfiguration
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "create",
      6,
      this->the_TAO_ApplicationFactory_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_ApplicationFactory_create_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

CF::ApplicationFactory::ApplicationFactory (void)
 : the_TAO_ApplicationFactory_Proxy_Broker_ (0)
{
  this->CF_ApplicationFactory_setup_collocation ();
}

void
CF::ApplicationFactory::CF_ApplicationFactory_setup_collocation ()
{
  if (::CF__TAO_ApplicationFactory_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_ApplicationFactory_Proxy_Broker_ =
        ::CF__TAO_ApplicationFactory_Proxy_Broker_Factory_function_pointer (this);
    }
}

CF::ApplicationFactory::~ApplicationFactory (void)
{}

void 
CF::ApplicationFactory::_tao_any_destructor (void *_tao_void_pointer)
{
  ApplicationFactory *_tao_tmp_pointer =
    static_cast<ApplicationFactory *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::ApplicationFactory_ptr
CF::ApplicationFactory::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ApplicationFactory>::narrow (
        _tao_objref,
        "IDL:CF/ApplicationFactory:1.0",
        CF__TAO_ApplicationFactory_Proxy_Broker_Factory_function_pointer
      );
}

CF::ApplicationFactory_ptr
CF::ApplicationFactory::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ApplicationFactory>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/ApplicationFactory:1.0",
        CF__TAO_ApplicationFactory_Proxy_Broker_Factory_function_pointer
      );
}

CF::ApplicationFactory_ptr
CF::ApplicationFactory::_nil (void)
{
  return 0;
}

CF::ApplicationFactory_ptr
CF::ApplicationFactory::_duplicate (ApplicationFactory_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::ApplicationFactory::_tao_release (ApplicationFactory_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::ApplicationFactory::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/ApplicationFactory:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::ApplicationFactory::_interface_repository_id (void) const
{
  return "IDL:CF/ApplicationFactory:1.0";
}

::CORBA::Boolean
CF::ApplicationFactory::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_ApplicationFactory (
    ::CORBA::tk_objref,
    "IDL:CF/ApplicationFactory:1.0",
    "ApplicationFactory");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_ApplicationFactory =
    &_tao_tc_CF_ApplicationFactory;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::PortSupplier.

CF::PortSupplier_ptr
TAO::Objref_Traits<CF::PortSupplier>::duplicate (
    CF::PortSupplier_ptr p)
{
  return CF::PortSupplier::_duplicate (p);
}

void
TAO::Objref_Traits<CF::PortSupplier>::release (
    CF::PortSupplier_ptr p)
{
  ::CORBA::release (p);
}

CF::PortSupplier_ptr
TAO::Objref_Traits<CF::PortSupplier>::nil (void)
{
  return CF::PortSupplier::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::PortSupplier>::marshal (
    const CF::PortSupplier_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_PortSupplier_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::PortSupplier::UnknownPort::UnknownPort (void)
  : ::CORBA::UserException (
        "IDL:CF/PortSupplier/UnknownPort:1.0",
        "UnknownPort"
      )
{
}

CF::PortSupplier::UnknownPort::~UnknownPort (void)
{
}

CF::PortSupplier::UnknownPort::UnknownPort (const ::CF::PortSupplier::UnknownPort &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::PortSupplier::UnknownPort&
CF::PortSupplier::UnknownPort::operator= (const ::CF::PortSupplier::UnknownPort &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::PortSupplier::UnknownPort::_tao_any_destructor (void *_tao_void_pointer)
{
  UnknownPort *_tao_tmp_pointer =
    static_cast<UnknownPort *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::PortSupplier::UnknownPort *
CF::PortSupplier::UnknownPort::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UnknownPort *> (_tao_excp);
}

const CF::PortSupplier::UnknownPort *
CF::PortSupplier::UnknownPort::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UnknownPort *> (_tao_excp);
}

::CORBA::Exception *CF::PortSupplier::UnknownPort::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::PortSupplier::UnknownPort, 0);
  return retval;
}

::CORBA::Exception *
CF::PortSupplier::UnknownPort::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::PortSupplier::UnknownPort (*this),
      0
    );
  return result;
}

void CF::PortSupplier::UnknownPort::_raise (void) const
{
  throw *this;
}

void CF::PortSupplier::UnknownPort::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::PortSupplier::UnknownPort::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::PortSupplier::UnknownPort::_tao_type (void) const
{
  return ::CF::PortSupplier::_tc_UnknownPort;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_PortSupplier_UnknownPort = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_PortSupplier_UnknownPort (
  ::CORBA::tk_except,
  "IDL:CF/PortSupplier/UnknownPort:1.0",
  "UnknownPort",
  _tao_fields_CF_PortSupplier_UnknownPort,
  0);

::CORBA::TypeCode_ptr const CF::PortSupplier::_tc_UnknownPort =
  &_tao_tc_CF_PortSupplier_UnknownPort;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Object_ptr
CF::PortSupplier::getPort (
  const char * name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PortSupplier_Proxy_Broker_ == 0)
    {
      CF_PortSupplier_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_name
    };

  static TAO::Exception_Data
  _tao_CF_PortSupplier_getPort_exceptiondata [] = 
    {
      {
        "IDL:CF/PortSupplier/UnknownPort:1.0",
        CF::PortSupplier::UnknownPort::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::PortSupplier::_tc_UnknownPort
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "getPort",
      7,
      this->the_TAO_PortSupplier_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_PortSupplier_getPort_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

CF::PortSupplier::PortSupplier (void)
 : the_TAO_PortSupplier_Proxy_Broker_ (0)
{
  this->CF_PortSupplier_setup_collocation ();
}

void
CF::PortSupplier::CF_PortSupplier_setup_collocation ()
{
  if (::CF__TAO_PortSupplier_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_PortSupplier_Proxy_Broker_ =
        ::CF__TAO_PortSupplier_Proxy_Broker_Factory_function_pointer (this);
    }
}

CF::PortSupplier::~PortSupplier (void)
{}

void 
CF::PortSupplier::_tao_any_destructor (void *_tao_void_pointer)
{
  PortSupplier *_tao_tmp_pointer =
    static_cast<PortSupplier *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::PortSupplier_ptr
CF::PortSupplier::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<PortSupplier>::narrow (
        _tao_objref,
        "IDL:CF/PortSupplier:1.0",
        CF__TAO_PortSupplier_Proxy_Broker_Factory_function_pointer
      );
}

CF::PortSupplier_ptr
CF::PortSupplier::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<PortSupplier>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/PortSupplier:1.0",
        CF__TAO_PortSupplier_Proxy_Broker_Factory_function_pointer
      );
}

CF::PortSupplier_ptr
CF::PortSupplier::_nil (void)
{
  return 0;
}

CF::PortSupplier_ptr
CF::PortSupplier::_duplicate (PortSupplier_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::PortSupplier::_tao_release (PortSupplier_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::PortSupplier::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/PortSupplier:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::PortSupplier::_interface_repository_id (void) const
{
  return "IDL:CF/PortSupplier:1.0";
}

::CORBA::Boolean
CF::PortSupplier::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_PortSupplier (
    ::CORBA::tk_objref,
    "IDL:CF/PortSupplier:1.0",
    "PortSupplier");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_PortSupplier =
    &_tao_tc_CF_PortSupplier;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::Resource.

CF::Resource_ptr
TAO::Objref_Traits<CF::Resource>::duplicate (
    CF::Resource_ptr p)
{
  return CF::Resource::_duplicate (p);
}

void
TAO::Objref_Traits<CF::Resource>::release (
    CF::Resource_ptr p)
{
  ::CORBA::release (p);
}

CF::Resource_ptr
TAO::Objref_Traits<CF::Resource>::nil (void)
{
  return CF::Resource::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::Resource>::marshal (
    const CF::Resource_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_Resource_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::Resource::StartError::StartError (
    CF::ErrorNumberType _tao_errorNumber,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/Resource/StartError:1.0",
        "StartError"
      )
{
  this->errorNumber = _tao_errorNumber;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::Resource::StartError::StartError (void)
  : ::CORBA::UserException (
        "IDL:CF/Resource/StartError:1.0",
        "StartError"
      )
{
}

CF::Resource::StartError::~StartError (void)
{
}

CF::Resource::StartError::StartError (const ::CF::Resource::StartError &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::Resource::StartError&
CF::Resource::StartError::operator= (const ::CF::Resource::StartError &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::Resource::StartError::_tao_any_destructor (void *_tao_void_pointer)
{
  StartError *_tao_tmp_pointer =
    static_cast<StartError *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::Resource::StartError *
CF::Resource::StartError::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<StartError *> (_tao_excp);
}

const CF::Resource::StartError *
CF::Resource::StartError::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const StartError *> (_tao_excp);
}

::CORBA::Exception *CF::Resource::StartError::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::Resource::StartError, 0);
  return retval;
}

::CORBA::Exception *
CF::Resource::StartError::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::Resource::StartError (*this),
      0
    );
  return result;
}

void CF::Resource::StartError::_raise (void) const
{
  throw *this;
}

void CF::Resource::StartError::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::Resource::StartError::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::Resource::StartError::_tao_type (void) const
{
  return ::CF::Resource::_tc_StartError;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_Resource_StartError[] =
      {
        { "errorNumber", &CF::_tc_ErrorNumberType },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_Resource_StartError (
  ::CORBA::tk_except,
  "IDL:CF/Resource/StartError:1.0",
  "StartError",
  _tao_fields_CF_Resource_StartError,
  2);

::CORBA::TypeCode_ptr const CF::Resource::_tc_StartError =
  &_tao_tc_CF_Resource_StartError;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::Resource::StopError::StopError (
    CF::ErrorNumberType _tao_errorNumber,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/Resource/StopError:1.0",
        "StopError"
      )
{
  this->errorNumber = _tao_errorNumber;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::Resource::StopError::StopError (void)
  : ::CORBA::UserException (
        "IDL:CF/Resource/StopError:1.0",
        "StopError"
      )
{
}

CF::Resource::StopError::~StopError (void)
{
}

CF::Resource::StopError::StopError (const ::CF::Resource::StopError &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::Resource::StopError&
CF::Resource::StopError::operator= (const ::CF::Resource::StopError &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::Resource::StopError::_tao_any_destructor (void *_tao_void_pointer)
{
  StopError *_tao_tmp_pointer =
    static_cast<StopError *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::Resource::StopError *
CF::Resource::StopError::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<StopError *> (_tao_excp);
}

const CF::Resource::StopError *
CF::Resource::StopError::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const StopError *> (_tao_excp);
}

::CORBA::Exception *CF::Resource::StopError::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::Resource::StopError, 0);
  return retval;
}

::CORBA::Exception *
CF::Resource::StopError::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::Resource::StopError (*this),
      0
    );
  return result;
}

void CF::Resource::StopError::_raise (void) const
{
  throw *this;
}

void CF::Resource::StopError::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::Resource::StopError::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::Resource::StopError::_tao_type (void) const
{
  return ::CF::Resource::_tc_StopError;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_Resource_StopError[] =
      {
        { "errorNumber", &CF::_tc_ErrorNumberType },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_Resource_StopError (
  ::CORBA::tk_except,
  "IDL:CF/Resource/StopError:1.0",
  "StopError",
  _tao_fields_CF_Resource_StopError,
  2);

::CORBA::TypeCode_ptr const CF::Resource::_tc_StopError =
  &_tao_tc_CF_Resource_StopError;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::Resource::identifier (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Resource_Proxy_Broker_ == 0)
    {
      CF_Resource_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_identifier",
      15,
      this->the_TAO_Resource_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::Resource::start (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Resource_Proxy_Broker_ == 0)
    {
      CF_Resource_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CF_Resource_start_exceptiondata [] = 
    {
      {
        "IDL:CF/Resource/StartError:1.0",
        CF::Resource::StartError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::Resource::_tc_StartError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "start",
      5,
      this->the_TAO_Resource_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_Resource_start_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::Resource::stop (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Resource_Proxy_Broker_ == 0)
    {
      CF_Resource_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CF_Resource_stop_exceptiondata [] = 
    {
      {
        "IDL:CF/Resource/StopError:1.0",
        CF::Resource::StopError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::Resource::_tc_StopError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "stop",
      4,
      this->the_TAO_Resource_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_Resource_stop_exceptiondata,
      1
    );
}

CF::Resource::Resource (void)
 : the_TAO_Resource_Proxy_Broker_ (0)
{
  this->CF_Resource_setup_collocation ();
}

void
CF::Resource::CF_Resource_setup_collocation ()
{
  if (::CF__TAO_Resource_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Resource_Proxy_Broker_ =
        ::CF__TAO_Resource_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CF_LifeCycle_setup_collocation ();
  this->CF_TestableObject_setup_collocation ();
  this->CF_PropertySet_setup_collocation ();
  this->CF_PortSupplier_setup_collocation ();
}

CF::Resource::~Resource (void)
{}

void 
CF::Resource::_tao_any_destructor (void *_tao_void_pointer)
{
  Resource *_tao_tmp_pointer =
    static_cast<Resource *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::Resource_ptr
CF::Resource::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Resource>::narrow (
        _tao_objref,
        "IDL:CF/Resource:1.0",
        CF__TAO_Resource_Proxy_Broker_Factory_function_pointer
      );
}

CF::Resource_ptr
CF::Resource::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Resource>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/Resource:1.0",
        CF__TAO_Resource_Proxy_Broker_Factory_function_pointer
      );
}

CF::Resource_ptr
CF::Resource::_nil (void)
{
  return 0;
}

CF::Resource_ptr
CF::Resource::_duplicate (Resource_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::Resource::_tao_release (Resource_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::Resource::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/LifeCycle:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/TestableObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/PortSupplier:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/Resource:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::Resource::_interface_repository_id (void) const
{
  return "IDL:CF/Resource:1.0";
}

::CORBA::Boolean
CF::Resource::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_Resource (
    ::CORBA::tk_objref,
    "IDL:CF/Resource:1.0",
    "Resource");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_Resource =
    &_tao_tc_CF_Resource;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::Device.

CF::Device_ptr
TAO::Objref_Traits<CF::Device>::duplicate (
    CF::Device_ptr p)
{
  return CF::Device::_duplicate (p);
}

void
TAO::Objref_Traits<CF::Device>::release (
    CF::Device_ptr p)
{
  ::CORBA::release (p);
}

CF::Device_ptr
TAO::Objref_Traits<CF::Device>::nil (void)
{
  return CF::Device::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::Device>::marshal (
    const CF::Device_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_Device_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::Device::InvalidState::InvalidState (
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/Device/InvalidState:1.0",
        "InvalidState"
      )
{
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::Device::InvalidState::InvalidState (void)
  : ::CORBA::UserException (
        "IDL:CF/Device/InvalidState:1.0",
        "InvalidState"
      )
{
}

CF::Device::InvalidState::~InvalidState (void)
{
}

CF::Device::InvalidState::InvalidState (const ::CF::Device::InvalidState &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::Device::InvalidState&
CF::Device::InvalidState::operator= (const ::CF::Device::InvalidState &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::Device::InvalidState::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidState *_tao_tmp_pointer =
    static_cast<InvalidState *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::Device::InvalidState *
CF::Device::InvalidState::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidState *> (_tao_excp);
}

const CF::Device::InvalidState *
CF::Device::InvalidState::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidState *> (_tao_excp);
}

::CORBA::Exception *CF::Device::InvalidState::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::Device::InvalidState, 0);
  return retval;
}

::CORBA::Exception *
CF::Device::InvalidState::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::Device::InvalidState (*this),
      0
    );
  return result;
}

void CF::Device::InvalidState::_raise (void) const
{
  throw *this;
}

void CF::Device::InvalidState::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::Device::InvalidState::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::Device::InvalidState::_tao_type (void) const
{
  return ::CF::Device::_tc_InvalidState;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_Device_InvalidState[] =
      {
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_Device_InvalidState (
  ::CORBA::tk_except,
  "IDL:CF/Device/InvalidState:1.0",
  "InvalidState",
  _tao_fields_CF_Device_InvalidState,
  1);

::CORBA::TypeCode_ptr const CF::Device::_tc_InvalidState =
  &_tao_tc_CF_Device_InvalidState;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::Device::InvalidCapacity::InvalidCapacity (
    const char * _tao_msg,
    const CF::Properties & _tao_capacities)
  : ::CORBA::UserException (
        "IDL:CF/Device/InvalidCapacity:1.0",
        "InvalidCapacity"
      )
{
  this->msg = ::CORBA::string_dup (_tao_msg);
  this->capacities = _tao_capacities;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::Device::InvalidCapacity::InvalidCapacity (void)
  : ::CORBA::UserException (
        "IDL:CF/Device/InvalidCapacity:1.0",
        "InvalidCapacity"
      )
{
}

CF::Device::InvalidCapacity::~InvalidCapacity (void)
{
}

CF::Device::InvalidCapacity::InvalidCapacity (const ::CF::Device::InvalidCapacity &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  this->capacities = _tao_excp.capacities;
}

CF::Device::InvalidCapacity&
CF::Device::InvalidCapacity::operator= (const ::CF::Device::InvalidCapacity &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  this->capacities = _tao_excp.capacities;
  return *this;
}

void CF::Device::InvalidCapacity::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidCapacity *_tao_tmp_pointer =
    static_cast<InvalidCapacity *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::Device::InvalidCapacity *
CF::Device::InvalidCapacity::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidCapacity *> (_tao_excp);
}

const CF::Device::InvalidCapacity *
CF::Device::InvalidCapacity::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidCapacity *> (_tao_excp);
}

::CORBA::Exception *CF::Device::InvalidCapacity::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::Device::InvalidCapacity, 0);
  return retval;
}

::CORBA::Exception *
CF::Device::InvalidCapacity::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::Device::InvalidCapacity (*this),
      0
    );
  return result;
}

void CF::Device::InvalidCapacity::_raise (void) const
{
  throw *this;
}

void CF::Device::InvalidCapacity::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::Device::InvalidCapacity::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::Device::InvalidCapacity::_tao_type (void) const
{
  return ::CF::Device::_tc_InvalidCapacity;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_Device_InvalidCapacity[] =
      {
        { "msg", &CORBA::_tc_string },
        { "capacities", &CF::_tc_Properties }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_Device_InvalidCapacity (
  ::CORBA::tk_except,
  "IDL:CF/Device/InvalidCapacity:1.0",
  "InvalidCapacity",
  _tao_fields_CF_Device_InvalidCapacity,
  2);

::CORBA::TypeCode_ptr const CF::Device::_tc_InvalidCapacity =
  &_tao_tc_CF_Device_InvalidCapacity;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_CF_Device_AdminType[] =
  {
    "LOCKED",
    "SHUTTING_DOWN",
    "UNLOCKED"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_CF_Device_AdminType (
    "IDL:CF/Device/AdminType:1.0",
    "AdminType",
    _tao_enumerators_CF_Device_AdminType,
    3);
  
::CORBA::TypeCode_ptr const CF::Device::_tc_AdminType =
  &_tao_tc_CF_Device_AdminType;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_CF_Device_OperationalType[] =
  {
    "ENABLED",
    "DISABLED"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_CF_Device_OperationalType (
    "IDL:CF/Device/OperationalType:1.0",
    "OperationalType",
    _tao_enumerators_CF_Device_OperationalType,
    2);
  
::CORBA::TypeCode_ptr const CF::Device::_tc_OperationalType =
  &_tao_tc_CF_Device_OperationalType;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_CF_Device_UsageType[] =
  {
    "IDLE",
    "ACTIVE",
    "BUSY"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_CF_Device_UsageType (
    "IDL:CF/Device/UsageType:1.0",
    "UsageType",
    _tao_enumerators_CF_Device_UsageType,
    3);
  
::CORBA::TypeCode_ptr const CF::Device::_tc_UsageType =
  &_tao_tc_CF_Device_UsageType;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::Device::UsageType
CF::Device::usageState (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Device_Proxy_Broker_ == 0)
    {
      CF_Device_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::Device::UsageType>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_usageState",
      15,
      this->the_TAO_Device_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::Device::AdminType
CF::Device::adminState (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Device_Proxy_Broker_ == 0)
    {
      CF_Device_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::Device::AdminType>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_adminState",
      15,
      this->the_TAO_Device_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::Device::adminState (
  ::CF::Device::AdminType adminState)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Device_Proxy_Broker_ == 0)
    {
      CF_Device_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::Device::AdminType>::in_arg_val _tao_adminState (adminState);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_adminState
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_adminState",
      15,
      this->the_TAO_Device_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::Device::OperationalType
CF::Device::operationalState (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Device_Proxy_Broker_ == 0)
    {
      CF_Device_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::Device::OperationalType>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_operationalState",
      21,
      this->the_TAO_Device_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::Device::softwareProfile (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Device_Proxy_Broker_ == 0)
    {
      CF_Device_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_softwareProfile",
      20,
      this->the_TAO_Device_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::Device::label (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Device_Proxy_Broker_ == 0)
    {
      CF_Device_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_label",
      10,
      this->the_TAO_Device_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::AggregateDevice_ptr
CF::Device::compositeDevice (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Device_Proxy_Broker_ == 0)
    {
      CF_Device_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::AggregateDevice>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_compositeDevice",
      20,
      this->the_TAO_Device_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CF::Device::allocateCapacity (
  const ::CF::Properties & capacities)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Device_Proxy_Broker_ == 0)
    {
      CF_Device_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::Properties>::in_arg_val _tao_capacities (capacities);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_capacities
    };

  static TAO::Exception_Data
  _tao_CF_Device_allocateCapacity_exceptiondata [] = 
    {
      {
        "IDL:CF/Device/InvalidCapacity:1.0",
        CF::Device::InvalidCapacity::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::Device::_tc_InvalidCapacity
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/Device/InvalidState:1.0",
        CF::Device::InvalidState::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::Device::_tc_InvalidState
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "allocateCapacity",
      16,
      this->the_TAO_Device_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_Device_allocateCapacity_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::Device::deallocateCapacity (
  const ::CF::Properties & capacities)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Device_Proxy_Broker_ == 0)
    {
      CF_Device_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::Properties>::in_arg_val _tao_capacities (capacities);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_capacities
    };

  static TAO::Exception_Data
  _tao_CF_Device_deallocateCapacity_exceptiondata [] = 
    {
      {
        "IDL:CF/Device/InvalidCapacity:1.0",
        CF::Device::InvalidCapacity::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::Device::_tc_InvalidCapacity
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/Device/InvalidState:1.0",
        CF::Device::InvalidState::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::Device::_tc_InvalidState
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "deallocateCapacity",
      18,
      this->the_TAO_Device_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_Device_deallocateCapacity_exceptiondata,
      2
    );
}

CF::Device::Device (void)
 : the_TAO_Device_Proxy_Broker_ (0)
{
  this->CF_Device_setup_collocation ();
}

void
CF::Device::CF_Device_setup_collocation ()
{
  if (::CF__TAO_Device_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Device_Proxy_Broker_ =
        ::CF__TAO_Device_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CF_Resource_setup_collocation ();
}

CF::Device::~Device (void)
{}

void 
CF::Device::_tao_any_destructor (void *_tao_void_pointer)
{
  Device *_tao_tmp_pointer =
    static_cast<Device *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::Device_ptr
CF::Device::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Device>::narrow (
        _tao_objref,
        "IDL:CF/Device:1.0",
        CF__TAO_Device_Proxy_Broker_Factory_function_pointer
      );
}

CF::Device_ptr
CF::Device::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Device>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/Device:1.0",
        CF__TAO_Device_Proxy_Broker_Factory_function_pointer
      );
}

CF::Device_ptr
CF::Device::_nil (void)
{
  return 0;
}

CF::Device_ptr
CF::Device::_duplicate (Device_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::Device::_tao_release (Device_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::Device::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/LifeCycle:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/TestableObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/PortSupplier:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/Resource:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/Device:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::Device::_interface_repository_id (void) const
{
  return "IDL:CF/Device:1.0";
}

::CORBA::Boolean
CF::Device::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_Device (
    ::CORBA::tk_objref,
    "IDL:CF/Device:1.0",
    "Device");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_Device =
    &_tao_tc_CF_Device;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::Application.

CF::Application_ptr
TAO::Objref_Traits<CF::Application>::duplicate (
    CF::Application_ptr p)
{
  return CF::Application::_duplicate (p);
}

void
TAO::Objref_Traits<CF::Application>::release (
    CF::Application_ptr p)
{
  ::CORBA::release (p);
}

CF::Application_ptr
TAO::Objref_Traits<CF::Application>::nil (void)
{
  return CF::Application::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::Application>::marshal (
    const CF::Application_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_Application_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_Application_ComponentProcessIdType[] =
      {
        { "componentId", &CORBA::_tc_string },
        { "processId", &CORBA::_tc_ulong }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_Application_ComponentProcessIdType (
  ::CORBA::tk_struct,
  "IDL:CF/Application/ComponentProcessIdType:1.0",
  "ComponentProcessIdType",
  _tao_fields_CF_Application_ComponentProcessIdType,
  2);

::CORBA::TypeCode_ptr const CF::Application::_tc_ComponentProcessIdType =
  &_tao_tc_CF_Application_ComponentProcessIdType;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CF::Application::ComponentProcessIdType::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ComponentProcessIdType *_tao_tmp_pointer =
    static_cast<ComponentProcessIdType *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CF_APPLICATION_COMPONENTPROCESSIDSEQUENCE_CS_)
#define _CF_APPLICATION_COMPONENTPROCESSIDSEQUENCE_CS_

CF::Application::ComponentProcessIdSequence::ComponentProcessIdSequence (void)
{}

CF::Application::ComponentProcessIdSequence::ComponentProcessIdSequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ComponentProcessIdType
      > (max)
{}

CF::Application::ComponentProcessIdSequence::ComponentProcessIdSequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CF::Application::ComponentProcessIdType * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ComponentProcessIdType
      >
    (max, length, buffer, release)
{}

CF::Application::ComponentProcessIdSequence::ComponentProcessIdSequence (
    const ComponentProcessIdSequence &seq)
  : ::TAO::unbounded_value_sequence<
        ComponentProcessIdType
      > (seq)
{}

CF::Application::ComponentProcessIdSequence::~ComponentProcessIdSequence (void)
{}

void CF::Application::ComponentProcessIdSequence::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ComponentProcessIdSequence * _tao_tmp_pointer =
    static_cast<ComponentProcessIdSequence *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CF_Application_ComponentProcessIdSequence_GUARD
#define _TAO_TYPECODE_CF_Application_ComponentProcessIdSequence_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CF_Application_ComponentProcessIdSequence_0 (
          ::CORBA::tk_sequence,
          &CF::Application::_tc_ComponentProcessIdType,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CF_Application_ComponentProcessIdSequence_0 =
        &CF_Application_ComponentProcessIdSequence_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CF_Application_ComponentProcessIdSequence_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CF_Application_ComponentProcessIdSequence (
    ::CORBA::tk_alias,
    "IDL:CF/Application/ComponentProcessIdSequence:1.0",
    "ComponentProcessIdSequence",
    &TAO::TypeCode::tc_CF_Application_ComponentProcessIdSequence_0);
  
::CORBA::TypeCode_ptr const CF::Application::_tc_ComponentProcessIdSequence =
  &_tao_tc_CF_Application_ComponentProcessIdSequence;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_Application_ComponentElementType[] =
      {
        { "componentId", &CORBA::_tc_string },
        { "elementId", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_Application_ComponentElementType (
  ::CORBA::tk_struct,
  "IDL:CF/Application/ComponentElementType:1.0",
  "ComponentElementType",
  _tao_fields_CF_Application_ComponentElementType,
  2);

::CORBA::TypeCode_ptr const CF::Application::_tc_ComponentElementType =
  &_tao_tc_CF_Application_ComponentElementType;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CF::Application::ComponentElementType::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ComponentElementType *_tao_tmp_pointer =
    static_cast<ComponentElementType *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CF_APPLICATION_COMPONENTELEMENTSEQUENCE_CS_)
#define _CF_APPLICATION_COMPONENTELEMENTSEQUENCE_CS_

CF::Application::ComponentElementSequence::ComponentElementSequence (void)
{}

CF::Application::ComponentElementSequence::ComponentElementSequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ComponentElementType
      > (max)
{}

CF::Application::ComponentElementSequence::ComponentElementSequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CF::Application::ComponentElementType * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ComponentElementType
      >
    (max, length, buffer, release)
{}

CF::Application::ComponentElementSequence::ComponentElementSequence (
    const ComponentElementSequence &seq)
  : ::TAO::unbounded_value_sequence<
        ComponentElementType
      > (seq)
{}

CF::Application::ComponentElementSequence::~ComponentElementSequence (void)
{}

void CF::Application::ComponentElementSequence::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ComponentElementSequence * _tao_tmp_pointer =
    static_cast<ComponentElementSequence *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CF_Application_ComponentElementSequence_GUARD
#define _TAO_TYPECODE_CF_Application_ComponentElementSequence_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CF_Application_ComponentElementSequence_0 (
          ::CORBA::tk_sequence,
          &CF::Application::_tc_ComponentElementType,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CF_Application_ComponentElementSequence_0 =
        &CF_Application_ComponentElementSequence_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CF_Application_ComponentElementSequence_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CF_Application_ComponentElementSequence (
    ::CORBA::tk_alias,
    "IDL:CF/Application/ComponentElementSequence:1.0",
    "ComponentElementSequence",
    &TAO::TypeCode::tc_CF_Application_ComponentElementSequence_0);
  
::CORBA::TypeCode_ptr const CF::Application::_tc_ComponentElementSequence =
  &_tao_tc_CF_Application_ComponentElementSequence;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::Application::ComponentElementSequence *
CF::Application::componentNamingContexts (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Application_Proxy_Broker_ == 0)
    {
      CF_Application_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::Application::ComponentElementSequence>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_componentNamingContexts",
      28,
      this->the_TAO_Application_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::Application::ComponentProcessIdSequence *
CF::Application::componentProcessIds (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Application_Proxy_Broker_ == 0)
    {
      CF_Application_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::Application::ComponentProcessIdSequence>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_componentProcessIds",
      24,
      this->the_TAO_Application_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::DeviceAssignmentSequence *
CF::Application::componentDevices (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Application_Proxy_Broker_ == 0)
    {
      CF_Application_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::DeviceAssignmentSequence>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_componentDevices",
      21,
      this->the_TAO_Application_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::Application::ComponentElementSequence *
CF::Application::componentImplementations (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Application_Proxy_Broker_ == 0)
    {
      CF_Application_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::Application::ComponentElementSequence>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_componentImplementations",
      29,
      this->the_TAO_Application_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::Application::profile (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Application_Proxy_Broker_ == 0)
    {
      CF_Application_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_profile",
      12,
      this->the_TAO_Application_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::Application::name (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Application_Proxy_Broker_ == 0)
    {
      CF_Application_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_name",
      9,
      this->the_TAO_Application_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

CF::Application::Application (void)
 : the_TAO_Application_Proxy_Broker_ (0)
{
  this->CF_Application_setup_collocation ();
}

void
CF::Application::CF_Application_setup_collocation ()
{
  if (::CF__TAO_Application_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Application_Proxy_Broker_ =
        ::CF__TAO_Application_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CF_Resource_setup_collocation ();
}

CF::Application::~Application (void)
{}

void 
CF::Application::_tao_any_destructor (void *_tao_void_pointer)
{
  Application *_tao_tmp_pointer =
    static_cast<Application *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::Application_ptr
CF::Application::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Application>::narrow (
        _tao_objref,
        "IDL:CF/Application:1.0",
        CF__TAO_Application_Proxy_Broker_Factory_function_pointer
      );
}

CF::Application_ptr
CF::Application::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Application>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/Application:1.0",
        CF__TAO_Application_Proxy_Broker_Factory_function_pointer
      );
}

CF::Application_ptr
CF::Application::_nil (void)
{
  return 0;
}

CF::Application_ptr
CF::Application::_duplicate (Application_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::Application::_tao_release (Application_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::Application::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/LifeCycle:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/TestableObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/PortSupplier:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/Resource:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/Application:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::Application::_interface_repository_id (void) const
{
  return "IDL:CF/Application:1.0";
}

::CORBA::Boolean
CF::Application::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_Application (
    ::CORBA::tk_objref,
    "IDL:CF/Application:1.0",
    "Application");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_Application =
    &_tao_tc_CF_Application;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::LoadableDevice.

CF::LoadableDevice_ptr
TAO::Objref_Traits<CF::LoadableDevice>::duplicate (
    CF::LoadableDevice_ptr p)
{
  return CF::LoadableDevice::_duplicate (p);
}

void
TAO::Objref_Traits<CF::LoadableDevice>::release (
    CF::LoadableDevice_ptr p)
{
  ::CORBA::release (p);
}

CF::LoadableDevice_ptr
TAO::Objref_Traits<CF::LoadableDevice>::nil (void)
{
  return CF::LoadableDevice::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::LoadableDevice>::marshal (
    const CF::LoadableDevice_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_LoadableDevice_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_CF_LoadableDevice_LoadType[] =
  {
    "KERNEL_MODULE",
    "DRIVER",
    "SHARED_LIBRARY",
    "EXECUTABLE"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_CF_LoadableDevice_LoadType (
    "IDL:CF/LoadableDevice/LoadType:1.0",
    "LoadType",
    _tao_enumerators_CF_LoadableDevice_LoadType,
    4);
  
::CORBA::TypeCode_ptr const CF::LoadableDevice::_tc_LoadType =
  &_tao_tc_CF_LoadableDevice_LoadType;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::LoadableDevice::InvalidLoadKind::InvalidLoadKind (void)
  : ::CORBA::UserException (
        "IDL:CF/LoadableDevice/InvalidLoadKind:1.0",
        "InvalidLoadKind"
      )
{
}

CF::LoadableDevice::InvalidLoadKind::~InvalidLoadKind (void)
{
}

CF::LoadableDevice::InvalidLoadKind::InvalidLoadKind (const ::CF::LoadableDevice::InvalidLoadKind &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::LoadableDevice::InvalidLoadKind&
CF::LoadableDevice::InvalidLoadKind::operator= (const ::CF::LoadableDevice::InvalidLoadKind &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::LoadableDevice::InvalidLoadKind::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidLoadKind *_tao_tmp_pointer =
    static_cast<InvalidLoadKind *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::LoadableDevice::InvalidLoadKind *
CF::LoadableDevice::InvalidLoadKind::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidLoadKind *> (_tao_excp);
}

const CF::LoadableDevice::InvalidLoadKind *
CF::LoadableDevice::InvalidLoadKind::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidLoadKind *> (_tao_excp);
}

::CORBA::Exception *CF::LoadableDevice::InvalidLoadKind::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::LoadableDevice::InvalidLoadKind, 0);
  return retval;
}

::CORBA::Exception *
CF::LoadableDevice::InvalidLoadKind::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::LoadableDevice::InvalidLoadKind (*this),
      0
    );
  return result;
}

void CF::LoadableDevice::InvalidLoadKind::_raise (void) const
{
  throw *this;
}

void CF::LoadableDevice::InvalidLoadKind::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::LoadableDevice::InvalidLoadKind::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::LoadableDevice::InvalidLoadKind::_tao_type (void) const
{
  return ::CF::LoadableDevice::_tc_InvalidLoadKind;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_LoadableDevice_InvalidLoadKind = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_LoadableDevice_InvalidLoadKind (
  ::CORBA::tk_except,
  "IDL:CF/LoadableDevice/InvalidLoadKind:1.0",
  "InvalidLoadKind",
  _tao_fields_CF_LoadableDevice_InvalidLoadKind,
  0);

::CORBA::TypeCode_ptr const CF::LoadableDevice::_tc_InvalidLoadKind =
  &_tao_tc_CF_LoadableDevice_InvalidLoadKind;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::LoadableDevice::LoadFail::LoadFail (
    CF::ErrorNumberType _tao_errorNumber,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/LoadableDevice/LoadFail:1.0",
        "LoadFail"
      )
{
  this->errorNumber = _tao_errorNumber;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::LoadableDevice::LoadFail::LoadFail (void)
  : ::CORBA::UserException (
        "IDL:CF/LoadableDevice/LoadFail:1.0",
        "LoadFail"
      )
{
}

CF::LoadableDevice::LoadFail::~LoadFail (void)
{
}

CF::LoadableDevice::LoadFail::LoadFail (const ::CF::LoadableDevice::LoadFail &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::LoadableDevice::LoadFail&
CF::LoadableDevice::LoadFail::operator= (const ::CF::LoadableDevice::LoadFail &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::LoadableDevice::LoadFail::_tao_any_destructor (void *_tao_void_pointer)
{
  LoadFail *_tao_tmp_pointer =
    static_cast<LoadFail *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::LoadableDevice::LoadFail *
CF::LoadableDevice::LoadFail::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<LoadFail *> (_tao_excp);
}

const CF::LoadableDevice::LoadFail *
CF::LoadableDevice::LoadFail::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const LoadFail *> (_tao_excp);
}

::CORBA::Exception *CF::LoadableDevice::LoadFail::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::LoadableDevice::LoadFail, 0);
  return retval;
}

::CORBA::Exception *
CF::LoadableDevice::LoadFail::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::LoadableDevice::LoadFail (*this),
      0
    );
  return result;
}

void CF::LoadableDevice::LoadFail::_raise (void) const
{
  throw *this;
}

void CF::LoadableDevice::LoadFail::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::LoadableDevice::LoadFail::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::LoadableDevice::LoadFail::_tao_type (void) const
{
  return ::CF::LoadableDevice::_tc_LoadFail;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_LoadableDevice_LoadFail[] =
      {
        { "errorNumber", &CF::_tc_ErrorNumberType },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_LoadableDevice_LoadFail (
  ::CORBA::tk_except,
  "IDL:CF/LoadableDevice/LoadFail:1.0",
  "LoadFail",
  _tao_fields_CF_LoadableDevice_LoadFail,
  2);

::CORBA::TypeCode_ptr const CF::LoadableDevice::_tc_LoadFail =
  &_tao_tc_CF_LoadableDevice_LoadFail;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::LoadableDevice::load (
  ::CF::FileSystem_ptr fs,
  const char * fileName,
  ::CF::LoadableDevice::LoadType loadKind)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadableDevice_Proxy_Broker_ == 0)
    {
      CF_LoadableDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::FileSystem>::in_arg_val _tao_fs (fs);
  TAO::Arg_Traits< char *>::in_arg_val _tao_fileName (fileName);
  TAO::Arg_Traits< ::CF::LoadableDevice::LoadType>::in_arg_val _tao_loadKind (loadKind);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_fs,
      &_tao_fileName,
      &_tao_loadKind
    };

  static TAO::Exception_Data
  _tao_CF_LoadableDevice_load_exceptiondata [] = 
    {
      {
        "IDL:CF/Device/InvalidState:1.0",
        CF::Device::InvalidState::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::Device::_tc_InvalidState
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/LoadableDevice/InvalidLoadKind:1.0",
        CF::LoadableDevice::InvalidLoadKind::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::LoadableDevice::_tc_InvalidLoadKind
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/InvalidFileName:1.0",
        CF::InvalidFileName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidFileName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/LoadableDevice/LoadFail:1.0",
        CF::LoadableDevice::LoadFail::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::LoadableDevice::_tc_LoadFail
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "load",
      4,
      this->the_TAO_LoadableDevice_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_LoadableDevice_load_exceptiondata,
      4
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::LoadableDevice::unload (
  const char * fileName)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadableDevice_Proxy_Broker_ == 0)
    {
      CF_LoadableDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_fileName (fileName);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_fileName
    };

  static TAO::Exception_Data
  _tao_CF_LoadableDevice_unload_exceptiondata [] = 
    {
      {
        "IDL:CF/Device/InvalidState:1.0",
        CF::Device::InvalidState::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::Device::_tc_InvalidState
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/InvalidFileName:1.0",
        CF::InvalidFileName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidFileName
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "unload",
      6,
      this->the_TAO_LoadableDevice_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_LoadableDevice_unload_exceptiondata,
      2
    );
}

CF::LoadableDevice::LoadableDevice (void)
 : the_TAO_LoadableDevice_Proxy_Broker_ (0)
{
  this->CF_LoadableDevice_setup_collocation ();
}

void
CF::LoadableDevice::CF_LoadableDevice_setup_collocation ()
{
  if (::CF__TAO_LoadableDevice_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_LoadableDevice_Proxy_Broker_ =
        ::CF__TAO_LoadableDevice_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CF_Device_setup_collocation ();
}

CF::LoadableDevice::~LoadableDevice (void)
{}

void 
CF::LoadableDevice::_tao_any_destructor (void *_tao_void_pointer)
{
  LoadableDevice *_tao_tmp_pointer =
    static_cast<LoadableDevice *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::LoadableDevice_ptr
CF::LoadableDevice::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<LoadableDevice>::narrow (
        _tao_objref,
        "IDL:CF/LoadableDevice:1.0",
        CF__TAO_LoadableDevice_Proxy_Broker_Factory_function_pointer
      );
}

CF::LoadableDevice_ptr
CF::LoadableDevice::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<LoadableDevice>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/LoadableDevice:1.0",
        CF__TAO_LoadableDevice_Proxy_Broker_Factory_function_pointer
      );
}

CF::LoadableDevice_ptr
CF::LoadableDevice::_nil (void)
{
  return 0;
}

CF::LoadableDevice_ptr
CF::LoadableDevice::_duplicate (LoadableDevice_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::LoadableDevice::_tao_release (LoadableDevice_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::LoadableDevice::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/LifeCycle:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/TestableObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/PortSupplier:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/Resource:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/Device:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/LoadableDevice:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::LoadableDevice::_interface_repository_id (void) const
{
  return "IDL:CF/LoadableDevice:1.0";
}

::CORBA::Boolean
CF::LoadableDevice::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_LoadableDevice (
    ::CORBA::tk_objref,
    "IDL:CF/LoadableDevice:1.0",
    "LoadableDevice");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_LoadableDevice =
    &_tao_tc_CF_LoadableDevice;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::ExecutableDevice.

CF::ExecutableDevice_ptr
TAO::Objref_Traits<CF::ExecutableDevice>::duplicate (
    CF::ExecutableDevice_ptr p)
{
  return CF::ExecutableDevice::_duplicate (p);
}

void
TAO::Objref_Traits<CF::ExecutableDevice>::release (
    CF::ExecutableDevice_ptr p)
{
  ::CORBA::release (p);
}

CF::ExecutableDevice_ptr
TAO::Objref_Traits<CF::ExecutableDevice>::nil (void)
{
  return CF::ExecutableDevice::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::ExecutableDevice>::marshal (
    const CF::ExecutableDevice_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_ExecutableDevice_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::ExecutableDevice::InvalidProcess::InvalidProcess (
    CF::ErrorNumberType _tao_errorNumber,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/ExecutableDevice/InvalidProcess:1.0",
        "InvalidProcess"
      )
{
  this->errorNumber = _tao_errorNumber;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::ExecutableDevice::InvalidProcess::InvalidProcess (void)
  : ::CORBA::UserException (
        "IDL:CF/ExecutableDevice/InvalidProcess:1.0",
        "InvalidProcess"
      )
{
}

CF::ExecutableDevice::InvalidProcess::~InvalidProcess (void)
{
}

CF::ExecutableDevice::InvalidProcess::InvalidProcess (const ::CF::ExecutableDevice::InvalidProcess &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::ExecutableDevice::InvalidProcess&
CF::ExecutableDevice::InvalidProcess::operator= (const ::CF::ExecutableDevice::InvalidProcess &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::ExecutableDevice::InvalidProcess::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidProcess *_tao_tmp_pointer =
    static_cast<InvalidProcess *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::ExecutableDevice::InvalidProcess *
CF::ExecutableDevice::InvalidProcess::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidProcess *> (_tao_excp);
}

const CF::ExecutableDevice::InvalidProcess *
CF::ExecutableDevice::InvalidProcess::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidProcess *> (_tao_excp);
}

::CORBA::Exception *CF::ExecutableDevice::InvalidProcess::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::ExecutableDevice::InvalidProcess, 0);
  return retval;
}

::CORBA::Exception *
CF::ExecutableDevice::InvalidProcess::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::ExecutableDevice::InvalidProcess (*this),
      0
    );
  return result;
}

void CF::ExecutableDevice::InvalidProcess::_raise (void) const
{
  throw *this;
}

void CF::ExecutableDevice::InvalidProcess::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::ExecutableDevice::InvalidProcess::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::ExecutableDevice::InvalidProcess::_tao_type (void) const
{
  return ::CF::ExecutableDevice::_tc_InvalidProcess;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_ExecutableDevice_InvalidProcess[] =
      {
        { "errorNumber", &CF::_tc_ErrorNumberType },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_ExecutableDevice_InvalidProcess (
  ::CORBA::tk_except,
  "IDL:CF/ExecutableDevice/InvalidProcess:1.0",
  "InvalidProcess",
  _tao_fields_CF_ExecutableDevice_InvalidProcess,
  2);

::CORBA::TypeCode_ptr const CF::ExecutableDevice::_tc_InvalidProcess =
  &_tao_tc_CF_ExecutableDevice_InvalidProcess;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::ExecutableDevice::InvalidFunction::InvalidFunction (void)
  : ::CORBA::UserException (
        "IDL:CF/ExecutableDevice/InvalidFunction:1.0",
        "InvalidFunction"
      )
{
}

CF::ExecutableDevice::InvalidFunction::~InvalidFunction (void)
{
}

CF::ExecutableDevice::InvalidFunction::InvalidFunction (const ::CF::ExecutableDevice::InvalidFunction &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CF::ExecutableDevice::InvalidFunction&
CF::ExecutableDevice::InvalidFunction::operator= (const ::CF::ExecutableDevice::InvalidFunction &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CF::ExecutableDevice::InvalidFunction::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidFunction *_tao_tmp_pointer =
    static_cast<InvalidFunction *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::ExecutableDevice::InvalidFunction *
CF::ExecutableDevice::InvalidFunction::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidFunction *> (_tao_excp);
}

const CF::ExecutableDevice::InvalidFunction *
CF::ExecutableDevice::InvalidFunction::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidFunction *> (_tao_excp);
}

::CORBA::Exception *CF::ExecutableDevice::InvalidFunction::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::ExecutableDevice::InvalidFunction, 0);
  return retval;
}

::CORBA::Exception *
CF::ExecutableDevice::InvalidFunction::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::ExecutableDevice::InvalidFunction (*this),
      0
    );
  return result;
}

void CF::ExecutableDevice::InvalidFunction::_raise (void) const
{
  throw *this;
}

void CF::ExecutableDevice::InvalidFunction::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::ExecutableDevice::InvalidFunction::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::ExecutableDevice::InvalidFunction::_tao_type (void) const
{
  return ::CF::ExecutableDevice::_tc_InvalidFunction;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CF_ExecutableDevice_InvalidFunction = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_ExecutableDevice_InvalidFunction (
  ::CORBA::tk_except,
  "IDL:CF/ExecutableDevice/InvalidFunction:1.0",
  "InvalidFunction",
  _tao_fields_CF_ExecutableDevice_InvalidFunction,
  0);

::CORBA::TypeCode_ptr const CF::ExecutableDevice::_tc_InvalidFunction =
  &_tao_tc_CF_ExecutableDevice_InvalidFunction;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CF_ExecutableDevice_ProcessID_Type (
    ::CORBA::tk_alias,
    "IDL:CF/ExecutableDevice/ProcessID_Type:1.0",
    "ProcessID_Type",
    &CORBA::_tc_ulong);
  
::CORBA::TypeCode_ptr const CF::ExecutableDevice::_tc_ProcessID_Type =
  &_tao_tc_CF_ExecutableDevice_ProcessID_Type;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::ExecutableDevice::InvalidParameters::InvalidParameters (
    const CF::Properties & _tao_invalidParms)
  : ::CORBA::UserException (
        "IDL:CF/ExecutableDevice/InvalidParameters:1.0",
        "InvalidParameters"
      )
{
  this->invalidParms = _tao_invalidParms;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::ExecutableDevice::InvalidParameters::InvalidParameters (void)
  : ::CORBA::UserException (
        "IDL:CF/ExecutableDevice/InvalidParameters:1.0",
        "InvalidParameters"
      )
{
}

CF::ExecutableDevice::InvalidParameters::~InvalidParameters (void)
{
}

CF::ExecutableDevice::InvalidParameters::InvalidParameters (const ::CF::ExecutableDevice::InvalidParameters &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->invalidParms = _tao_excp.invalidParms;
}

CF::ExecutableDevice::InvalidParameters&
CF::ExecutableDevice::InvalidParameters::operator= (const ::CF::ExecutableDevice::InvalidParameters &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->invalidParms = _tao_excp.invalidParms;
  return *this;
}

void CF::ExecutableDevice::InvalidParameters::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidParameters *_tao_tmp_pointer =
    static_cast<InvalidParameters *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::ExecutableDevice::InvalidParameters *
CF::ExecutableDevice::InvalidParameters::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidParameters *> (_tao_excp);
}

const CF::ExecutableDevice::InvalidParameters *
CF::ExecutableDevice::InvalidParameters::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidParameters *> (_tao_excp);
}

::CORBA::Exception *CF::ExecutableDevice::InvalidParameters::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::ExecutableDevice::InvalidParameters, 0);
  return retval;
}

::CORBA::Exception *
CF::ExecutableDevice::InvalidParameters::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::ExecutableDevice::InvalidParameters (*this),
      0
    );
  return result;
}

void CF::ExecutableDevice::InvalidParameters::_raise (void) const
{
  throw *this;
}

void CF::ExecutableDevice::InvalidParameters::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::ExecutableDevice::InvalidParameters::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::ExecutableDevice::InvalidParameters::_tao_type (void) const
{
  return ::CF::ExecutableDevice::_tc_InvalidParameters;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_ExecutableDevice_InvalidParameters[] =
      {
        { "invalidParms", &CF::_tc_Properties }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_ExecutableDevice_InvalidParameters (
  ::CORBA::tk_except,
  "IDL:CF/ExecutableDevice/InvalidParameters:1.0",
  "InvalidParameters",
  _tao_fields_CF_ExecutableDevice_InvalidParameters,
  1);

::CORBA::TypeCode_ptr const CF::ExecutableDevice::_tc_InvalidParameters =
  &_tao_tc_CF_ExecutableDevice_InvalidParameters;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::ExecutableDevice::InvalidOptions::InvalidOptions (
    const CF::Properties & _tao_invalidOpts)
  : ::CORBA::UserException (
        "IDL:CF/ExecutableDevice/InvalidOptions:1.0",
        "InvalidOptions"
      )
{
  this->invalidOpts = _tao_invalidOpts;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::ExecutableDevice::InvalidOptions::InvalidOptions (void)
  : ::CORBA::UserException (
        "IDL:CF/ExecutableDevice/InvalidOptions:1.0",
        "InvalidOptions"
      )
{
}

CF::ExecutableDevice::InvalidOptions::~InvalidOptions (void)
{
}

CF::ExecutableDevice::InvalidOptions::InvalidOptions (const ::CF::ExecutableDevice::InvalidOptions &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->invalidOpts = _tao_excp.invalidOpts;
}

CF::ExecutableDevice::InvalidOptions&
CF::ExecutableDevice::InvalidOptions::operator= (const ::CF::ExecutableDevice::InvalidOptions &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->invalidOpts = _tao_excp.invalidOpts;
  return *this;
}

void CF::ExecutableDevice::InvalidOptions::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidOptions *_tao_tmp_pointer =
    static_cast<InvalidOptions *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::ExecutableDevice::InvalidOptions *
CF::ExecutableDevice::InvalidOptions::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidOptions *> (_tao_excp);
}

const CF::ExecutableDevice::InvalidOptions *
CF::ExecutableDevice::InvalidOptions::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidOptions *> (_tao_excp);
}

::CORBA::Exception *CF::ExecutableDevice::InvalidOptions::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::ExecutableDevice::InvalidOptions, 0);
  return retval;
}

::CORBA::Exception *
CF::ExecutableDevice::InvalidOptions::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::ExecutableDevice::InvalidOptions (*this),
      0
    );
  return result;
}

void CF::ExecutableDevice::InvalidOptions::_raise (void) const
{
  throw *this;
}

void CF::ExecutableDevice::InvalidOptions::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::ExecutableDevice::InvalidOptions::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::ExecutableDevice::InvalidOptions::_tao_type (void) const
{
  return ::CF::ExecutableDevice::_tc_InvalidOptions;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_ExecutableDevice_InvalidOptions[] =
      {
        { "invalidOpts", &CF::_tc_Properties }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_ExecutableDevice_InvalidOptions (
  ::CORBA::tk_except,
  "IDL:CF/ExecutableDevice/InvalidOptions:1.0",
  "InvalidOptions",
  _tao_fields_CF_ExecutableDevice_InvalidOptions,
  1);

::CORBA::TypeCode_ptr const CF::ExecutableDevice::_tc_InvalidOptions =
  &_tao_tc_CF_ExecutableDevice_InvalidOptions;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_constant/constant_cs.cpp:61

const char *const CF::ExecutableDevice::STACK_SIZE = "STACK_SIZE";

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_constant/constant_cs.cpp:61

const char *const CF::ExecutableDevice::PRIORITY_ID = "PRIORITY";

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CF::ExecutableDevice::ExecuteFail::ExecuteFail (
    CF::ErrorNumberType _tao_errorNumber,
    const char * _tao_msg)
  : ::CORBA::UserException (
        "IDL:CF/ExecutableDevice/ExecuteFail:1.0",
        "ExecuteFail"
      )
{
  this->errorNumber = _tao_errorNumber;
  this->msg = ::CORBA::string_dup (_tao_msg);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CF::ExecutableDevice::ExecuteFail::ExecuteFail (void)
  : ::CORBA::UserException (
        "IDL:CF/ExecutableDevice/ExecuteFail:1.0",
        "ExecuteFail"
      )
{
}

CF::ExecutableDevice::ExecuteFail::~ExecuteFail (void)
{
}

CF::ExecutableDevice::ExecuteFail::ExecuteFail (const ::CF::ExecutableDevice::ExecuteFail &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
}

CF::ExecutableDevice::ExecuteFail&
CF::ExecutableDevice::ExecuteFail::operator= (const ::CF::ExecutableDevice::ExecuteFail &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorNumber = _tao_excp.errorNumber;
  this->msg = ::CORBA::string_dup (_tao_excp.msg.in ());
  return *this;
}

void CF::ExecutableDevice::ExecuteFail::_tao_any_destructor (void *_tao_void_pointer)
{
  ExecuteFail *_tao_tmp_pointer =
    static_cast<ExecuteFail *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CF::ExecutableDevice::ExecuteFail *
CF::ExecutableDevice::ExecuteFail::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ExecuteFail *> (_tao_excp);
}

const CF::ExecutableDevice::ExecuteFail *
CF::ExecutableDevice::ExecuteFail::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ExecuteFail *> (_tao_excp);
}

::CORBA::Exception *CF::ExecutableDevice::ExecuteFail::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CF::ExecutableDevice::ExecuteFail, 0);
  return retval;
}

::CORBA::Exception *
CF::ExecutableDevice::ExecuteFail::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CF::ExecutableDevice::ExecuteFail (*this),
      0
    );
  return result;
}

void CF::ExecutableDevice::ExecuteFail::_raise (void) const
{
  throw *this;
}

void CF::ExecutableDevice::ExecuteFail::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CF::ExecutableDevice::ExecuteFail::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CF::ExecutableDevice::ExecuteFail::_tao_type (void) const
{
  return ::CF::ExecutableDevice::_tc_ExecuteFail;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_ExecutableDevice_ExecuteFail[] =
      {
        { "errorNumber", &CF::_tc_ErrorNumberType },
        { "msg", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_ExecutableDevice_ExecuteFail (
  ::CORBA::tk_except,
  "IDL:CF/ExecutableDevice/ExecuteFail:1.0",
  "ExecuteFail",
  _tao_fields_CF_ExecutableDevice_ExecuteFail,
  2);

::CORBA::TypeCode_ptr const CF::ExecutableDevice::_tc_ExecuteFail =
  &_tao_tc_CF_ExecutableDevice_ExecuteFail;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::ExecutableDevice::terminate (
  ::CF::ExecutableDevice::ProcessID_Type processId)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ExecutableDevice_Proxy_Broker_ == 0)
    {
      CF_ExecutableDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_processId (processId);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_processId
    };

  static TAO::Exception_Data
  _tao_CF_ExecutableDevice_terminate_exceptiondata [] = 
    {
      {
        "IDL:CF/ExecutableDevice/InvalidProcess:1.0",
        CF::ExecutableDevice::InvalidProcess::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::ExecutableDevice::_tc_InvalidProcess
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/Device/InvalidState:1.0",
        CF::Device::InvalidState::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::Device::_tc_InvalidState
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "terminate",
      9,
      this->the_TAO_ExecutableDevice_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_ExecutableDevice_terminate_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::ExecutableDevice::ProcessID_Type
CF::ExecutableDevice::execute (
  const char * name,
  const ::CF::Properties & options,
  const ::CF::Properties & parameters)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ExecutableDevice_Proxy_Broker_ == 0)
    {
      CF_ExecutableDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);
  TAO::Arg_Traits< ::CF::Properties>::in_arg_val _tao_options (options);
  TAO::Arg_Traits< ::CF::Properties>::in_arg_val _tao_parameters (parameters);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_name,
      &_tao_options,
      &_tao_parameters
    };

  static TAO::Exception_Data
  _tao_CF_ExecutableDevice_execute_exceptiondata [] = 
    {
      {
        "IDL:CF/Device/InvalidState:1.0",
        CF::Device::InvalidState::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::Device::_tc_InvalidState
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/ExecutableDevice/InvalidFunction:1.0",
        CF::ExecutableDevice::InvalidFunction::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::ExecutableDevice::_tc_InvalidFunction
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/ExecutableDevice/InvalidParameters:1.0",
        CF::ExecutableDevice::InvalidParameters::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::ExecutableDevice::_tc_InvalidParameters
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/ExecutableDevice/InvalidOptions:1.0",
        CF::ExecutableDevice::InvalidOptions::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::ExecutableDevice::_tc_InvalidOptions
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/InvalidFileName:1.0",
        CF::InvalidFileName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidFileName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:CF/ExecutableDevice/ExecuteFail:1.0",
        CF::ExecutableDevice::ExecuteFail::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::ExecutableDevice::_tc_ExecuteFail
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "execute",
      7,
      this->the_TAO_ExecutableDevice_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_ExecutableDevice_execute_exceptiondata,
      6
    );

  return _tao_retval.retn ();
}

CF::ExecutableDevice::ExecutableDevice (void)
 : the_TAO_ExecutableDevice_Proxy_Broker_ (0)
{
  this->CF_ExecutableDevice_setup_collocation ();
}

void
CF::ExecutableDevice::CF_ExecutableDevice_setup_collocation ()
{
  if (::CF__TAO_ExecutableDevice_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_ExecutableDevice_Proxy_Broker_ =
        ::CF__TAO_ExecutableDevice_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CF_LoadableDevice_setup_collocation ();
}

CF::ExecutableDevice::~ExecutableDevice (void)
{}

void 
CF::ExecutableDevice::_tao_any_destructor (void *_tao_void_pointer)
{
  ExecutableDevice *_tao_tmp_pointer =
    static_cast<ExecutableDevice *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::ExecutableDevice_ptr
CF::ExecutableDevice::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ExecutableDevice>::narrow (
        _tao_objref,
        "IDL:CF/ExecutableDevice:1.0",
        CF__TAO_ExecutableDevice_Proxy_Broker_Factory_function_pointer
      );
}

CF::ExecutableDevice_ptr
CF::ExecutableDevice::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ExecutableDevice>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/ExecutableDevice:1.0",
        CF__TAO_ExecutableDevice_Proxy_Broker_Factory_function_pointer
      );
}

CF::ExecutableDevice_ptr
CF::ExecutableDevice::_nil (void)
{
  return 0;
}

CF::ExecutableDevice_ptr
CF::ExecutableDevice::_duplicate (ExecutableDevice_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::ExecutableDevice::_tao_release (ExecutableDevice_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::ExecutableDevice::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/LifeCycle:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/TestableObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/PortSupplier:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/Resource:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/Device:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/LoadableDevice:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/ExecutableDevice:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::ExecutableDevice::_interface_repository_id (void) const
{
  return "IDL:CF/ExecutableDevice:1.0";
}

::CORBA::Boolean
CF::ExecutableDevice::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_ExecutableDevice (
    ::CORBA::tk_objref,
    "IDL:CF/ExecutableDevice:1.0",
    "ExecutableDevice");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_ExecutableDevice =
    &_tao_tc_CF_ExecutableDevice;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CF::DeviceManager.

CF::DeviceManager_ptr
TAO::Objref_Traits<CF::DeviceManager>::duplicate (
    CF::DeviceManager_ptr p)
{
  return CF::DeviceManager::_duplicate (p);
}

void
TAO::Objref_Traits<CF::DeviceManager>::release (
    CF::DeviceManager_ptr p)
{
  ::CORBA::release (p);
}

CF::DeviceManager_ptr
TAO::Objref_Traits<CF::DeviceManager>::nil (void)
{
  return CF::DeviceManager::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CF::DeviceManager>::marshal (
    const CF::DeviceManager_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CF__TAO_DeviceManager_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CF_DeviceManager_ServiceType[] =
      {
        { "serviceObject", &CORBA::_tc_Object },
        { "serviceName", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CF_DeviceManager_ServiceType (
  ::CORBA::tk_struct,
  "IDL:CF/DeviceManager/ServiceType:1.0",
  "ServiceType",
  _tao_fields_CF_DeviceManager_ServiceType,
  2);

::CORBA::TypeCode_ptr const CF::DeviceManager::_tc_ServiceType =
  &_tao_tc_CF_DeviceManager_ServiceType;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CF::DeviceManager::ServiceType::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ServiceType *_tao_tmp_pointer =
    static_cast<ServiceType *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CF_DEVICEMANAGER_SERVICESEQUENCE_CS_)
#define _CF_DEVICEMANAGER_SERVICESEQUENCE_CS_

CF::DeviceManager::ServiceSequence::ServiceSequence (void)
{}

CF::DeviceManager::ServiceSequence::ServiceSequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ServiceType
      > (max)
{}

CF::DeviceManager::ServiceSequence::ServiceSequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CF::DeviceManager::ServiceType * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ServiceType
      >
    (max, length, buffer, release)
{}

CF::DeviceManager::ServiceSequence::ServiceSequence (
    const ServiceSequence &seq)
  : ::TAO::unbounded_value_sequence<
        ServiceType
      > (seq)
{}

CF::DeviceManager::ServiceSequence::~ServiceSequence (void)
{}

void CF::DeviceManager::ServiceSequence::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ServiceSequence * _tao_tmp_pointer =
    static_cast<ServiceSequence *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CF_DeviceManager_ServiceSequence_GUARD
#define _TAO_TYPECODE_CF_DeviceManager_ServiceSequence_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CF_DeviceManager_ServiceSequence_0 (
          ::CORBA::tk_sequence,
          &CF::DeviceManager::_tc_ServiceType,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CF_DeviceManager_ServiceSequence_0 =
        &CF_DeviceManager_ServiceSequence_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CF_DeviceManager_ServiceSequence_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CF_DeviceManager_ServiceSequence (
    ::CORBA::tk_alias,
    "IDL:CF/DeviceManager/ServiceSequence:1.0",
    "ServiceSequence",
    &TAO::TypeCode::tc_CF_DeviceManager_ServiceSequence_0);
  
::CORBA::TypeCode_ptr const CF::DeviceManager::_tc_ServiceSequence =
  &_tao_tc_CF_DeviceManager_ServiceSequence;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::DeviceManager::deviceConfigurationProfile (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DeviceManager_Proxy_Broker_ == 0)
    {
      CF_DeviceManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_deviceConfigurationProfile",
      31,
      this->the_TAO_DeviceManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::FileSystem_ptr
CF::DeviceManager::fileSys (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DeviceManager_Proxy_Broker_ == 0)
    {
      CF_DeviceManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::FileSystem>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_fileSys",
      12,
      this->the_TAO_DeviceManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::DeviceManager::identifier (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DeviceManager_Proxy_Broker_ == 0)
    {
      CF_DeviceManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_identifier",
      15,
      this->the_TAO_DeviceManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::DeviceManager::label (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DeviceManager_Proxy_Broker_ == 0)
    {
      CF_DeviceManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_label",
      10,
      this->the_TAO_DeviceManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::DeviceSequence *
CF::DeviceManager::registeredDevices (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DeviceManager_Proxy_Broker_ == 0)
    {
      CF_DeviceManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::DeviceSequence>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_registeredDevices",
      22,
      this->the_TAO_DeviceManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CF::DeviceManager::ServiceSequence *
CF::DeviceManager::registeredServices (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DeviceManager_Proxy_Broker_ == 0)
    {
      CF_DeviceManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CF::DeviceManager::ServiceSequence>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_registeredServices",
      23,
      this->the_TAO_DeviceManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DeviceManager::registerDevice (
  ::CF::Device_ptr registeringDevice)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DeviceManager_Proxy_Broker_ == 0)
    {
      CF_DeviceManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::Device>::in_arg_val _tao_registeringDevice (registeringDevice);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_registeringDevice
    };

  static TAO::Exception_Data
  _tao_CF_DeviceManager_registerDevice_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidObjectReference:1.0",
        CF::InvalidObjectReference::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidObjectReference
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "registerDevice",
      14,
      this->the_TAO_DeviceManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_DeviceManager_registerDevice_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DeviceManager::unregisterDevice (
  ::CF::Device_ptr registeredDevice)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DeviceManager_Proxy_Broker_ == 0)
    {
      CF_DeviceManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CF::Device>::in_arg_val _tao_registeredDevice (registeredDevice);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_registeredDevice
    };

  static TAO::Exception_Data
  _tao_CF_DeviceManager_unregisterDevice_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidObjectReference:1.0",
        CF::InvalidObjectReference::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidObjectReference
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "unregisterDevice",
      16,
      this->the_TAO_DeviceManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_DeviceManager_unregisterDevice_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DeviceManager::shutdown (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DeviceManager_Proxy_Broker_ == 0)
    {
      CF_DeviceManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "shutdown",
      8,
      this->the_TAO_DeviceManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DeviceManager::registerService (
  ::CORBA::Object_ptr registeringService,
  const char * name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DeviceManager_Proxy_Broker_ == 0)
    {
      CF_DeviceManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_registeringService (registeringService);
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_registeringService,
      &_tao_name
    };

  static TAO::Exception_Data
  _tao_CF_DeviceManager_registerService_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidObjectReference:1.0",
        CF::InvalidObjectReference::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidObjectReference
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "registerService",
      15,
      this->the_TAO_DeviceManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_DeviceManager_registerService_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CF::DeviceManager::unregisterService (
  ::CORBA::Object_ptr registeredService,
  const char * name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DeviceManager_Proxy_Broker_ == 0)
    {
      CF_DeviceManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_registeredService (registeredService);
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_registeredService,
      &_tao_name
    };

  static TAO::Exception_Data
  _tao_CF_DeviceManager_unregisterService_exceptiondata [] = 
    {
      {
        "IDL:CF/InvalidObjectReference:1.0",
        CF::InvalidObjectReference::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CF::_tc_InvalidObjectReference
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "unregisterService",
      17,
      this->the_TAO_DeviceManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CF_DeviceManager_unregisterService_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CF::DeviceManager::getComponentImplementationId (
  const char * componentInstantiationId)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_DeviceManager_Proxy_Broker_ == 0)
    {
      CF_DeviceManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_componentInstantiationId (componentInstantiationId);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_componentInstantiationId
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "getComponentImplementationId",
      28,
      this->the_TAO_DeviceManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

CF::DeviceManager::DeviceManager (void)
 : the_TAO_DeviceManager_Proxy_Broker_ (0)
{
  this->CF_DeviceManager_setup_collocation ();
}

void
CF::DeviceManager::CF_DeviceManager_setup_collocation ()
{
  if (::CF__TAO_DeviceManager_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_DeviceManager_Proxy_Broker_ =
        ::CF__TAO_DeviceManager_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CF_PropertySet_setup_collocation ();
  this->CF_PortSupplier_setup_collocation ();
}

CF::DeviceManager::~DeviceManager (void)
{}

void 
CF::DeviceManager::_tao_any_destructor (void *_tao_void_pointer)
{
  DeviceManager *_tao_tmp_pointer =
    static_cast<DeviceManager *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CF::DeviceManager_ptr
CF::DeviceManager::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<DeviceManager>::narrow (
        _tao_objref,
        "IDL:CF/DeviceManager:1.0",
        CF__TAO_DeviceManager_Proxy_Broker_Factory_function_pointer
      );
}

CF::DeviceManager_ptr
CF::DeviceManager::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<DeviceManager>::unchecked_narrow (
        _tao_objref,
        "IDL:CF/DeviceManager:1.0",
        CF__TAO_DeviceManager_Proxy_Broker_Factory_function_pointer
      );
}

CF::DeviceManager_ptr
CF::DeviceManager::_nil (void)
{
  return 0;
}

CF::DeviceManager_ptr
CF::DeviceManager::_duplicate (DeviceManager_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CF::DeviceManager::_tao_release (DeviceManager_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CF::DeviceManager::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:CF/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/PortSupplier:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:CF/DeviceManager:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CF::DeviceManager::_interface_repository_id (void) const
{
  return "IDL:CF/DeviceManager:1.0";
}

::CORBA::Boolean
CF::DeviceManager::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CF_DeviceManager (
    ::CORBA::tk_objref,
    "IDL:CF/DeviceManager:1.0",
    "DeviceManager");
  

namespace CF
{
  ::CORBA::TypeCode_ptr const _tc_DeviceManager =
    &_tao_tc_CF_DeviceManager;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DataType &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::DataType *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::DataType>::insert_copy (
          _tao_any,
          ::CF::DataType::_tao_any_destructor,
          ::CF::_tc_DataType,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CF::DataType *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DataType>::insert (
        _tao_any,
        ::CF::DataType::_tao_any_destructor,
        ::CF::_tc_DataType,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DataType *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DataType *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DataType *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DataType>::extract (
          _tao_any,
          ::CF::DataType::_tao_any_destructor,
          ::CF::_tc_DataType,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DataType &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::DataType *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::DataType>::insert_copy (
        _tao_any,
        CF::DataType::_tao_any_destructor,
        CF::_tc_DataType,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DataType *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DataType>::insert (
      _tao_any,
      CF::DataType::_tao_any_destructor,
      CF::_tc_DataType,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DataType *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DataType *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DataType *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DataType>::extract (
        _tao_any,
        CF::DataType::_tao_any_destructor,
        CF::_tc_DataType,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::InvalidProfile>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::InvalidProfile &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::InvalidProfile>::insert_copy (
        _tao_any,
        ::CF::InvalidProfile::_tao_any_destructor,
        ::CF::_tc_InvalidProfile,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::InvalidProfile *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::InvalidProfile>::insert (
        _tao_any,
        ::CF::InvalidProfile::_tao_any_destructor,
        ::CF::_tc_InvalidProfile,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::InvalidProfile *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::InvalidProfile *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::InvalidProfile *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::InvalidProfile>::extract (
          _tao_any,
          ::CF::InvalidProfile::_tao_any_destructor,
          ::CF::_tc_InvalidProfile,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::InvalidProfile &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::InvalidProfile>::insert_copy (
      _tao_any,
      CF::InvalidProfile::_tao_any_destructor,
      CF::_tc_InvalidProfile,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::InvalidProfile *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::InvalidProfile>::insert (
      _tao_any,
      CF::InvalidProfile::_tao_any_destructor,
      CF::_tc_InvalidProfile,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::InvalidProfile *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::InvalidProfile *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::InvalidProfile *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::InvalidProfile>::extract (
        _tao_any,
        CF::InvalidProfile::_tao_any_destructor,
        CF::_tc_InvalidProfile,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::Properties &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::Properties *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::Properties>::insert_copy (
          _tao_any,
          ::CF::Properties::_tao_any_destructor,
          ::CF::_tc_Properties,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::Properties *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::Properties>::insert (
        _tao_any,
        ::CF::Properties::_tao_any_destructor,
        ::CF::_tc_Properties,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::Properties *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::Properties *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::Properties *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::Properties>::extract (
          _tao_any,
          ::CF::Properties::_tao_any_destructor,
          ::CF::_tc_Properties,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::Properties &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::Properties *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::Properties>::insert_copy (
        _tao_any,
        CF::Properties::_tao_any_destructor,
        CF::_tc_Properties,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Properties *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::Properties>::insert (
      _tao_any,
      CF::Properties::_tao_any_destructor,
      CF::_tc_Properties,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Properties *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::Properties *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::Properties *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::Properties>::extract (
        _tao_any,
        CF::Properties::_tao_any_destructor,
        CF::_tc_Properties,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::InvalidObjectReference>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::InvalidObjectReference &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::InvalidObjectReference>::insert_copy (
        _tao_any,
        ::CF::InvalidObjectReference::_tao_any_destructor,
        ::CF::_tc_InvalidObjectReference,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::InvalidObjectReference *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::InvalidObjectReference>::insert (
        _tao_any,
        ::CF::InvalidObjectReference::_tao_any_destructor,
        ::CF::_tc_InvalidObjectReference,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::InvalidObjectReference *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::InvalidObjectReference *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::InvalidObjectReference *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::InvalidObjectReference>::extract (
          _tao_any,
          ::CF::InvalidObjectReference::_tao_any_destructor,
          ::CF::_tc_InvalidObjectReference,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::InvalidObjectReference &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::InvalidObjectReference>::insert_copy (
      _tao_any,
      CF::InvalidObjectReference::_tao_any_destructor,
      CF::_tc_InvalidObjectReference,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::InvalidObjectReference *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::InvalidObjectReference>::insert (
      _tao_any,
      CF::InvalidObjectReference::_tao_any_destructor,
      CF::_tc_InvalidObjectReference,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::InvalidObjectReference *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::InvalidObjectReference *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::InvalidObjectReference *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::InvalidObjectReference>::extract (
        _tao_any,
        CF::InvalidObjectReference::_tao_any_destructor,
        CF::_tc_InvalidObjectReference,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::OctetSequence &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::OctetSequence *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::OctetSequence>::insert_copy (
          _tao_any,
          ::CF::OctetSequence::_tao_any_destructor,
          ::CF::_tc_OctetSequence,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::OctetSequence *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::OctetSequence>::insert (
        _tao_any,
        ::CF::OctetSequence::_tao_any_destructor,
        ::CF::_tc_OctetSequence,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::OctetSequence *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::OctetSequence *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::OctetSequence *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::OctetSequence>::extract (
          _tao_any,
          ::CF::OctetSequence::_tao_any_destructor,
          ::CF::_tc_OctetSequence,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::OctetSequence &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::OctetSequence *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::OctetSequence>::insert_copy (
        _tao_any,
        CF::OctetSequence::_tao_any_destructor,
        CF::_tc_OctetSequence,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::OctetSequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::OctetSequence>::insert (
      _tao_any,
      CF::OctetSequence::_tao_any_destructor,
      CF::_tc_OctetSequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::OctetSequence *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::OctetSequence *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::OctetSequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::OctetSequence>::extract (
        _tao_any,
        CF::OctetSequence::_tao_any_destructor,
        CF::_tc_OctetSequence,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::StringSequence &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::StringSequence *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::StringSequence>::insert_copy (
          _tao_any,
          ::CF::StringSequence::_tao_any_destructor,
          ::CF::_tc_StringSequence,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::StringSequence *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::StringSequence>::insert (
        _tao_any,
        ::CF::StringSequence::_tao_any_destructor,
        ::CF::_tc_StringSequence,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::StringSequence *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::StringSequence *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::StringSequence *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::StringSequence>::extract (
          _tao_any,
          ::CF::StringSequence::_tao_any_destructor,
          ::CF::_tc_StringSequence,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::StringSequence &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::StringSequence *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::StringSequence>::insert_copy (
        _tao_any,
        CF::StringSequence::_tao_any_destructor,
        CF::_tc_StringSequence,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::StringSequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::StringSequence>::insert (
      _tao_any,
      CF::StringSequence::_tao_any_destructor,
      CF::_tc_StringSequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::StringSequence *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::StringSequence *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::StringSequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::StringSequence>::extract (
        _tao_any,
        CF::StringSequence::_tao_any_destructor,
        CF::_tc_StringSequence,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::UnknownProperties>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::UnknownProperties &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::UnknownProperties>::insert_copy (
        _tao_any,
        ::CF::UnknownProperties::_tao_any_destructor,
        ::CF::_tc_UnknownProperties,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::UnknownProperties *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::UnknownProperties>::insert (
        _tao_any,
        ::CF::UnknownProperties::_tao_any_destructor,
        ::CF::_tc_UnknownProperties,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::UnknownProperties *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::UnknownProperties *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::UnknownProperties *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::UnknownProperties>::extract (
          _tao_any,
          ::CF::UnknownProperties::_tao_any_destructor,
          ::CF::_tc_UnknownProperties,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::UnknownProperties &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::UnknownProperties>::insert_copy (
      _tao_any,
      CF::UnknownProperties::_tao_any_destructor,
      CF::_tc_UnknownProperties,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::UnknownProperties *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::UnknownProperties>::insert (
      _tao_any,
      CF::UnknownProperties::_tao_any_destructor,
      CF::_tc_UnknownProperties,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::UnknownProperties *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::UnknownProperties *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::UnknownProperties *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::UnknownProperties>::extract (
        _tao_any,
        CF::UnknownProperties::_tao_any_destructor,
        CF::_tc_UnknownProperties,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DeviceAssignmentType &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::DeviceAssignmentType *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::DeviceAssignmentType>::insert_copy (
          _tao_any,
          ::CF::DeviceAssignmentType::_tao_any_destructor,
          ::CF::_tc_DeviceAssignmentType,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CF::DeviceAssignmentType *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DeviceAssignmentType>::insert (
        _tao_any,
        ::CF::DeviceAssignmentType::_tao_any_destructor,
        ::CF::_tc_DeviceAssignmentType,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DeviceAssignmentType *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DeviceAssignmentType *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DeviceAssignmentType *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DeviceAssignmentType>::extract (
          _tao_any,
          ::CF::DeviceAssignmentType::_tao_any_destructor,
          ::CF::_tc_DeviceAssignmentType,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DeviceAssignmentType &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::DeviceAssignmentType *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::DeviceAssignmentType>::insert_copy (
        _tao_any,
        CF::DeviceAssignmentType::_tao_any_destructor,
        CF::_tc_DeviceAssignmentType,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DeviceAssignmentType *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DeviceAssignmentType>::insert (
      _tao_any,
      CF::DeviceAssignmentType::_tao_any_destructor,
      CF::_tc_DeviceAssignmentType,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DeviceAssignmentType *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DeviceAssignmentType *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DeviceAssignmentType *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DeviceAssignmentType>::extract (
        _tao_any,
        CF::DeviceAssignmentType::_tao_any_destructor,
        CF::_tc_DeviceAssignmentType,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DeviceAssignmentSequence &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::DeviceAssignmentSequence *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::DeviceAssignmentSequence>::insert_copy (
          _tao_any,
          ::CF::DeviceAssignmentSequence::_tao_any_destructor,
          ::CF::_tc_DeviceAssignmentSequence,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DeviceAssignmentSequence *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DeviceAssignmentSequence>::insert (
        _tao_any,
        ::CF::DeviceAssignmentSequence::_tao_any_destructor,
        ::CF::_tc_DeviceAssignmentSequence,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DeviceAssignmentSequence *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DeviceAssignmentSequence *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DeviceAssignmentSequence *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DeviceAssignmentSequence>::extract (
          _tao_any,
          ::CF::DeviceAssignmentSequence::_tao_any_destructor,
          ::CF::_tc_DeviceAssignmentSequence,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DeviceAssignmentSequence &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::DeviceAssignmentSequence *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::DeviceAssignmentSequence>::insert_copy (
        _tao_any,
        CF::DeviceAssignmentSequence::_tao_any_destructor,
        CF::_tc_DeviceAssignmentSequence,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DeviceAssignmentSequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DeviceAssignmentSequence>::insert (
      _tao_any,
      CF::DeviceAssignmentSequence::_tao_any_destructor,
      CF::_tc_DeviceAssignmentSequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DeviceAssignmentSequence *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DeviceAssignmentSequence *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DeviceAssignmentSequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DeviceAssignmentSequence>::extract (
        _tao_any,
        CF::DeviceAssignmentSequence::_tao_any_destructor,
        CF::_tc_DeviceAssignmentSequence,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::ErrorNumberType _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::CF::ErrorNumberType>::insert (
        _tao_any,
        ::CF::_tc_ErrorNumberType,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::ErrorNumberType &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::CF::ErrorNumberType>::extract (
          _tao_any,
          ::CF::_tc_ErrorNumberType,
          _tao_elem 
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ErrorNumberType _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<CF::ErrorNumberType>::insert (
      _tao_any,
      CF::_tc_ErrorNumberType,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ErrorNumberType &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<CF::ErrorNumberType>::extract (
        _tao_any,
        CF::_tc_ErrorNumberType,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::InvalidFileName>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::InvalidFileName &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::InvalidFileName>::insert_copy (
        _tao_any,
        ::CF::InvalidFileName::_tao_any_destructor,
        ::CF::_tc_InvalidFileName,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::InvalidFileName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::InvalidFileName>::insert (
        _tao_any,
        ::CF::InvalidFileName::_tao_any_destructor,
        ::CF::_tc_InvalidFileName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::InvalidFileName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::InvalidFileName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::InvalidFileName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::InvalidFileName>::extract (
          _tao_any,
          ::CF::InvalidFileName::_tao_any_destructor,
          ::CF::_tc_InvalidFileName,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::InvalidFileName &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::InvalidFileName>::insert_copy (
      _tao_any,
      CF::InvalidFileName::_tao_any_destructor,
      CF::_tc_InvalidFileName,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::InvalidFileName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::InvalidFileName>::insert (
      _tao_any,
      CF::InvalidFileName::_tao_any_destructor,
      CF::_tc_InvalidFileName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::InvalidFileName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::InvalidFileName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::InvalidFileName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::InvalidFileName>::extract (
        _tao_any,
        CF::InvalidFileName::_tao_any_destructor,
        CF::_tc_InvalidFileName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::FileException>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::FileException &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::FileException>::insert_copy (
        _tao_any,
        ::CF::FileException::_tao_any_destructor,
        ::CF::_tc_FileException,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::FileException *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::FileException>::insert (
        _tao_any,
        ::CF::FileException::_tao_any_destructor,
        ::CF::_tc_FileException,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::FileException *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::FileException *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::FileException *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::FileException>::extract (
          _tao_any,
          ::CF::FileException::_tao_any_destructor,
          ::CF::_tc_FileException,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::FileException &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::FileException>::insert_copy (
      _tao_any,
      CF::FileException::_tao_any_destructor,
      CF::_tc_FileException,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::FileException *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::FileException>::insert (
      _tao_any,
      CF::FileException::_tao_any_destructor,
      CF::_tc_FileException,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::FileException *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::FileException *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::FileException *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::FileException>::extract (
        _tao_any,
        CF::FileException::_tao_any_destructor,
        CF::_tc_FileException,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DeviceSequence &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::DeviceSequence *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::DeviceSequence>::insert_copy (
          _tao_any,
          ::CF::DeviceSequence::_tao_any_destructor,
          ::CF::_tc_DeviceSequence,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DeviceSequence *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DeviceSequence>::insert (
        _tao_any,
        ::CF::DeviceSequence::_tao_any_destructor,
        ::CF::_tc_DeviceSequence,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DeviceSequence *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DeviceSequence *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DeviceSequence *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DeviceSequence>::extract (
          _tao_any,
          ::CF::DeviceSequence::_tao_any_destructor,
          ::CF::_tc_DeviceSequence,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DeviceSequence &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::DeviceSequence *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::DeviceSequence>::insert_copy (
        _tao_any,
        CF::DeviceSequence::_tao_any_destructor,
        CF::_tc_DeviceSequence,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DeviceSequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DeviceSequence>::insert (
      _tao_any,
      CF::DeviceSequence::_tao_any_destructor,
      CF::_tc_DeviceSequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DeviceSequence *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DeviceSequence *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DeviceSequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DeviceSequence>::extract (
        _tao_any,
        CF::DeviceSequence::_tao_any_destructor,
        CF::_tc_DeviceSequence,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::AggregateDevice>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AggregateDevice_ptr _tao_elem)
  {
    AggregateDevice_ptr _tao_objptr =
      AggregateDevice::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AggregateDevice_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AggregateDevice>::insert (
        _tao_any,
        AggregateDevice::_tao_any_destructor,
        _tc_AggregateDevice,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AggregateDevice_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AggregateDevice>::extract (
          _tao_any,
          AggregateDevice::_tao_any_destructor,
          _tc_AggregateDevice,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::AggregateDevice_ptr _tao_elem)
{
  CF::AggregateDevice_ptr _tao_objptr =
    CF::AggregateDevice::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::AggregateDevice_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::AggregateDevice>::insert (
      _tao_any,
      CF::AggregateDevice::_tao_any_destructor,
      CF::_tc_AggregateDevice,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::AggregateDevice_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::AggregateDevice>::extract (
        _tao_any,
        CF::AggregateDevice::_tao_any_destructor,
        CF::_tc_AggregateDevice,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::FileSystem>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FileSystem_ptr _tao_elem)
  {
    FileSystem_ptr _tao_objptr =
      FileSystem::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FileSystem_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<FileSystem>::insert (
        _tao_any,
        FileSystem::_tao_any_destructor,
        _tc_FileSystem,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      FileSystem_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<FileSystem>::extract (
          _tao_any,
          FileSystem::_tao_any_destructor,
          _tc_FileSystem,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::FileSystem_ptr _tao_elem)
{
  CF::FileSystem_ptr _tao_objptr =
    CF::FileSystem::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::FileSystem_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::FileSystem>::insert (
      _tao_any,
      CF::FileSystem::_tao_any_destructor,
      CF::_tc_FileSystem,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::FileSystem_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::FileSystem>::extract (
        _tao_any,
        CF::FileSystem::_tao_any_destructor,
        CF::_tc_FileSystem,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::FileSystem::UnknownFileSystemProperties>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::FileSystem::UnknownFileSystemProperties &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::FileSystem::UnknownFileSystemProperties>::insert_copy (
        _tao_any,
        ::CF::FileSystem::UnknownFileSystemProperties::_tao_any_destructor,
        ::CF::FileSystem::_tc_UnknownFileSystemProperties,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::FileSystem::UnknownFileSystemProperties *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::FileSystem::UnknownFileSystemProperties>::insert (
        _tao_any,
        ::CF::FileSystem::UnknownFileSystemProperties::_tao_any_destructor,
        ::CF::FileSystem::_tc_UnknownFileSystemProperties,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::FileSystem::UnknownFileSystemProperties *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::FileSystem::UnknownFileSystemProperties *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::FileSystem::UnknownFileSystemProperties *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::FileSystem::UnknownFileSystemProperties>::extract (
          _tao_any,
          ::CF::FileSystem::UnknownFileSystemProperties::_tao_any_destructor,
          ::CF::FileSystem::_tc_UnknownFileSystemProperties,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::FileSystem::UnknownFileSystemProperties &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::FileSystem::UnknownFileSystemProperties>::insert_copy (
      _tao_any,
      CF::FileSystem::UnknownFileSystemProperties::_tao_any_destructor,
      CF::FileSystem::_tc_UnknownFileSystemProperties,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::FileSystem::UnknownFileSystemProperties *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::FileSystem::UnknownFileSystemProperties>::insert (
      _tao_any,
      CF::FileSystem::UnknownFileSystemProperties::_tao_any_destructor,
      CF::FileSystem::_tc_UnknownFileSystemProperties,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::FileSystem::UnknownFileSystemProperties *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::FileSystem::UnknownFileSystemProperties *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::FileSystem::UnknownFileSystemProperties *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::FileSystem::UnknownFileSystemProperties>::extract (
        _tao_any,
        CF::FileSystem::UnknownFileSystemProperties::_tao_any_destructor,
        CF::FileSystem::_tc_UnknownFileSystemProperties,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::FileSystem::FileType _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::CF::FileSystem::FileType>::insert (
        _tao_any,
        ::CF::FileSystem::_tc_FileType,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::FileSystem::FileType &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::CF::FileSystem::FileType>::extract (
          _tao_any,
          ::CF::FileSystem::_tc_FileType,
          _tao_elem 
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::FileSystem::FileType _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<CF::FileSystem::FileType>::insert (
      _tao_any,
      CF::FileSystem::_tc_FileType,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::FileSystem::FileType &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<CF::FileSystem::FileType>::extract (
        _tao_any,
        CF::FileSystem::_tc_FileType,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::FileSystem::FileInformationType &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::FileSystem::FileInformationType *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::FileSystem::FileInformationType>::insert_copy (
          _tao_any,
          ::CF::FileSystem::FileInformationType::_tao_any_destructor,
          ::CF::FileSystem::_tc_FileInformationType,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CF::FileSystem::FileInformationType *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::FileSystem::FileInformationType>::insert (
        _tao_any,
        ::CF::FileSystem::FileInformationType::_tao_any_destructor,
        ::CF::FileSystem::_tc_FileInformationType,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::FileSystem::FileInformationType *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::FileSystem::FileInformationType *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::FileSystem::FileInformationType *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::FileSystem::FileInformationType>::extract (
          _tao_any,
          ::CF::FileSystem::FileInformationType::_tao_any_destructor,
          ::CF::FileSystem::_tc_FileInformationType,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::FileSystem::FileInformationType &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::FileSystem::FileInformationType *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::FileSystem::FileInformationType>::insert_copy (
        _tao_any,
        CF::FileSystem::FileInformationType::_tao_any_destructor,
        CF::FileSystem::_tc_FileInformationType,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::FileSystem::FileInformationType *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::FileSystem::FileInformationType>::insert (
      _tao_any,
      CF::FileSystem::FileInformationType::_tao_any_destructor,
      CF::FileSystem::_tc_FileInformationType,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::FileSystem::FileInformationType *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::FileSystem::FileInformationType *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::FileSystem::FileInformationType *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::FileSystem::FileInformationType>::extract (
        _tao_any,
        CF::FileSystem::FileInformationType::_tao_any_destructor,
        CF::FileSystem::_tc_FileInformationType,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::FileSystem::FileInformationSequence &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::FileSystem::FileInformationSequence *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::FileSystem::FileInformationSequence>::insert_copy (
          _tao_any,
          ::CF::FileSystem::FileInformationSequence::_tao_any_destructor,
          ::CF::FileSystem::_tc_FileInformationSequence,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::FileSystem::FileInformationSequence *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::FileSystem::FileInformationSequence>::insert (
        _tao_any,
        ::CF::FileSystem::FileInformationSequence::_tao_any_destructor,
        ::CF::FileSystem::_tc_FileInformationSequence,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::FileSystem::FileInformationSequence *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::FileSystem::FileInformationSequence *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::FileSystem::FileInformationSequence *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::FileSystem::FileInformationSequence>::extract (
          _tao_any,
          ::CF::FileSystem::FileInformationSequence::_tao_any_destructor,
          ::CF::FileSystem::_tc_FileInformationSequence,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::FileSystem::FileInformationSequence &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::FileSystem::FileInformationSequence *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::FileSystem::FileInformationSequence>::insert_copy (
        _tao_any,
        CF::FileSystem::FileInformationSequence::_tao_any_destructor,
        CF::FileSystem::_tc_FileInformationSequence,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::FileSystem::FileInformationSequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::FileSystem::FileInformationSequence>::insert (
      _tao_any,
      CF::FileSystem::FileInformationSequence::_tao_any_destructor,
      CF::FileSystem::_tc_FileInformationSequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::FileSystem::FileInformationSequence *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::FileSystem::FileInformationSequence *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::FileSystem::FileInformationSequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::FileSystem::FileInformationSequence>::extract (
        _tao_any,
        CF::FileSystem::FileInformationSequence::_tao_any_destructor,
        CF::FileSystem::_tc_FileInformationSequence,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::File>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      File_ptr _tao_elem)
  {
    File_ptr _tao_objptr =
      File::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      File_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<File>::insert (
        _tao_any,
        File::_tao_any_destructor,
        _tc_File,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      File_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<File>::extract (
          _tao_any,
          File::_tao_any_destructor,
          _tc_File,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::File_ptr _tao_elem)
{
  CF::File_ptr _tao_objptr =
    CF::File::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::File_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::File>::insert (
      _tao_any,
      CF::File::_tao_any_destructor,
      CF::_tc_File,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::File_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::File>::extract (
        _tao_any,
        CF::File::_tao_any_destructor,
        CF::_tc_File,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::File::IOException>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::File::IOException &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::File::IOException>::insert_copy (
        _tao_any,
        ::CF::File::IOException::_tao_any_destructor,
        ::CF::File::_tc_IOException,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::File::IOException *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::File::IOException>::insert (
        _tao_any,
        ::CF::File::IOException::_tao_any_destructor,
        ::CF::File::_tc_IOException,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::File::IOException *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::File::IOException *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::File::IOException *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::File::IOException>::extract (
          _tao_any,
          ::CF::File::IOException::_tao_any_destructor,
          ::CF::File::_tc_IOException,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::File::IOException &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::File::IOException>::insert_copy (
      _tao_any,
      CF::File::IOException::_tao_any_destructor,
      CF::File::_tc_IOException,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::File::IOException *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::File::IOException>::insert (
      _tao_any,
      CF::File::IOException::_tao_any_destructor,
      CF::File::_tc_IOException,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::File::IOException *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::File::IOException *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::File::IOException *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::File::IOException>::extract (
        _tao_any,
        CF::File::IOException::_tao_any_destructor,
        CF::File::_tc_IOException,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::File::InvalidFilePointer>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::File::InvalidFilePointer &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::File::InvalidFilePointer>::insert_copy (
        _tao_any,
        ::CF::File::InvalidFilePointer::_tao_any_destructor,
        ::CF::File::_tc_InvalidFilePointer,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::File::InvalidFilePointer *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::File::InvalidFilePointer>::insert (
        _tao_any,
        ::CF::File::InvalidFilePointer::_tao_any_destructor,
        ::CF::File::_tc_InvalidFilePointer,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::File::InvalidFilePointer *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::File::InvalidFilePointer *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::File::InvalidFilePointer *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::File::InvalidFilePointer>::extract (
          _tao_any,
          ::CF::File::InvalidFilePointer::_tao_any_destructor,
          ::CF::File::_tc_InvalidFilePointer,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::File::InvalidFilePointer &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::File::InvalidFilePointer>::insert_copy (
      _tao_any,
      CF::File::InvalidFilePointer::_tao_any_destructor,
      CF::File::_tc_InvalidFilePointer,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::File::InvalidFilePointer *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::File::InvalidFilePointer>::insert (
      _tao_any,
      CF::File::InvalidFilePointer::_tao_any_destructor,
      CF::File::_tc_InvalidFilePointer,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::File::InvalidFilePointer *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::File::InvalidFilePointer *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::File::InvalidFilePointer *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::File::InvalidFilePointer>::extract (
        _tao_any,
        CF::File::InvalidFilePointer::_tao_any_destructor,
        CF::File::_tc_InvalidFilePointer,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::ResourceFactory>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ResourceFactory_ptr _tao_elem)
  {
    ResourceFactory_ptr _tao_objptr =
      ResourceFactory::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ResourceFactory_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<ResourceFactory>::insert (
        _tao_any,
        ResourceFactory::_tao_any_destructor,
        _tc_ResourceFactory,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      ResourceFactory_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<ResourceFactory>::extract (
          _tao_any,
          ResourceFactory::_tao_any_destructor,
          _tc_ResourceFactory,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ResourceFactory_ptr _tao_elem)
{
  CF::ResourceFactory_ptr _tao_objptr =
    CF::ResourceFactory::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ResourceFactory_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::ResourceFactory>::insert (
      _tao_any,
      CF::ResourceFactory::_tao_any_destructor,
      CF::_tc_ResourceFactory,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ResourceFactory_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::ResourceFactory>::extract (
        _tao_any,
        CF::ResourceFactory::_tao_any_destructor,
        CF::_tc_ResourceFactory,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::ResourceFactory::InvalidResourceId>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::ResourceFactory::InvalidResourceId &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ResourceFactory::InvalidResourceId>::insert_copy (
        _tao_any,
        ::CF::ResourceFactory::InvalidResourceId::_tao_any_destructor,
        ::CF::ResourceFactory::_tc_InvalidResourceId,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::ResourceFactory::InvalidResourceId *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ResourceFactory::InvalidResourceId>::insert (
        _tao_any,
        ::CF::ResourceFactory::InvalidResourceId::_tao_any_destructor,
        ::CF::ResourceFactory::_tc_InvalidResourceId,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::ResourceFactory::InvalidResourceId *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::ResourceFactory::InvalidResourceId *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::ResourceFactory::InvalidResourceId *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::ResourceFactory::InvalidResourceId>::extract (
          _tao_any,
          ::CF::ResourceFactory::InvalidResourceId::_tao_any_destructor,
          ::CF::ResourceFactory::_tc_InvalidResourceId,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::ResourceFactory::InvalidResourceId &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ResourceFactory::InvalidResourceId>::insert_copy (
      _tao_any,
      CF::ResourceFactory::InvalidResourceId::_tao_any_destructor,
      CF::ResourceFactory::_tc_InvalidResourceId,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ResourceFactory::InvalidResourceId *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ResourceFactory::InvalidResourceId>::insert (
      _tao_any,
      CF::ResourceFactory::InvalidResourceId::_tao_any_destructor,
      CF::ResourceFactory::_tc_InvalidResourceId,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ResourceFactory::InvalidResourceId *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::ResourceFactory::InvalidResourceId *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::ResourceFactory::InvalidResourceId *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::ResourceFactory::InvalidResourceId>::extract (
        _tao_any,
        CF::ResourceFactory::InvalidResourceId::_tao_any_destructor,
        CF::ResourceFactory::_tc_InvalidResourceId,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::ResourceFactory::ShutdownFailure>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::ResourceFactory::ShutdownFailure &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ResourceFactory::ShutdownFailure>::insert_copy (
        _tao_any,
        ::CF::ResourceFactory::ShutdownFailure::_tao_any_destructor,
        ::CF::ResourceFactory::_tc_ShutdownFailure,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::ResourceFactory::ShutdownFailure *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ResourceFactory::ShutdownFailure>::insert (
        _tao_any,
        ::CF::ResourceFactory::ShutdownFailure::_tao_any_destructor,
        ::CF::ResourceFactory::_tc_ShutdownFailure,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::ResourceFactory::ShutdownFailure *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::ResourceFactory::ShutdownFailure *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::ResourceFactory::ShutdownFailure *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::ResourceFactory::ShutdownFailure>::extract (
          _tao_any,
          ::CF::ResourceFactory::ShutdownFailure::_tao_any_destructor,
          ::CF::ResourceFactory::_tc_ShutdownFailure,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::ResourceFactory::ShutdownFailure &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ResourceFactory::ShutdownFailure>::insert_copy (
      _tao_any,
      CF::ResourceFactory::ShutdownFailure::_tao_any_destructor,
      CF::ResourceFactory::_tc_ShutdownFailure,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ResourceFactory::ShutdownFailure *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ResourceFactory::ShutdownFailure>::insert (
      _tao_any,
      CF::ResourceFactory::ShutdownFailure::_tao_any_destructor,
      CF::ResourceFactory::_tc_ShutdownFailure,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ResourceFactory::ShutdownFailure *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::ResourceFactory::ShutdownFailure *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::ResourceFactory::ShutdownFailure *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::ResourceFactory::ShutdownFailure>::extract (
        _tao_any,
        CF::ResourceFactory::ShutdownFailure::_tao_any_destructor,
        CF::ResourceFactory::_tc_ShutdownFailure,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::ResourceFactory::CreateResourceFailure>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::ResourceFactory::CreateResourceFailure &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ResourceFactory::CreateResourceFailure>::insert_copy (
        _tao_any,
        ::CF::ResourceFactory::CreateResourceFailure::_tao_any_destructor,
        ::CF::ResourceFactory::_tc_CreateResourceFailure,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::ResourceFactory::CreateResourceFailure *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ResourceFactory::CreateResourceFailure>::insert (
        _tao_any,
        ::CF::ResourceFactory::CreateResourceFailure::_tao_any_destructor,
        ::CF::ResourceFactory::_tc_CreateResourceFailure,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::ResourceFactory::CreateResourceFailure *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::ResourceFactory::CreateResourceFailure *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::ResourceFactory::CreateResourceFailure *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::ResourceFactory::CreateResourceFailure>::extract (
          _tao_any,
          ::CF::ResourceFactory::CreateResourceFailure::_tao_any_destructor,
          ::CF::ResourceFactory::_tc_CreateResourceFailure,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::ResourceFactory::CreateResourceFailure &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ResourceFactory::CreateResourceFailure>::insert_copy (
      _tao_any,
      CF::ResourceFactory::CreateResourceFailure::_tao_any_destructor,
      CF::ResourceFactory::_tc_CreateResourceFailure,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ResourceFactory::CreateResourceFailure *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ResourceFactory::CreateResourceFailure>::insert (
      _tao_any,
      CF::ResourceFactory::CreateResourceFailure::_tao_any_destructor,
      CF::ResourceFactory::_tc_CreateResourceFailure,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ResourceFactory::CreateResourceFailure *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::ResourceFactory::CreateResourceFailure *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::ResourceFactory::CreateResourceFailure *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::ResourceFactory::CreateResourceFailure>::extract (
        _tao_any,
        CF::ResourceFactory::CreateResourceFailure::_tao_any_destructor,
        CF::ResourceFactory::_tc_CreateResourceFailure,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::FileManager>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FileManager_ptr _tao_elem)
  {
    FileManager_ptr _tao_objptr =
      FileManager::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FileManager_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<FileManager>::insert (
        _tao_any,
        FileManager::_tao_any_destructor,
        _tc_FileManager,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      FileManager_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<FileManager>::extract (
          _tao_any,
          FileManager::_tao_any_destructor,
          _tc_FileManager,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::FileManager_ptr _tao_elem)
{
  CF::FileManager_ptr _tao_objptr =
    CF::FileManager::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::FileManager_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::FileManager>::insert (
      _tao_any,
      CF::FileManager::_tao_any_destructor,
      CF::_tc_FileManager,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::FileManager_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::FileManager>::extract (
        _tao_any,
        CF::FileManager::_tao_any_destructor,
        CF::_tc_FileManager,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::FileManager::MountType &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::FileManager::MountType *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::FileManager::MountType>::insert_copy (
          _tao_any,
          ::CF::FileManager::MountType::_tao_any_destructor,
          ::CF::FileManager::_tc_MountType,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CF::FileManager::MountType *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::FileManager::MountType>::insert (
        _tao_any,
        ::CF::FileManager::MountType::_tao_any_destructor,
        ::CF::FileManager::_tc_MountType,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::FileManager::MountType *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::FileManager::MountType *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::FileManager::MountType *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::FileManager::MountType>::extract (
          _tao_any,
          ::CF::FileManager::MountType::_tao_any_destructor,
          ::CF::FileManager::_tc_MountType,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::FileManager::MountType &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::FileManager::MountType *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::FileManager::MountType>::insert_copy (
        _tao_any,
        CF::FileManager::MountType::_tao_any_destructor,
        CF::FileManager::_tc_MountType,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::FileManager::MountType *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::FileManager::MountType>::insert (
      _tao_any,
      CF::FileManager::MountType::_tao_any_destructor,
      CF::FileManager::_tc_MountType,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::FileManager::MountType *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::FileManager::MountType *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::FileManager::MountType *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::FileManager::MountType>::extract (
        _tao_any,
        CF::FileManager::MountType::_tao_any_destructor,
        CF::FileManager::_tc_MountType,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::FileManager::MountSequence &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::FileManager::MountSequence *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::FileManager::MountSequence>::insert_copy (
          _tao_any,
          ::CF::FileManager::MountSequence::_tao_any_destructor,
          ::CF::FileManager::_tc_MountSequence,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::FileManager::MountSequence *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::FileManager::MountSequence>::insert (
        _tao_any,
        ::CF::FileManager::MountSequence::_tao_any_destructor,
        ::CF::FileManager::_tc_MountSequence,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::FileManager::MountSequence *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::FileManager::MountSequence *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::FileManager::MountSequence *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::FileManager::MountSequence>::extract (
          _tao_any,
          ::CF::FileManager::MountSequence::_tao_any_destructor,
          ::CF::FileManager::_tc_MountSequence,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::FileManager::MountSequence &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::FileManager::MountSequence *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::FileManager::MountSequence>::insert_copy (
        _tao_any,
        CF::FileManager::MountSequence::_tao_any_destructor,
        CF::FileManager::_tc_MountSequence,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::FileManager::MountSequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::FileManager::MountSequence>::insert (
      _tao_any,
      CF::FileManager::MountSequence::_tao_any_destructor,
      CF::FileManager::_tc_MountSequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::FileManager::MountSequence *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::FileManager::MountSequence *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::FileManager::MountSequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::FileManager::MountSequence>::extract (
        _tao_any,
        CF::FileManager::MountSequence::_tao_any_destructor,
        CF::FileManager::_tc_MountSequence,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::FileManager::NonExistentMount>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::FileManager::NonExistentMount &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::FileManager::NonExistentMount>::insert_copy (
        _tao_any,
        ::CF::FileManager::NonExistentMount::_tao_any_destructor,
        ::CF::FileManager::_tc_NonExistentMount,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::FileManager::NonExistentMount *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::FileManager::NonExistentMount>::insert (
        _tao_any,
        ::CF::FileManager::NonExistentMount::_tao_any_destructor,
        ::CF::FileManager::_tc_NonExistentMount,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::FileManager::NonExistentMount *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::FileManager::NonExistentMount *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::FileManager::NonExistentMount *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::FileManager::NonExistentMount>::extract (
          _tao_any,
          ::CF::FileManager::NonExistentMount::_tao_any_destructor,
          ::CF::FileManager::_tc_NonExistentMount,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::FileManager::NonExistentMount &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::FileManager::NonExistentMount>::insert_copy (
      _tao_any,
      CF::FileManager::NonExistentMount::_tao_any_destructor,
      CF::FileManager::_tc_NonExistentMount,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::FileManager::NonExistentMount *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::FileManager::NonExistentMount>::insert (
      _tao_any,
      CF::FileManager::NonExistentMount::_tao_any_destructor,
      CF::FileManager::_tc_NonExistentMount,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::FileManager::NonExistentMount *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::FileManager::NonExistentMount *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::FileManager::NonExistentMount *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::FileManager::NonExistentMount>::extract (
        _tao_any,
        CF::FileManager::NonExistentMount::_tao_any_destructor,
        CF::FileManager::_tc_NonExistentMount,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::FileManager::InvalidFileSystem>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::FileManager::InvalidFileSystem &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::FileManager::InvalidFileSystem>::insert_copy (
        _tao_any,
        ::CF::FileManager::InvalidFileSystem::_tao_any_destructor,
        ::CF::FileManager::_tc_InvalidFileSystem,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::FileManager::InvalidFileSystem *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::FileManager::InvalidFileSystem>::insert (
        _tao_any,
        ::CF::FileManager::InvalidFileSystem::_tao_any_destructor,
        ::CF::FileManager::_tc_InvalidFileSystem,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::FileManager::InvalidFileSystem *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::FileManager::InvalidFileSystem *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::FileManager::InvalidFileSystem *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::FileManager::InvalidFileSystem>::extract (
          _tao_any,
          ::CF::FileManager::InvalidFileSystem::_tao_any_destructor,
          ::CF::FileManager::_tc_InvalidFileSystem,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::FileManager::InvalidFileSystem &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::FileManager::InvalidFileSystem>::insert_copy (
      _tao_any,
      CF::FileManager::InvalidFileSystem::_tao_any_destructor,
      CF::FileManager::_tc_InvalidFileSystem,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::FileManager::InvalidFileSystem *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::FileManager::InvalidFileSystem>::insert (
      _tao_any,
      CF::FileManager::InvalidFileSystem::_tao_any_destructor,
      CF::FileManager::_tc_InvalidFileSystem,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::FileManager::InvalidFileSystem *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::FileManager::InvalidFileSystem *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::FileManager::InvalidFileSystem *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::FileManager::InvalidFileSystem>::extract (
        _tao_any,
        CF::FileManager::InvalidFileSystem::_tao_any_destructor,
        CF::FileManager::_tc_InvalidFileSystem,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::FileManager::MountPointAlreadyExists>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::FileManager::MountPointAlreadyExists &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::FileManager::MountPointAlreadyExists>::insert_copy (
        _tao_any,
        ::CF::FileManager::MountPointAlreadyExists::_tao_any_destructor,
        ::CF::FileManager::_tc_MountPointAlreadyExists,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::FileManager::MountPointAlreadyExists *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::FileManager::MountPointAlreadyExists>::insert (
        _tao_any,
        ::CF::FileManager::MountPointAlreadyExists::_tao_any_destructor,
        ::CF::FileManager::_tc_MountPointAlreadyExists,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::FileManager::MountPointAlreadyExists *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::FileManager::MountPointAlreadyExists *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::FileManager::MountPointAlreadyExists *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::FileManager::MountPointAlreadyExists>::extract (
          _tao_any,
          ::CF::FileManager::MountPointAlreadyExists::_tao_any_destructor,
          ::CF::FileManager::_tc_MountPointAlreadyExists,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::FileManager::MountPointAlreadyExists &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::FileManager::MountPointAlreadyExists>::insert_copy (
      _tao_any,
      CF::FileManager::MountPointAlreadyExists::_tao_any_destructor,
      CF::FileManager::_tc_MountPointAlreadyExists,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::FileManager::MountPointAlreadyExists *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::FileManager::MountPointAlreadyExists>::insert (
      _tao_any,
      CF::FileManager::MountPointAlreadyExists::_tao_any_destructor,
      CF::FileManager::_tc_MountPointAlreadyExists,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::FileManager::MountPointAlreadyExists *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::FileManager::MountPointAlreadyExists *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::FileManager::MountPointAlreadyExists *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::FileManager::MountPointAlreadyExists>::extract (
        _tao_any,
        CF::FileManager::MountPointAlreadyExists::_tao_any_destructor,
        CF::FileManager::_tc_MountPointAlreadyExists,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::PPort>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      PPort_ptr _tao_elem)
  {
    PPort_ptr _tao_objptr =
      PPort::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      PPort_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<PPort>::insert (
        _tao_any,
        PPort::_tao_any_destructor,
        _tc_PPort,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      PPort_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<PPort>::extract (
          _tao_any,
          PPort::_tao_any_destructor,
          _tc_PPort,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::PPort_ptr _tao_elem)
{
  CF::PPort_ptr _tao_objptr =
    CF::PPort::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::PPort_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::PPort>::insert (
      _tao_any,
      CF::PPort::_tao_any_destructor,
      CF::_tc_PPort,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::PPort_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::PPort>::extract (
        _tao_any,
        CF::PPort::_tao_any_destructor,
        CF::_tc_PPort,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::PPort::InvalidPort>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::PPort::InvalidPort &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::PPort::InvalidPort>::insert_copy (
        _tao_any,
        ::CF::PPort::InvalidPort::_tao_any_destructor,
        ::CF::PPort::_tc_InvalidPort,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::PPort::InvalidPort *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::PPort::InvalidPort>::insert (
        _tao_any,
        ::CF::PPort::InvalidPort::_tao_any_destructor,
        ::CF::PPort::_tc_InvalidPort,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::PPort::InvalidPort *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::PPort::InvalidPort *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::PPort::InvalidPort *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::PPort::InvalidPort>::extract (
          _tao_any,
          ::CF::PPort::InvalidPort::_tao_any_destructor,
          ::CF::PPort::_tc_InvalidPort,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::PPort::InvalidPort &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::PPort::InvalidPort>::insert_copy (
      _tao_any,
      CF::PPort::InvalidPort::_tao_any_destructor,
      CF::PPort::_tc_InvalidPort,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::PPort::InvalidPort *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::PPort::InvalidPort>::insert (
      _tao_any,
      CF::PPort::InvalidPort::_tao_any_destructor,
      CF::PPort::_tc_InvalidPort,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::PPort::InvalidPort *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::PPort::InvalidPort *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::PPort::InvalidPort *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::PPort::InvalidPort>::extract (
        _tao_any,
        CF::PPort::InvalidPort::_tao_any_destructor,
        CF::PPort::_tc_InvalidPort,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::PPort::OccupiedPort>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::PPort::OccupiedPort &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::PPort::OccupiedPort>::insert_copy (
        _tao_any,
        ::CF::PPort::OccupiedPort::_tao_any_destructor,
        ::CF::PPort::_tc_OccupiedPort,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::PPort::OccupiedPort *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::PPort::OccupiedPort>::insert (
        _tao_any,
        ::CF::PPort::OccupiedPort::_tao_any_destructor,
        ::CF::PPort::_tc_OccupiedPort,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::PPort::OccupiedPort *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::PPort::OccupiedPort *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::PPort::OccupiedPort *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::PPort::OccupiedPort>::extract (
          _tao_any,
          ::CF::PPort::OccupiedPort::_tao_any_destructor,
          ::CF::PPort::_tc_OccupiedPort,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::PPort::OccupiedPort &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::PPort::OccupiedPort>::insert_copy (
      _tao_any,
      CF::PPort::OccupiedPort::_tao_any_destructor,
      CF::PPort::_tc_OccupiedPort,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::PPort::OccupiedPort *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::PPort::OccupiedPort>::insert (
      _tao_any,
      CF::PPort::OccupiedPort::_tao_any_destructor,
      CF::PPort::_tc_OccupiedPort,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::PPort::OccupiedPort *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::PPort::OccupiedPort *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::PPort::OccupiedPort *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::PPort::OccupiedPort>::extract (
        _tao_any,
        CF::PPort::OccupiedPort::_tao_any_destructor,
        CF::PPort::_tc_OccupiedPort,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::LifeCycle>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      LifeCycle_ptr _tao_elem)
  {
    LifeCycle_ptr _tao_objptr =
      LifeCycle::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      LifeCycle_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<LifeCycle>::insert (
        _tao_any,
        LifeCycle::_tao_any_destructor,
        _tc_LifeCycle,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      LifeCycle_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<LifeCycle>::extract (
          _tao_any,
          LifeCycle::_tao_any_destructor,
          _tc_LifeCycle,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::LifeCycle_ptr _tao_elem)
{
  CF::LifeCycle_ptr _tao_objptr =
    CF::LifeCycle::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::LifeCycle_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::LifeCycle>::insert (
      _tao_any,
      CF::LifeCycle::_tao_any_destructor,
      CF::_tc_LifeCycle,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::LifeCycle_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::LifeCycle>::extract (
        _tao_any,
        CF::LifeCycle::_tao_any_destructor,
        CF::_tc_LifeCycle,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::LifeCycle::InitializeError>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::LifeCycle::InitializeError &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::LifeCycle::InitializeError>::insert_copy (
        _tao_any,
        ::CF::LifeCycle::InitializeError::_tao_any_destructor,
        ::CF::LifeCycle::_tc_InitializeError,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::LifeCycle::InitializeError *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::LifeCycle::InitializeError>::insert (
        _tao_any,
        ::CF::LifeCycle::InitializeError::_tao_any_destructor,
        ::CF::LifeCycle::_tc_InitializeError,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::LifeCycle::InitializeError *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::LifeCycle::InitializeError *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::LifeCycle::InitializeError *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::LifeCycle::InitializeError>::extract (
          _tao_any,
          ::CF::LifeCycle::InitializeError::_tao_any_destructor,
          ::CF::LifeCycle::_tc_InitializeError,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::LifeCycle::InitializeError &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::LifeCycle::InitializeError>::insert_copy (
      _tao_any,
      CF::LifeCycle::InitializeError::_tao_any_destructor,
      CF::LifeCycle::_tc_InitializeError,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::LifeCycle::InitializeError *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::LifeCycle::InitializeError>::insert (
      _tao_any,
      CF::LifeCycle::InitializeError::_tao_any_destructor,
      CF::LifeCycle::_tc_InitializeError,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::LifeCycle::InitializeError *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::LifeCycle::InitializeError *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::LifeCycle::InitializeError *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::LifeCycle::InitializeError>::extract (
        _tao_any,
        CF::LifeCycle::InitializeError::_tao_any_destructor,
        CF::LifeCycle::_tc_InitializeError,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::LifeCycle::ReleaseError>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::LifeCycle::ReleaseError &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::LifeCycle::ReleaseError>::insert_copy (
        _tao_any,
        ::CF::LifeCycle::ReleaseError::_tao_any_destructor,
        ::CF::LifeCycle::_tc_ReleaseError,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::LifeCycle::ReleaseError *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::LifeCycle::ReleaseError>::insert (
        _tao_any,
        ::CF::LifeCycle::ReleaseError::_tao_any_destructor,
        ::CF::LifeCycle::_tc_ReleaseError,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::LifeCycle::ReleaseError *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::LifeCycle::ReleaseError *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::LifeCycle::ReleaseError *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::LifeCycle::ReleaseError>::extract (
          _tao_any,
          ::CF::LifeCycle::ReleaseError::_tao_any_destructor,
          ::CF::LifeCycle::_tc_ReleaseError,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::LifeCycle::ReleaseError &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::LifeCycle::ReleaseError>::insert_copy (
      _tao_any,
      CF::LifeCycle::ReleaseError::_tao_any_destructor,
      CF::LifeCycle::_tc_ReleaseError,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::LifeCycle::ReleaseError *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::LifeCycle::ReleaseError>::insert (
      _tao_any,
      CF::LifeCycle::ReleaseError::_tao_any_destructor,
      CF::LifeCycle::_tc_ReleaseError,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::LifeCycle::ReleaseError *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::LifeCycle::ReleaseError *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::LifeCycle::ReleaseError *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::LifeCycle::ReleaseError>::extract (
        _tao_any,
        CF::LifeCycle::ReleaseError::_tao_any_destructor,
        CF::LifeCycle::_tc_ReleaseError,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::TestableObject>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      TestableObject_ptr _tao_elem)
  {
    TestableObject_ptr _tao_objptr =
      TestableObject::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      TestableObject_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<TestableObject>::insert (
        _tao_any,
        TestableObject::_tao_any_destructor,
        _tc_TestableObject,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      TestableObject_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<TestableObject>::extract (
          _tao_any,
          TestableObject::_tao_any_destructor,
          _tc_TestableObject,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::TestableObject_ptr _tao_elem)
{
  CF::TestableObject_ptr _tao_objptr =
    CF::TestableObject::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::TestableObject_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::TestableObject>::insert (
      _tao_any,
      CF::TestableObject::_tao_any_destructor,
      CF::_tc_TestableObject,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::TestableObject_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::TestableObject>::extract (
        _tao_any,
        CF::TestableObject::_tao_any_destructor,
        CF::_tc_TestableObject,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::TestableObject::UnknownTest>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::TestableObject::UnknownTest &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::TestableObject::UnknownTest>::insert_copy (
        _tao_any,
        ::CF::TestableObject::UnknownTest::_tao_any_destructor,
        ::CF::TestableObject::_tc_UnknownTest,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::TestableObject::UnknownTest *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::TestableObject::UnknownTest>::insert (
        _tao_any,
        ::CF::TestableObject::UnknownTest::_tao_any_destructor,
        ::CF::TestableObject::_tc_UnknownTest,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::TestableObject::UnknownTest *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::TestableObject::UnknownTest *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::TestableObject::UnknownTest *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::TestableObject::UnknownTest>::extract (
          _tao_any,
          ::CF::TestableObject::UnknownTest::_tao_any_destructor,
          ::CF::TestableObject::_tc_UnknownTest,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::TestableObject::UnknownTest &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::TestableObject::UnknownTest>::insert_copy (
      _tao_any,
      CF::TestableObject::UnknownTest::_tao_any_destructor,
      CF::TestableObject::_tc_UnknownTest,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::TestableObject::UnknownTest *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::TestableObject::UnknownTest>::insert (
      _tao_any,
      CF::TestableObject::UnknownTest::_tao_any_destructor,
      CF::TestableObject::_tc_UnknownTest,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::TestableObject::UnknownTest *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::TestableObject::UnknownTest *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::TestableObject::UnknownTest *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::TestableObject::UnknownTest>::extract (
        _tao_any,
        CF::TestableObject::UnknownTest::_tao_any_destructor,
        CF::TestableObject::_tc_UnknownTest,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::PropertySet>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      PropertySet_ptr _tao_elem)
  {
    PropertySet_ptr _tao_objptr =
      PropertySet::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      PropertySet_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<PropertySet>::insert (
        _tao_any,
        PropertySet::_tao_any_destructor,
        _tc_PropertySet,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      PropertySet_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<PropertySet>::extract (
          _tao_any,
          PropertySet::_tao_any_destructor,
          _tc_PropertySet,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::PropertySet_ptr _tao_elem)
{
  CF::PropertySet_ptr _tao_objptr =
    CF::PropertySet::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::PropertySet_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::PropertySet>::insert (
      _tao_any,
      CF::PropertySet::_tao_any_destructor,
      CF::_tc_PropertySet,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::PropertySet_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::PropertySet>::extract (
        _tao_any,
        CF::PropertySet::_tao_any_destructor,
        CF::_tc_PropertySet,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::PropertySet::InvalidConfiguration>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::PropertySet::InvalidConfiguration &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::PropertySet::InvalidConfiguration>::insert_copy (
        _tao_any,
        ::CF::PropertySet::InvalidConfiguration::_tao_any_destructor,
        ::CF::PropertySet::_tc_InvalidConfiguration,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::PropertySet::InvalidConfiguration *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::PropertySet::InvalidConfiguration>::insert (
        _tao_any,
        ::CF::PropertySet::InvalidConfiguration::_tao_any_destructor,
        ::CF::PropertySet::_tc_InvalidConfiguration,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::PropertySet::InvalidConfiguration *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::PropertySet::InvalidConfiguration *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::PropertySet::InvalidConfiguration *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::PropertySet::InvalidConfiguration>::extract (
          _tao_any,
          ::CF::PropertySet::InvalidConfiguration::_tao_any_destructor,
          ::CF::PropertySet::_tc_InvalidConfiguration,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::PropertySet::InvalidConfiguration &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::PropertySet::InvalidConfiguration>::insert_copy (
      _tao_any,
      CF::PropertySet::InvalidConfiguration::_tao_any_destructor,
      CF::PropertySet::_tc_InvalidConfiguration,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::PropertySet::InvalidConfiguration *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::PropertySet::InvalidConfiguration>::insert (
      _tao_any,
      CF::PropertySet::InvalidConfiguration::_tao_any_destructor,
      CF::PropertySet::_tc_InvalidConfiguration,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::PropertySet::InvalidConfiguration *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::PropertySet::InvalidConfiguration *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::PropertySet::InvalidConfiguration *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::PropertySet::InvalidConfiguration>::extract (
        _tao_any,
        CF::PropertySet::InvalidConfiguration::_tao_any_destructor,
        CF::PropertySet::_tc_InvalidConfiguration,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::PropertySet::PartialConfiguration>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::PropertySet::PartialConfiguration &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::PropertySet::PartialConfiguration>::insert_copy (
        _tao_any,
        ::CF::PropertySet::PartialConfiguration::_tao_any_destructor,
        ::CF::PropertySet::_tc_PartialConfiguration,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::PropertySet::PartialConfiguration *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::PropertySet::PartialConfiguration>::insert (
        _tao_any,
        ::CF::PropertySet::PartialConfiguration::_tao_any_destructor,
        ::CF::PropertySet::_tc_PartialConfiguration,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::PropertySet::PartialConfiguration *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::PropertySet::PartialConfiguration *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::PropertySet::PartialConfiguration *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::PropertySet::PartialConfiguration>::extract (
          _tao_any,
          ::CF::PropertySet::PartialConfiguration::_tao_any_destructor,
          ::CF::PropertySet::_tc_PartialConfiguration,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::PropertySet::PartialConfiguration &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::PropertySet::PartialConfiguration>::insert_copy (
      _tao_any,
      CF::PropertySet::PartialConfiguration::_tao_any_destructor,
      CF::PropertySet::_tc_PartialConfiguration,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::PropertySet::PartialConfiguration *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::PropertySet::PartialConfiguration>::insert (
      _tao_any,
      CF::PropertySet::PartialConfiguration::_tao_any_destructor,
      CF::PropertySet::_tc_PartialConfiguration,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::PropertySet::PartialConfiguration *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::PropertySet::PartialConfiguration *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::PropertySet::PartialConfiguration *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::PropertySet::PartialConfiguration>::extract (
        _tao_any,
        CF::PropertySet::PartialConfiguration::_tao_any_destructor,
        CF::PropertySet::_tc_PartialConfiguration,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::DomainManager>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DomainManager_ptr _tao_elem)
  {
    DomainManager_ptr _tao_objptr =
      DomainManager::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DomainManager_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<DomainManager>::insert (
        _tao_any,
        DomainManager::_tao_any_destructor,
        _tc_DomainManager,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DomainManager_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<DomainManager>::extract (
          _tao_any,
          DomainManager::_tao_any_destructor,
          _tc_DomainManager,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DomainManager_ptr _tao_elem)
{
  CF::DomainManager_ptr _tao_objptr =
    CF::DomainManager::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DomainManager_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::DomainManager>::insert (
      _tao_any,
      CF::DomainManager::_tao_any_destructor,
      CF::_tc_DomainManager,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DomainManager_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::DomainManager>::extract (
        _tao_any,
        CF::DomainManager::_tao_any_destructor,
        CF::_tc_DomainManager,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::DomainManager::ApplicationInstallationError>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::ApplicationInstallationError &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::ApplicationInstallationError>::insert_copy (
        _tao_any,
        ::CF::DomainManager::ApplicationInstallationError::_tao_any_destructor,
        ::CF::DomainManager::_tc_ApplicationInstallationError,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DomainManager::ApplicationInstallationError *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::ApplicationInstallationError>::insert (
        _tao_any,
        ::CF::DomainManager::ApplicationInstallationError::_tao_any_destructor,
        ::CF::DomainManager::_tc_ApplicationInstallationError,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DomainManager::ApplicationInstallationError *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DomainManager::ApplicationInstallationError *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::ApplicationInstallationError *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::ApplicationInstallationError>::extract (
          _tao_any,
          ::CF::DomainManager::ApplicationInstallationError::_tao_any_destructor,
          ::CF::DomainManager::_tc_ApplicationInstallationError,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DomainManager::ApplicationInstallationError &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::ApplicationInstallationError>::insert_copy (
      _tao_any,
      CF::DomainManager::ApplicationInstallationError::_tao_any_destructor,
      CF::DomainManager::_tc_ApplicationInstallationError,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DomainManager::ApplicationInstallationError *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::ApplicationInstallationError>::insert (
      _tao_any,
      CF::DomainManager::ApplicationInstallationError::_tao_any_destructor,
      CF::DomainManager::_tc_ApplicationInstallationError,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DomainManager::ApplicationInstallationError *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DomainManager::ApplicationInstallationError *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DomainManager::ApplicationInstallationError *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DomainManager::ApplicationInstallationError>::extract (
        _tao_any,
        CF::DomainManager::ApplicationInstallationError::_tao_any_destructor,
        CF::DomainManager::_tc_ApplicationInstallationError,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::ApplicationSequence &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::DomainManager::ApplicationSequence *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::ApplicationSequence>::insert_copy (
          _tao_any,
          ::CF::DomainManager::ApplicationSequence::_tao_any_destructor,
          ::CF::DomainManager::_tc_ApplicationSequence,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DomainManager::ApplicationSequence *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::ApplicationSequence>::insert (
        _tao_any,
        ::CF::DomainManager::ApplicationSequence::_tao_any_destructor,
        ::CF::DomainManager::_tc_ApplicationSequence,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DomainManager::ApplicationSequence *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DomainManager::ApplicationSequence *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::ApplicationSequence *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::ApplicationSequence>::extract (
          _tao_any,
          ::CF::DomainManager::ApplicationSequence::_tao_any_destructor,
          ::CF::DomainManager::_tc_ApplicationSequence,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DomainManager::ApplicationSequence &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::DomainManager::ApplicationSequence *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::DomainManager::ApplicationSequence>::insert_copy (
        _tao_any,
        CF::DomainManager::ApplicationSequence::_tao_any_destructor,
        CF::DomainManager::_tc_ApplicationSequence,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DomainManager::ApplicationSequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::ApplicationSequence>::insert (
      _tao_any,
      CF::DomainManager::ApplicationSequence::_tao_any_destructor,
      CF::DomainManager::_tc_ApplicationSequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DomainManager::ApplicationSequence *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DomainManager::ApplicationSequence *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DomainManager::ApplicationSequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DomainManager::ApplicationSequence>::extract (
        _tao_any,
        CF::DomainManager::ApplicationSequence::_tao_any_destructor,
        CF::DomainManager::_tc_ApplicationSequence,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::ApplicationFactorySequence &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::DomainManager::ApplicationFactorySequence *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::ApplicationFactorySequence>::insert_copy (
          _tao_any,
          ::CF::DomainManager::ApplicationFactorySequence::_tao_any_destructor,
          ::CF::DomainManager::_tc_ApplicationFactorySequence,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DomainManager::ApplicationFactorySequence *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::ApplicationFactorySequence>::insert (
        _tao_any,
        ::CF::DomainManager::ApplicationFactorySequence::_tao_any_destructor,
        ::CF::DomainManager::_tc_ApplicationFactorySequence,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DomainManager::ApplicationFactorySequence *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DomainManager::ApplicationFactorySequence *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::ApplicationFactorySequence *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::ApplicationFactorySequence>::extract (
          _tao_any,
          ::CF::DomainManager::ApplicationFactorySequence::_tao_any_destructor,
          ::CF::DomainManager::_tc_ApplicationFactorySequence,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DomainManager::ApplicationFactorySequence &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::DomainManager::ApplicationFactorySequence *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::DomainManager::ApplicationFactorySequence>::insert_copy (
        _tao_any,
        CF::DomainManager::ApplicationFactorySequence::_tao_any_destructor,
        CF::DomainManager::_tc_ApplicationFactorySequence,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DomainManager::ApplicationFactorySequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::ApplicationFactorySequence>::insert (
      _tao_any,
      CF::DomainManager::ApplicationFactorySequence::_tao_any_destructor,
      CF::DomainManager::_tc_ApplicationFactorySequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DomainManager::ApplicationFactorySequence *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DomainManager::ApplicationFactorySequence *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DomainManager::ApplicationFactorySequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DomainManager::ApplicationFactorySequence>::extract (
        _tao_any,
        CF::DomainManager::ApplicationFactorySequence::_tao_any_destructor,
        CF::DomainManager::_tc_ApplicationFactorySequence,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::DeviceManagerSequence &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::DomainManager::DeviceManagerSequence *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::DeviceManagerSequence>::insert_copy (
          _tao_any,
          ::CF::DomainManager::DeviceManagerSequence::_tao_any_destructor,
          ::CF::DomainManager::_tc_DeviceManagerSequence,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DomainManager::DeviceManagerSequence *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::DeviceManagerSequence>::insert (
        _tao_any,
        ::CF::DomainManager::DeviceManagerSequence::_tao_any_destructor,
        ::CF::DomainManager::_tc_DeviceManagerSequence,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DomainManager::DeviceManagerSequence *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DomainManager::DeviceManagerSequence *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::DeviceManagerSequence *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::DeviceManagerSequence>::extract (
          _tao_any,
          ::CF::DomainManager::DeviceManagerSequence::_tao_any_destructor,
          ::CF::DomainManager::_tc_DeviceManagerSequence,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DomainManager::DeviceManagerSequence &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::DomainManager::DeviceManagerSequence *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::DomainManager::DeviceManagerSequence>::insert_copy (
        _tao_any,
        CF::DomainManager::DeviceManagerSequence::_tao_any_destructor,
        CF::DomainManager::_tc_DeviceManagerSequence,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DomainManager::DeviceManagerSequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::DeviceManagerSequence>::insert (
      _tao_any,
      CF::DomainManager::DeviceManagerSequence::_tao_any_destructor,
      CF::DomainManager::_tc_DeviceManagerSequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DomainManager::DeviceManagerSequence *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DomainManager::DeviceManagerSequence *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DomainManager::DeviceManagerSequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DomainManager::DeviceManagerSequence>::extract (
        _tao_any,
        CF::DomainManager::DeviceManagerSequence::_tao_any_destructor,
        CF::DomainManager::_tc_DeviceManagerSequence,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::DomainManager::InvalidIdentifier>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::InvalidIdentifier &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::InvalidIdentifier>::insert_copy (
        _tao_any,
        ::CF::DomainManager::InvalidIdentifier::_tao_any_destructor,
        ::CF::DomainManager::_tc_InvalidIdentifier,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DomainManager::InvalidIdentifier *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::InvalidIdentifier>::insert (
        _tao_any,
        ::CF::DomainManager::InvalidIdentifier::_tao_any_destructor,
        ::CF::DomainManager::_tc_InvalidIdentifier,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DomainManager::InvalidIdentifier *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DomainManager::InvalidIdentifier *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::InvalidIdentifier *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::InvalidIdentifier>::extract (
          _tao_any,
          ::CF::DomainManager::InvalidIdentifier::_tao_any_destructor,
          ::CF::DomainManager::_tc_InvalidIdentifier,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DomainManager::InvalidIdentifier &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::InvalidIdentifier>::insert_copy (
      _tao_any,
      CF::DomainManager::InvalidIdentifier::_tao_any_destructor,
      CF::DomainManager::_tc_InvalidIdentifier,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DomainManager::InvalidIdentifier *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::InvalidIdentifier>::insert (
      _tao_any,
      CF::DomainManager::InvalidIdentifier::_tao_any_destructor,
      CF::DomainManager::_tc_InvalidIdentifier,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DomainManager::InvalidIdentifier *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DomainManager::InvalidIdentifier *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DomainManager::InvalidIdentifier *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DomainManager::InvalidIdentifier>::extract (
        _tao_any,
        CF::DomainManager::InvalidIdentifier::_tao_any_destructor,
        CF::DomainManager::_tc_InvalidIdentifier,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::DomainManager::DeviceManagerNotRegistered>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::DeviceManagerNotRegistered &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::DeviceManagerNotRegistered>::insert_copy (
        _tao_any,
        ::CF::DomainManager::DeviceManagerNotRegistered::_tao_any_destructor,
        ::CF::DomainManager::_tc_DeviceManagerNotRegistered,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DomainManager::DeviceManagerNotRegistered *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::DeviceManagerNotRegistered>::insert (
        _tao_any,
        ::CF::DomainManager::DeviceManagerNotRegistered::_tao_any_destructor,
        ::CF::DomainManager::_tc_DeviceManagerNotRegistered,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DomainManager::DeviceManagerNotRegistered *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DomainManager::DeviceManagerNotRegistered *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::DeviceManagerNotRegistered *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::DeviceManagerNotRegistered>::extract (
          _tao_any,
          ::CF::DomainManager::DeviceManagerNotRegistered::_tao_any_destructor,
          ::CF::DomainManager::_tc_DeviceManagerNotRegistered,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DomainManager::DeviceManagerNotRegistered &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::DeviceManagerNotRegistered>::insert_copy (
      _tao_any,
      CF::DomainManager::DeviceManagerNotRegistered::_tao_any_destructor,
      CF::DomainManager::_tc_DeviceManagerNotRegistered,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DomainManager::DeviceManagerNotRegistered *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::DeviceManagerNotRegistered>::insert (
      _tao_any,
      CF::DomainManager::DeviceManagerNotRegistered::_tao_any_destructor,
      CF::DomainManager::_tc_DeviceManagerNotRegistered,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DomainManager::DeviceManagerNotRegistered *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DomainManager::DeviceManagerNotRegistered *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DomainManager::DeviceManagerNotRegistered *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DomainManager::DeviceManagerNotRegistered>::extract (
        _tao_any,
        CF::DomainManager::DeviceManagerNotRegistered::_tao_any_destructor,
        CF::DomainManager::_tc_DeviceManagerNotRegistered,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::DomainManager::ApplicationUninstallationError>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::ApplicationUninstallationError &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::ApplicationUninstallationError>::insert_copy (
        _tao_any,
        ::CF::DomainManager::ApplicationUninstallationError::_tao_any_destructor,
        ::CF::DomainManager::_tc_ApplicationUninstallationError,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DomainManager::ApplicationUninstallationError *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::ApplicationUninstallationError>::insert (
        _tao_any,
        ::CF::DomainManager::ApplicationUninstallationError::_tao_any_destructor,
        ::CF::DomainManager::_tc_ApplicationUninstallationError,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DomainManager::ApplicationUninstallationError *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DomainManager::ApplicationUninstallationError *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::ApplicationUninstallationError *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::ApplicationUninstallationError>::extract (
          _tao_any,
          ::CF::DomainManager::ApplicationUninstallationError::_tao_any_destructor,
          ::CF::DomainManager::_tc_ApplicationUninstallationError,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DomainManager::ApplicationUninstallationError &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::ApplicationUninstallationError>::insert_copy (
      _tao_any,
      CF::DomainManager::ApplicationUninstallationError::_tao_any_destructor,
      CF::DomainManager::_tc_ApplicationUninstallationError,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DomainManager::ApplicationUninstallationError *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::ApplicationUninstallationError>::insert (
      _tao_any,
      CF::DomainManager::ApplicationUninstallationError::_tao_any_destructor,
      CF::DomainManager::_tc_ApplicationUninstallationError,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DomainManager::ApplicationUninstallationError *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DomainManager::ApplicationUninstallationError *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DomainManager::ApplicationUninstallationError *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DomainManager::ApplicationUninstallationError>::extract (
        _tao_any,
        CF::DomainManager::ApplicationUninstallationError::_tao_any_destructor,
        CF::DomainManager::_tc_ApplicationUninstallationError,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::DomainManager::RegisterError>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::RegisterError &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::RegisterError>::insert_copy (
        _tao_any,
        ::CF::DomainManager::RegisterError::_tao_any_destructor,
        ::CF::DomainManager::_tc_RegisterError,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DomainManager::RegisterError *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::RegisterError>::insert (
        _tao_any,
        ::CF::DomainManager::RegisterError::_tao_any_destructor,
        ::CF::DomainManager::_tc_RegisterError,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DomainManager::RegisterError *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DomainManager::RegisterError *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::RegisterError *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::RegisterError>::extract (
          _tao_any,
          ::CF::DomainManager::RegisterError::_tao_any_destructor,
          ::CF::DomainManager::_tc_RegisterError,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DomainManager::RegisterError &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::RegisterError>::insert_copy (
      _tao_any,
      CF::DomainManager::RegisterError::_tao_any_destructor,
      CF::DomainManager::_tc_RegisterError,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DomainManager::RegisterError *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::RegisterError>::insert (
      _tao_any,
      CF::DomainManager::RegisterError::_tao_any_destructor,
      CF::DomainManager::_tc_RegisterError,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DomainManager::RegisterError *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DomainManager::RegisterError *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DomainManager::RegisterError *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DomainManager::RegisterError>::extract (
        _tao_any,
        CF::DomainManager::RegisterError::_tao_any_destructor,
        CF::DomainManager::_tc_RegisterError,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::DomainManager::UnregisterError>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::UnregisterError &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::UnregisterError>::insert_copy (
        _tao_any,
        ::CF::DomainManager::UnregisterError::_tao_any_destructor,
        ::CF::DomainManager::_tc_UnregisterError,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DomainManager::UnregisterError *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::UnregisterError>::insert (
        _tao_any,
        ::CF::DomainManager::UnregisterError::_tao_any_destructor,
        ::CF::DomainManager::_tc_UnregisterError,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DomainManager::UnregisterError *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DomainManager::UnregisterError *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::UnregisterError *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::UnregisterError>::extract (
          _tao_any,
          ::CF::DomainManager::UnregisterError::_tao_any_destructor,
          ::CF::DomainManager::_tc_UnregisterError,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DomainManager::UnregisterError &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::UnregisterError>::insert_copy (
      _tao_any,
      CF::DomainManager::UnregisterError::_tao_any_destructor,
      CF::DomainManager::_tc_UnregisterError,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DomainManager::UnregisterError *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::UnregisterError>::insert (
      _tao_any,
      CF::DomainManager::UnregisterError::_tao_any_destructor,
      CF::DomainManager::_tc_UnregisterError,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DomainManager::UnregisterError *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DomainManager::UnregisterError *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DomainManager::UnregisterError *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DomainManager::UnregisterError>::extract (
        _tao_any,
        CF::DomainManager::UnregisterError::_tao_any_destructor,
        CF::DomainManager::_tc_UnregisterError,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::DomainManager::AlreadyConnected>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::AlreadyConnected &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::AlreadyConnected>::insert_copy (
        _tao_any,
        ::CF::DomainManager::AlreadyConnected::_tao_any_destructor,
        ::CF::DomainManager::_tc_AlreadyConnected,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DomainManager::AlreadyConnected *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::AlreadyConnected>::insert (
        _tao_any,
        ::CF::DomainManager::AlreadyConnected::_tao_any_destructor,
        ::CF::DomainManager::_tc_AlreadyConnected,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DomainManager::AlreadyConnected *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DomainManager::AlreadyConnected *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::AlreadyConnected *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::AlreadyConnected>::extract (
          _tao_any,
          ::CF::DomainManager::AlreadyConnected::_tao_any_destructor,
          ::CF::DomainManager::_tc_AlreadyConnected,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DomainManager::AlreadyConnected &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::AlreadyConnected>::insert_copy (
      _tao_any,
      CF::DomainManager::AlreadyConnected::_tao_any_destructor,
      CF::DomainManager::_tc_AlreadyConnected,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DomainManager::AlreadyConnected *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::AlreadyConnected>::insert (
      _tao_any,
      CF::DomainManager::AlreadyConnected::_tao_any_destructor,
      CF::DomainManager::_tc_AlreadyConnected,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DomainManager::AlreadyConnected *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DomainManager::AlreadyConnected *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DomainManager::AlreadyConnected *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DomainManager::AlreadyConnected>::extract (
        _tao_any,
        CF::DomainManager::AlreadyConnected::_tao_any_destructor,
        CF::DomainManager::_tc_AlreadyConnected,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::DomainManager::InvalidEventChannelName>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::InvalidEventChannelName &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::InvalidEventChannelName>::insert_copy (
        _tao_any,
        ::CF::DomainManager::InvalidEventChannelName::_tao_any_destructor,
        ::CF::DomainManager::_tc_InvalidEventChannelName,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DomainManager::InvalidEventChannelName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::InvalidEventChannelName>::insert (
        _tao_any,
        ::CF::DomainManager::InvalidEventChannelName::_tao_any_destructor,
        ::CF::DomainManager::_tc_InvalidEventChannelName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DomainManager::InvalidEventChannelName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DomainManager::InvalidEventChannelName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::InvalidEventChannelName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::InvalidEventChannelName>::extract (
          _tao_any,
          ::CF::DomainManager::InvalidEventChannelName::_tao_any_destructor,
          ::CF::DomainManager::_tc_InvalidEventChannelName,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DomainManager::InvalidEventChannelName &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::InvalidEventChannelName>::insert_copy (
      _tao_any,
      CF::DomainManager::InvalidEventChannelName::_tao_any_destructor,
      CF::DomainManager::_tc_InvalidEventChannelName,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DomainManager::InvalidEventChannelName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::InvalidEventChannelName>::insert (
      _tao_any,
      CF::DomainManager::InvalidEventChannelName::_tao_any_destructor,
      CF::DomainManager::_tc_InvalidEventChannelName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DomainManager::InvalidEventChannelName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DomainManager::InvalidEventChannelName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DomainManager::InvalidEventChannelName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DomainManager::InvalidEventChannelName>::extract (
        _tao_any,
        CF::DomainManager::InvalidEventChannelName::_tao_any_destructor,
        CF::DomainManager::_tc_InvalidEventChannelName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::DomainManager::NotConnected>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::NotConnected &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::NotConnected>::insert_copy (
        _tao_any,
        ::CF::DomainManager::NotConnected::_tao_any_destructor,
        ::CF::DomainManager::_tc_NotConnected,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DomainManager::NotConnected *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DomainManager::NotConnected>::insert (
        _tao_any,
        ::CF::DomainManager::NotConnected::_tao_any_destructor,
        ::CF::DomainManager::_tc_NotConnected,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DomainManager::NotConnected *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DomainManager::NotConnected *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DomainManager::NotConnected *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DomainManager::NotConnected>::extract (
          _tao_any,
          ::CF::DomainManager::NotConnected::_tao_any_destructor,
          ::CF::DomainManager::_tc_NotConnected,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DomainManager::NotConnected &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::NotConnected>::insert_copy (
      _tao_any,
      CF::DomainManager::NotConnected::_tao_any_destructor,
      CF::DomainManager::_tc_NotConnected,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DomainManager::NotConnected *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DomainManager::NotConnected>::insert (
      _tao_any,
      CF::DomainManager::NotConnected::_tao_any_destructor,
      CF::DomainManager::_tc_NotConnected,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DomainManager::NotConnected *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DomainManager::NotConnected *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DomainManager::NotConnected *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DomainManager::NotConnected>::extract (
        _tao_any,
        CF::DomainManager::NotConnected::_tao_any_destructor,
        CF::DomainManager::_tc_NotConnected,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::ApplicationFactory>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ApplicationFactory_ptr _tao_elem)
  {
    ApplicationFactory_ptr _tao_objptr =
      ApplicationFactory::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ApplicationFactory_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<ApplicationFactory>::insert (
        _tao_any,
        ApplicationFactory::_tao_any_destructor,
        _tc_ApplicationFactory,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      ApplicationFactory_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<ApplicationFactory>::extract (
          _tao_any,
          ApplicationFactory::_tao_any_destructor,
          _tc_ApplicationFactory,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ApplicationFactory_ptr _tao_elem)
{
  CF::ApplicationFactory_ptr _tao_objptr =
    CF::ApplicationFactory::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ApplicationFactory_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::ApplicationFactory>::insert (
      _tao_any,
      CF::ApplicationFactory::_tao_any_destructor,
      CF::_tc_ApplicationFactory,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ApplicationFactory_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::ApplicationFactory>::extract (
        _tao_any,
        CF::ApplicationFactory::_tao_any_destructor,
        CF::_tc_ApplicationFactory,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::ApplicationFactory::CreateApplicationRequestError>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::ApplicationFactory::CreateApplicationRequestError &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ApplicationFactory::CreateApplicationRequestError>::insert_copy (
        _tao_any,
        ::CF::ApplicationFactory::CreateApplicationRequestError::_tao_any_destructor,
        ::CF::ApplicationFactory::_tc_CreateApplicationRequestError,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::ApplicationFactory::CreateApplicationRequestError *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ApplicationFactory::CreateApplicationRequestError>::insert (
        _tao_any,
        ::CF::ApplicationFactory::CreateApplicationRequestError::_tao_any_destructor,
        ::CF::ApplicationFactory::_tc_CreateApplicationRequestError,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::ApplicationFactory::CreateApplicationRequestError *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::ApplicationFactory::CreateApplicationRequestError *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::ApplicationFactory::CreateApplicationRequestError *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::ApplicationFactory::CreateApplicationRequestError>::extract (
          _tao_any,
          ::CF::ApplicationFactory::CreateApplicationRequestError::_tao_any_destructor,
          ::CF::ApplicationFactory::_tc_CreateApplicationRequestError,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::ApplicationFactory::CreateApplicationRequestError &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ApplicationFactory::CreateApplicationRequestError>::insert_copy (
      _tao_any,
      CF::ApplicationFactory::CreateApplicationRequestError::_tao_any_destructor,
      CF::ApplicationFactory::_tc_CreateApplicationRequestError,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ApplicationFactory::CreateApplicationRequestError *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ApplicationFactory::CreateApplicationRequestError>::insert (
      _tao_any,
      CF::ApplicationFactory::CreateApplicationRequestError::_tao_any_destructor,
      CF::ApplicationFactory::_tc_CreateApplicationRequestError,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ApplicationFactory::CreateApplicationRequestError *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::ApplicationFactory::CreateApplicationRequestError *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::ApplicationFactory::CreateApplicationRequestError *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::ApplicationFactory::CreateApplicationRequestError>::extract (
        _tao_any,
        CF::ApplicationFactory::CreateApplicationRequestError::_tao_any_destructor,
        CF::ApplicationFactory::_tc_CreateApplicationRequestError,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::ApplicationFactory::CreateApplicationError>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::ApplicationFactory::CreateApplicationError &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ApplicationFactory::CreateApplicationError>::insert_copy (
        _tao_any,
        ::CF::ApplicationFactory::CreateApplicationError::_tao_any_destructor,
        ::CF::ApplicationFactory::_tc_CreateApplicationError,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::ApplicationFactory::CreateApplicationError *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ApplicationFactory::CreateApplicationError>::insert (
        _tao_any,
        ::CF::ApplicationFactory::CreateApplicationError::_tao_any_destructor,
        ::CF::ApplicationFactory::_tc_CreateApplicationError,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::ApplicationFactory::CreateApplicationError *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::ApplicationFactory::CreateApplicationError *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::ApplicationFactory::CreateApplicationError *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::ApplicationFactory::CreateApplicationError>::extract (
          _tao_any,
          ::CF::ApplicationFactory::CreateApplicationError::_tao_any_destructor,
          ::CF::ApplicationFactory::_tc_CreateApplicationError,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::ApplicationFactory::CreateApplicationError &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ApplicationFactory::CreateApplicationError>::insert_copy (
      _tao_any,
      CF::ApplicationFactory::CreateApplicationError::_tao_any_destructor,
      CF::ApplicationFactory::_tc_CreateApplicationError,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ApplicationFactory::CreateApplicationError *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ApplicationFactory::CreateApplicationError>::insert (
      _tao_any,
      CF::ApplicationFactory::CreateApplicationError::_tao_any_destructor,
      CF::ApplicationFactory::_tc_CreateApplicationError,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ApplicationFactory::CreateApplicationError *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::ApplicationFactory::CreateApplicationError *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::ApplicationFactory::CreateApplicationError *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::ApplicationFactory::CreateApplicationError>::extract (
        _tao_any,
        CF::ApplicationFactory::CreateApplicationError::_tao_any_destructor,
        CF::ApplicationFactory::_tc_CreateApplicationError,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::ApplicationFactory::InvalidInitConfiguration>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::ApplicationFactory::InvalidInitConfiguration &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ApplicationFactory::InvalidInitConfiguration>::insert_copy (
        _tao_any,
        ::CF::ApplicationFactory::InvalidInitConfiguration::_tao_any_destructor,
        ::CF::ApplicationFactory::_tc_InvalidInitConfiguration,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::ApplicationFactory::InvalidInitConfiguration *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ApplicationFactory::InvalidInitConfiguration>::insert (
        _tao_any,
        ::CF::ApplicationFactory::InvalidInitConfiguration::_tao_any_destructor,
        ::CF::ApplicationFactory::_tc_InvalidInitConfiguration,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::ApplicationFactory::InvalidInitConfiguration *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::ApplicationFactory::InvalidInitConfiguration *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::ApplicationFactory::InvalidInitConfiguration *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::ApplicationFactory::InvalidInitConfiguration>::extract (
          _tao_any,
          ::CF::ApplicationFactory::InvalidInitConfiguration::_tao_any_destructor,
          ::CF::ApplicationFactory::_tc_InvalidInitConfiguration,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::ApplicationFactory::InvalidInitConfiguration &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ApplicationFactory::InvalidInitConfiguration>::insert_copy (
      _tao_any,
      CF::ApplicationFactory::InvalidInitConfiguration::_tao_any_destructor,
      CF::ApplicationFactory::_tc_InvalidInitConfiguration,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ApplicationFactory::InvalidInitConfiguration *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ApplicationFactory::InvalidInitConfiguration>::insert (
      _tao_any,
      CF::ApplicationFactory::InvalidInitConfiguration::_tao_any_destructor,
      CF::ApplicationFactory::_tc_InvalidInitConfiguration,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ApplicationFactory::InvalidInitConfiguration *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::ApplicationFactory::InvalidInitConfiguration *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::ApplicationFactory::InvalidInitConfiguration *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::ApplicationFactory::InvalidInitConfiguration>::extract (
        _tao_any,
        CF::ApplicationFactory::InvalidInitConfiguration::_tao_any_destructor,
        CF::ApplicationFactory::_tc_InvalidInitConfiguration,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::PortSupplier>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      PortSupplier_ptr _tao_elem)
  {
    PortSupplier_ptr _tao_objptr =
      PortSupplier::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      PortSupplier_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<PortSupplier>::insert (
        _tao_any,
        PortSupplier::_tao_any_destructor,
        _tc_PortSupplier,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      PortSupplier_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<PortSupplier>::extract (
          _tao_any,
          PortSupplier::_tao_any_destructor,
          _tc_PortSupplier,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::PortSupplier_ptr _tao_elem)
{
  CF::PortSupplier_ptr _tao_objptr =
    CF::PortSupplier::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::PortSupplier_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::PortSupplier>::insert (
      _tao_any,
      CF::PortSupplier::_tao_any_destructor,
      CF::_tc_PortSupplier,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::PortSupplier_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::PortSupplier>::extract (
        _tao_any,
        CF::PortSupplier::_tao_any_destructor,
        CF::_tc_PortSupplier,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::PortSupplier::UnknownPort>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::PortSupplier::UnknownPort &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::PortSupplier::UnknownPort>::insert_copy (
        _tao_any,
        ::CF::PortSupplier::UnknownPort::_tao_any_destructor,
        ::CF::PortSupplier::_tc_UnknownPort,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::PortSupplier::UnknownPort *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::PortSupplier::UnknownPort>::insert (
        _tao_any,
        ::CF::PortSupplier::UnknownPort::_tao_any_destructor,
        ::CF::PortSupplier::_tc_UnknownPort,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::PortSupplier::UnknownPort *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::PortSupplier::UnknownPort *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::PortSupplier::UnknownPort *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::PortSupplier::UnknownPort>::extract (
          _tao_any,
          ::CF::PortSupplier::UnknownPort::_tao_any_destructor,
          ::CF::PortSupplier::_tc_UnknownPort,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::PortSupplier::UnknownPort &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::PortSupplier::UnknownPort>::insert_copy (
      _tao_any,
      CF::PortSupplier::UnknownPort::_tao_any_destructor,
      CF::PortSupplier::_tc_UnknownPort,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::PortSupplier::UnknownPort *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::PortSupplier::UnknownPort>::insert (
      _tao_any,
      CF::PortSupplier::UnknownPort::_tao_any_destructor,
      CF::PortSupplier::_tc_UnknownPort,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::PortSupplier::UnknownPort *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::PortSupplier::UnknownPort *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::PortSupplier::UnknownPort *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::PortSupplier::UnknownPort>::extract (
        _tao_any,
        CF::PortSupplier::UnknownPort::_tao_any_destructor,
        CF::PortSupplier::_tc_UnknownPort,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::Resource>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Resource_ptr _tao_elem)
  {
    Resource_ptr _tao_objptr =
      Resource::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Resource_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Resource>::insert (
        _tao_any,
        Resource::_tao_any_destructor,
        _tc_Resource,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Resource_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Resource>::extract (
          _tao_any,
          Resource::_tao_any_destructor,
          _tc_Resource,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Resource_ptr _tao_elem)
{
  CF::Resource_ptr _tao_objptr =
    CF::Resource::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Resource_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::Resource>::insert (
      _tao_any,
      CF::Resource::_tao_any_destructor,
      CF::_tc_Resource,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Resource_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::Resource>::extract (
        _tao_any,
        CF::Resource::_tao_any_destructor,
        CF::_tc_Resource,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::Resource::StartError>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::Resource::StartError &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::Resource::StartError>::insert_copy (
        _tao_any,
        ::CF::Resource::StartError::_tao_any_destructor,
        ::CF::Resource::_tc_StartError,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::Resource::StartError *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::Resource::StartError>::insert (
        _tao_any,
        ::CF::Resource::StartError::_tao_any_destructor,
        ::CF::Resource::_tc_StartError,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::Resource::StartError *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::Resource::StartError *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::Resource::StartError *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::Resource::StartError>::extract (
          _tao_any,
          ::CF::Resource::StartError::_tao_any_destructor,
          ::CF::Resource::_tc_StartError,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::Resource::StartError &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::Resource::StartError>::insert_copy (
      _tao_any,
      CF::Resource::StartError::_tao_any_destructor,
      CF::Resource::_tc_StartError,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Resource::StartError *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::Resource::StartError>::insert (
      _tao_any,
      CF::Resource::StartError::_tao_any_destructor,
      CF::Resource::_tc_StartError,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Resource::StartError *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::Resource::StartError *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::Resource::StartError *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::Resource::StartError>::extract (
        _tao_any,
        CF::Resource::StartError::_tao_any_destructor,
        CF::Resource::_tc_StartError,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::Resource::StopError>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::Resource::StopError &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::Resource::StopError>::insert_copy (
        _tao_any,
        ::CF::Resource::StopError::_tao_any_destructor,
        ::CF::Resource::_tc_StopError,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::Resource::StopError *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::Resource::StopError>::insert (
        _tao_any,
        ::CF::Resource::StopError::_tao_any_destructor,
        ::CF::Resource::_tc_StopError,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::Resource::StopError *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::Resource::StopError *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::Resource::StopError *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::Resource::StopError>::extract (
          _tao_any,
          ::CF::Resource::StopError::_tao_any_destructor,
          ::CF::Resource::_tc_StopError,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::Resource::StopError &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::Resource::StopError>::insert_copy (
      _tao_any,
      CF::Resource::StopError::_tao_any_destructor,
      CF::Resource::_tc_StopError,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Resource::StopError *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::Resource::StopError>::insert (
      _tao_any,
      CF::Resource::StopError::_tao_any_destructor,
      CF::Resource::_tc_StopError,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Resource::StopError *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::Resource::StopError *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::Resource::StopError *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::Resource::StopError>::extract (
        _tao_any,
        CF::Resource::StopError::_tao_any_destructor,
        CF::Resource::_tc_StopError,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::Device>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Device_ptr _tao_elem)
  {
    Device_ptr _tao_objptr =
      Device::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Device_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Device>::insert (
        _tao_any,
        Device::_tao_any_destructor,
        _tc_Device,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Device_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Device>::extract (
          _tao_any,
          Device::_tao_any_destructor,
          _tc_Device,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Device_ptr _tao_elem)
{
  CF::Device_ptr _tao_objptr =
    CF::Device::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Device_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::Device>::insert (
      _tao_any,
      CF::Device::_tao_any_destructor,
      CF::_tc_Device,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Device_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::Device>::extract (
        _tao_any,
        CF::Device::_tao_any_destructor,
        CF::_tc_Device,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::Device::InvalidState>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::Device::InvalidState &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::Device::InvalidState>::insert_copy (
        _tao_any,
        ::CF::Device::InvalidState::_tao_any_destructor,
        ::CF::Device::_tc_InvalidState,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::Device::InvalidState *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::Device::InvalidState>::insert (
        _tao_any,
        ::CF::Device::InvalidState::_tao_any_destructor,
        ::CF::Device::_tc_InvalidState,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::Device::InvalidState *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::Device::InvalidState *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::Device::InvalidState *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::Device::InvalidState>::extract (
          _tao_any,
          ::CF::Device::InvalidState::_tao_any_destructor,
          ::CF::Device::_tc_InvalidState,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::Device::InvalidState &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::Device::InvalidState>::insert_copy (
      _tao_any,
      CF::Device::InvalidState::_tao_any_destructor,
      CF::Device::_tc_InvalidState,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Device::InvalidState *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::Device::InvalidState>::insert (
      _tao_any,
      CF::Device::InvalidState::_tao_any_destructor,
      CF::Device::_tc_InvalidState,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Device::InvalidState *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::Device::InvalidState *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::Device::InvalidState *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::Device::InvalidState>::extract (
        _tao_any,
        CF::Device::InvalidState::_tao_any_destructor,
        CF::Device::_tc_InvalidState,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::Device::InvalidCapacity>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::Device::InvalidCapacity &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::Device::InvalidCapacity>::insert_copy (
        _tao_any,
        ::CF::Device::InvalidCapacity::_tao_any_destructor,
        ::CF::Device::_tc_InvalidCapacity,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::Device::InvalidCapacity *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::Device::InvalidCapacity>::insert (
        _tao_any,
        ::CF::Device::InvalidCapacity::_tao_any_destructor,
        ::CF::Device::_tc_InvalidCapacity,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::Device::InvalidCapacity *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::Device::InvalidCapacity *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::Device::InvalidCapacity *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::Device::InvalidCapacity>::extract (
          _tao_any,
          ::CF::Device::InvalidCapacity::_tao_any_destructor,
          ::CF::Device::_tc_InvalidCapacity,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::Device::InvalidCapacity &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::Device::InvalidCapacity>::insert_copy (
      _tao_any,
      CF::Device::InvalidCapacity::_tao_any_destructor,
      CF::Device::_tc_InvalidCapacity,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Device::InvalidCapacity *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::Device::InvalidCapacity>::insert (
      _tao_any,
      CF::Device::InvalidCapacity::_tao_any_destructor,
      CF::Device::_tc_InvalidCapacity,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Device::InvalidCapacity *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::Device::InvalidCapacity *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::Device::InvalidCapacity *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::Device::InvalidCapacity>::extract (
        _tao_any,
        CF::Device::InvalidCapacity::_tao_any_destructor,
        CF::Device::_tc_InvalidCapacity,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::Device::AdminType _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::CF::Device::AdminType>::insert (
        _tao_any,
        ::CF::Device::_tc_AdminType,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::Device::AdminType &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::CF::Device::AdminType>::extract (
          _tao_any,
          ::CF::Device::_tc_AdminType,
          _tao_elem 
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Device::AdminType _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<CF::Device::AdminType>::insert (
      _tao_any,
      CF::Device::_tc_AdminType,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Device::AdminType &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<CF::Device::AdminType>::extract (
        _tao_any,
        CF::Device::_tc_AdminType,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::Device::OperationalType _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::CF::Device::OperationalType>::insert (
        _tao_any,
        ::CF::Device::_tc_OperationalType,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::Device::OperationalType &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::CF::Device::OperationalType>::extract (
          _tao_any,
          ::CF::Device::_tc_OperationalType,
          _tao_elem 
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Device::OperationalType _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<CF::Device::OperationalType>::insert (
      _tao_any,
      CF::Device::_tc_OperationalType,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Device::OperationalType &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<CF::Device::OperationalType>::extract (
        _tao_any,
        CF::Device::_tc_OperationalType,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::Device::UsageType _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::CF::Device::UsageType>::insert (
        _tao_any,
        ::CF::Device::_tc_UsageType,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::Device::UsageType &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::CF::Device::UsageType>::extract (
          _tao_any,
          ::CF::Device::_tc_UsageType,
          _tao_elem 
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Device::UsageType _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<CF::Device::UsageType>::insert (
      _tao_any,
      CF::Device::_tc_UsageType,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Device::UsageType &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<CF::Device::UsageType>::extract (
        _tao_any,
        CF::Device::_tc_UsageType,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::Application>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Application_ptr _tao_elem)
  {
    Application_ptr _tao_objptr =
      Application::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Application_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Application>::insert (
        _tao_any,
        Application::_tao_any_destructor,
        _tc_Application,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Application_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Application>::extract (
          _tao_any,
          Application::_tao_any_destructor,
          _tc_Application,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Application_ptr _tao_elem)
{
  CF::Application_ptr _tao_objptr =
    CF::Application::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Application_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::Application>::insert (
      _tao_any,
      CF::Application::_tao_any_destructor,
      CF::_tc_Application,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Application_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::Application>::extract (
        _tao_any,
        CF::Application::_tao_any_destructor,
        CF::_tc_Application,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::Application::ComponentProcessIdType &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::Application::ComponentProcessIdType *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::Application::ComponentProcessIdType>::insert_copy (
          _tao_any,
          ::CF::Application::ComponentProcessIdType::_tao_any_destructor,
          ::CF::Application::_tc_ComponentProcessIdType,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CF::Application::ComponentProcessIdType *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::Application::ComponentProcessIdType>::insert (
        _tao_any,
        ::CF::Application::ComponentProcessIdType::_tao_any_destructor,
        ::CF::Application::_tc_ComponentProcessIdType,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::Application::ComponentProcessIdType *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::Application::ComponentProcessIdType *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::Application::ComponentProcessIdType *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::Application::ComponentProcessIdType>::extract (
          _tao_any,
          ::CF::Application::ComponentProcessIdType::_tao_any_destructor,
          ::CF::Application::_tc_ComponentProcessIdType,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::Application::ComponentProcessIdType &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::Application::ComponentProcessIdType *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::Application::ComponentProcessIdType>::insert_copy (
        _tao_any,
        CF::Application::ComponentProcessIdType::_tao_any_destructor,
        CF::Application::_tc_ComponentProcessIdType,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Application::ComponentProcessIdType *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::Application::ComponentProcessIdType>::insert (
      _tao_any,
      CF::Application::ComponentProcessIdType::_tao_any_destructor,
      CF::Application::_tc_ComponentProcessIdType,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Application::ComponentProcessIdType *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::Application::ComponentProcessIdType *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::Application::ComponentProcessIdType *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::Application::ComponentProcessIdType>::extract (
        _tao_any,
        CF::Application::ComponentProcessIdType::_tao_any_destructor,
        CF::Application::_tc_ComponentProcessIdType,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::Application::ComponentProcessIdSequence &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::Application::ComponentProcessIdSequence *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::Application::ComponentProcessIdSequence>::insert_copy (
          _tao_any,
          ::CF::Application::ComponentProcessIdSequence::_tao_any_destructor,
          ::CF::Application::_tc_ComponentProcessIdSequence,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::Application::ComponentProcessIdSequence *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::Application::ComponentProcessIdSequence>::insert (
        _tao_any,
        ::CF::Application::ComponentProcessIdSequence::_tao_any_destructor,
        ::CF::Application::_tc_ComponentProcessIdSequence,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::Application::ComponentProcessIdSequence *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::Application::ComponentProcessIdSequence *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::Application::ComponentProcessIdSequence *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::Application::ComponentProcessIdSequence>::extract (
          _tao_any,
          ::CF::Application::ComponentProcessIdSequence::_tao_any_destructor,
          ::CF::Application::_tc_ComponentProcessIdSequence,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::Application::ComponentProcessIdSequence &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::Application::ComponentProcessIdSequence *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::Application::ComponentProcessIdSequence>::insert_copy (
        _tao_any,
        CF::Application::ComponentProcessIdSequence::_tao_any_destructor,
        CF::Application::_tc_ComponentProcessIdSequence,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Application::ComponentProcessIdSequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::Application::ComponentProcessIdSequence>::insert (
      _tao_any,
      CF::Application::ComponentProcessIdSequence::_tao_any_destructor,
      CF::Application::_tc_ComponentProcessIdSequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Application::ComponentProcessIdSequence *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::Application::ComponentProcessIdSequence *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::Application::ComponentProcessIdSequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::Application::ComponentProcessIdSequence>::extract (
        _tao_any,
        CF::Application::ComponentProcessIdSequence::_tao_any_destructor,
        CF::Application::_tc_ComponentProcessIdSequence,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::Application::ComponentElementType &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::Application::ComponentElementType *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::Application::ComponentElementType>::insert_copy (
          _tao_any,
          ::CF::Application::ComponentElementType::_tao_any_destructor,
          ::CF::Application::_tc_ComponentElementType,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CF::Application::ComponentElementType *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::Application::ComponentElementType>::insert (
        _tao_any,
        ::CF::Application::ComponentElementType::_tao_any_destructor,
        ::CF::Application::_tc_ComponentElementType,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::Application::ComponentElementType *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::Application::ComponentElementType *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::Application::ComponentElementType *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::Application::ComponentElementType>::extract (
          _tao_any,
          ::CF::Application::ComponentElementType::_tao_any_destructor,
          ::CF::Application::_tc_ComponentElementType,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::Application::ComponentElementType &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::Application::ComponentElementType *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::Application::ComponentElementType>::insert_copy (
        _tao_any,
        CF::Application::ComponentElementType::_tao_any_destructor,
        CF::Application::_tc_ComponentElementType,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Application::ComponentElementType *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::Application::ComponentElementType>::insert (
      _tao_any,
      CF::Application::ComponentElementType::_tao_any_destructor,
      CF::Application::_tc_ComponentElementType,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Application::ComponentElementType *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::Application::ComponentElementType *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::Application::ComponentElementType *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::Application::ComponentElementType>::extract (
        _tao_any,
        CF::Application::ComponentElementType::_tao_any_destructor,
        CF::Application::_tc_ComponentElementType,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::Application::ComponentElementSequence &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::Application::ComponentElementSequence *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::Application::ComponentElementSequence>::insert_copy (
          _tao_any,
          ::CF::Application::ComponentElementSequence::_tao_any_destructor,
          ::CF::Application::_tc_ComponentElementSequence,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::Application::ComponentElementSequence *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::Application::ComponentElementSequence>::insert (
        _tao_any,
        ::CF::Application::ComponentElementSequence::_tao_any_destructor,
        ::CF::Application::_tc_ComponentElementSequence,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::Application::ComponentElementSequence *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::Application::ComponentElementSequence *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::Application::ComponentElementSequence *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::Application::ComponentElementSequence>::extract (
          _tao_any,
          ::CF::Application::ComponentElementSequence::_tao_any_destructor,
          ::CF::Application::_tc_ComponentElementSequence,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::Application::ComponentElementSequence &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::Application::ComponentElementSequence *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::Application::ComponentElementSequence>::insert_copy (
        _tao_any,
        CF::Application::ComponentElementSequence::_tao_any_destructor,
        CF::Application::_tc_ComponentElementSequence,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::Application::ComponentElementSequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::Application::ComponentElementSequence>::insert (
      _tao_any,
      CF::Application::ComponentElementSequence::_tao_any_destructor,
      CF::Application::_tc_ComponentElementSequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::Application::ComponentElementSequence *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::Application::ComponentElementSequence *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::Application::ComponentElementSequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::Application::ComponentElementSequence>::extract (
        _tao_any,
        CF::Application::ComponentElementSequence::_tao_any_destructor,
        CF::Application::_tc_ComponentElementSequence,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::LoadableDevice>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      LoadableDevice_ptr _tao_elem)
  {
    LoadableDevice_ptr _tao_objptr =
      LoadableDevice::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      LoadableDevice_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<LoadableDevice>::insert (
        _tao_any,
        LoadableDevice::_tao_any_destructor,
        _tc_LoadableDevice,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      LoadableDevice_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<LoadableDevice>::extract (
          _tao_any,
          LoadableDevice::_tao_any_destructor,
          _tc_LoadableDevice,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::LoadableDevice_ptr _tao_elem)
{
  CF::LoadableDevice_ptr _tao_objptr =
    CF::LoadableDevice::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::LoadableDevice_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::LoadableDevice>::insert (
      _tao_any,
      CF::LoadableDevice::_tao_any_destructor,
      CF::_tc_LoadableDevice,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::LoadableDevice_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::LoadableDevice>::extract (
        _tao_any,
        CF::LoadableDevice::_tao_any_destructor,
        CF::_tc_LoadableDevice,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::LoadableDevice::LoadType _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::CF::LoadableDevice::LoadType>::insert (
        _tao_any,
        ::CF::LoadableDevice::_tc_LoadType,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::LoadableDevice::LoadType &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::CF::LoadableDevice::LoadType>::extract (
          _tao_any,
          ::CF::LoadableDevice::_tc_LoadType,
          _tao_elem 
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::LoadableDevice::LoadType _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<CF::LoadableDevice::LoadType>::insert (
      _tao_any,
      CF::LoadableDevice::_tc_LoadType,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::LoadableDevice::LoadType &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<CF::LoadableDevice::LoadType>::extract (
        _tao_any,
        CF::LoadableDevice::_tc_LoadType,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::LoadableDevice::InvalidLoadKind>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::LoadableDevice::InvalidLoadKind &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::LoadableDevice::InvalidLoadKind>::insert_copy (
        _tao_any,
        ::CF::LoadableDevice::InvalidLoadKind::_tao_any_destructor,
        ::CF::LoadableDevice::_tc_InvalidLoadKind,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::LoadableDevice::InvalidLoadKind *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::LoadableDevice::InvalidLoadKind>::insert (
        _tao_any,
        ::CF::LoadableDevice::InvalidLoadKind::_tao_any_destructor,
        ::CF::LoadableDevice::_tc_InvalidLoadKind,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::LoadableDevice::InvalidLoadKind *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::LoadableDevice::InvalidLoadKind *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::LoadableDevice::InvalidLoadKind *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::LoadableDevice::InvalidLoadKind>::extract (
          _tao_any,
          ::CF::LoadableDevice::InvalidLoadKind::_tao_any_destructor,
          ::CF::LoadableDevice::_tc_InvalidLoadKind,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::LoadableDevice::InvalidLoadKind &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::LoadableDevice::InvalidLoadKind>::insert_copy (
      _tao_any,
      CF::LoadableDevice::InvalidLoadKind::_tao_any_destructor,
      CF::LoadableDevice::_tc_InvalidLoadKind,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::LoadableDevice::InvalidLoadKind *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::LoadableDevice::InvalidLoadKind>::insert (
      _tao_any,
      CF::LoadableDevice::InvalidLoadKind::_tao_any_destructor,
      CF::LoadableDevice::_tc_InvalidLoadKind,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::LoadableDevice::InvalidLoadKind *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::LoadableDevice::InvalidLoadKind *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::LoadableDevice::InvalidLoadKind *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::LoadableDevice::InvalidLoadKind>::extract (
        _tao_any,
        CF::LoadableDevice::InvalidLoadKind::_tao_any_destructor,
        CF::LoadableDevice::_tc_InvalidLoadKind,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::LoadableDevice::LoadFail>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::LoadableDevice::LoadFail &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::LoadableDevice::LoadFail>::insert_copy (
        _tao_any,
        ::CF::LoadableDevice::LoadFail::_tao_any_destructor,
        ::CF::LoadableDevice::_tc_LoadFail,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::LoadableDevice::LoadFail *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::LoadableDevice::LoadFail>::insert (
        _tao_any,
        ::CF::LoadableDevice::LoadFail::_tao_any_destructor,
        ::CF::LoadableDevice::_tc_LoadFail,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::LoadableDevice::LoadFail *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::LoadableDevice::LoadFail *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::LoadableDevice::LoadFail *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::LoadableDevice::LoadFail>::extract (
          _tao_any,
          ::CF::LoadableDevice::LoadFail::_tao_any_destructor,
          ::CF::LoadableDevice::_tc_LoadFail,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::LoadableDevice::LoadFail &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::LoadableDevice::LoadFail>::insert_copy (
      _tao_any,
      CF::LoadableDevice::LoadFail::_tao_any_destructor,
      CF::LoadableDevice::_tc_LoadFail,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::LoadableDevice::LoadFail *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::LoadableDevice::LoadFail>::insert (
      _tao_any,
      CF::LoadableDevice::LoadFail::_tao_any_destructor,
      CF::LoadableDevice::_tc_LoadFail,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::LoadableDevice::LoadFail *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::LoadableDevice::LoadFail *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::LoadableDevice::LoadFail *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::LoadableDevice::LoadFail>::extract (
        _tao_any,
        CF::LoadableDevice::LoadFail::_tao_any_destructor,
        CF::LoadableDevice::_tc_LoadFail,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::ExecutableDevice>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ExecutableDevice_ptr _tao_elem)
  {
    ExecutableDevice_ptr _tao_objptr =
      ExecutableDevice::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ExecutableDevice_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<ExecutableDevice>::insert (
        _tao_any,
        ExecutableDevice::_tao_any_destructor,
        _tc_ExecutableDevice,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      ExecutableDevice_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<ExecutableDevice>::extract (
          _tao_any,
          ExecutableDevice::_tao_any_destructor,
          _tc_ExecutableDevice,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ExecutableDevice_ptr _tao_elem)
{
  CF::ExecutableDevice_ptr _tao_objptr =
    CF::ExecutableDevice::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ExecutableDevice_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::ExecutableDevice>::insert (
      _tao_any,
      CF::ExecutableDevice::_tao_any_destructor,
      CF::_tc_ExecutableDevice,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ExecutableDevice_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::ExecutableDevice>::extract (
        _tao_any,
        CF::ExecutableDevice::_tao_any_destructor,
        CF::_tc_ExecutableDevice,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::ExecutableDevice::InvalidProcess>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::ExecutableDevice::InvalidProcess &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::InvalidProcess>::insert_copy (
        _tao_any,
        ::CF::ExecutableDevice::InvalidProcess::_tao_any_destructor,
        ::CF::ExecutableDevice::_tc_InvalidProcess,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::ExecutableDevice::InvalidProcess *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::InvalidProcess>::insert (
        _tao_any,
        ::CF::ExecutableDevice::InvalidProcess::_tao_any_destructor,
        ::CF::ExecutableDevice::_tc_InvalidProcess,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::ExecutableDevice::InvalidProcess *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::ExecutableDevice::InvalidProcess *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::ExecutableDevice::InvalidProcess *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::InvalidProcess>::extract (
          _tao_any,
          ::CF::ExecutableDevice::InvalidProcess::_tao_any_destructor,
          ::CF::ExecutableDevice::_tc_InvalidProcess,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::ExecutableDevice::InvalidProcess &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ExecutableDevice::InvalidProcess>::insert_copy (
      _tao_any,
      CF::ExecutableDevice::InvalidProcess::_tao_any_destructor,
      CF::ExecutableDevice::_tc_InvalidProcess,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ExecutableDevice::InvalidProcess *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ExecutableDevice::InvalidProcess>::insert (
      _tao_any,
      CF::ExecutableDevice::InvalidProcess::_tao_any_destructor,
      CF::ExecutableDevice::_tc_InvalidProcess,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ExecutableDevice::InvalidProcess *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::ExecutableDevice::InvalidProcess *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::ExecutableDevice::InvalidProcess *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::ExecutableDevice::InvalidProcess>::extract (
        _tao_any,
        CF::ExecutableDevice::InvalidProcess::_tao_any_destructor,
        CF::ExecutableDevice::_tc_InvalidProcess,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::ExecutableDevice::InvalidFunction>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::ExecutableDevice::InvalidFunction &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::InvalidFunction>::insert_copy (
        _tao_any,
        ::CF::ExecutableDevice::InvalidFunction::_tao_any_destructor,
        ::CF::ExecutableDevice::_tc_InvalidFunction,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::ExecutableDevice::InvalidFunction *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::InvalidFunction>::insert (
        _tao_any,
        ::CF::ExecutableDevice::InvalidFunction::_tao_any_destructor,
        ::CF::ExecutableDevice::_tc_InvalidFunction,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::ExecutableDevice::InvalidFunction *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::ExecutableDevice::InvalidFunction *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::ExecutableDevice::InvalidFunction *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::InvalidFunction>::extract (
          _tao_any,
          ::CF::ExecutableDevice::InvalidFunction::_tao_any_destructor,
          ::CF::ExecutableDevice::_tc_InvalidFunction,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::ExecutableDevice::InvalidFunction &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ExecutableDevice::InvalidFunction>::insert_copy (
      _tao_any,
      CF::ExecutableDevice::InvalidFunction::_tao_any_destructor,
      CF::ExecutableDevice::_tc_InvalidFunction,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ExecutableDevice::InvalidFunction *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ExecutableDevice::InvalidFunction>::insert (
      _tao_any,
      CF::ExecutableDevice::InvalidFunction::_tao_any_destructor,
      CF::ExecutableDevice::_tc_InvalidFunction,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ExecutableDevice::InvalidFunction *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::ExecutableDevice::InvalidFunction *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::ExecutableDevice::InvalidFunction *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::ExecutableDevice::InvalidFunction>::extract (
        _tao_any,
        CF::ExecutableDevice::InvalidFunction::_tao_any_destructor,
        CF::ExecutableDevice::_tc_InvalidFunction,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::ExecutableDevice::InvalidParameters>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::ExecutableDevice::InvalidParameters &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::InvalidParameters>::insert_copy (
        _tao_any,
        ::CF::ExecutableDevice::InvalidParameters::_tao_any_destructor,
        ::CF::ExecutableDevice::_tc_InvalidParameters,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::ExecutableDevice::InvalidParameters *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::InvalidParameters>::insert (
        _tao_any,
        ::CF::ExecutableDevice::InvalidParameters::_tao_any_destructor,
        ::CF::ExecutableDevice::_tc_InvalidParameters,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::ExecutableDevice::InvalidParameters *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::ExecutableDevice::InvalidParameters *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::ExecutableDevice::InvalidParameters *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::InvalidParameters>::extract (
          _tao_any,
          ::CF::ExecutableDevice::InvalidParameters::_tao_any_destructor,
          ::CF::ExecutableDevice::_tc_InvalidParameters,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::ExecutableDevice::InvalidParameters &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ExecutableDevice::InvalidParameters>::insert_copy (
      _tao_any,
      CF::ExecutableDevice::InvalidParameters::_tao_any_destructor,
      CF::ExecutableDevice::_tc_InvalidParameters,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ExecutableDevice::InvalidParameters *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ExecutableDevice::InvalidParameters>::insert (
      _tao_any,
      CF::ExecutableDevice::InvalidParameters::_tao_any_destructor,
      CF::ExecutableDevice::_tc_InvalidParameters,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ExecutableDevice::InvalidParameters *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::ExecutableDevice::InvalidParameters *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::ExecutableDevice::InvalidParameters *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::ExecutableDevice::InvalidParameters>::extract (
        _tao_any,
        CF::ExecutableDevice::InvalidParameters::_tao_any_destructor,
        CF::ExecutableDevice::_tc_InvalidParameters,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::ExecutableDevice::InvalidOptions>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::ExecutableDevice::InvalidOptions &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::InvalidOptions>::insert_copy (
        _tao_any,
        ::CF::ExecutableDevice::InvalidOptions::_tao_any_destructor,
        ::CF::ExecutableDevice::_tc_InvalidOptions,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::ExecutableDevice::InvalidOptions *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::InvalidOptions>::insert (
        _tao_any,
        ::CF::ExecutableDevice::InvalidOptions::_tao_any_destructor,
        ::CF::ExecutableDevice::_tc_InvalidOptions,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::ExecutableDevice::InvalidOptions *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::ExecutableDevice::InvalidOptions *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::ExecutableDevice::InvalidOptions *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::InvalidOptions>::extract (
          _tao_any,
          ::CF::ExecutableDevice::InvalidOptions::_tao_any_destructor,
          ::CF::ExecutableDevice::_tc_InvalidOptions,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::ExecutableDevice::InvalidOptions &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ExecutableDevice::InvalidOptions>::insert_copy (
      _tao_any,
      CF::ExecutableDevice::InvalidOptions::_tao_any_destructor,
      CF::ExecutableDevice::_tc_InvalidOptions,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ExecutableDevice::InvalidOptions *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ExecutableDevice::InvalidOptions>::insert (
      _tao_any,
      CF::ExecutableDevice::InvalidOptions::_tao_any_destructor,
      CF::ExecutableDevice::_tc_InvalidOptions,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ExecutableDevice::InvalidOptions *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::ExecutableDevice::InvalidOptions *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::ExecutableDevice::InvalidOptions *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::ExecutableDevice::InvalidOptions>::extract (
        _tao_any,
        CF::ExecutableDevice::InvalidOptions::_tao_any_destructor,
        CF::ExecutableDevice::_tc_InvalidOptions,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CF::ExecutableDevice::ExecuteFail>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::ExecutableDevice::ExecuteFail &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::ExecuteFail>::insert_copy (
        _tao_any,
        ::CF::ExecutableDevice::ExecuteFail::_tao_any_destructor,
        ::CF::ExecutableDevice::_tc_ExecuteFail,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::ExecutableDevice::ExecuteFail *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::ExecuteFail>::insert (
        _tao_any,
        ::CF::ExecutableDevice::ExecuteFail::_tao_any_destructor,
        ::CF::ExecutableDevice::_tc_ExecuteFail,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::ExecutableDevice::ExecuteFail *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::ExecutableDevice::ExecuteFail *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::ExecutableDevice::ExecuteFail *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::ExecutableDevice::ExecuteFail>::extract (
          _tao_any,
          ::CF::ExecutableDevice::ExecuteFail::_tao_any_destructor,
          ::CF::ExecutableDevice::_tc_ExecuteFail,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::ExecutableDevice::ExecuteFail &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ExecutableDevice::ExecuteFail>::insert_copy (
      _tao_any,
      CF::ExecutableDevice::ExecuteFail::_tao_any_destructor,
      CF::ExecutableDevice::_tc_ExecuteFail,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::ExecutableDevice::ExecuteFail *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::ExecutableDevice::ExecuteFail>::insert (
      _tao_any,
      CF::ExecutableDevice::ExecuteFail::_tao_any_destructor,
      CF::ExecutableDevice::_tc_ExecuteFail,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::ExecutableDevice::ExecuteFail *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::ExecutableDevice::ExecuteFail *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::ExecutableDevice::ExecuteFail *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::ExecutableDevice::ExecuteFail>::extract (
        _tao_any,
        CF::ExecutableDevice::ExecuteFail::_tao_any_destructor,
        CF::ExecutableDevice::_tc_ExecuteFail,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CF::DeviceManager>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DeviceManager_ptr _tao_elem)
  {
    DeviceManager_ptr _tao_objptr =
      DeviceManager::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DeviceManager_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<DeviceManager>::insert (
        _tao_any,
        DeviceManager::_tao_any_destructor,
        _tc_DeviceManager,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DeviceManager_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<DeviceManager>::extract (
          _tao_any,
          DeviceManager::_tao_any_destructor,
          _tc_DeviceManager,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DeviceManager_ptr _tao_elem)
{
  CF::DeviceManager_ptr _tao_objptr =
    CF::DeviceManager::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DeviceManager_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CF::DeviceManager>::insert (
      _tao_any,
      CF::DeviceManager::_tao_any_destructor,
      CF::_tc_DeviceManager,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DeviceManager_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CF::DeviceManager>::extract (
        _tao_any,
        CF::DeviceManager::_tao_any_destructor,
        CF::_tc_DeviceManager,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DeviceManager::ServiceType &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::DeviceManager::ServiceType *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::DeviceManager::ServiceType>::insert_copy (
          _tao_any,
          ::CF::DeviceManager::ServiceType::_tao_any_destructor,
          ::CF::DeviceManager::_tc_ServiceType,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CF::DeviceManager::ServiceType *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DeviceManager::ServiceType>::insert (
        _tao_any,
        ::CF::DeviceManager::ServiceType::_tao_any_destructor,
        ::CF::DeviceManager::_tc_ServiceType,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DeviceManager::ServiceType *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DeviceManager::ServiceType *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DeviceManager::ServiceType *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DeviceManager::ServiceType>::extract (
          _tao_any,
          ::CF::DeviceManager::ServiceType::_tao_any_destructor,
          ::CF::DeviceManager::_tc_ServiceType,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DeviceManager::ServiceType &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::DeviceManager::ServiceType *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::DeviceManager::ServiceType>::insert_copy (
        _tao_any,
        CF::DeviceManager::ServiceType::_tao_any_destructor,
        CF::DeviceManager::_tc_ServiceType,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DeviceManager::ServiceType *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DeviceManager::ServiceType>::insert (
      _tao_any,
      CF::DeviceManager::ServiceType::_tao_any_destructor,
      CF::DeviceManager::_tc_ServiceType,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DeviceManager::ServiceType *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DeviceManager::ServiceType *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DeviceManager::ServiceType *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DeviceManager::ServiceType>::extract (
        _tao_any,
        CF::DeviceManager::ServiceType::_tao_any_destructor,
        CF::DeviceManager::_tc_ServiceType,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CF::DeviceManager::ServiceSequence &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CF::DeviceManager::ServiceSequence *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CF::DeviceManager::ServiceSequence>::insert_copy (
          _tao_any,
          ::CF::DeviceManager::ServiceSequence::_tao_any_destructor,
          ::CF::DeviceManager::_tc_ServiceSequence,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CF::DeviceManager::ServiceSequence *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CF::DeviceManager::ServiceSequence>::insert (
        _tao_any,
        ::CF::DeviceManager::ServiceSequence::_tao_any_destructor,
        ::CF::DeviceManager::_tc_ServiceSequence,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CF::DeviceManager::ServiceSequence *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CF::DeviceManager::ServiceSequence *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CF::DeviceManager::ServiceSequence *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CF::DeviceManager::ServiceSequence>::extract (
          _tao_any,
          ::CF::DeviceManager::ServiceSequence::_tao_any_destructor,
          ::CF::DeviceManager::_tc_ServiceSequence,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CF::DeviceManager::ServiceSequence &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CF::DeviceManager::ServiceSequence *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CF::DeviceManager::ServiceSequence>::insert_copy (
        _tao_any,
        CF::DeviceManager::ServiceSequence::_tao_any_destructor,
        CF::DeviceManager::_tc_ServiceSequence,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CF::DeviceManager::ServiceSequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CF::DeviceManager::ServiceSequence>::insert (
      _tao_any,
      CF::DeviceManager::ServiceSequence::_tao_any_destructor,
      CF::DeviceManager::_tc_ServiceSequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CF::DeviceManager::ServiceSequence *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CF::DeviceManager::ServiceSequence *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CF::DeviceManager::ServiceSequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CF::DeviceManager::ServiceSequence>::extract (
        _tao_any,
        CF::DeviceManager::ServiceSequence::_tao_any_destructor,
        CF::DeviceManager::_tc_ServiceSequence,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DataType &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DataType &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::InvalidProfile &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::InvalidProfile&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CF_Properties_CPP_
#define _TAO_CDR_OP_CF_Properties_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Properties &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Properties &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_CF_Properties_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::InvalidObjectReference &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::InvalidObjectReference &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CF_OctetSequence_CPP_
#define _TAO_CDR_OP_CF_OctetSequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::OctetSequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::OctetSequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_CF_OctetSequence_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CF_StringSequence_CPP_
#define _TAO_CDR_OP_CF_StringSequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::StringSequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::StringSequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_CF_StringSequence_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::UnknownProperties &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.invalidProperties)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::UnknownProperties &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.invalidProperties)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DeviceAssignmentType &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.componentId.in ()) &&
    (strm << _tao_aggregate.assignedDeviceId.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DeviceAssignmentType &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.componentId.out ()) &&
    (strm >> _tao_aggregate.assignedDeviceId.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CF_DeviceAssignmentSequence_CPP_
#define _TAO_CDR_OP_CF_DeviceAssignmentSequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DeviceAssignmentSequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DeviceAssignmentSequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_CF_DeviceAssignmentSequence_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CF::ErrorNumberType _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, CF::ErrorNumberType & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<CF::ErrorNumberType> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::InvalidFileName &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorNumber) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::InvalidFileName &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorNumber) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::FileException &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorNumber) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::FileException &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorNumber) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CF_DeviceSequence_CPP_
#define _TAO_CDR_OP_CF_DeviceSequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DeviceSequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DeviceSequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_CF_DeviceSequence_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::AggregateDevice_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::AggregateDevice_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::AggregateDevice RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_AggregateDevice_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::FileSystem::UnknownFileSystemProperties &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.invalidProperties)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::FileSystem::UnknownFileSystemProperties &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.invalidProperties)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CF::FileSystem::FileType _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, CF::FileSystem::FileType & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<CF::FileSystem::FileType> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::FileSystem::FileInformationType &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.kind) &&
    (strm << _tao_aggregate.size) &&
    (strm << _tao_aggregate.fileProperties);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::FileSystem::FileInformationType &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.kind) &&
    (strm >> _tao_aggregate.size) &&
    (strm >> _tao_aggregate.fileProperties);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CF_FileSystem_FileInformationSequence_CPP_
#define _TAO_CDR_OP_CF_FileSystem_FileInformationSequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::FileSystem::FileInformationSequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::FileSystem::FileInformationSequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_CF_FileSystem_FileInformationSequence_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::FileSystem_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::FileSystem_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::FileSystem RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_FileSystem_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::File::IOException &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorNumber) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::File::IOException &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorNumber) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::File::InvalidFilePointer &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::File::InvalidFilePointer&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::File_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::File_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::File RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_File_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::ResourceFactory::InvalidResourceId &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::ResourceFactory::InvalidResourceId&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::ResourceFactory::ShutdownFailure &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::ResourceFactory::ShutdownFailure &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::ResourceFactory::CreateResourceFailure &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorNumber) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::ResourceFactory::CreateResourceFailure &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorNumber) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::ResourceFactory_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::ResourceFactory_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::ResourceFactory RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_ResourceFactory_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::FileManager::MountType &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.mountPoint.in ()) &&
    ::CORBA::Object::marshal (
        _tao_aggregate.fs.in (),
        strm
      );
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::FileManager::MountType &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.mountPoint.out ()) &&
    (strm >> _tao_aggregate.fs.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CF_FileManager_MountSequence_CPP_
#define _TAO_CDR_OP_CF_FileManager_MountSequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::FileManager::MountSequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::FileManager::MountSequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_CF_FileManager_MountSequence_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::FileManager::NonExistentMount &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::FileManager::NonExistentMount&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::FileManager::InvalidFileSystem &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::FileManager::InvalidFileSystem&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::FileManager::MountPointAlreadyExists &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::FileManager::MountPointAlreadyExists&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::FileManager_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::FileManager_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::FileManager RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_FileManager_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::PPort::InvalidPort &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorCode) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::PPort::InvalidPort &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorCode) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::PPort::OccupiedPort &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::PPort::OccupiedPort&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::PPort_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::PPort_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::PPort RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_PPort_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::LifeCycle::InitializeError &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorMessages)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::LifeCycle::InitializeError &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorMessages)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::LifeCycle::ReleaseError &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorMessages)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::LifeCycle::ReleaseError &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorMessages)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::LifeCycle_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::LifeCycle_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::LifeCycle RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_LifeCycle_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::TestableObject::UnknownTest &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::TestableObject::UnknownTest&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::TestableObject_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::TestableObject_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::TestableObject RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_TestableObject_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::PropertySet::InvalidConfiguration &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.msg.in ()) &&
        (strm << _tao_aggregate.invalidProperties)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::PropertySet::InvalidConfiguration &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.msg.out ()) &&
    (strm >> _tao_aggregate.invalidProperties)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::PropertySet::PartialConfiguration &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.invalidProperties)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::PropertySet::PartialConfiguration &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.invalidProperties)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::PropertySet_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::PropertySet_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::PropertySet RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_PropertySet_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::ApplicationInstallationError &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorNumber) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DomainManager::ApplicationInstallationError &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorNumber) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CF_DomainManager_ApplicationSequence_CPP_
#define _TAO_CDR_OP_CF_DomainManager_ApplicationSequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::ApplicationSequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DomainManager::ApplicationSequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_CF_DomainManager_ApplicationSequence_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CF_DomainManager_ApplicationFactorySequence_CPP_
#define _TAO_CDR_OP_CF_DomainManager_ApplicationFactorySequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::ApplicationFactorySequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DomainManager::ApplicationFactorySequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_CF_DomainManager_ApplicationFactorySequence_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CF_DomainManager_DeviceManagerSequence_CPP_
#define _TAO_CDR_OP_CF_DomainManager_DeviceManagerSequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::DeviceManagerSequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DomainManager::DeviceManagerSequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_CF_DomainManager_DeviceManagerSequence_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::InvalidIdentifier &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::DomainManager::InvalidIdentifier&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::DeviceManagerNotRegistered &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::DomainManager::DeviceManagerNotRegistered&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::ApplicationUninstallationError &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorNumber) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DomainManager::ApplicationUninstallationError &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorNumber) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::RegisterError &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorNumber) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DomainManager::RegisterError &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorNumber) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::UnregisterError &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorNumber) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DomainManager::UnregisterError &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorNumber) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::AlreadyConnected &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::DomainManager::AlreadyConnected&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::InvalidEventChannelName &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::DomainManager::InvalidEventChannelName&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager::NotConnected &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::DomainManager::NotConnected&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DomainManager_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DomainManager_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::DomainManager RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_DomainManager_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::ApplicationFactory::CreateApplicationRequestError &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.invalidAssignments)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::ApplicationFactory::CreateApplicationRequestError &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.invalidAssignments)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::ApplicationFactory::CreateApplicationError &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorNumber) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::ApplicationFactory::CreateApplicationError &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorNumber) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::ApplicationFactory::InvalidInitConfiguration &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.invalidProperties)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::ApplicationFactory::InvalidInitConfiguration &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.invalidProperties)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::ApplicationFactory_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::ApplicationFactory_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::ApplicationFactory RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_ApplicationFactory_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::PortSupplier::UnknownPort &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::PortSupplier::UnknownPort&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::PortSupplier_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::PortSupplier_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::PortSupplier RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_PortSupplier_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Resource::StartError &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorNumber) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Resource::StartError &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorNumber) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Resource::StopError &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorNumber) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Resource::StopError &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorNumber) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Resource_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Resource_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::Resource RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_Resource_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Device::InvalidState &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Device::InvalidState &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Device::InvalidCapacity &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.msg.in ()) &&
        (strm << _tao_aggregate.capacities)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Device::InvalidCapacity &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.msg.out ()) &&
    (strm >> _tao_aggregate.capacities)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CF::Device::AdminType _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, CF::Device::AdminType & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<CF::Device::AdminType> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CF::Device::OperationalType _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, CF::Device::OperationalType & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<CF::Device::OperationalType> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CF::Device::UsageType _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, CF::Device::UsageType & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<CF::Device::UsageType> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Device_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Device_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::Device RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_Device_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Application::ComponentProcessIdType &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.componentId.in ()) &&
    (strm << _tao_aggregate.processId);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Application::ComponentProcessIdType &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.componentId.out ()) &&
    (strm >> _tao_aggregate.processId);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CF_Application_ComponentProcessIdSequence_CPP_
#define _TAO_CDR_OP_CF_Application_ComponentProcessIdSequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Application::ComponentProcessIdSequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Application::ComponentProcessIdSequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_CF_Application_ComponentProcessIdSequence_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Application::ComponentElementType &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.componentId.in ()) &&
    (strm << _tao_aggregate.elementId.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Application::ComponentElementType &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.componentId.out ()) &&
    (strm >> _tao_aggregate.elementId.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CF_Application_ComponentElementSequence_CPP_
#define _TAO_CDR_OP_CF_Application_ComponentElementSequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Application::ComponentElementSequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Application::ComponentElementSequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_CF_Application_ComponentElementSequence_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::Application_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::Application_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::Application RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_Application_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CF::LoadableDevice::LoadType _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, CF::LoadableDevice::LoadType & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<CF::LoadableDevice::LoadType> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::LoadableDevice::InvalidLoadKind &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::LoadableDevice::InvalidLoadKind&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::LoadableDevice::LoadFail &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorNumber) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::LoadableDevice::LoadFail &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorNumber) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::LoadableDevice_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::LoadableDevice_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::LoadableDevice RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_LoadableDevice_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::ExecutableDevice::InvalidProcess &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorNumber) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::ExecutableDevice::InvalidProcess &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorNumber) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::ExecutableDevice::InvalidFunction &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CF::ExecutableDevice::InvalidFunction&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::ExecutableDevice::InvalidParameters &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.invalidParms)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::ExecutableDevice::InvalidParameters &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.invalidParms)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::ExecutableDevice::InvalidOptions &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.invalidOpts)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::ExecutableDevice::InvalidOptions &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.invalidOpts)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::ExecutableDevice::ExecuteFail &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorNumber) &&
        (strm << _tao_aggregate.msg.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::ExecutableDevice::ExecuteFail &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorNumber) &&
    (strm >> _tao_aggregate.msg.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::ExecutableDevice_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::ExecutableDevice_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::ExecutableDevice RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_ExecutableDevice_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DeviceManager::ServiceType &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.serviceObject.in ()) &&
    (strm << _tao_aggregate.serviceName.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DeviceManager::ServiceType &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.serviceObject.out ()) &&
    (strm >> _tao_aggregate.serviceName.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CF_DeviceManager_ServiceSequence_CPP_
#define _TAO_CDR_OP_CF_DeviceManager_ServiceSequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DeviceManager::ServiceSequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DeviceManager::ServiceSequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_CF_DeviceManager_ServiceSequence_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CF::DeviceManager_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CF::DeviceManager_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CF::DeviceManager RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CF__TAO_DeviceManager_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL