// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "CSIC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/TypeCode_Case_T.h"
#include "tao/AnyTypeCode/Union_TypeCode_Static.h"
#include "tao/CDR.h"
#include "tao/ORB_Core.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "CSIC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSI_X509CERTIFICATECHAIN_CS_)
#define _CSI_X509CERTIFICATECHAIN_CS_

CSI::X509CertificateChain::X509CertificateChain (void)
{}

CSI::X509CertificateChain::X509CertificateChain (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

CSI::X509CertificateChain::X509CertificateChain (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

CSI::X509CertificateChain::X509CertificateChain (
    const X509CertificateChain &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

CSI::X509CertificateChain::~X509CertificateChain (void)
{}

void CSI::X509CertificateChain::_tao_any_destructor (
    void * _tao_void_pointer)
{
  X509CertificateChain * _tao_tmp_pointer =
    static_cast<X509CertificateChain *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSI_X509CertificateChain_GUARD
#define _TAO_TYPECODE_CSI_X509CertificateChain_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSI_X509CertificateChain_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSI_X509CertificateChain_0 =
        &CSI_X509CertificateChain_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSI_X509CertificateChain_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_X509CertificateChain (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/X509CertificateChain:1.0",
    "X509CertificateChain",
    &TAO::TypeCode::tc_CSI_X509CertificateChain_0);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_X509CertificateChain =
    &_tao_tc_CSI_X509CertificateChain;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSI_X501DISTINGUISHEDNAME_CS_)
#define _CSI_X501DISTINGUISHEDNAME_CS_

CSI::X501DistinguishedName::X501DistinguishedName (void)
{}

CSI::X501DistinguishedName::X501DistinguishedName (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

CSI::X501DistinguishedName::X501DistinguishedName (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

CSI::X501DistinguishedName::X501DistinguishedName (
    const X501DistinguishedName &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

CSI::X501DistinguishedName::~X501DistinguishedName (void)
{}

void CSI::X501DistinguishedName::_tao_any_destructor (
    void * _tao_void_pointer)
{
  X501DistinguishedName * _tao_tmp_pointer =
    static_cast<X501DistinguishedName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSI_X501DistinguishedName_GUARD
#define _TAO_TYPECODE_CSI_X501DistinguishedName_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSI_X501DistinguishedName_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSI_X501DistinguishedName_0 =
        &CSI_X501DistinguishedName_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSI_X501DistinguishedName_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_X501DistinguishedName (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/X501DistinguishedName:1.0",
    "X501DistinguishedName",
    &TAO::TypeCode::tc_CSI_X501DistinguishedName_0);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_X501DistinguishedName =
    &_tao_tc_CSI_X501DistinguishedName;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSI_UTF8STRING_CS_)
#define _CSI_UTF8STRING_CS_

CSI::UTF8String::UTF8String (void)
{}

CSI::UTF8String::UTF8String (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

CSI::UTF8String::UTF8String (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

CSI::UTF8String::UTF8String (
    const UTF8String &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

CSI::UTF8String::~UTF8String (void)
{}

void CSI::UTF8String::_tao_any_destructor (
    void * _tao_void_pointer)
{
  UTF8String * _tao_tmp_pointer =
    static_cast<UTF8String *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSI_UTF8String_GUARD
#define _TAO_TYPECODE_CSI_UTF8String_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSI_UTF8String_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSI_UTF8String_0 =
        &CSI_UTF8String_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSI_UTF8String_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_UTF8String (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/UTF8String:1.0",
    "UTF8String",
    &TAO::TypeCode::tc_CSI_UTF8String_0);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_UTF8String =
    &_tao_tc_CSI_UTF8String;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSI_OID_CS_)
#define _CSI_OID_CS_

CSI::OID::OID (void)
{}

CSI::OID::OID (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

CSI::OID::OID (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

CSI::OID::OID (
    const OID &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

CSI::OID::~OID (void)
{}

void CSI::OID::_tao_any_destructor (
    void * _tao_void_pointer)
{
  OID * _tao_tmp_pointer =
    static_cast<OID *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSI_OID_GUARD
#define _TAO_TYPECODE_CSI_OID_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSI_OID_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSI_OID_0 =
        &CSI_OID_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSI_OID_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_OID (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/OID:1.0",
    "OID",
    &TAO::TypeCode::tc_CSI_OID_0);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_OID =
    &_tao_tc_CSI_OID;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSI_OIDLIST_CS_)
#define _CSI_OIDLIST_CS_

CSI::OIDList::OIDList (void)
{}

CSI::OIDList::OIDList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        OID
      > (max)
{}

CSI::OIDList::OIDList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CSI::OID * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        OID
      >
    (max, length, buffer, release)
{}

CSI::OIDList::OIDList (
    const OIDList &seq)
  : ::TAO::unbounded_value_sequence<
        OID
      > (seq)
{}

CSI::OIDList::~OIDList (void)
{}

void CSI::OIDList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  OIDList * _tao_tmp_pointer =
    static_cast<OIDList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSI_OIDList_GUARD
#define _TAO_TYPECODE_CSI_OIDList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSI_OIDList_0 (
          ::CORBA::tk_sequence,
          &CSI::_tc_OID,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSI_OIDList_0 =
        &CSI_OIDList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSI_OIDList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_OIDList (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/OIDList:1.0",
    "OIDList",
    &TAO::TypeCode::tc_CSI_OIDList_0);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_OIDList =
    &_tao_tc_CSI_OIDList;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSI_GSSTOKEN_CS_)
#define _CSI_GSSTOKEN_CS_

CSI::GSSToken::GSSToken (void)
{}

CSI::GSSToken::GSSToken (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

CSI::GSSToken::GSSToken (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

CSI::GSSToken::GSSToken (
    const GSSToken &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

CSI::GSSToken::~GSSToken (void)
{}

void CSI::GSSToken::_tao_any_destructor (
    void * _tao_void_pointer)
{
  GSSToken * _tao_tmp_pointer =
    static_cast<GSSToken *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSI_GSSToken_GUARD
#define _TAO_TYPECODE_CSI_GSSToken_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSI_GSSToken_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSI_GSSToken_0 =
        &CSI_GSSToken_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSI_GSSToken_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_GSSToken (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/GSSToken:1.0",
    "GSSToken",
    &TAO::TypeCode::tc_CSI_GSSToken_0);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_GSSToken =
    &_tao_tc_CSI_GSSToken;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSI_GSS_NT_EXPORTEDNAME_CS_)
#define _CSI_GSS_NT_EXPORTEDNAME_CS_

CSI::GSS_NT_ExportedName::GSS_NT_ExportedName (void)
{}

CSI::GSS_NT_ExportedName::GSS_NT_ExportedName (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

CSI::GSS_NT_ExportedName::GSS_NT_ExportedName (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

CSI::GSS_NT_ExportedName::GSS_NT_ExportedName (
    const GSS_NT_ExportedName &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

CSI::GSS_NT_ExportedName::~GSS_NT_ExportedName (void)
{}

void CSI::GSS_NT_ExportedName::_tao_any_destructor (
    void * _tao_void_pointer)
{
  GSS_NT_ExportedName * _tao_tmp_pointer =
    static_cast<GSS_NT_ExportedName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSI_GSS_NT_ExportedName_GUARD
#define _TAO_TYPECODE_CSI_GSS_NT_ExportedName_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSI_GSS_NT_ExportedName_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSI_GSS_NT_ExportedName_0 =
        &CSI_GSS_NT_ExportedName_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSI_GSS_NT_ExportedName_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_GSS_NT_ExportedName (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/GSS_NT_ExportedName:1.0",
    "GSS_NT_ExportedName",
    &TAO::TypeCode::tc_CSI_GSS_NT_ExportedName_0);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_GSS_NT_ExportedName =
    &_tao_tc_CSI_GSS_NT_ExportedName;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSI_GSS_NT_EXPORTEDNAMELIST_CS_)
#define _CSI_GSS_NT_EXPORTEDNAMELIST_CS_

CSI::GSS_NT_ExportedNameList::GSS_NT_ExportedNameList (void)
{}

CSI::GSS_NT_ExportedNameList::GSS_NT_ExportedNameList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        GSS_NT_ExportedName
      > (max)
{}

CSI::GSS_NT_ExportedNameList::GSS_NT_ExportedNameList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CSI::GSS_NT_ExportedName * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        GSS_NT_ExportedName
      >
    (max, length, buffer, release)
{}

CSI::GSS_NT_ExportedNameList::GSS_NT_ExportedNameList (
    const GSS_NT_ExportedNameList &seq)
  : ::TAO::unbounded_value_sequence<
        GSS_NT_ExportedName
      > (seq)
{}

CSI::GSS_NT_ExportedNameList::~GSS_NT_ExportedNameList (void)
{}

void CSI::GSS_NT_ExportedNameList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  GSS_NT_ExportedNameList * _tao_tmp_pointer =
    static_cast<GSS_NT_ExportedNameList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSI_GSS_NT_ExportedNameList_GUARD
#define _TAO_TYPECODE_CSI_GSS_NT_ExportedNameList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSI_GSS_NT_ExportedNameList_0 (
          ::CORBA::tk_sequence,
          &CSI::_tc_GSS_NT_ExportedName,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSI_GSS_NT_ExportedNameList_0 =
        &CSI_GSS_NT_ExportedNameList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSI_GSS_NT_ExportedNameList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_GSS_NT_ExportedNameList (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/GSS_NT_ExportedNameList:1.0",
    "GSS_NT_ExportedNameList",
    &TAO::TypeCode::tc_CSI_GSS_NT_ExportedNameList_0);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_GSS_NT_ExportedNameList =
    &_tao_tc_CSI_GSS_NT_ExportedNameList;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_MsgType (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/MsgType:1.0",
    "MsgType",
    &CORBA::_tc_short);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_MsgType =
    &_tao_tc_CSI_MsgType;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_ContextId (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/ContextId:1.0",
    "ContextId",
    &CORBA::_tc_ulonglong);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_ContextId =
    &_tao_tc_CSI_ContextId;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_AuthorizationElementType (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/AuthorizationElementType:1.0",
    "AuthorizationElementType",
    &CORBA::_tc_ulong);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_AuthorizationElementType =
    &_tao_tc_CSI_AuthorizationElementType;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSI_AUTHORIZATIONELEMENTCONTENTS_CS_)
#define _CSI_AUTHORIZATIONELEMENTCONTENTS_CS_

CSI::AuthorizationElementContents::AuthorizationElementContents (void)
{}

CSI::AuthorizationElementContents::AuthorizationElementContents (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

CSI::AuthorizationElementContents::AuthorizationElementContents (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

CSI::AuthorizationElementContents::AuthorizationElementContents (
    const AuthorizationElementContents &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

CSI::AuthorizationElementContents::~AuthorizationElementContents (void)
{}

void CSI::AuthorizationElementContents::_tao_any_destructor (
    void * _tao_void_pointer)
{
  AuthorizationElementContents * _tao_tmp_pointer =
    static_cast<AuthorizationElementContents *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSI_AuthorizationElementContents_GUARD
#define _TAO_TYPECODE_CSI_AuthorizationElementContents_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSI_AuthorizationElementContents_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSI_AuthorizationElementContents_0 =
        &CSI_AuthorizationElementContents_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSI_AuthorizationElementContents_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_AuthorizationElementContents (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/AuthorizationElementContents:1.0",
    "AuthorizationElementContents",
    &TAO::TypeCode::tc_CSI_AuthorizationElementContents_0);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_AuthorizationElementContents =
    &_tao_tc_CSI_AuthorizationElementContents;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CSI_AuthorizationElement[] =
      {
        { "the_type", &CSI::_tc_AuthorizationElementType },
        { "the_element", &CSI::_tc_AuthorizationElementContents }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CSI_AuthorizationElement (
  ::CORBA::tk_struct,
  "IDL:omg.org/CSI/AuthorizationElement:1.0",
  "AuthorizationElement",
  _tao_fields_CSI_AuthorizationElement,
  2);


namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_AuthorizationElement =
    &_tao_tc_CSI_AuthorizationElement;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CSI::AuthorizationElement::_tao_any_destructor (
    void *_tao_void_pointer)
{
  AuthorizationElement *_tao_tmp_pointer =
    static_cast<AuthorizationElement *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSI_AUTHORIZATIONTOKEN_CS_)
#define _CSI_AUTHORIZATIONTOKEN_CS_

CSI::AuthorizationToken::AuthorizationToken (void)
{}

CSI::AuthorizationToken::AuthorizationToken (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        AuthorizationElement
      > (max)
{}

CSI::AuthorizationToken::AuthorizationToken (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CSI::AuthorizationElement * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        AuthorizationElement
      >
    (max, length, buffer, release)
{}

CSI::AuthorizationToken::AuthorizationToken (
    const AuthorizationToken &seq)
  : ::TAO::unbounded_value_sequence<
        AuthorizationElement
      > (seq)
{}

CSI::AuthorizationToken::~AuthorizationToken (void)
{}

void CSI::AuthorizationToken::_tao_any_destructor (
    void * _tao_void_pointer)
{
  AuthorizationToken * _tao_tmp_pointer =
    static_cast<AuthorizationToken *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSI_AuthorizationToken_GUARD
#define _TAO_TYPECODE_CSI_AuthorizationToken_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSI_AuthorizationToken_0 (
          ::CORBA::tk_sequence,
          &CSI::_tc_AuthorizationElement,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSI_AuthorizationToken_0 =
        &CSI_AuthorizationToken_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSI_AuthorizationToken_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_AuthorizationToken (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/AuthorizationToken:1.0",
    "AuthorizationToken",
    &TAO::TypeCode::tc_CSI_AuthorizationToken_0);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_AuthorizationToken =
    &_tao_tc_CSI_AuthorizationToken;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_IdentityTokenType (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/IdentityTokenType:1.0",
    "IdentityTokenType",
    &CORBA::_tc_ulong);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_IdentityTokenType =
    &_tao_tc_CSI_IdentityTokenType;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSI_IDENTITYEXTENSION_CS_)
#define _CSI_IDENTITYEXTENSION_CS_

CSI::IdentityExtension::IdentityExtension (void)
{}

CSI::IdentityExtension::IdentityExtension (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

CSI::IdentityExtension::IdentityExtension (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

CSI::IdentityExtension::IdentityExtension (
    const IdentityExtension &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

CSI::IdentityExtension::~IdentityExtension (void)
{}

void CSI::IdentityExtension::_tao_any_destructor (
    void * _tao_void_pointer)
{
  IdentityExtension * _tao_tmp_pointer =
    static_cast<IdentityExtension *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSI_IdentityExtension_GUARD
#define _TAO_TYPECODE_CSI_IdentityExtension_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSI_IdentityExtension_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSI_IdentityExtension_0 =
        &CSI_IdentityExtension_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSI_IdentityExtension_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_IdentityExtension (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/IdentityExtension:1.0",
    "IdentityExtension",
    &TAO::TypeCode::tc_CSI_IdentityExtension_0);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_IdentityExtension =
    &_tao_tc_CSI_IdentityExtension;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_union/union_cs.cpp:82

CSI::IdentityToken::IdentityToken (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = 3;
}

CSI::IdentityToken::IdentityToken (const ::CSI::IdentityToken &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 0U:
    {
      this->u_.absent_ = u.u_.absent_;
    }
    break;
    case 1U:
    {
      this->u_.anonymous_ = u.u_.anonymous_;
    }
    break;
    case 2U:
    {
      if (u.u_.principal_name_ == 0)
        {
          this->u_.principal_name_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.principal_name_,
              CSI::GSS_NT_ExportedName (*u.u_.principal_name_)
            );
        }
    }
    break;
    case 4U:
    {
      if (u.u_.certificate_chain_ == 0)
        {
          this->u_.certificate_chain_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.certificate_chain_,
              CSI::X509CertificateChain (*u.u_.certificate_chain_)
            );
        }
    }
    break;
    case 8U:
    {
      if (u.u_.dn_ == 0)
        {
          this->u_.dn_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.dn_,
              CSI::X501DistinguishedName (*u.u_.dn_)
            );
        }
    }
    break;
    default:
    {
      if (u.u_.id_ == 0)
        {
          this->u_.id_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.id_,
              CSI::IdentityExtension (*u.u_.id_)
            );
        }
    }
    break;
  }
}

CSI::IdentityToken::~IdentityToken (void)
{
  // Finalize.
  this->_reset ();
}

void CSI::IdentityToken::_tao_any_destructor (void *_tao_void_pointer)
{
  IdentityToken *tmp =
    static_cast<IdentityToken *> (_tao_void_pointer);
  delete tmp;
}

CSI::IdentityToken &
CSI::IdentityToken::operator= (const ::CSI::IdentityToken &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case 0U:
    {
      this->u_.absent_ = u.u_.absent_;
    }
    break;
    case 1U:
    {
      this->u_.anonymous_ = u.u_.anonymous_;
    }
    break;
    case 2U:
    {
      if (u.u_.principal_name_ == 0)
        {
          this->u_.principal_name_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.principal_name_,
              CSI::GSS_NT_ExportedName (*u.u_.principal_name_),
              *this
            );
        }
    }
    break;
    case 4U:
    {
      if (u.u_.certificate_chain_ == 0)
        {
          this->u_.certificate_chain_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.certificate_chain_,
              CSI::X509CertificateChain (*u.u_.certificate_chain_),
              *this
            );
        }
    }
    break;
    case 8U:
    {
      if (u.u_.dn_ == 0)
        {
          this->u_.dn_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.dn_,
              CSI::X501DistinguishedName (*u.u_.dn_),
              *this
            );
        }
    }
    break;
    default:
    {
      if (u.u_.id_ == 0)
        {
          this->u_.id_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.id_,
              CSI::IdentityExtension (*u.u_.id_),
              *this
            );
        }
    }
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void CSI::IdentityToken::_reset (void)
{
  switch (this->disc_)
  {
    
    case 0U:
      break;
    case 1U:
      break;
    case 2U:
      delete this->u_.principal_name_;
      this->u_.principal_name_ = 0;
      break;
    case 4U:
      delete this->u_.certificate_chain_;
      this->u_.certificate_chain_ = 0;
      break;
    case 8U:
      delete this->u_.dn_;
      this->u_.dn_ = 0;
      break;
    default:
      delete this->u_.id_;
      this->u_.id_ = 0;
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/union_typecode.cpp:66



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Case_T<CORBA::ULong, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_CSI_IdentityToken__0 (0U, "absent", &CORBA::_tc_boolean);
static TAO::TypeCode::Case_T<CORBA::ULong, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_CSI_IdentityToken__1 (1U, "anonymous", &CORBA::_tc_boolean);
static TAO::TypeCode::Case_T<CORBA::ULong, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_CSI_IdentityToken__2 (2U, "principal_name", &CSI::_tc_GSS_NT_ExportedName);
static TAO::TypeCode::Case_T<CORBA::ULong, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_CSI_IdentityToken__3 (4U, "certificate_chain", &CSI::_tc_X509CertificateChain);
static TAO::TypeCode::Case_T<CORBA::ULong, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_CSI_IdentityToken__4 (8U, "dn", &CSI::_tc_X501DistinguishedName);
static TAO::TypeCode::Case_T<CORBA::ULong, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_CSI_IdentityToken__5 (3, "id", &CSI::_tc_IdentityExtension);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_CSI_IdentityToken[] =
  {
    &_tao_cases_CSI_IdentityToken__0,
    &_tao_cases_CSI_IdentityToken__1,
    &_tao_cases_CSI_IdentityToken__2,
    &_tao_cases_CSI_IdentityToken__3,
    &_tao_cases_CSI_IdentityToken__4,
    &_tao_cases_CSI_IdentityToken__5
    
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_IdentityToken (
    "IDL:omg.org/CSI/IdentityToken:1.0",
    "IdentityToken",
    &CORBA::_tc_ulong,
    _tao_cases_CSI_IdentityToken,
    6, 5);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_IdentityToken =
    &_tao_tc_CSI_IdentityToken;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CSI_EstablishContext[] =
      {
        { "client_context_id", &CSI::_tc_ContextId },
        { "authorization_token", &CSI::_tc_AuthorizationToken },
        { "identity_token", &CSI::_tc_IdentityToken },
        { "client_authentication_token", &CSI::_tc_GSSToken }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CSI_EstablishContext (
  ::CORBA::tk_struct,
  "IDL:omg.org/CSI/EstablishContext:1.0",
  "EstablishContext",
  _tao_fields_CSI_EstablishContext,
  4);


namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_EstablishContext =
    &_tao_tc_CSI_EstablishContext;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CSI::EstablishContext::_tao_any_destructor (
    void *_tao_void_pointer)
{
  EstablishContext *_tao_tmp_pointer =
    static_cast<EstablishContext *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CSI_CompleteEstablishContext[] =
      {
        { "client_context_id", &CSI::_tc_ContextId },
        { "context_stateful", &CORBA::_tc_boolean },
        { "final_context_token", &CSI::_tc_GSSToken }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CSI_CompleteEstablishContext (
  ::CORBA::tk_struct,
  "IDL:omg.org/CSI/CompleteEstablishContext:1.0",
  "CompleteEstablishContext",
  _tao_fields_CSI_CompleteEstablishContext,
  3);


namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_CompleteEstablishContext =
    &_tao_tc_CSI_CompleteEstablishContext;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CSI::CompleteEstablishContext::_tao_any_destructor (
    void *_tao_void_pointer)
{
  CompleteEstablishContext *_tao_tmp_pointer =
    static_cast<CompleteEstablishContext *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CSI_ContextError[] =
      {
        { "client_context_id", &CSI::_tc_ContextId },
        { "major_status", &CORBA::_tc_long },
        { "minor_status", &CORBA::_tc_long },
        { "error_token", &CSI::_tc_GSSToken }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CSI_ContextError (
  ::CORBA::tk_struct,
  "IDL:omg.org/CSI/ContextError:1.0",
  "ContextError",
  _tao_fields_CSI_ContextError,
  4);


namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_ContextError =
    &_tao_tc_CSI_ContextError;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CSI::ContextError::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ContextError *_tao_tmp_pointer =
    static_cast<ContextError *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CSI_MessageInContext[] =
      {
        { "client_context_id", &CSI::_tc_ContextId },
        { "discard_context", &CORBA::_tc_boolean }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CSI_MessageInContext (
  ::CORBA::tk_struct,
  "IDL:omg.org/CSI/MessageInContext:1.0",
  "MessageInContext",
  _tao_fields_CSI_MessageInContext,
  2);


namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_MessageInContext =
    &_tao_tc_CSI_MessageInContext;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CSI::MessageInContext::_tao_any_destructor (
    void *_tao_void_pointer)
{
  MessageInContext *_tao_tmp_pointer =
    static_cast<MessageInContext *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_union/union_cs.cpp:82

CSI::SASContextBody::SASContextBody (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = -32768;
}

CSI::SASContextBody::SASContextBody (const ::CSI::SASContextBody &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 0:
    {
      if (u.u_.establish_msg_ == 0)
        {
          this->u_.establish_msg_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.establish_msg_,
              CSI::EstablishContext (*u.u_.establish_msg_)
            );
        }
    }
    break;
    case 1:
    {
      if (u.u_.complete_msg_ == 0)
        {
          this->u_.complete_msg_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.complete_msg_,
              CSI::CompleteEstablishContext (*u.u_.complete_msg_)
            );
        }
    }
    break;
    case 4:
    {
      if (u.u_.error_msg_ == 0)
        {
          this->u_.error_msg_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.error_msg_,
              CSI::ContextError (*u.u_.error_msg_)
            );
        }
    }
    break;
    case 5:
    {
      this->u_.in_context_msg_ = u.u_.in_context_msg_;
    }
    break;
    default:
    break;
  }
}

CSI::SASContextBody::~SASContextBody (void)
{
  // Finalize.
  this->_reset ();
}

void CSI::SASContextBody::_tao_any_destructor (void *_tao_void_pointer)
{
  SASContextBody *tmp =
    static_cast<SASContextBody *> (_tao_void_pointer);
  delete tmp;
}

CSI::SASContextBody &
CSI::SASContextBody::operator= (const ::CSI::SASContextBody &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case 0:
    {
      if (u.u_.establish_msg_ == 0)
        {
          this->u_.establish_msg_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.establish_msg_,
              CSI::EstablishContext (*u.u_.establish_msg_),
              *this
            );
        }
    }
    break;
    case 1:
    {
      if (u.u_.complete_msg_ == 0)
        {
          this->u_.complete_msg_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.complete_msg_,
              CSI::CompleteEstablishContext (*u.u_.complete_msg_),
              *this
            );
        }
    }
    break;
    case 4:
    {
      if (u.u_.error_msg_ == 0)
        {
          this->u_.error_msg_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.error_msg_,
              CSI::ContextError (*u.u_.error_msg_),
              *this
            );
        }
    }
    break;
    case 5:
    {
      this->u_.in_context_msg_ = u.u_.in_context_msg_;
    }
    break;
    default:
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void CSI::SASContextBody::_reset (void)
{
  switch (this->disc_)
  {
    
    case 0:
      delete this->u_.establish_msg_;
      this->u_.establish_msg_ = 0;
      break;
    case 1:
      delete this->u_.complete_msg_;
      this->u_.complete_msg_ = 0;
      break;
    case 4:
      delete this->u_.error_msg_;
      this->u_.error_msg_ = 0;
      break;
    case 5:
      break;
    default:
    break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/union_typecode.cpp:66

static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_CSI_SASContextBody__0 (0, "establish_msg", &CSI::_tc_EstablishContext);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_CSI_SASContextBody__1 (1, "complete_msg", &CSI::_tc_CompleteEstablishContext);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_CSI_SASContextBody__2 (4, "error_msg", &CSI::_tc_ContextError);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_CSI_SASContextBody__3 (5, "in_context_msg", &CSI::_tc_MessageInContext);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_CSI_SASContextBody[] =
  {
    &_tao_cases_CSI_SASContextBody__0,
    &_tao_cases_CSI_SASContextBody__1,
    &_tao_cases_CSI_SASContextBody__2,
    &_tao_cases_CSI_SASContextBody__3
    
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_SASContextBody (
    "IDL:omg.org/CSI/SASContextBody:1.0",
    "SASContextBody",
    &CORBA::_tc_short,
    _tao_cases_CSI_SASContextBody,
    4, -1);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_SASContextBody =
    &_tao_tc_CSI_SASContextBody;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSI_StringOID (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSI/StringOID:1.0",
    "StringOID",
    &CORBA::_tc_string);
  

namespace CSI
{
  ::CORBA::TypeCode_ptr const _tc_StringOID =
    &_tao_tc_CSI_StringOID;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::X509CertificateChain &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::X509CertificateChain *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::X509CertificateChain>::insert_copy (
          _tao_any,
          ::CSI::X509CertificateChain::_tao_any_destructor,
          ::CSI::_tc_X509CertificateChain,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSI::X509CertificateChain *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::X509CertificateChain>::insert (
        _tao_any,
        ::CSI::X509CertificateChain::_tao_any_destructor,
        ::CSI::_tc_X509CertificateChain,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::X509CertificateChain *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::X509CertificateChain *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::X509CertificateChain *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::X509CertificateChain>::extract (
          _tao_any,
          ::CSI::X509CertificateChain::_tao_any_destructor,
          ::CSI::_tc_X509CertificateChain,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::X509CertificateChain &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::X509CertificateChain *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::X509CertificateChain>::insert_copy (
        _tao_any,
        CSI::X509CertificateChain::_tao_any_destructor,
        CSI::_tc_X509CertificateChain,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::X509CertificateChain *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::X509CertificateChain>::insert (
      _tao_any,
      CSI::X509CertificateChain::_tao_any_destructor,
      CSI::_tc_X509CertificateChain,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::X509CertificateChain *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::X509CertificateChain *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::X509CertificateChain *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::X509CertificateChain>::extract (
        _tao_any,
        CSI::X509CertificateChain::_tao_any_destructor,
        CSI::_tc_X509CertificateChain,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::X501DistinguishedName &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::X501DistinguishedName *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::X501DistinguishedName>::insert_copy (
          _tao_any,
          ::CSI::X501DistinguishedName::_tao_any_destructor,
          ::CSI::_tc_X501DistinguishedName,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSI::X501DistinguishedName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::X501DistinguishedName>::insert (
        _tao_any,
        ::CSI::X501DistinguishedName::_tao_any_destructor,
        ::CSI::_tc_X501DistinguishedName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::X501DistinguishedName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::X501DistinguishedName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::X501DistinguishedName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::X501DistinguishedName>::extract (
          _tao_any,
          ::CSI::X501DistinguishedName::_tao_any_destructor,
          ::CSI::_tc_X501DistinguishedName,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::X501DistinguishedName &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::X501DistinguishedName *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::X501DistinguishedName>::insert_copy (
        _tao_any,
        CSI::X501DistinguishedName::_tao_any_destructor,
        CSI::_tc_X501DistinguishedName,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::X501DistinguishedName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::X501DistinguishedName>::insert (
      _tao_any,
      CSI::X501DistinguishedName::_tao_any_destructor,
      CSI::_tc_X501DistinguishedName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::X501DistinguishedName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::X501DistinguishedName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::X501DistinguishedName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::X501DistinguishedName>::extract (
        _tao_any,
        CSI::X501DistinguishedName::_tao_any_destructor,
        CSI::_tc_X501DistinguishedName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::UTF8String &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::UTF8String *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::UTF8String>::insert_copy (
          _tao_any,
          ::CSI::UTF8String::_tao_any_destructor,
          ::CSI::_tc_UTF8String,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSI::UTF8String *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::UTF8String>::insert (
        _tao_any,
        ::CSI::UTF8String::_tao_any_destructor,
        ::CSI::_tc_UTF8String,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::UTF8String *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::UTF8String *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::UTF8String *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::UTF8String>::extract (
          _tao_any,
          ::CSI::UTF8String::_tao_any_destructor,
          ::CSI::_tc_UTF8String,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::UTF8String &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::UTF8String *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::UTF8String>::insert_copy (
        _tao_any,
        CSI::UTF8String::_tao_any_destructor,
        CSI::_tc_UTF8String,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::UTF8String *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::UTF8String>::insert (
      _tao_any,
      CSI::UTF8String::_tao_any_destructor,
      CSI::_tc_UTF8String,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::UTF8String *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::UTF8String *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::UTF8String *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::UTF8String>::extract (
        _tao_any,
        CSI::UTF8String::_tao_any_destructor,
        CSI::_tc_UTF8String,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::OID &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::OID *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::OID>::insert_copy (
          _tao_any,
          ::CSI::OID::_tao_any_destructor,
          ::CSI::_tc_OID,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSI::OID *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::OID>::insert (
        _tao_any,
        ::CSI::OID::_tao_any_destructor,
        ::CSI::_tc_OID,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::OID *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::OID *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::OID *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::OID>::extract (
          _tao_any,
          ::CSI::OID::_tao_any_destructor,
          ::CSI::_tc_OID,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::OID &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::OID *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::OID>::insert_copy (
        _tao_any,
        CSI::OID::_tao_any_destructor,
        CSI::_tc_OID,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::OID *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::OID>::insert (
      _tao_any,
      CSI::OID::_tao_any_destructor,
      CSI::_tc_OID,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::OID *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::OID *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::OID *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::OID>::extract (
        _tao_any,
        CSI::OID::_tao_any_destructor,
        CSI::_tc_OID,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::OIDList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::OIDList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::OIDList>::insert_copy (
          _tao_any,
          ::CSI::OIDList::_tao_any_destructor,
          ::CSI::_tc_OIDList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSI::OIDList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::OIDList>::insert (
        _tao_any,
        ::CSI::OIDList::_tao_any_destructor,
        ::CSI::_tc_OIDList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::OIDList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::OIDList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::OIDList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::OIDList>::extract (
          _tao_any,
          ::CSI::OIDList::_tao_any_destructor,
          ::CSI::_tc_OIDList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::OIDList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::OIDList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::OIDList>::insert_copy (
        _tao_any,
        CSI::OIDList::_tao_any_destructor,
        CSI::_tc_OIDList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::OIDList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::OIDList>::insert (
      _tao_any,
      CSI::OIDList::_tao_any_destructor,
      CSI::_tc_OIDList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::OIDList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::OIDList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::OIDList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::OIDList>::extract (
        _tao_any,
        CSI::OIDList::_tao_any_destructor,
        CSI::_tc_OIDList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::GSSToken &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::GSSToken *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::GSSToken>::insert_copy (
          _tao_any,
          ::CSI::GSSToken::_tao_any_destructor,
          ::CSI::_tc_GSSToken,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSI::GSSToken *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::GSSToken>::insert (
        _tao_any,
        ::CSI::GSSToken::_tao_any_destructor,
        ::CSI::_tc_GSSToken,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::GSSToken *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::GSSToken *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::GSSToken *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::GSSToken>::extract (
          _tao_any,
          ::CSI::GSSToken::_tao_any_destructor,
          ::CSI::_tc_GSSToken,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::GSSToken &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::GSSToken *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::GSSToken>::insert_copy (
        _tao_any,
        CSI::GSSToken::_tao_any_destructor,
        CSI::_tc_GSSToken,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::GSSToken *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::GSSToken>::insert (
      _tao_any,
      CSI::GSSToken::_tao_any_destructor,
      CSI::_tc_GSSToken,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::GSSToken *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::GSSToken *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::GSSToken *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::GSSToken>::extract (
        _tao_any,
        CSI::GSSToken::_tao_any_destructor,
        CSI::_tc_GSSToken,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::GSS_NT_ExportedName &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::GSS_NT_ExportedName *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::GSS_NT_ExportedName>::insert_copy (
          _tao_any,
          ::CSI::GSS_NT_ExportedName::_tao_any_destructor,
          ::CSI::_tc_GSS_NT_ExportedName,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSI::GSS_NT_ExportedName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::GSS_NT_ExportedName>::insert (
        _tao_any,
        ::CSI::GSS_NT_ExportedName::_tao_any_destructor,
        ::CSI::_tc_GSS_NT_ExportedName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::GSS_NT_ExportedName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::GSS_NT_ExportedName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::GSS_NT_ExportedName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::GSS_NT_ExportedName>::extract (
          _tao_any,
          ::CSI::GSS_NT_ExportedName::_tao_any_destructor,
          ::CSI::_tc_GSS_NT_ExportedName,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::GSS_NT_ExportedName &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::GSS_NT_ExportedName *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::GSS_NT_ExportedName>::insert_copy (
        _tao_any,
        CSI::GSS_NT_ExportedName::_tao_any_destructor,
        CSI::_tc_GSS_NT_ExportedName,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::GSS_NT_ExportedName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::GSS_NT_ExportedName>::insert (
      _tao_any,
      CSI::GSS_NT_ExportedName::_tao_any_destructor,
      CSI::_tc_GSS_NT_ExportedName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::GSS_NT_ExportedName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::GSS_NT_ExportedName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::GSS_NT_ExportedName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::GSS_NT_ExportedName>::extract (
        _tao_any,
        CSI::GSS_NT_ExportedName::_tao_any_destructor,
        CSI::_tc_GSS_NT_ExportedName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::GSS_NT_ExportedNameList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::GSS_NT_ExportedNameList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::GSS_NT_ExportedNameList>::insert_copy (
          _tao_any,
          ::CSI::GSS_NT_ExportedNameList::_tao_any_destructor,
          ::CSI::_tc_GSS_NT_ExportedNameList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSI::GSS_NT_ExportedNameList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::GSS_NT_ExportedNameList>::insert (
        _tao_any,
        ::CSI::GSS_NT_ExportedNameList::_tao_any_destructor,
        ::CSI::_tc_GSS_NT_ExportedNameList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::GSS_NT_ExportedNameList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::GSS_NT_ExportedNameList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::GSS_NT_ExportedNameList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::GSS_NT_ExportedNameList>::extract (
          _tao_any,
          ::CSI::GSS_NT_ExportedNameList::_tao_any_destructor,
          ::CSI::_tc_GSS_NT_ExportedNameList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::GSS_NT_ExportedNameList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::GSS_NT_ExportedNameList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::GSS_NT_ExportedNameList>::insert_copy (
        _tao_any,
        CSI::GSS_NT_ExportedNameList::_tao_any_destructor,
        CSI::_tc_GSS_NT_ExportedNameList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::GSS_NT_ExportedNameList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::GSS_NT_ExportedNameList>::insert (
      _tao_any,
      CSI::GSS_NT_ExportedNameList::_tao_any_destructor,
      CSI::_tc_GSS_NT_ExportedNameList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::GSS_NT_ExportedNameList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::GSS_NT_ExportedNameList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::GSS_NT_ExportedNameList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::GSS_NT_ExportedNameList>::extract (
        _tao_any,
        CSI::GSS_NT_ExportedNameList::_tao_any_destructor,
        CSI::_tc_GSS_NT_ExportedNameList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::AuthorizationElementContents &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::AuthorizationElementContents *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::AuthorizationElementContents>::insert_copy (
          _tao_any,
          ::CSI::AuthorizationElementContents::_tao_any_destructor,
          ::CSI::_tc_AuthorizationElementContents,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSI::AuthorizationElementContents *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::AuthorizationElementContents>::insert (
        _tao_any,
        ::CSI::AuthorizationElementContents::_tao_any_destructor,
        ::CSI::_tc_AuthorizationElementContents,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::AuthorizationElementContents *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::AuthorizationElementContents *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::AuthorizationElementContents *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::AuthorizationElementContents>::extract (
          _tao_any,
          ::CSI::AuthorizationElementContents::_tao_any_destructor,
          ::CSI::_tc_AuthorizationElementContents,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::AuthorizationElementContents &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::AuthorizationElementContents *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::AuthorizationElementContents>::insert_copy (
        _tao_any,
        CSI::AuthorizationElementContents::_tao_any_destructor,
        CSI::_tc_AuthorizationElementContents,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::AuthorizationElementContents *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::AuthorizationElementContents>::insert (
      _tao_any,
      CSI::AuthorizationElementContents::_tao_any_destructor,
      CSI::_tc_AuthorizationElementContents,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::AuthorizationElementContents *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::AuthorizationElementContents *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::AuthorizationElementContents *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::AuthorizationElementContents>::extract (
        _tao_any,
        CSI::AuthorizationElementContents::_tao_any_destructor,
        CSI::_tc_AuthorizationElementContents,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::AuthorizationElement &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::AuthorizationElement *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::AuthorizationElement>::insert_copy (
          _tao_any,
          ::CSI::AuthorizationElement::_tao_any_destructor,
          ::CSI::_tc_AuthorizationElement,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CSI::AuthorizationElement *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::AuthorizationElement>::insert (
        _tao_any,
        ::CSI::AuthorizationElement::_tao_any_destructor,
        ::CSI::_tc_AuthorizationElement,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::AuthorizationElement *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::AuthorizationElement *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::AuthorizationElement *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::AuthorizationElement>::extract (
          _tao_any,
          ::CSI::AuthorizationElement::_tao_any_destructor,
          ::CSI::_tc_AuthorizationElement,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::AuthorizationElement &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::AuthorizationElement *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::AuthorizationElement>::insert_copy (
        _tao_any,
        CSI::AuthorizationElement::_tao_any_destructor,
        CSI::_tc_AuthorizationElement,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::AuthorizationElement *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::AuthorizationElement>::insert (
      _tao_any,
      CSI::AuthorizationElement::_tao_any_destructor,
      CSI::_tc_AuthorizationElement,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::AuthorizationElement *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::AuthorizationElement *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::AuthorizationElement *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::AuthorizationElement>::extract (
        _tao_any,
        CSI::AuthorizationElement::_tao_any_destructor,
        CSI::_tc_AuthorizationElement,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::AuthorizationToken &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::AuthorizationToken *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::AuthorizationToken>::insert_copy (
          _tao_any,
          ::CSI::AuthorizationToken::_tao_any_destructor,
          ::CSI::_tc_AuthorizationToken,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSI::AuthorizationToken *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::AuthorizationToken>::insert (
        _tao_any,
        ::CSI::AuthorizationToken::_tao_any_destructor,
        ::CSI::_tc_AuthorizationToken,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::AuthorizationToken *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::AuthorizationToken *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::AuthorizationToken *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::AuthorizationToken>::extract (
          _tao_any,
          ::CSI::AuthorizationToken::_tao_any_destructor,
          ::CSI::_tc_AuthorizationToken,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::AuthorizationToken &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::AuthorizationToken *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::AuthorizationToken>::insert_copy (
        _tao_any,
        CSI::AuthorizationToken::_tao_any_destructor,
        CSI::_tc_AuthorizationToken,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::AuthorizationToken *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::AuthorizationToken>::insert (
      _tao_any,
      CSI::AuthorizationToken::_tao_any_destructor,
      CSI::_tc_AuthorizationToken,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::AuthorizationToken *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::AuthorizationToken *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::AuthorizationToken *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::AuthorizationToken>::extract (
        _tao_any,
        CSI::AuthorizationToken::_tao_any_destructor,
        CSI::_tc_AuthorizationToken,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::IdentityExtension &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::IdentityExtension *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::IdentityExtension>::insert_copy (
          _tao_any,
          ::CSI::IdentityExtension::_tao_any_destructor,
          ::CSI::_tc_IdentityExtension,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSI::IdentityExtension *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::IdentityExtension>::insert (
        _tao_any,
        ::CSI::IdentityExtension::_tao_any_destructor,
        ::CSI::_tc_IdentityExtension,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::IdentityExtension *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::IdentityExtension *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::IdentityExtension *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::IdentityExtension>::extract (
          _tao_any,
          ::CSI::IdentityExtension::_tao_any_destructor,
          ::CSI::_tc_IdentityExtension,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::IdentityExtension &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::IdentityExtension *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::IdentityExtension>::insert_copy (
        _tao_any,
        CSI::IdentityExtension::_tao_any_destructor,
        CSI::_tc_IdentityExtension,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::IdentityExtension *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::IdentityExtension>::insert (
      _tao_any,
      CSI::IdentityExtension::_tao_any_destructor,
      CSI::_tc_IdentityExtension,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::IdentityExtension *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::IdentityExtension *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::IdentityExtension *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::IdentityExtension>::extract (
        _tao_any,
        CSI::IdentityExtension::_tao_any_destructor,
        CSI::_tc_IdentityExtension,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_union/any_op_cs.cpp:45



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::IdentityToken &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::IdentityToken *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::IdentityToken>::insert_copy (
          _tao_any,
          ::CSI::IdentityToken::_tao_any_destructor,
          ::CSI::_tc_IdentityToken,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSI::IdentityToken *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::IdentityToken>::insert (
        _tao_any,
        ::CSI::IdentityToken::_tao_any_destructor,
        ::CSI::_tc_IdentityToken,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::IdentityToken *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::IdentityToken *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::IdentityToken *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::IdentityToken>::extract (
          _tao_any,
          ::CSI::IdentityToken::_tao_any_destructor,
          ::CSI::_tc_IdentityToken,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::IdentityToken &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::IdentityToken *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::IdentityToken>::insert_copy (
        _tao_any,
        CSI::IdentityToken::_tao_any_destructor,
        CSI::_tc_IdentityToken,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::IdentityToken *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::IdentityToken>::insert (
      _tao_any,
      CSI::IdentityToken::_tao_any_destructor,
      CSI::_tc_IdentityToken,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::IdentityToken *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::IdentityToken *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::IdentityToken *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::IdentityToken>::extract (
        _tao_any,
        CSI::IdentityToken::_tao_any_destructor,
        CSI::_tc_IdentityToken,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::EstablishContext &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::EstablishContext *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::EstablishContext>::insert_copy (
          _tao_any,
          ::CSI::EstablishContext::_tao_any_destructor,
          ::CSI::_tc_EstablishContext,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CSI::EstablishContext *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::EstablishContext>::insert (
        _tao_any,
        ::CSI::EstablishContext::_tao_any_destructor,
        ::CSI::_tc_EstablishContext,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::EstablishContext *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::EstablishContext *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::EstablishContext *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::EstablishContext>::extract (
          _tao_any,
          ::CSI::EstablishContext::_tao_any_destructor,
          ::CSI::_tc_EstablishContext,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::EstablishContext &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::EstablishContext *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::EstablishContext>::insert_copy (
        _tao_any,
        CSI::EstablishContext::_tao_any_destructor,
        CSI::_tc_EstablishContext,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::EstablishContext *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::EstablishContext>::insert (
      _tao_any,
      CSI::EstablishContext::_tao_any_destructor,
      CSI::_tc_EstablishContext,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::EstablishContext *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::EstablishContext *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::EstablishContext *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::EstablishContext>::extract (
        _tao_any,
        CSI::EstablishContext::_tao_any_destructor,
        CSI::_tc_EstablishContext,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::CompleteEstablishContext &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::CompleteEstablishContext *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::CompleteEstablishContext>::insert_copy (
          _tao_any,
          ::CSI::CompleteEstablishContext::_tao_any_destructor,
          ::CSI::_tc_CompleteEstablishContext,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CSI::CompleteEstablishContext *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::CompleteEstablishContext>::insert (
        _tao_any,
        ::CSI::CompleteEstablishContext::_tao_any_destructor,
        ::CSI::_tc_CompleteEstablishContext,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::CompleteEstablishContext *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::CompleteEstablishContext *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::CompleteEstablishContext *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::CompleteEstablishContext>::extract (
          _tao_any,
          ::CSI::CompleteEstablishContext::_tao_any_destructor,
          ::CSI::_tc_CompleteEstablishContext,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::CompleteEstablishContext &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::CompleteEstablishContext *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::CompleteEstablishContext>::insert_copy (
        _tao_any,
        CSI::CompleteEstablishContext::_tao_any_destructor,
        CSI::_tc_CompleteEstablishContext,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::CompleteEstablishContext *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::CompleteEstablishContext>::insert (
      _tao_any,
      CSI::CompleteEstablishContext::_tao_any_destructor,
      CSI::_tc_CompleteEstablishContext,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::CompleteEstablishContext *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::CompleteEstablishContext *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::CompleteEstablishContext *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::CompleteEstablishContext>::extract (
        _tao_any,
        CSI::CompleteEstablishContext::_tao_any_destructor,
        CSI::_tc_CompleteEstablishContext,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::ContextError &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::ContextError *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::ContextError>::insert_copy (
          _tao_any,
          ::CSI::ContextError::_tao_any_destructor,
          ::CSI::_tc_ContextError,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CSI::ContextError *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::ContextError>::insert (
        _tao_any,
        ::CSI::ContextError::_tao_any_destructor,
        ::CSI::_tc_ContextError,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::ContextError *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::ContextError *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::ContextError *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::ContextError>::extract (
          _tao_any,
          ::CSI::ContextError::_tao_any_destructor,
          ::CSI::_tc_ContextError,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::ContextError &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::ContextError *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::ContextError>::insert_copy (
        _tao_any,
        CSI::ContextError::_tao_any_destructor,
        CSI::_tc_ContextError,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::ContextError *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::ContextError>::insert (
      _tao_any,
      CSI::ContextError::_tao_any_destructor,
      CSI::_tc_ContextError,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::ContextError *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::ContextError *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::ContextError *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::ContextError>::extract (
        _tao_any,
        CSI::ContextError::_tao_any_destructor,
        CSI::_tc_ContextError,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::MessageInContext &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::MessageInContext *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::MessageInContext>::insert_copy (
          _tao_any,
          ::CSI::MessageInContext::_tao_any_destructor,
          ::CSI::_tc_MessageInContext,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CSI::MessageInContext *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::MessageInContext>::insert (
        _tao_any,
        ::CSI::MessageInContext::_tao_any_destructor,
        ::CSI::_tc_MessageInContext,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::MessageInContext *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::MessageInContext *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::MessageInContext *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::MessageInContext>::extract (
          _tao_any,
          ::CSI::MessageInContext::_tao_any_destructor,
          ::CSI::_tc_MessageInContext,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::MessageInContext &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::MessageInContext *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::MessageInContext>::insert_copy (
        _tao_any,
        CSI::MessageInContext::_tao_any_destructor,
        CSI::_tc_MessageInContext,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::MessageInContext *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::MessageInContext>::insert (
      _tao_any,
      CSI::MessageInContext::_tao_any_destructor,
      CSI::_tc_MessageInContext,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::MessageInContext *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::MessageInContext *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::MessageInContext *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::MessageInContext>::extract (
        _tao_any,
        CSI::MessageInContext::_tao_any_destructor,
        CSI::_tc_MessageInContext,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_union/any_op_cs.cpp:45



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSI
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSI::SASContextBody &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSI::SASContextBody *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSI::SASContextBody>::insert_copy (
          _tao_any,
          ::CSI::SASContextBody::_tao_any_destructor,
          ::CSI::_tc_SASContextBody,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSI::SASContextBody *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSI::SASContextBody>::insert (
        _tao_any,
        ::CSI::SASContextBody::_tao_any_destructor,
        ::CSI::_tc_SASContextBody,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSI::SASContextBody *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSI::SASContextBody *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSI::SASContextBody *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSI::SASContextBody>::extract (
          _tao_any,
          ::CSI::SASContextBody::_tao_any_destructor,
          ::CSI::_tc_SASContextBody,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSI::SASContextBody &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSI::SASContextBody *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSI::SASContextBody>::insert_copy (
        _tao_any,
        CSI::SASContextBody::_tao_any_destructor,
        CSI::_tc_SASContextBody,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSI::SASContextBody *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSI::SASContextBody>::insert (
      _tao_any,
      CSI::SASContextBody::_tao_any_destructor,
      CSI::_tc_SASContextBody,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSI::SASContextBody *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSI::SASContextBody *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSI::SASContextBody *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSI::SASContextBody>::extract (
        _tao_any,
        CSI::SASContextBody::_tao_any_destructor,
        CSI::_tc_SASContextBody,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSI_X509CertificateChain_CPP_
#define _TAO_CDR_OP_CSI_X509CertificateChain_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::X509CertificateChain &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::X509CertificateChain &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSI_X509CertificateChain_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSI_X501DistinguishedName_CPP_
#define _TAO_CDR_OP_CSI_X501DistinguishedName_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::X501DistinguishedName &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::X501DistinguishedName &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSI_X501DistinguishedName_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSI_UTF8String_CPP_
#define _TAO_CDR_OP_CSI_UTF8String_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::UTF8String &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::UTF8String &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSI_UTF8String_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSI_OID_CPP_
#define _TAO_CDR_OP_CSI_OID_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::OID &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::OID &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSI_OID_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSI_OIDList_CPP_
#define _TAO_CDR_OP_CSI_OIDList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::OIDList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::OIDList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSI_OIDList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSI_GSSToken_CPP_
#define _TAO_CDR_OP_CSI_GSSToken_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::GSSToken &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::GSSToken &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSI_GSSToken_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSI_GSS_NT_ExportedName_CPP_
#define _TAO_CDR_OP_CSI_GSS_NT_ExportedName_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::GSS_NT_ExportedName &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::GSS_NT_ExportedName &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSI_GSS_NT_ExportedName_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSI_GSS_NT_ExportedNameList_CPP_
#define _TAO_CDR_OP_CSI_GSS_NT_ExportedNameList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::GSS_NT_ExportedNameList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::GSS_NT_ExportedNameList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSI_GSS_NT_ExportedNameList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSI_AuthorizationElementContents_CPP_
#define _TAO_CDR_OP_CSI_AuthorizationElementContents_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::AuthorizationElementContents &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::AuthorizationElementContents &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSI_AuthorizationElementContents_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::AuthorizationElement &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.the_type) &&
    (strm << _tao_aggregate.the_element);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::AuthorizationElement &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.the_type) &&
    (strm >> _tao_aggregate.the_element);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSI_AuthorizationToken_CPP_
#define _TAO_CDR_OP_CSI_AuthorizationToken_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::AuthorizationToken &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::AuthorizationToken &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSI_AuthorizationToken_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSI_IdentityExtension_CPP_
#define _TAO_CDR_OP_CSI_IdentityExtension_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::IdentityExtension &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::IdentityExtension &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSI_IdentityExtension_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_union/cdr_op_cs.cpp:82



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::IdentityToken &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case 0U:
      {
        result = strm << ::ACE_OutputCDR::from_boolean (_tao_union.absent ());
      }
      break;
    case 1U:
      {
        result = strm << ::ACE_OutputCDR::from_boolean (_tao_union.anonymous ());
      }
      break;
    case 2U:
      {
        result = strm << _tao_union.principal_name ();
      }
      break;
    case 4U:
      {
        result = strm << _tao_union.certificate_chain ();
      }
      break;
    case 8U:
      {
        result = strm << _tao_union.dn ();
      }
      break;
    default:
      {
        result = strm << _tao_union.id ();
      }
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::IdentityToken &_tao_union
  )
{
  CORBA::ULong _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case 0U:
      {
        ::CORBA::Boolean _tao_union_tmp;
        ::ACE_InputCDR::to_boolean _tao_union_helper (_tao_union_tmp);
        result = strm >> _tao_union_helper;

        if (result)
          {
            _tao_union.absent (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 1U:
      {
        ::CORBA::Boolean _tao_union_tmp;
        ::ACE_InputCDR::to_boolean _tao_union_helper (_tao_union_tmp);
        result = strm >> _tao_union_helper;

        if (result)
          {
            _tao_union.anonymous (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 2U:
      {
        CSI::GSS_NT_ExportedName _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.principal_name (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 4U:
      {
        CSI::X509CertificateChain _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.certificate_chain (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 8U:
      {
        CSI::X501DistinguishedName _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.dn (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      {
        CSI::IdentityExtension _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.id (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::EstablishContext &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.client_context_id) &&
    (strm << _tao_aggregate.authorization_token) &&
    (strm << _tao_aggregate.identity_token) &&
    (strm << _tao_aggregate.client_authentication_token);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::EstablishContext &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.client_context_id) &&
    (strm >> _tao_aggregate.authorization_token) &&
    (strm >> _tao_aggregate.identity_token) &&
    (strm >> _tao_aggregate.client_authentication_token);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::CompleteEstablishContext &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.client_context_id) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.context_stateful)) &&
    (strm << _tao_aggregate.final_context_token);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::CompleteEstablishContext &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.client_context_id) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.context_stateful)) &&
    (strm >> _tao_aggregate.final_context_token);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::ContextError &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.client_context_id) &&
    (strm << _tao_aggregate.major_status) &&
    (strm << _tao_aggregate.minor_status) &&
    (strm << _tao_aggregate.error_token);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::ContextError &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.client_context_id) &&
    (strm >> _tao_aggregate.major_status) &&
    (strm >> _tao_aggregate.minor_status) &&
    (strm >> _tao_aggregate.error_token);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::MessageInContext &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.client_context_id) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.discard_context));
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::MessageInContext &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.client_context_id) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.discard_context));
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_union/cdr_op_cs.cpp:82



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSI::SASContextBody &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case 0:
      {
        result = strm << _tao_union.establish_msg ();
      }
      break;
    case 1:
      {
        result = strm << _tao_union.complete_msg ();
      }
      break;
    case 4:
      {
        result = strm << _tao_union.error_msg ();
      }
      break;
    case 5:
      {
        result = strm << _tao_union.in_context_msg ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSI::SASContextBody &_tao_union
  )
{
  CORBA::Short _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case 0:
      {
        CSI::EstablishContext _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.establish_msg (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 1:
      {
        CSI::CompleteEstablishContext _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.complete_msg (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 4:
      {
        CSI::ContextError _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.error_msg (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 5:
      {
        CSI::MessageInContext _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.in_context_msg (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatability, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL





TAO_END_VERSIONED_NAMESPACE_DECL


