// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "FTRT_GroupManagerC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/Value_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Value_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Messaging/Asynch_Invocation_Adapter.h"
#include "tao/Messaging/ExceptionHolder_i.h"
#include "tao/Valuetype/ValueFactory.h"
#include "tao/Object_T.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "FTRT_GroupManagerC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_FTRT_Location (
    ::CORBA::tk_alias,
    "IDL:FTRT/Location:1.0",
    "Location",
    &CosNaming::_tc_Name);
  

namespace FTRT
{
  ::CORBA::TypeCode_ptr const _tc_Location =
    &_tao_tc_FTRT_Location;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for FTRT::FaultListener.

FTRT::FaultListener_ptr
TAO::Objref_Traits<FTRT::FaultListener>::duplicate (
    FTRT::FaultListener_ptr p)
{
  return FTRT::FaultListener::_duplicate (p);
}

void
TAO::Objref_Traits<FTRT::FaultListener>::release (
    FTRT::FaultListener_ptr p)
{
  ::CORBA::release (p);
}

FTRT::FaultListener_ptr
TAO::Objref_Traits<FTRT::FaultListener>::nil (void)
{
  return FTRT::FaultListener::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<FTRT::FaultListener>::marshal (
    const FTRT::FaultListener_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*FTRT__TAO_FaultListener_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
FTRT::FaultListener::replica_crashed (
  const ::FTRT::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FaultListener_Proxy_Broker_ == 0)
    {
      FTRT_FaultListener_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FTRT::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "replica_crashed",
      15,
      this->the_TAO_FaultListener_Proxy_Broker_,
      TAO::TAO_ONEWAY_INVOCATION
    );

  _tao_call.invoke (0, 0);
}

FTRT::FaultListener::FaultListener (void)
 : the_TAO_FaultListener_Proxy_Broker_ (0)
{
  this->FTRT_FaultListener_setup_collocation ();
}

void
FTRT::FaultListener::FTRT_FaultListener_setup_collocation ()
{
  if (::FTRT__TAO_FaultListener_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_FaultListener_Proxy_Broker_ =
        ::FTRT__TAO_FaultListener_Proxy_Broker_Factory_function_pointer (this);
    }
}

FTRT::FaultListener::~FaultListener (void)
{}

void 
FTRT::FaultListener::_tao_any_destructor (void *_tao_void_pointer)
{
  FaultListener *_tao_tmp_pointer =
    static_cast<FaultListener *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

FTRT::FaultListener_ptr
FTRT::FaultListener::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FaultListener>::narrow (
        _tao_objref,
        "IDL:FTRT/FaultListener:1.0",
        FTRT__TAO_FaultListener_Proxy_Broker_Factory_function_pointer
      );
}

FTRT::FaultListener_ptr
FTRT::FaultListener::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FaultListener>::unchecked_narrow (
        _tao_objref,
        "IDL:FTRT/FaultListener:1.0",
        FTRT__TAO_FaultListener_Proxy_Broker_Factory_function_pointer
      );
}

FTRT::FaultListener_ptr
FTRT::FaultListener::_nil (void)
{
  return 0;
}

FTRT::FaultListener_ptr
FTRT::FaultListener::_duplicate (FaultListener_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
FTRT::FaultListener::_tao_release (FaultListener_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
FTRT::FaultListener::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:FTRT/FaultListener:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* FTRT::FaultListener::_interface_repository_id (void) const
{
  return "IDL:FTRT/FaultListener:1.0";
}

::CORBA::Boolean
FTRT::FaultListener::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_FTRT_FaultListener (
    ::CORBA::tk_objref,
    "IDL:FTRT/FaultListener:1.0",
    "FaultListener");
  

namespace FTRT
{
  ::CORBA::TypeCode_ptr const _tc_FaultListener =
    &_tao_tc_FTRT_FaultListener;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for FTRT::AMI_FaultListenerHandler.

FTRT::AMI_FaultListenerHandler_ptr
TAO::Objref_Traits<FTRT::AMI_FaultListenerHandler>::duplicate (
    FTRT::AMI_FaultListenerHandler_ptr p)
{
  return FTRT::AMI_FaultListenerHandler::_duplicate (p);
}

void
TAO::Objref_Traits<FTRT::AMI_FaultListenerHandler>::release (
    FTRT::AMI_FaultListenerHandler_ptr p)
{
  ::CORBA::release (p);
}

FTRT::AMI_FaultListenerHandler_ptr
TAO::Objref_Traits<FTRT::AMI_FaultListenerHandler>::nil (void)
{
  return FTRT::AMI_FaultListenerHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<FTRT::AMI_FaultListenerHandler>::marshal (
    const FTRT::AMI_FaultListenerHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*FTRT__TAO_AMI_FaultListenerHandler_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

FTRT::AMI_FaultListenerHandler::AMI_FaultListenerHandler (void)
 : the_TAO_AMI_FaultListenerHandler_Proxy_Broker_ (0)
{
  this->FTRT_AMI_FaultListenerHandler_setup_collocation ();
}

void
FTRT::AMI_FaultListenerHandler::FTRT_AMI_FaultListenerHandler_setup_collocation ()
{
  if (::FTRT__TAO_AMI_FaultListenerHandler_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_AMI_FaultListenerHandler_Proxy_Broker_ =
        ::FTRT__TAO_AMI_FaultListenerHandler_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->Messaging_ReplyHandler_setup_collocation ();
}

FTRT::AMI_FaultListenerHandler::~AMI_FaultListenerHandler (void)
{}

void 
FTRT::AMI_FaultListenerHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_FaultListenerHandler *_tao_tmp_pointer =
    static_cast<AMI_FaultListenerHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

FTRT::AMI_FaultListenerHandler_ptr
FTRT::AMI_FaultListenerHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_FaultListenerHandler>::narrow (
        _tao_objref,
        "IDL:FTRT/AMI_FaultListenerHandler:1.0",
        FTRT__TAO_AMI_FaultListenerHandler_Proxy_Broker_Factory_function_pointer
      );
}

FTRT::AMI_FaultListenerHandler_ptr
FTRT::AMI_FaultListenerHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_FaultListenerHandler>::unchecked_narrow (
        _tao_objref,
        "IDL:FTRT/AMI_FaultListenerHandler:1.0",
        FTRT__TAO_AMI_FaultListenerHandler_Proxy_Broker_Factory_function_pointer
      );
}

FTRT::AMI_FaultListenerHandler_ptr
FTRT::AMI_FaultListenerHandler::_nil (void)
{
  return 0;
}

FTRT::AMI_FaultListenerHandler_ptr
FTRT::AMI_FaultListenerHandler::_duplicate (AMI_FaultListenerHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
FTRT::AMI_FaultListenerHandler::_tao_release (AMI_FaultListenerHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
FTRT::AMI_FaultListenerHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:FTRT/AMI_FaultListenerHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* FTRT::AMI_FaultListenerHandler::_interface_repository_id (void) const
{
  return "IDL:FTRT/AMI_FaultListenerHandler:1.0";
}

::CORBA::Boolean
FTRT::AMI_FaultListenerHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_FTRT_AMI_FaultListenerHandler (
    ::CORBA::tk_objref,
    "IDL:FTRT/AMI_FaultListenerHandler:1.0",
    "AMI_FaultListenerHandler");
  

namespace FTRT
{
  ::CORBA::TypeCode_ptr const _tc_AMI_FaultListenerHandler =
    &_tao_tc_FTRT_AMI_FaultListenerHandler;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_FTRT_ManagerInfo[] =
      {
        { "the_location", &FTRT::_tc_Location },
        { "ior", &FTRT::_tc_ObjectGroupManager }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_FTRT_ManagerInfo (
  ::CORBA::tk_struct,
  "IDL:FTRT/ManagerInfo:1.0",
  "ManagerInfo",
  _tao_fields_FTRT_ManagerInfo,
  2);


namespace FTRT
{
  ::CORBA::TypeCode_ptr const _tc_ManagerInfo =
    &_tao_tc_FTRT_ManagerInfo;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
FTRT::ManagerInfo::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ManagerInfo *_tao_tmp_pointer =
    static_cast<ManagerInfo *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

FTRT::PredecessorUnreachable::PredecessorUnreachable (void)
  : ::CORBA::UserException (
        "IDL:FTRT/PredecessorUnreachable:1.0",
        "PredecessorUnreachable"
      )
{
}

FTRT::PredecessorUnreachable::~PredecessorUnreachable (void)
{
}

FTRT::PredecessorUnreachable::PredecessorUnreachable (const ::FTRT::PredecessorUnreachable &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

FTRT::PredecessorUnreachable&
FTRT::PredecessorUnreachable::operator= (const ::FTRT::PredecessorUnreachable &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void FTRT::PredecessorUnreachable::_tao_any_destructor (void *_tao_void_pointer)
{
  PredecessorUnreachable *_tao_tmp_pointer =
    static_cast<PredecessorUnreachable *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

FTRT::PredecessorUnreachable *
FTRT::PredecessorUnreachable::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<PredecessorUnreachable *> (_tao_excp);
}

const FTRT::PredecessorUnreachable *
FTRT::PredecessorUnreachable::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const PredecessorUnreachable *> (_tao_excp);
}

::CORBA::Exception *FTRT::PredecessorUnreachable::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::FTRT::PredecessorUnreachable, 0);
  return retval;
}

::CORBA::Exception *
FTRT::PredecessorUnreachable::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::FTRT::PredecessorUnreachable (*this),
      0
    );
  return result;
}

void FTRT::PredecessorUnreachable::_raise (void) const
{
  throw *this;
}

void FTRT::PredecessorUnreachable::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void FTRT::PredecessorUnreachable::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr FTRT::PredecessorUnreachable::_tao_type (void) const
{
  return ::FTRT::_tc_PredecessorUnreachable;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_FTRT_PredecessorUnreachable = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_FTRT_PredecessorUnreachable (
  ::CORBA::tk_except,
  "IDL:FTRT/PredecessorUnreachable:1.0",
  "PredecessorUnreachable",
  _tao_fields_FTRT_PredecessorUnreachable,
  0);


namespace FTRT
{
  ::CORBA::TypeCode_ptr const _tc_PredecessorUnreachable =
    &_tao_tc_FTRT_PredecessorUnreachable;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_FTRT_MANAGERINFOLIST_CS_)
#define _FTRT_MANAGERINFOLIST_CS_

FTRT::ManagerInfoList::ManagerInfoList (void)
{}

FTRT::ManagerInfoList::ManagerInfoList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ManagerInfo
      > (max)
{}

FTRT::ManagerInfoList::ManagerInfoList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    FTRT::ManagerInfo * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ManagerInfo
      >
    (max, length, buffer, release)
{}

FTRT::ManagerInfoList::ManagerInfoList (
    const ManagerInfoList &seq)
  : ::TAO::unbounded_value_sequence<
        ManagerInfo
      > (seq)
{}

FTRT::ManagerInfoList::~ManagerInfoList (void)
{}

void FTRT::ManagerInfoList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ManagerInfoList * _tao_tmp_pointer =
    static_cast<ManagerInfoList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_FTRT_ManagerInfoList_GUARD
#define _TAO_TYPECODE_FTRT_ManagerInfoList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        FTRT_ManagerInfoList_0 (
          ::CORBA::tk_sequence,
          &FTRT::_tc_ManagerInfo,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_FTRT_ManagerInfoList_0 =
        &FTRT_ManagerInfoList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_FTRT_ManagerInfoList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_FTRT_ManagerInfoList (
    ::CORBA::tk_alias,
    "IDL:FTRT/ManagerInfoList:1.0",
    "ManagerInfoList",
    &TAO::TypeCode::tc_FTRT_ManagerInfoList_0);
  

namespace FTRT
{
  ::CORBA::TypeCode_ptr const _tc_ManagerInfoList =
    &_tao_tc_FTRT_ManagerInfoList;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

FTRT::InvalidState::InvalidState (void)
  : ::CORBA::UserException (
        "IDL:FTRT/InvalidState:1.0",
        "InvalidState"
      )
{
}

FTRT::InvalidState::~InvalidState (void)
{
}

FTRT::InvalidState::InvalidState (const ::FTRT::InvalidState &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

FTRT::InvalidState&
FTRT::InvalidState::operator= (const ::FTRT::InvalidState &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void FTRT::InvalidState::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidState *_tao_tmp_pointer =
    static_cast<InvalidState *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

FTRT::InvalidState *
FTRT::InvalidState::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidState *> (_tao_excp);
}

const FTRT::InvalidState *
FTRT::InvalidState::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidState *> (_tao_excp);
}

::CORBA::Exception *FTRT::InvalidState::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::FTRT::InvalidState, 0);
  return retval;
}

::CORBA::Exception *
FTRT::InvalidState::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::FTRT::InvalidState (*this),
      0
    );
  return result;
}

void FTRT::InvalidState::_raise (void) const
{
  throw *this;
}

void FTRT::InvalidState::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void FTRT::InvalidState::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr FTRT::InvalidState::_tao_type (void) const
{
  return ::FTRT::_tc_InvalidState;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_FTRT_InvalidState = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_FTRT_InvalidState (
  ::CORBA::tk_except,
  "IDL:FTRT/InvalidState:1.0",
  "InvalidState",
  _tao_fields_FTRT_InvalidState,
  0);


namespace FTRT
{
  ::CORBA::TypeCode_ptr const _tc_InvalidState =
    &_tao_tc_FTRT_InvalidState;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for FTRT::ObjectGroupManager.

FTRT::ObjectGroupManager_ptr
TAO::Objref_Traits<FTRT::ObjectGroupManager>::duplicate (
    FTRT::ObjectGroupManager_ptr p)
{
  return FTRT::ObjectGroupManager::_duplicate (p);
}

void
TAO::Objref_Traits<FTRT::ObjectGroupManager>::release (
    FTRT::ObjectGroupManager_ptr p)
{
  ::CORBA::release (p);
}

FTRT::ObjectGroupManager_ptr
TAO::Objref_Traits<FTRT::ObjectGroupManager>::nil (void)
{
  return FTRT::ObjectGroupManager::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<FTRT::ObjectGroupManager>::marshal (
    const FTRT::ObjectGroupManager_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*FTRT__TAO_ObjectGroupManager_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
FTRT::ObjectGroupManager::start (
  ::FTRT::FaultListener_ptr listener,
  ::FTRT::Location_out the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      FTRT_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FTRT::FaultListener>::in_arg_val _tao_listener (listener);
  TAO::Arg_Traits< ::FTRT::Location>::out_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_listener,
      &_tao_the_location
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "start",
      5,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
FTRT::ObjectGroupManager::create_group (
  const ::FTRT::ManagerInfoList & info_list,
  ::CORBA::ULong object_group_ref_version)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      FTRT_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FTRT::ManagerInfoList>::in_arg_val _tao_info_list (info_list);
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_object_group_ref_version (object_group_ref_version);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_info_list,
      &_tao_object_group_ref_version
    };

  static TAO::Exception_Data
  _tao_FTRT_ObjectGroupManager_create_group_exceptiondata [] = 
    {
      {
        "IDL:FTRT/PredecessorUnreachable:1.0",
        FTRT::PredecessorUnreachable::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , FTRT::_tc_PredecessorUnreachable
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "create_group",
      12,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_FTRT_ObjectGroupManager_create_group_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
FTRT::ObjectGroupManager::join_group (
  const ::FTRT::ManagerInfo & info)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      FTRT_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FTRT::ManagerInfo>::in_arg_val _tao_info (info);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_info
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "join_group",
      10,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_,
      TAO::TAO_ONEWAY_INVOCATION
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
FTRT::ObjectGroupManager::add_member (
  const ::FTRT::ManagerInfo & info,
  ::CORBA::ULong object_group_ref_version)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      FTRT_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FTRT::ManagerInfo>::in_arg_val _tao_info (info);
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_object_group_ref_version (object_group_ref_version);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_info,
      &_tao_object_group_ref_version
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "add_member",
      10,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
FTRT::ObjectGroupManager::remove_member (
  const ::FTRT::Location & crashed_location,
  ::CORBA::ULong object_group_ref_version)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      FTRT_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FTRT::Location>::in_arg_val _tao_crashed_location (crashed_location);
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_object_group_ref_version (object_group_ref_version);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_crashed_location,
      &_tao_object_group_ref_version
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "remove_member",
      13,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_,
      TAO::TAO_ONEWAY_INVOCATION
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
FTRT::ObjectGroupManager::set_state (
  const ::FTRT::State & stat)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      FTRT_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FTRT::State>::in_arg_val _tao_stat (stat);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_stat
    };

  static TAO::Exception_Data
  _tao_FTRT_ObjectGroupManager_set_state_exceptiondata [] = 
    {
      {
        "IDL:FTRT/InvalidState:1.0",
        FTRT::InvalidState::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , FTRT::_tc_InvalidState
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_state",
      9,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_FTRT_ObjectGroupManager_set_state_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
FTRT::ObjectGroupManager::sendc_start (
  ::FTRT::AMI_ObjectGroupManagerHandler_ptr ami_handler,
  ::FTRT::FaultListener_ptr listener)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      FTRT_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FTRT::FaultListener>::in_arg_val _tao_listener (listener);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_listener
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "start",
      5,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &FTRT::AMI_ObjectGroupManagerHandler::start_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
FTRT::ObjectGroupManager::sendc_create_group (
  ::FTRT::AMI_ObjectGroupManagerHandler_ptr ami_handler,
  const ::FTRT::ManagerInfoList & info_list,
  ::CORBA::ULong object_group_ref_version)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      FTRT_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FTRT::ManagerInfoList>::in_arg_val _tao_info_list (info_list);
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_object_group_ref_version (object_group_ref_version);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_info_list,
      &_tao_object_group_ref_version
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "create_group",
      12,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &FTRT::AMI_ObjectGroupManagerHandler::create_group_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
FTRT::ObjectGroupManager::sendc_add_member (
  ::FTRT::AMI_ObjectGroupManagerHandler_ptr ami_handler,
  const ::FTRT::ManagerInfo & info,
  ::CORBA::ULong object_group_ref_version)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      FTRT_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FTRT::ManagerInfo>::in_arg_val _tao_info (info);
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_object_group_ref_version (object_group_ref_version);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_info,
      &_tao_object_group_ref_version
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "add_member",
      10,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &FTRT::AMI_ObjectGroupManagerHandler::add_member_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
FTRT::ObjectGroupManager::sendc_set_state (
  ::FTRT::AMI_ObjectGroupManagerHandler_ptr ami_handler,
  const ::FTRT::State & stat)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      FTRT_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FTRT::State>::in_arg_val _tao_stat (stat);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_stat
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_state",
      9,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &FTRT::AMI_ObjectGroupManagerHandler::set_state_reply_stub
    );
}

FTRT::ObjectGroupManager::ObjectGroupManager (void)
 : the_TAO_ObjectGroupManager_Proxy_Broker_ (0)
{
  this->FTRT_ObjectGroupManager_setup_collocation ();
}

void
FTRT::ObjectGroupManager::FTRT_ObjectGroupManager_setup_collocation ()
{
  if (::FTRT__TAO_ObjectGroupManager_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_ObjectGroupManager_Proxy_Broker_ =
        ::FTRT__TAO_ObjectGroupManager_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->FTRT_FaultListener_setup_collocation ();
}

FTRT::ObjectGroupManager::~ObjectGroupManager (void)
{}

void 
FTRT::ObjectGroupManager::_tao_any_destructor (void *_tao_void_pointer)
{
  ObjectGroupManager *_tao_tmp_pointer =
    static_cast<ObjectGroupManager *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

FTRT::ObjectGroupManager_ptr
FTRT::ObjectGroupManager::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ObjectGroupManager>::narrow (
        _tao_objref,
        "IDL:FTRT/ObjectGroupManager:1.0",
        FTRT__TAO_ObjectGroupManager_Proxy_Broker_Factory_function_pointer
      );
}

FTRT::ObjectGroupManager_ptr
FTRT::ObjectGroupManager::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ObjectGroupManager>::unchecked_narrow (
        _tao_objref,
        "IDL:FTRT/ObjectGroupManager:1.0",
        FTRT__TAO_ObjectGroupManager_Proxy_Broker_Factory_function_pointer
      );
}

FTRT::ObjectGroupManager_ptr
FTRT::ObjectGroupManager::_nil (void)
{
  return 0;
}

FTRT::ObjectGroupManager_ptr
FTRT::ObjectGroupManager::_duplicate (ObjectGroupManager_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
FTRT::ObjectGroupManager::_tao_release (ObjectGroupManager_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
FTRT::ObjectGroupManager::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:FTRT/FaultListener:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:FTRT/ObjectGroupManager:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* FTRT::ObjectGroupManager::_interface_repository_id (void) const
{
  return "IDL:FTRT/ObjectGroupManager:1.0";
}

::CORBA::Boolean
FTRT::ObjectGroupManager::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_FTRT_ObjectGroupManager (
    ::CORBA::tk_objref,
    "IDL:FTRT/ObjectGroupManager:1.0",
    "ObjectGroupManager");
  

namespace FTRT
{
  ::CORBA::TypeCode_ptr const _tc_ObjectGroupManager =
    &_tao_tc_FTRT_ObjectGroupManager;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for FTRT::AMI_ObjectGroupManagerHandler.

FTRT::AMI_ObjectGroupManagerHandler_ptr
TAO::Objref_Traits<FTRT::AMI_ObjectGroupManagerHandler>::duplicate (
    FTRT::AMI_ObjectGroupManagerHandler_ptr p)
{
  return FTRT::AMI_ObjectGroupManagerHandler::_duplicate (p);
}

void
TAO::Objref_Traits<FTRT::AMI_ObjectGroupManagerHandler>::release (
    FTRT::AMI_ObjectGroupManagerHandler_ptr p)
{
  ::CORBA::release (p);
}

FTRT::AMI_ObjectGroupManagerHandler_ptr
TAO::Objref_Traits<FTRT::AMI_ObjectGroupManagerHandler>::nil (void)
{
  return FTRT::AMI_ObjectGroupManagerHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<FTRT::AMI_ObjectGroupManagerHandler>::marshal (
    const FTRT::AMI_ObjectGroupManagerHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*FTRT__TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
FTRT::AMI_ObjectGroupManagerHandler::start (
  ::CORBA::Boolean ami_return_val,
  const ::FTRT::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      FTRT_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_ami_return_val (ami_return_val);
  TAO::Arg_Traits< ::FTRT::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val,
      &_tao_the_location
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "start",
      5,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
FTRT::AMI_ObjectGroupManagerHandler::start_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  FTRT::AMI_ObjectGroupManagerHandler_var _tao_reply_handler_object =
    FTRT::AMI_ObjectGroupManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CORBA::Boolean ami_return_val;
      ::FTRT::Location the_location;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ::ACE_InputCDR::to_boolean (ami_return_val)) &&
            (_tao_in >> the_location)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->start (
          
          ami_return_val,
          
          the_location
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->start_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
FTRT::AMI_ObjectGroupManagerHandler::start_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      FTRT_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "start_excep",
      11,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
FTRT::AMI_ObjectGroupManagerHandler::create_group (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      FTRT_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_FTRT_AMI_ObjectGroupManagerHandler_create_group_exceptiondata [] = 
    {
      {
        "IDL:FTRT/PredecessorUnreachable:1.0",
        FTRT::PredecessorUnreachable::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , FTRT::_tc_PredecessorUnreachable
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "create_group",
      12,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_FTRT_AMI_ObjectGroupManagerHandler_create_group_exceptiondata,
      1
    );
}

void
FTRT::AMI_ObjectGroupManagerHandler::create_group_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  FTRT::AMI_ObjectGroupManagerHandler_var _tao_reply_handler_object =
    FTRT::AMI_ObjectGroupManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->create_group (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:FTRT/PredecessorUnreachable:1.0",
          FTRT::PredecessorUnreachable::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , FTRT::_tc_PredecessorUnreachable
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->create_group_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
FTRT::AMI_ObjectGroupManagerHandler::create_group_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      FTRT_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_FTRT_AMI_ObjectGroupManagerHandler_create_group_excep_exceptiondata [] = 
    {
      {
        "IDL:FTRT/PredecessorUnreachable:1.0",
        FTRT::PredecessorUnreachable::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , FTRT::_tc_PredecessorUnreachable
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "create_group_excep",
      18,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_FTRT_AMI_ObjectGroupManagerHandler_create_group_excep_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
FTRT::AMI_ObjectGroupManagerHandler::add_member (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      FTRT_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "add_member",
      10,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
FTRT::AMI_ObjectGroupManagerHandler::add_member_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  FTRT::AMI_ObjectGroupManagerHandler_var _tao_reply_handler_object =
    FTRT::AMI_ObjectGroupManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->add_member (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->add_member_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
FTRT::AMI_ObjectGroupManagerHandler::add_member_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      FTRT_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "add_member_excep",
      16,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
FTRT::AMI_ObjectGroupManagerHandler::set_state (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      FTRT_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_FTRT_AMI_ObjectGroupManagerHandler_set_state_exceptiondata [] = 
    {
      {
        "IDL:FTRT/InvalidState:1.0",
        FTRT::InvalidState::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , FTRT::_tc_InvalidState
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "set_state",
      9,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_FTRT_AMI_ObjectGroupManagerHandler_set_state_exceptiondata,
      1
    );
}

void
FTRT::AMI_ObjectGroupManagerHandler::set_state_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  FTRT::AMI_ObjectGroupManagerHandler_var _tao_reply_handler_object =
    FTRT::AMI_ObjectGroupManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->set_state (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:FTRT/InvalidState:1.0",
          FTRT::InvalidState::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , FTRT::_tc_InvalidState
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->set_state_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
FTRT::AMI_ObjectGroupManagerHandler::set_state_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      FTRT_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_FTRT_AMI_ObjectGroupManagerHandler_set_state_excep_exceptiondata [] = 
    {
      {
        "IDL:FTRT/InvalidState:1.0",
        FTRT::InvalidState::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , FTRT::_tc_InvalidState
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_state_excep",
      15,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_FTRT_AMI_ObjectGroupManagerHandler_set_state_excep_exceptiondata,
      1
    );
}

FTRT::AMI_ObjectGroupManagerHandler::AMI_ObjectGroupManagerHandler (void)
 : the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ (0)
{
  this->FTRT_AMI_ObjectGroupManagerHandler_setup_collocation ();
}

void
FTRT::AMI_ObjectGroupManagerHandler::FTRT_AMI_ObjectGroupManagerHandler_setup_collocation ()
{
  if (::FTRT__TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ =
        ::FTRT__TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->FTRT_AMI_FaultListenerHandler_setup_collocation ();
}

FTRT::AMI_ObjectGroupManagerHandler::~AMI_ObjectGroupManagerHandler (void)
{}

void 
FTRT::AMI_ObjectGroupManagerHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_ObjectGroupManagerHandler *_tao_tmp_pointer =
    static_cast<AMI_ObjectGroupManagerHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

FTRT::AMI_ObjectGroupManagerHandler_ptr
FTRT::AMI_ObjectGroupManagerHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_ObjectGroupManagerHandler>::narrow (
        _tao_objref,
        "IDL:FTRT/AMI_ObjectGroupManagerHandler:1.0",
        FTRT__TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_Factory_function_pointer
      );
}

FTRT::AMI_ObjectGroupManagerHandler_ptr
FTRT::AMI_ObjectGroupManagerHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_ObjectGroupManagerHandler>::unchecked_narrow (
        _tao_objref,
        "IDL:FTRT/AMI_ObjectGroupManagerHandler:1.0",
        FTRT__TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_Factory_function_pointer
      );
}

FTRT::AMI_ObjectGroupManagerHandler_ptr
FTRT::AMI_ObjectGroupManagerHandler::_nil (void)
{
  return 0;
}

FTRT::AMI_ObjectGroupManagerHandler_ptr
FTRT::AMI_ObjectGroupManagerHandler::_duplicate (AMI_ObjectGroupManagerHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
FTRT::AMI_ObjectGroupManagerHandler::_tao_release (AMI_ObjectGroupManagerHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
FTRT::AMI_ObjectGroupManagerHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:FTRT/AMI_FaultListenerHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:FTRT/AMI_ObjectGroupManagerHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* FTRT::AMI_ObjectGroupManagerHandler::_interface_repository_id (void) const
{
  return "IDL:FTRT/AMI_ObjectGroupManagerHandler:1.0";
}

::CORBA::Boolean
FTRT::AMI_ObjectGroupManagerHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_FTRT_AMI_ObjectGroupManagerHandler (
    ::CORBA::tk_objref,
    "IDL:FTRT/AMI_ObjectGroupManagerHandler:1.0",
    "AMI_ObjectGroupManagerHandler");
  

namespace FTRT
{
  ::CORBA::TypeCode_ptr const _tc_AMI_ObjectGroupManagerHandler =
    &_tao_tc_FTRT_AMI_ObjectGroupManagerHandler;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<FTRT::FaultListener>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FTRT
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FaultListener_ptr _tao_elem)
  {
    FaultListener_ptr _tao_objptr =
      FaultListener::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FaultListener_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<FaultListener>::insert (
        _tao_any,
        FaultListener::_tao_any_destructor,
        _tc_FaultListener,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      FaultListener_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<FaultListener>::extract (
          _tao_any,
          FaultListener::_tao_any_destructor,
          _tc_FaultListener,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FTRT::FaultListener_ptr _tao_elem)
{
  FTRT::FaultListener_ptr _tao_objptr =
    FTRT::FaultListener::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FTRT::FaultListener_ptr *_tao_elem)
{
  TAO::Any_Impl_T<FTRT::FaultListener>::insert (
      _tao_any,
      FTRT::FaultListener::_tao_any_destructor,
      FTRT::_tc_FaultListener,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    FTRT::FaultListener_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<FTRT::FaultListener>::extract (
        _tao_any,
        FTRT::FaultListener::_tao_any_destructor,
        FTRT::_tc_FaultListener,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<FTRT::AMI_FaultListenerHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FTRT
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_FaultListenerHandler_ptr _tao_elem)
  {
    AMI_FaultListenerHandler_ptr _tao_objptr =
      AMI_FaultListenerHandler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_FaultListenerHandler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AMI_FaultListenerHandler>::insert (
        _tao_any,
        AMI_FaultListenerHandler::_tao_any_destructor,
        _tc_AMI_FaultListenerHandler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMI_FaultListenerHandler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AMI_FaultListenerHandler>::extract (
          _tao_any,
          AMI_FaultListenerHandler::_tao_any_destructor,
          _tc_AMI_FaultListenerHandler,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FTRT::AMI_FaultListenerHandler_ptr _tao_elem)
{
  FTRT::AMI_FaultListenerHandler_ptr _tao_objptr =
    FTRT::AMI_FaultListenerHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FTRT::AMI_FaultListenerHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<FTRT::AMI_FaultListenerHandler>::insert (
      _tao_any,
      FTRT::AMI_FaultListenerHandler::_tao_any_destructor,
      FTRT::_tc_AMI_FaultListenerHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    FTRT::AMI_FaultListenerHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<FTRT::AMI_FaultListenerHandler>::extract (
        _tao_any,
        FTRT::AMI_FaultListenerHandler::_tao_any_destructor,
        FTRT::_tc_AMI_FaultListenerHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FTRT
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::FTRT::ManagerInfo &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::FTRT::ManagerInfo *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::FTRT::ManagerInfo>::insert_copy (
          _tao_any,
          ::FTRT::ManagerInfo::_tao_any_destructor,
          ::FTRT::_tc_ManagerInfo,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      FTRT::ManagerInfo *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::FTRT::ManagerInfo>::insert (
        _tao_any,
        ::FTRT::ManagerInfo::_tao_any_destructor,
        ::FTRT::_tc_ManagerInfo,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::FTRT::ManagerInfo *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::FTRT::ManagerInfo *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::FTRT::ManagerInfo *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::FTRT::ManagerInfo>::extract (
          _tao_any,
          ::FTRT::ManagerInfo::_tao_any_destructor,
          ::FTRT::_tc_ManagerInfo,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const FTRT::ManagerInfo &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<FTRT::ManagerInfo *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<FTRT::ManagerInfo>::insert_copy (
        _tao_any,
        FTRT::ManagerInfo::_tao_any_destructor,
        FTRT::_tc_ManagerInfo,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    FTRT::ManagerInfo *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<FTRT::ManagerInfo>::insert (
      _tao_any,
      FTRT::ManagerInfo::_tao_any_destructor,
      FTRT::_tc_ManagerInfo,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    FTRT::ManagerInfo *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const FTRT::ManagerInfo *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const FTRT::ManagerInfo *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<FTRT::ManagerInfo>::extract (
        _tao_any,
        FTRT::ManagerInfo::_tao_any_destructor,
        FTRT::_tc_ManagerInfo,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<FTRT::PredecessorUnreachable>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FTRT
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::FTRT::PredecessorUnreachable &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::FTRT::PredecessorUnreachable>::insert_copy (
        _tao_any,
        ::FTRT::PredecessorUnreachable::_tao_any_destructor,
        ::FTRT::_tc_PredecessorUnreachable,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::FTRT::PredecessorUnreachable *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::FTRT::PredecessorUnreachable>::insert (
        _tao_any,
        ::FTRT::PredecessorUnreachable::_tao_any_destructor,
        ::FTRT::_tc_PredecessorUnreachable,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::FTRT::PredecessorUnreachable *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::FTRT::PredecessorUnreachable *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::FTRT::PredecessorUnreachable *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::FTRT::PredecessorUnreachable>::extract (
          _tao_any,
          ::FTRT::PredecessorUnreachable::_tao_any_destructor,
          ::FTRT::_tc_PredecessorUnreachable,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const FTRT::PredecessorUnreachable &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<FTRT::PredecessorUnreachable>::insert_copy (
      _tao_any,
      FTRT::PredecessorUnreachable::_tao_any_destructor,
      FTRT::_tc_PredecessorUnreachable,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    FTRT::PredecessorUnreachable *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<FTRT::PredecessorUnreachable>::insert (
      _tao_any,
      FTRT::PredecessorUnreachable::_tao_any_destructor,
      FTRT::_tc_PredecessorUnreachable,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    FTRT::PredecessorUnreachable *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const FTRT::PredecessorUnreachable *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const FTRT::PredecessorUnreachable *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<FTRT::PredecessorUnreachable>::extract (
        _tao_any,
        FTRT::PredecessorUnreachable::_tao_any_destructor,
        FTRT::_tc_PredecessorUnreachable,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FTRT
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::FTRT::ManagerInfoList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::FTRT::ManagerInfoList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::FTRT::ManagerInfoList>::insert_copy (
          _tao_any,
          ::FTRT::ManagerInfoList::_tao_any_destructor,
          ::FTRT::_tc_ManagerInfoList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::FTRT::ManagerInfoList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::FTRT::ManagerInfoList>::insert (
        _tao_any,
        ::FTRT::ManagerInfoList::_tao_any_destructor,
        ::FTRT::_tc_ManagerInfoList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::FTRT::ManagerInfoList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::FTRT::ManagerInfoList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::FTRT::ManagerInfoList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::FTRT::ManagerInfoList>::extract (
          _tao_any,
          ::FTRT::ManagerInfoList::_tao_any_destructor,
          ::FTRT::_tc_ManagerInfoList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const FTRT::ManagerInfoList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<FTRT::ManagerInfoList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<FTRT::ManagerInfoList>::insert_copy (
        _tao_any,
        FTRT::ManagerInfoList::_tao_any_destructor,
        FTRT::_tc_ManagerInfoList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    FTRT::ManagerInfoList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<FTRT::ManagerInfoList>::insert (
      _tao_any,
      FTRT::ManagerInfoList::_tao_any_destructor,
      FTRT::_tc_ManagerInfoList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    FTRT::ManagerInfoList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const FTRT::ManagerInfoList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const FTRT::ManagerInfoList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<FTRT::ManagerInfoList>::extract (
        _tao_any,
        FTRT::ManagerInfoList::_tao_any_destructor,
        FTRT::_tc_ManagerInfoList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<FTRT::InvalidState>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FTRT
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::FTRT::InvalidState &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::FTRT::InvalidState>::insert_copy (
        _tao_any,
        ::FTRT::InvalidState::_tao_any_destructor,
        ::FTRT::_tc_InvalidState,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::FTRT::InvalidState *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::FTRT::InvalidState>::insert (
        _tao_any,
        ::FTRT::InvalidState::_tao_any_destructor,
        ::FTRT::_tc_InvalidState,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::FTRT::InvalidState *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::FTRT::InvalidState *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::FTRT::InvalidState *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::FTRT::InvalidState>::extract (
          _tao_any,
          ::FTRT::InvalidState::_tao_any_destructor,
          ::FTRT::_tc_InvalidState,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const FTRT::InvalidState &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<FTRT::InvalidState>::insert_copy (
      _tao_any,
      FTRT::InvalidState::_tao_any_destructor,
      FTRT::_tc_InvalidState,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    FTRT::InvalidState *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<FTRT::InvalidState>::insert (
      _tao_any,
      FTRT::InvalidState::_tao_any_destructor,
      FTRT::_tc_InvalidState,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    FTRT::InvalidState *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const FTRT::InvalidState *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const FTRT::InvalidState *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<FTRT::InvalidState>::extract (
        _tao_any,
        FTRT::InvalidState::_tao_any_destructor,
        FTRT::_tc_InvalidState,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<FTRT::ObjectGroupManager>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FTRT
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ObjectGroupManager_ptr _tao_elem)
  {
    ObjectGroupManager_ptr _tao_objptr =
      ObjectGroupManager::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ObjectGroupManager_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<ObjectGroupManager>::insert (
        _tao_any,
        ObjectGroupManager::_tao_any_destructor,
        _tc_ObjectGroupManager,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      ObjectGroupManager_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<ObjectGroupManager>::extract (
          _tao_any,
          ObjectGroupManager::_tao_any_destructor,
          _tc_ObjectGroupManager,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FTRT::ObjectGroupManager_ptr _tao_elem)
{
  FTRT::ObjectGroupManager_ptr _tao_objptr =
    FTRT::ObjectGroupManager::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FTRT::ObjectGroupManager_ptr *_tao_elem)
{
  TAO::Any_Impl_T<FTRT::ObjectGroupManager>::insert (
      _tao_any,
      FTRT::ObjectGroupManager::_tao_any_destructor,
      FTRT::_tc_ObjectGroupManager,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    FTRT::ObjectGroupManager_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<FTRT::ObjectGroupManager>::extract (
        _tao_any,
        FTRT::ObjectGroupManager::_tao_any_destructor,
        FTRT::_tc_ObjectGroupManager,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<FTRT::AMI_ObjectGroupManagerHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FTRT
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_ObjectGroupManagerHandler_ptr _tao_elem)
  {
    AMI_ObjectGroupManagerHandler_ptr _tao_objptr =
      AMI_ObjectGroupManagerHandler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_ObjectGroupManagerHandler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AMI_ObjectGroupManagerHandler>::insert (
        _tao_any,
        AMI_ObjectGroupManagerHandler::_tao_any_destructor,
        _tc_AMI_ObjectGroupManagerHandler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMI_ObjectGroupManagerHandler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AMI_ObjectGroupManagerHandler>::extract (
          _tao_any,
          AMI_ObjectGroupManagerHandler::_tao_any_destructor,
          _tc_AMI_ObjectGroupManagerHandler,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FTRT::AMI_ObjectGroupManagerHandler_ptr _tao_elem)
{
  FTRT::AMI_ObjectGroupManagerHandler_ptr _tao_objptr =
    FTRT::AMI_ObjectGroupManagerHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FTRT::AMI_ObjectGroupManagerHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<FTRT::AMI_ObjectGroupManagerHandler>::insert (
      _tao_any,
      FTRT::AMI_ObjectGroupManagerHandler::_tao_any_destructor,
      FTRT::_tc_AMI_ObjectGroupManagerHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    FTRT::AMI_ObjectGroupManagerHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<FTRT::AMI_ObjectGroupManagerHandler>::extract (
        _tao_any,
        FTRT::AMI_ObjectGroupManagerHandler::_tao_any_destructor,
        FTRT::_tc_AMI_ObjectGroupManagerHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FTRT::FaultListener_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FTRT::FaultListener_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::FTRT::FaultListener RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        FTRT__TAO_FaultListener_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FTRT::AMI_FaultListenerHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FTRT::AMI_FaultListenerHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::FTRT::AMI_FaultListenerHandler RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        FTRT__TAO_AMI_FaultListenerHandler_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FTRT::ManagerInfo &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.the_location) &&
    ::CORBA::Object::marshal (
        _tao_aggregate.ior.in (),
        strm
      );
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FTRT::ManagerInfo &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.the_location) &&
    (strm >> _tao_aggregate.ior.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FTRT::PredecessorUnreachable &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    FTRT::PredecessorUnreachable&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_FTRT_ManagerInfoList_CPP_
#define _TAO_CDR_OP_FTRT_ManagerInfoList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FTRT::ManagerInfoList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FTRT::ManagerInfoList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_FTRT_ManagerInfoList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FTRT::InvalidState &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    FTRT::InvalidState&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FTRT::ObjectGroupManager_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FTRT::ObjectGroupManager_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::FTRT::ObjectGroupManager RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        FTRT__TAO_ObjectGroupManager_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FTRT::AMI_ObjectGroupManagerHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FTRT::AMI_ObjectGroupManagerHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::FTRT::AMI_ObjectGroupManagerHandler RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        FTRT__TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL





TAO_END_VERSIONED_NAMESPACE_DECL


