// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "SecurityLevel2C.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/ORB_Core.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "SecurityLevel2C.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::PrincipalAuthenticator.

SecurityLevel2::PrincipalAuthenticator_ptr
TAO::Objref_Traits<SecurityLevel2::PrincipalAuthenticator>::duplicate (
    SecurityLevel2::PrincipalAuthenticator_ptr p)
{
  return SecurityLevel2::PrincipalAuthenticator::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::PrincipalAuthenticator>::release (
    SecurityLevel2::PrincipalAuthenticator_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::PrincipalAuthenticator_ptr
TAO::Objref_Traits<SecurityLevel2::PrincipalAuthenticator>::nil (void)
{
  return SecurityLevel2::PrincipalAuthenticator::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::PrincipalAuthenticator>::marshal (
    const SecurityLevel2::PrincipalAuthenticator_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

SecurityLevel2::PrincipalAuthenticator::PrincipalAuthenticator (void)
{}

SecurityLevel2::PrincipalAuthenticator::~PrincipalAuthenticator (void)
{}

void 
SecurityLevel2::PrincipalAuthenticator::_tao_any_destructor (void *_tao_void_pointer)
{
  PrincipalAuthenticator *_tao_tmp_pointer =
    static_cast<PrincipalAuthenticator *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::PrincipalAuthenticator_ptr
SecurityLevel2::PrincipalAuthenticator::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return PrincipalAuthenticator::_duplicate (
      dynamic_cast<PrincipalAuthenticator_ptr> (_tao_objref)
    );
}

SecurityLevel2::PrincipalAuthenticator_ptr
SecurityLevel2::PrincipalAuthenticator::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return PrincipalAuthenticator::_duplicate (
      dynamic_cast<PrincipalAuthenticator_ptr> (_tao_objref)
    );
}

SecurityLevel2::PrincipalAuthenticator_ptr
SecurityLevel2::PrincipalAuthenticator::_nil (void)
{
  return 0;
}

SecurityLevel2::PrincipalAuthenticator_ptr
SecurityLevel2::PrincipalAuthenticator::_duplicate (PrincipalAuthenticator_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::PrincipalAuthenticator::_tao_release (PrincipalAuthenticator_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::PrincipalAuthenticator::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/PrincipalAuthenticator:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* SecurityLevel2::PrincipalAuthenticator::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/PrincipalAuthenticator:1.8";
}

::CORBA::Boolean
SecurityLevel2::PrincipalAuthenticator::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_PrincipalAuthenticator (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/SecurityLevel2/PrincipalAuthenticator:1.8",
    "PrincipalAuthenticator");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_PrincipalAuthenticator =
    &_tao_tc_SecurityLevel2_PrincipalAuthenticator;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::Credentials.

SecurityLevel2::Credentials_ptr
TAO::Objref_Traits<SecurityLevel2::Credentials>::duplicate (
    SecurityLevel2::Credentials_ptr p)
{
  return SecurityLevel2::Credentials::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::Credentials>::release (
    SecurityLevel2::Credentials_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::Credentials_ptr
TAO::Objref_Traits<SecurityLevel2::Credentials>::nil (void)
{
  return SecurityLevel2::Credentials::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::Credentials>::marshal (
    const SecurityLevel2::Credentials_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

SecurityLevel2::Credentials::Credentials (void)
{}

SecurityLevel2::Credentials::~Credentials (void)
{}

void 
SecurityLevel2::Credentials::_tao_any_destructor (void *_tao_void_pointer)
{
  Credentials *_tao_tmp_pointer =
    static_cast<Credentials *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::Credentials_ptr
SecurityLevel2::Credentials::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return Credentials::_duplicate (
      dynamic_cast<Credentials_ptr> (_tao_objref)
    );
}

SecurityLevel2::Credentials_ptr
SecurityLevel2::Credentials::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return Credentials::_duplicate (
      dynamic_cast<Credentials_ptr> (_tao_objref)
    );
}

SecurityLevel2::Credentials_ptr
SecurityLevel2::Credentials::_nil (void)
{
  return 0;
}

SecurityLevel2::Credentials_ptr
SecurityLevel2::Credentials::_duplicate (Credentials_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::Credentials::_tao_release (Credentials_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::Credentials::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/Credentials:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* SecurityLevel2::Credentials::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/Credentials:1.8";
}

::CORBA::Boolean
SecurityLevel2::Credentials::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_Credentials (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/SecurityLevel2/Credentials:1.8",
    "Credentials");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_Credentials =
    &_tao_tc_SecurityLevel2_Credentials;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_SECURITYLEVEL2_CREDENTIALSLIST_CS_)
#define _SECURITYLEVEL2_CREDENTIALSLIST_CS_

SecurityLevel2::CredentialsList::CredentialsList (void)
{}

SecurityLevel2::CredentialsList::CredentialsList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        Credentials,
        Credentials_var
      > (max)
{}

SecurityLevel2::CredentialsList::CredentialsList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    SecurityLevel2::Credentials_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        Credentials,
        Credentials_var
      >
    (max, length, buffer, release)
{}

SecurityLevel2::CredentialsList::CredentialsList (
    const CredentialsList &seq)
  : ::TAO::unbounded_object_reference_sequence<
        Credentials,
        Credentials_var
      > (seq)
{}

SecurityLevel2::CredentialsList::~CredentialsList (void)
{}

void SecurityLevel2::CredentialsList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  CredentialsList * _tao_tmp_pointer =
    static_cast<CredentialsList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_SecurityLevel2_CredentialsList_GUARD
#define _TAO_TYPECODE_SecurityLevel2_CredentialsList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        SecurityLevel2_CredentialsList_0 (
          ::CORBA::tk_sequence,
          &SecurityLevel2::_tc_Credentials,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_SecurityLevel2_CredentialsList_0 =
        &SecurityLevel2_CredentialsList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_SecurityLevel2_CredentialsList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_CredentialsList (
    ::CORBA::tk_alias,
    "IDL:omg.org/SecurityLevel2/CredentialsList:1.8",
    "CredentialsList",
    &TAO::TypeCode::tc_SecurityLevel2_CredentialsList_0);
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_CredentialsList =
    &_tao_tc_SecurityLevel2_CredentialsList;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::ReceivedCredentials.

SecurityLevel2::ReceivedCredentials_ptr
TAO::Objref_Traits<SecurityLevel2::ReceivedCredentials>::duplicate (
    SecurityLevel2::ReceivedCredentials_ptr p)
{
  return SecurityLevel2::ReceivedCredentials::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::ReceivedCredentials>::release (
    SecurityLevel2::ReceivedCredentials_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::ReceivedCredentials_ptr
TAO::Objref_Traits<SecurityLevel2::ReceivedCredentials>::nil (void)
{
  return SecurityLevel2::ReceivedCredentials::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::ReceivedCredentials>::marshal (
    const SecurityLevel2::ReceivedCredentials_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

SecurityLevel2::ReceivedCredentials::ReceivedCredentials (void)
{}

SecurityLevel2::ReceivedCredentials::~ReceivedCredentials (void)
{}

void 
SecurityLevel2::ReceivedCredentials::_tao_any_destructor (void *_tao_void_pointer)
{
  ReceivedCredentials *_tao_tmp_pointer =
    static_cast<ReceivedCredentials *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::ReceivedCredentials_ptr
SecurityLevel2::ReceivedCredentials::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return ReceivedCredentials::_duplicate (
      dynamic_cast<ReceivedCredentials_ptr> (_tao_objref)
    );
}

SecurityLevel2::ReceivedCredentials_ptr
SecurityLevel2::ReceivedCredentials::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return ReceivedCredentials::_duplicate (
      dynamic_cast<ReceivedCredentials_ptr> (_tao_objref)
    );
}

SecurityLevel2::ReceivedCredentials_ptr
SecurityLevel2::ReceivedCredentials::_nil (void)
{
  return 0;
}

SecurityLevel2::ReceivedCredentials_ptr
SecurityLevel2::ReceivedCredentials::_duplicate (ReceivedCredentials_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::ReceivedCredentials::_tao_release (ReceivedCredentials_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::ReceivedCredentials::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/Credentials:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/ReceivedCredentials:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* SecurityLevel2::ReceivedCredentials::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/ReceivedCredentials:1.8";
}

::CORBA::Boolean
SecurityLevel2::ReceivedCredentials::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_ReceivedCredentials (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/SecurityLevel2/ReceivedCredentials:1.8",
    "ReceivedCredentials");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_ReceivedCredentials =
    &_tao_tc_SecurityLevel2_ReceivedCredentials;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::TargetCredentials.

SecurityLevel2::TargetCredentials_ptr
TAO::Objref_Traits<SecurityLevel2::TargetCredentials>::duplicate (
    SecurityLevel2::TargetCredentials_ptr p)
{
  return SecurityLevel2::TargetCredentials::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::TargetCredentials>::release (
    SecurityLevel2::TargetCredentials_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::TargetCredentials_ptr
TAO::Objref_Traits<SecurityLevel2::TargetCredentials>::nil (void)
{
  return SecurityLevel2::TargetCredentials::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::TargetCredentials>::marshal (
    const SecurityLevel2::TargetCredentials_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

SecurityLevel2::TargetCredentials::TargetCredentials (void)
{}

SecurityLevel2::TargetCredentials::~TargetCredentials (void)
{}

void 
SecurityLevel2::TargetCredentials::_tao_any_destructor (void *_tao_void_pointer)
{
  TargetCredentials *_tao_tmp_pointer =
    static_cast<TargetCredentials *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::TargetCredentials_ptr
SecurityLevel2::TargetCredentials::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return TargetCredentials::_duplicate (
      dynamic_cast<TargetCredentials_ptr> (_tao_objref)
    );
}

SecurityLevel2::TargetCredentials_ptr
SecurityLevel2::TargetCredentials::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return TargetCredentials::_duplicate (
      dynamic_cast<TargetCredentials_ptr> (_tao_objref)
    );
}

SecurityLevel2::TargetCredentials_ptr
SecurityLevel2::TargetCredentials::_nil (void)
{
  return 0;
}

SecurityLevel2::TargetCredentials_ptr
SecurityLevel2::TargetCredentials::_duplicate (TargetCredentials_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::TargetCredentials::_tao_release (TargetCredentials_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::TargetCredentials::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/Credentials:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/TargetCredentials:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* SecurityLevel2::TargetCredentials::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/TargetCredentials:1.8";
}

::CORBA::Boolean
SecurityLevel2::TargetCredentials::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_TargetCredentials (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/SecurityLevel2/TargetCredentials:1.8",
    "TargetCredentials");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_TargetCredentials =
    &_tao_tc_SecurityLevel2_TargetCredentials;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::RequiredRights.

SecurityLevel2::RequiredRights_ptr
TAO::Objref_Traits<SecurityLevel2::RequiredRights>::duplicate (
    SecurityLevel2::RequiredRights_ptr p)
{
  return SecurityLevel2::RequiredRights::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::RequiredRights>::release (
    SecurityLevel2::RequiredRights_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::RequiredRights_ptr
TAO::Objref_Traits<SecurityLevel2::RequiredRights>::nil (void)
{
  return SecurityLevel2::RequiredRights::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::RequiredRights>::marshal (
    const SecurityLevel2::RequiredRights_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*SecurityLevel2__TAO_RequiredRights_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
SecurityLevel2::RequiredRights::get_required_rights (
  ::CORBA::Object_ptr obj,
  const char * operation_name,
  const char * interface_name,
  ::Security::RightsList_out rights,
  ::Security::RightsCombinator_out rights_combinator)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_RequiredRights_Proxy_Broker_ == 0)
    {
      SecurityLevel2_RequiredRights_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_obj (obj);
  TAO::Arg_Traits< char *>::in_arg_val _tao_operation_name (operation_name);
  TAO::Arg_Traits< char *>::in_arg_val _tao_interface_name (interface_name);
  TAO::Arg_Traits< ::Security::RightsList>::out_arg_val _tao_rights (rights);
  TAO::Arg_Traits< ::Security::RightsCombinator>::out_arg_val _tao_rights_combinator (rights_combinator);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_obj,
      &_tao_operation_name,
      &_tao_interface_name,
      &_tao_rights,
      &_tao_rights_combinator
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      6,
      "get_required_rights",
      19,
      this->the_TAO_RequiredRights_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
SecurityLevel2::RequiredRights::set_required_rights (
  const char * operation_name,
  const char * interface_name,
  const ::Security::RightsList & rights,
  ::Security::RightsCombinator rights_combinator)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_RequiredRights_Proxy_Broker_ == 0)
    {
      SecurityLevel2_RequiredRights_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_operation_name (operation_name);
  TAO::Arg_Traits< char *>::in_arg_val _tao_interface_name (interface_name);
  TAO::Arg_Traits< ::Security::RightsList>::in_arg_val _tao_rights (rights);
  TAO::Arg_Traits< ::Security::RightsCombinator>::in_arg_val _tao_rights_combinator (rights_combinator);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_operation_name,
      &_tao_interface_name,
      &_tao_rights,
      &_tao_rights_combinator
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "set_required_rights",
      19,
      this->the_TAO_RequiredRights_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

SecurityLevel2::RequiredRights::RequiredRights (void)
 : the_TAO_RequiredRights_Proxy_Broker_ (0)
{
  this->SecurityLevel2_RequiredRights_setup_collocation ();
}

void
SecurityLevel2::RequiredRights::SecurityLevel2_RequiredRights_setup_collocation ()
{
  if (::SecurityLevel2__TAO_RequiredRights_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_RequiredRights_Proxy_Broker_ =
        ::SecurityLevel2__TAO_RequiredRights_Proxy_Broker_Factory_function_pointer (this);
    }
}

SecurityLevel2::RequiredRights::~RequiredRights (void)
{}

void 
SecurityLevel2::RequiredRights::_tao_any_destructor (void *_tao_void_pointer)
{
  RequiredRights *_tao_tmp_pointer =
    static_cast<RequiredRights *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::RequiredRights_ptr
SecurityLevel2::RequiredRights::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<RequiredRights>::narrow (
        _tao_objref,
        "IDL:omg.org/SecurityLevel2/RequiredRights:1.8",
        SecurityLevel2__TAO_RequiredRights_Proxy_Broker_Factory_function_pointer
      );
}

SecurityLevel2::RequiredRights_ptr
SecurityLevel2::RequiredRights::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<RequiredRights>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/SecurityLevel2/RequiredRights:1.8",
        SecurityLevel2__TAO_RequiredRights_Proxy_Broker_Factory_function_pointer
      );
}

SecurityLevel2::RequiredRights_ptr
SecurityLevel2::RequiredRights::_nil (void)
{
  return 0;
}

SecurityLevel2::RequiredRights_ptr
SecurityLevel2::RequiredRights::_duplicate (RequiredRights_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::RequiredRights::_tao_release (RequiredRights_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::RequiredRights::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/RequiredRights:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* SecurityLevel2::RequiredRights::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/RequiredRights:1.8";
}

::CORBA::Boolean
SecurityLevel2::RequiredRights::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_RequiredRights (
    ::CORBA::tk_objref,
    "IDL:omg.org/SecurityLevel2/RequiredRights:1.8",
    "RequiredRights");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_RequiredRights =
    &_tao_tc_SecurityLevel2_RequiredRights;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::AuditChannel.

SecurityLevel2::AuditChannel_ptr
TAO::Objref_Traits<SecurityLevel2::AuditChannel>::duplicate (
    SecurityLevel2::AuditChannel_ptr p)
{
  return SecurityLevel2::AuditChannel::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::AuditChannel>::release (
    SecurityLevel2::AuditChannel_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::AuditChannel_ptr
TAO::Objref_Traits<SecurityLevel2::AuditChannel>::nil (void)
{
  return SecurityLevel2::AuditChannel::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::AuditChannel>::marshal (
    const SecurityLevel2::AuditChannel_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

SecurityLevel2::AuditChannel::AuditChannel (void)
{}

SecurityLevel2::AuditChannel::~AuditChannel (void)
{}

void 
SecurityLevel2::AuditChannel::_tao_any_destructor (void *_tao_void_pointer)
{
  AuditChannel *_tao_tmp_pointer =
    static_cast<AuditChannel *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::AuditChannel_ptr
SecurityLevel2::AuditChannel::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return AuditChannel::_duplicate (
      dynamic_cast<AuditChannel_ptr> (_tao_objref)
    );
}

SecurityLevel2::AuditChannel_ptr
SecurityLevel2::AuditChannel::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return AuditChannel::_duplicate (
      dynamic_cast<AuditChannel_ptr> (_tao_objref)
    );
}

SecurityLevel2::AuditChannel_ptr
SecurityLevel2::AuditChannel::_nil (void)
{
  return 0;
}

SecurityLevel2::AuditChannel_ptr
SecurityLevel2::AuditChannel::_duplicate (AuditChannel_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::AuditChannel::_tao_release (AuditChannel_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::AuditChannel::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/AuditChannel:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* SecurityLevel2::AuditChannel::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/AuditChannel:1.8";
}

::CORBA::Boolean
SecurityLevel2::AuditChannel::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_AuditChannel (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/SecurityLevel2/AuditChannel:1.8",
    "AuditChannel");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_AuditChannel =
    &_tao_tc_SecurityLevel2_AuditChannel;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::AuditDecision.

SecurityLevel2::AuditDecision_ptr
TAO::Objref_Traits<SecurityLevel2::AuditDecision>::duplicate (
    SecurityLevel2::AuditDecision_ptr p)
{
  return SecurityLevel2::AuditDecision::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::AuditDecision>::release (
    SecurityLevel2::AuditDecision_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::AuditDecision_ptr
TAO::Objref_Traits<SecurityLevel2::AuditDecision>::nil (void)
{
  return SecurityLevel2::AuditDecision::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::AuditDecision>::marshal (
    const SecurityLevel2::AuditDecision_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

SecurityLevel2::AuditDecision::AuditDecision (void)
{}

SecurityLevel2::AuditDecision::~AuditDecision (void)
{}

void 
SecurityLevel2::AuditDecision::_tao_any_destructor (void *_tao_void_pointer)
{
  AuditDecision *_tao_tmp_pointer =
    static_cast<AuditDecision *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::AuditDecision_ptr
SecurityLevel2::AuditDecision::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return AuditDecision::_duplicate (
      dynamic_cast<AuditDecision_ptr> (_tao_objref)
    );
}

SecurityLevel2::AuditDecision_ptr
SecurityLevel2::AuditDecision::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return AuditDecision::_duplicate (
      dynamic_cast<AuditDecision_ptr> (_tao_objref)
    );
}

SecurityLevel2::AuditDecision_ptr
SecurityLevel2::AuditDecision::_nil (void)
{
  return 0;
}

SecurityLevel2::AuditDecision_ptr
SecurityLevel2::AuditDecision::_duplicate (AuditDecision_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::AuditDecision::_tao_release (AuditDecision_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::AuditDecision::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/AuditDecision:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* SecurityLevel2::AuditDecision::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/AuditDecision:1.8";
}

::CORBA::Boolean
SecurityLevel2::AuditDecision::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_AuditDecision (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/SecurityLevel2/AuditDecision:1.8",
    "AuditDecision");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_AuditDecision =
    &_tao_tc_SecurityLevel2_AuditDecision;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::AccessDecision.

SecurityLevel2::AccessDecision_ptr
TAO::Objref_Traits<SecurityLevel2::AccessDecision>::duplicate (
    SecurityLevel2::AccessDecision_ptr p)
{
  return SecurityLevel2::AccessDecision::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::AccessDecision>::release (
    SecurityLevel2::AccessDecision_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::AccessDecision_ptr
TAO::Objref_Traits<SecurityLevel2::AccessDecision>::nil (void)
{
  return SecurityLevel2::AccessDecision::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::AccessDecision>::marshal (
    const SecurityLevel2::AccessDecision_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

SecurityLevel2::AccessDecision::AccessDecision (void)
{}

SecurityLevel2::AccessDecision::~AccessDecision (void)
{}

void 
SecurityLevel2::AccessDecision::_tao_any_destructor (void *_tao_void_pointer)
{
  AccessDecision *_tao_tmp_pointer =
    static_cast<AccessDecision *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::AccessDecision_ptr
SecurityLevel2::AccessDecision::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return AccessDecision::_duplicate (
      dynamic_cast<AccessDecision_ptr> (_tao_objref)
    );
}

SecurityLevel2::AccessDecision_ptr
SecurityLevel2::AccessDecision::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return AccessDecision::_duplicate (
      dynamic_cast<AccessDecision_ptr> (_tao_objref)
    );
}

SecurityLevel2::AccessDecision_ptr
SecurityLevel2::AccessDecision::_nil (void)
{
  return 0;
}

SecurityLevel2::AccessDecision_ptr
SecurityLevel2::AccessDecision::_duplicate (AccessDecision_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::AccessDecision::_tao_release (AccessDecision_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::AccessDecision::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/AccessDecision:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* SecurityLevel2::AccessDecision::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/AccessDecision:1.8";
}

::CORBA::Boolean
SecurityLevel2::AccessDecision::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_AccessDecision (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/SecurityLevel2/AccessDecision:1.8",
    "AccessDecision");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_AccessDecision =
    &_tao_tc_SecurityLevel2_AccessDecision;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::QOPPolicy.

SecurityLevel2::QOPPolicy_ptr
TAO::Objref_Traits<SecurityLevel2::QOPPolicy>::duplicate (
    SecurityLevel2::QOPPolicy_ptr p)
{
  return SecurityLevel2::QOPPolicy::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::QOPPolicy>::release (
    SecurityLevel2::QOPPolicy_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::QOPPolicy_ptr
TAO::Objref_Traits<SecurityLevel2::QOPPolicy>::nil (void)
{
  return SecurityLevel2::QOPPolicy::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::QOPPolicy>::marshal (
    const SecurityLevel2::QOPPolicy_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

SecurityLevel2::QOPPolicy::QOPPolicy (void)
{}

SecurityLevel2::QOPPolicy::~QOPPolicy (void)
{}

void 
SecurityLevel2::QOPPolicy::_tao_any_destructor (void *_tao_void_pointer)
{
  QOPPolicy *_tao_tmp_pointer =
    static_cast<QOPPolicy *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::QOPPolicy_ptr
SecurityLevel2::QOPPolicy::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return QOPPolicy::_duplicate (
      dynamic_cast<QOPPolicy_ptr> (_tao_objref)
    );
}

SecurityLevel2::QOPPolicy_ptr
SecurityLevel2::QOPPolicy::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return QOPPolicy::_duplicate (
      dynamic_cast<QOPPolicy_ptr> (_tao_objref)
    );
}

SecurityLevel2::QOPPolicy_ptr
SecurityLevel2::QOPPolicy::_nil (void)
{
  return 0;
}

SecurityLevel2::QOPPolicy_ptr
SecurityLevel2::QOPPolicy::_duplicate (QOPPolicy_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::QOPPolicy::_tao_release (QOPPolicy_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::QOPPolicy::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Policy:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/QOPPolicy:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* SecurityLevel2::QOPPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/QOPPolicy:1.8";
}

::CORBA::Boolean
SecurityLevel2::QOPPolicy::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_QOPPolicy (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/SecurityLevel2/QOPPolicy:1.8",
    "QOPPolicy");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_QOPPolicy =
    &_tao_tc_SecurityLevel2_QOPPolicy;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::MechanismPolicy.

SecurityLevel2::MechanismPolicy_ptr
TAO::Objref_Traits<SecurityLevel2::MechanismPolicy>::duplicate (
    SecurityLevel2::MechanismPolicy_ptr p)
{
  return SecurityLevel2::MechanismPolicy::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::MechanismPolicy>::release (
    SecurityLevel2::MechanismPolicy_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::MechanismPolicy_ptr
TAO::Objref_Traits<SecurityLevel2::MechanismPolicy>::nil (void)
{
  return SecurityLevel2::MechanismPolicy::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::MechanismPolicy>::marshal (
    const SecurityLevel2::MechanismPolicy_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

SecurityLevel2::MechanismPolicy::MechanismPolicy (void)
{}

SecurityLevel2::MechanismPolicy::~MechanismPolicy (void)
{}

void 
SecurityLevel2::MechanismPolicy::_tao_any_destructor (void *_tao_void_pointer)
{
  MechanismPolicy *_tao_tmp_pointer =
    static_cast<MechanismPolicy *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::MechanismPolicy_ptr
SecurityLevel2::MechanismPolicy::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return MechanismPolicy::_duplicate (
      dynamic_cast<MechanismPolicy_ptr> (_tao_objref)
    );
}

SecurityLevel2::MechanismPolicy_ptr
SecurityLevel2::MechanismPolicy::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return MechanismPolicy::_duplicate (
      dynamic_cast<MechanismPolicy_ptr> (_tao_objref)
    );
}

SecurityLevel2::MechanismPolicy_ptr
SecurityLevel2::MechanismPolicy::_nil (void)
{
  return 0;
}

SecurityLevel2::MechanismPolicy_ptr
SecurityLevel2::MechanismPolicy::_duplicate (MechanismPolicy_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::MechanismPolicy::_tao_release (MechanismPolicy_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::MechanismPolicy::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Policy:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/MechanismPolicy:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* SecurityLevel2::MechanismPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/MechanismPolicy:1.8";
}

::CORBA::Boolean
SecurityLevel2::MechanismPolicy::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_MechanismPolicy (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/SecurityLevel2/MechanismPolicy:1.8",
    "MechanismPolicy");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_MechanismPolicy =
    &_tao_tc_SecurityLevel2_MechanismPolicy;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::InvocationCredentialsPolicy.

SecurityLevel2::InvocationCredentialsPolicy_ptr
TAO::Objref_Traits<SecurityLevel2::InvocationCredentialsPolicy>::duplicate (
    SecurityLevel2::InvocationCredentialsPolicy_ptr p)
{
  return SecurityLevel2::InvocationCredentialsPolicy::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::InvocationCredentialsPolicy>::release (
    SecurityLevel2::InvocationCredentialsPolicy_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::InvocationCredentialsPolicy_ptr
TAO::Objref_Traits<SecurityLevel2::InvocationCredentialsPolicy>::nil (void)
{
  return SecurityLevel2::InvocationCredentialsPolicy::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::InvocationCredentialsPolicy>::marshal (
    const SecurityLevel2::InvocationCredentialsPolicy_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

SecurityLevel2::InvocationCredentialsPolicy::InvocationCredentialsPolicy (void)
{}

SecurityLevel2::InvocationCredentialsPolicy::~InvocationCredentialsPolicy (void)
{}

void 
SecurityLevel2::InvocationCredentialsPolicy::_tao_any_destructor (void *_tao_void_pointer)
{
  InvocationCredentialsPolicy *_tao_tmp_pointer =
    static_cast<InvocationCredentialsPolicy *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::InvocationCredentialsPolicy_ptr
SecurityLevel2::InvocationCredentialsPolicy::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return InvocationCredentialsPolicy::_duplicate (
      dynamic_cast<InvocationCredentialsPolicy_ptr> (_tao_objref)
    );
}

SecurityLevel2::InvocationCredentialsPolicy_ptr
SecurityLevel2::InvocationCredentialsPolicy::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return InvocationCredentialsPolicy::_duplicate (
      dynamic_cast<InvocationCredentialsPolicy_ptr> (_tao_objref)
    );
}

SecurityLevel2::InvocationCredentialsPolicy_ptr
SecurityLevel2::InvocationCredentialsPolicy::_nil (void)
{
  return 0;
}

SecurityLevel2::InvocationCredentialsPolicy_ptr
SecurityLevel2::InvocationCredentialsPolicy::_duplicate (InvocationCredentialsPolicy_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::InvocationCredentialsPolicy::_tao_release (InvocationCredentialsPolicy_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::InvocationCredentialsPolicy::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Policy:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/InvocationCredentialsPolicy:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* SecurityLevel2::InvocationCredentialsPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/InvocationCredentialsPolicy:1.8";
}

::CORBA::Boolean
SecurityLevel2::InvocationCredentialsPolicy::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_InvocationCredentialsPolicy (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/SecurityLevel2/InvocationCredentialsPolicy:1.8",
    "InvocationCredentialsPolicy");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_InvocationCredentialsPolicy =
    &_tao_tc_SecurityLevel2_InvocationCredentialsPolicy;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::EstablishTrustPolicy.

SecurityLevel2::EstablishTrustPolicy_ptr
TAO::Objref_Traits<SecurityLevel2::EstablishTrustPolicy>::duplicate (
    SecurityLevel2::EstablishTrustPolicy_ptr p)
{
  return SecurityLevel2::EstablishTrustPolicy::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::EstablishTrustPolicy>::release (
    SecurityLevel2::EstablishTrustPolicy_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::EstablishTrustPolicy_ptr
TAO::Objref_Traits<SecurityLevel2::EstablishTrustPolicy>::nil (void)
{
  return SecurityLevel2::EstablishTrustPolicy::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::EstablishTrustPolicy>::marshal (
    const SecurityLevel2::EstablishTrustPolicy_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

SecurityLevel2::EstablishTrustPolicy::EstablishTrustPolicy (void)
{}

SecurityLevel2::EstablishTrustPolicy::~EstablishTrustPolicy (void)
{}

void 
SecurityLevel2::EstablishTrustPolicy::_tao_any_destructor (void *_tao_void_pointer)
{
  EstablishTrustPolicy *_tao_tmp_pointer =
    static_cast<EstablishTrustPolicy *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::EstablishTrustPolicy_ptr
SecurityLevel2::EstablishTrustPolicy::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return EstablishTrustPolicy::_duplicate (
      dynamic_cast<EstablishTrustPolicy_ptr> (_tao_objref)
    );
}

SecurityLevel2::EstablishTrustPolicy_ptr
SecurityLevel2::EstablishTrustPolicy::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return EstablishTrustPolicy::_duplicate (
      dynamic_cast<EstablishTrustPolicy_ptr> (_tao_objref)
    );
}

SecurityLevel2::EstablishTrustPolicy_ptr
SecurityLevel2::EstablishTrustPolicy::_nil (void)
{
  return 0;
}

SecurityLevel2::EstablishTrustPolicy_ptr
SecurityLevel2::EstablishTrustPolicy::_duplicate (EstablishTrustPolicy_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::EstablishTrustPolicy::_tao_release (EstablishTrustPolicy_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::EstablishTrustPolicy::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Policy:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/EstablishTrustPolicy:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* SecurityLevel2::EstablishTrustPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/EstablishTrustPolicy:1.8";
}

::CORBA::Boolean
SecurityLevel2::EstablishTrustPolicy::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_EstablishTrustPolicy (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/SecurityLevel2/EstablishTrustPolicy:1.8",
    "EstablishTrustPolicy");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_EstablishTrustPolicy =
    &_tao_tc_SecurityLevel2_EstablishTrustPolicy;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::DelegationDirectivePolicy.

SecurityLevel2::DelegationDirectivePolicy_ptr
TAO::Objref_Traits<SecurityLevel2::DelegationDirectivePolicy>::duplicate (
    SecurityLevel2::DelegationDirectivePolicy_ptr p)
{
  return SecurityLevel2::DelegationDirectivePolicy::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::DelegationDirectivePolicy>::release (
    SecurityLevel2::DelegationDirectivePolicy_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::DelegationDirectivePolicy_ptr
TAO::Objref_Traits<SecurityLevel2::DelegationDirectivePolicy>::nil (void)
{
  return SecurityLevel2::DelegationDirectivePolicy::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::DelegationDirectivePolicy>::marshal (
    const SecurityLevel2::DelegationDirectivePolicy_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

SecurityLevel2::DelegationDirectivePolicy::DelegationDirectivePolicy (void)
{}

SecurityLevel2::DelegationDirectivePolicy::~DelegationDirectivePolicy (void)
{}

void 
SecurityLevel2::DelegationDirectivePolicy::_tao_any_destructor (void *_tao_void_pointer)
{
  DelegationDirectivePolicy *_tao_tmp_pointer =
    static_cast<DelegationDirectivePolicy *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::DelegationDirectivePolicy_ptr
SecurityLevel2::DelegationDirectivePolicy::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DelegationDirectivePolicy::_duplicate (
      dynamic_cast<DelegationDirectivePolicy_ptr> (_tao_objref)
    );
}

SecurityLevel2::DelegationDirectivePolicy_ptr
SecurityLevel2::DelegationDirectivePolicy::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DelegationDirectivePolicy::_duplicate (
      dynamic_cast<DelegationDirectivePolicy_ptr> (_tao_objref)
    );
}

SecurityLevel2::DelegationDirectivePolicy_ptr
SecurityLevel2::DelegationDirectivePolicy::_nil (void)
{
  return 0;
}

SecurityLevel2::DelegationDirectivePolicy_ptr
SecurityLevel2::DelegationDirectivePolicy::_duplicate (DelegationDirectivePolicy_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::DelegationDirectivePolicy::_tao_release (DelegationDirectivePolicy_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::DelegationDirectivePolicy::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Policy:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/DelegationDirectivePolicy:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* SecurityLevel2::DelegationDirectivePolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/DelegationDirectivePolicy:1.8";
}

::CORBA::Boolean
SecurityLevel2::DelegationDirectivePolicy::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_DelegationDirectivePolicy (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/SecurityLevel2/DelegationDirectivePolicy:1.8",
    "DelegationDirectivePolicy");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_DelegationDirectivePolicy =
    &_tao_tc_SecurityLevel2_DelegationDirectivePolicy;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::SecurityManager.

SecurityLevel2::SecurityManager_ptr
TAO::Objref_Traits<SecurityLevel2::SecurityManager>::duplicate (
    SecurityLevel2::SecurityManager_ptr p)
{
  return SecurityLevel2::SecurityManager::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::SecurityManager>::release (
    SecurityLevel2::SecurityManager_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::SecurityManager_ptr
TAO::Objref_Traits<SecurityLevel2::SecurityManager>::nil (void)
{
  return SecurityLevel2::SecurityManager::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::SecurityManager>::marshal (
    const SecurityLevel2::SecurityManager_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

SecurityLevel2::SecurityManager::SecurityManager (void)
{}

SecurityLevel2::SecurityManager::~SecurityManager (void)
{}

void 
SecurityLevel2::SecurityManager::_tao_any_destructor (void *_tao_void_pointer)
{
  SecurityManager *_tao_tmp_pointer =
    static_cast<SecurityManager *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::SecurityManager_ptr
SecurityLevel2::SecurityManager::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return SecurityManager::_duplicate (
      dynamic_cast<SecurityManager_ptr> (_tao_objref)
    );
}

SecurityLevel2::SecurityManager_ptr
SecurityLevel2::SecurityManager::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return SecurityManager::_duplicate (
      dynamic_cast<SecurityManager_ptr> (_tao_objref)
    );
}

SecurityLevel2::SecurityManager_ptr
SecurityLevel2::SecurityManager::_nil (void)
{
  return 0;
}

SecurityLevel2::SecurityManager_ptr
SecurityLevel2::SecurityManager::_duplicate (SecurityManager_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::SecurityManager::_tao_release (SecurityManager_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::SecurityManager::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/SecurityManager:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* SecurityLevel2::SecurityManager::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/SecurityManager:1.8";
}

::CORBA::Boolean
SecurityLevel2::SecurityManager::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_SecurityManager (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/SecurityLevel2/SecurityManager:1.8",
    "SecurityManager");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_SecurityManager =
    &_tao_tc_SecurityLevel2_SecurityManager;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for SecurityLevel2::Current.

SecurityLevel2::Current_ptr
TAO::Objref_Traits<SecurityLevel2::Current>::duplicate (
    SecurityLevel2::Current_ptr p)
{
  return SecurityLevel2::Current::_duplicate (p);
}

void
TAO::Objref_Traits<SecurityLevel2::Current>::release (
    SecurityLevel2::Current_ptr p)
{
  ::CORBA::release (p);
}

SecurityLevel2::Current_ptr
TAO::Objref_Traits<SecurityLevel2::Current>::nil (void)
{
  return SecurityLevel2::Current::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SecurityLevel2::Current>::marshal (
    const SecurityLevel2::Current_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

SecurityLevel2::Current::Current (void)
{}

SecurityLevel2::Current::~Current (void)
{}

void 
SecurityLevel2::Current::_tao_any_destructor (void *_tao_void_pointer)
{
  Current *_tao_tmp_pointer =
    static_cast<Current *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SecurityLevel2::Current_ptr
SecurityLevel2::Current::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return Current::_duplicate (
      dynamic_cast<Current_ptr> (_tao_objref)
    );
}

SecurityLevel2::Current_ptr
SecurityLevel2::Current::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return Current::_duplicate (
      dynamic_cast<Current_ptr> (_tao_objref)
    );
}

SecurityLevel2::Current_ptr
SecurityLevel2::Current::_nil (void)
{
  return 0;
}

SecurityLevel2::Current_ptr
SecurityLevel2::Current::_duplicate (Current_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SecurityLevel2::Current::_tao_release (Current_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SecurityLevel2::Current::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Current:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel1/Current:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/Current:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* SecurityLevel2::Current::_interface_repository_id (void) const
{
  return "IDL:omg.org/SecurityLevel2/Current:1.8";
}

::CORBA::Boolean
SecurityLevel2::Current::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SecurityLevel2_Current (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/SecurityLevel2/Current:1.8",
    "Current");
  

namespace SecurityLevel2
{
  ::CORBA::TypeCode_ptr const _tc_Current =
    &_tao_tc_SecurityLevel2_Current;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for TAO::SL2::AccessDecision.

TAO::SL2::AccessDecision_ptr
TAO::Objref_Traits<TAO::SL2::AccessDecision>::duplicate (
    TAO::SL2::AccessDecision_ptr p)
{
  return TAO::SL2::AccessDecision::_duplicate (p);
}

void
TAO::Objref_Traits<TAO::SL2::AccessDecision>::release (
    TAO::SL2::AccessDecision_ptr p)
{
  ::CORBA::release (p);
}

TAO::SL2::AccessDecision_ptr
TAO::Objref_Traits<TAO::SL2::AccessDecision>::nil (void)
{
  return TAO::SL2::AccessDecision::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<TAO::SL2::AccessDecision>::marshal (
    const TAO::SL2::AccessDecision_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO::SL2::AccessDecision::AccessDecision (void)
{}

TAO::SL2::AccessDecision::~AccessDecision (void)
{}

void 
TAO::SL2::AccessDecision::_tao_any_destructor (void *_tao_void_pointer)
{
  AccessDecision *_tao_tmp_pointer =
    static_cast<AccessDecision *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

TAO::SL2::AccessDecision_ptr
TAO::SL2::AccessDecision::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return AccessDecision::_duplicate (
      dynamic_cast<AccessDecision_ptr> (_tao_objref)
    );
}

TAO::SL2::AccessDecision_ptr
TAO::SL2::AccessDecision::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return AccessDecision::_duplicate (
      dynamic_cast<AccessDecision_ptr> (_tao_objref)
    );
}

TAO::SL2::AccessDecision_ptr
TAO::SL2::AccessDecision::_nil (void)
{
  return 0;
}

TAO::SL2::AccessDecision_ptr
TAO::SL2::AccessDecision::_duplicate (AccessDecision_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
TAO::SL2::AccessDecision::_tao_release (AccessDecision_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
TAO::SL2::AccessDecision::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/SecurityLevel2/AccessDecision:1.8"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:TAO/SL2/AccessDecision:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* TAO::SL2::AccessDecision::_interface_repository_id (void) const
{
  return "IDL:TAO/SL2/AccessDecision:1.0";
}

::CORBA::Boolean
TAO::SL2::AccessDecision::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_TAO_SL2_AccessDecision (
    ::CORBA::tk_local_interface,
    "IDL:TAO/SL2/AccessDecision:1.0",
    "AccessDecision");
  

namespace TAO
{
  
  namespace SL2
  {
    ::CORBA::TypeCode_ptr const _tc_AccessDecision =
      &_tao_tc_TAO_SL2_AccessDecision;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::PrincipalAuthenticator>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::PrincipalAuthenticator>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::PrincipalAuthenticator>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      PrincipalAuthenticator_ptr _tao_elem)
  {
    PrincipalAuthenticator_ptr _tao_objptr =
      PrincipalAuthenticator::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      PrincipalAuthenticator_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<PrincipalAuthenticator>::insert (
        _tao_any,
        PrincipalAuthenticator::_tao_any_destructor,
        _tc_PrincipalAuthenticator,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      PrincipalAuthenticator_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<PrincipalAuthenticator>::extract (
          _tao_any,
          PrincipalAuthenticator::_tao_any_destructor,
          _tc_PrincipalAuthenticator,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::PrincipalAuthenticator_ptr _tao_elem)
{
  SecurityLevel2::PrincipalAuthenticator_ptr _tao_objptr =
    SecurityLevel2::PrincipalAuthenticator::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::PrincipalAuthenticator_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::PrincipalAuthenticator>::insert (
      _tao_any,
      SecurityLevel2::PrincipalAuthenticator::_tao_any_destructor,
      SecurityLevel2::_tc_PrincipalAuthenticator,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::PrincipalAuthenticator_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::PrincipalAuthenticator>::extract (
        _tao_any,
        SecurityLevel2::PrincipalAuthenticator::_tao_any_destructor,
        SecurityLevel2::_tc_PrincipalAuthenticator,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::Credentials>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::Credentials>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::Credentials>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Credentials_ptr _tao_elem)
  {
    Credentials_ptr _tao_objptr =
      Credentials::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Credentials_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Credentials>::insert (
        _tao_any,
        Credentials::_tao_any_destructor,
        _tc_Credentials,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Credentials_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Credentials>::extract (
          _tao_any,
          Credentials::_tao_any_destructor,
          _tc_Credentials,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::Credentials_ptr _tao_elem)
{
  SecurityLevel2::Credentials_ptr _tao_objptr =
    SecurityLevel2::Credentials::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::Credentials_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::Credentials>::insert (
      _tao_any,
      SecurityLevel2::Credentials::_tao_any_destructor,
      SecurityLevel2::_tc_Credentials,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::Credentials_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::Credentials>::extract (
        _tao_any,
        SecurityLevel2::Credentials::_tao_any_destructor,
        SecurityLevel2::_tc_Credentials,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SecurityLevel2::CredentialsList>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SecurityLevel2::CredentialsList>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::SecurityLevel2::CredentialsList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::SecurityLevel2::CredentialsList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::SecurityLevel2::CredentialsList>::insert_copy (
          _tao_any,
          ::SecurityLevel2::CredentialsList::_tao_any_destructor,
          ::SecurityLevel2::_tc_CredentialsList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::SecurityLevel2::CredentialsList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::SecurityLevel2::CredentialsList>::insert (
        _tao_any,
        ::SecurityLevel2::CredentialsList::_tao_any_destructor,
        ::SecurityLevel2::_tc_CredentialsList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::SecurityLevel2::CredentialsList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::SecurityLevel2::CredentialsList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::SecurityLevel2::CredentialsList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::SecurityLevel2::CredentialsList>::extract (
          _tao_any,
          ::SecurityLevel2::CredentialsList::_tao_any_destructor,
          ::SecurityLevel2::_tc_CredentialsList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SecurityLevel2::CredentialsList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<SecurityLevel2::CredentialsList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<SecurityLevel2::CredentialsList>::insert_copy (
        _tao_any,
        SecurityLevel2::CredentialsList::_tao_any_destructor,
        SecurityLevel2::_tc_CredentialsList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::CredentialsList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<SecurityLevel2::CredentialsList>::insert (
      _tao_any,
      SecurityLevel2::CredentialsList::_tao_any_destructor,
      SecurityLevel2::_tc_CredentialsList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::CredentialsList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const SecurityLevel2::CredentialsList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SecurityLevel2::CredentialsList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SecurityLevel2::CredentialsList>::extract (
        _tao_any,
        SecurityLevel2::CredentialsList::_tao_any_destructor,
        SecurityLevel2::_tc_CredentialsList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::ReceivedCredentials>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::ReceivedCredentials>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::ReceivedCredentials>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ReceivedCredentials_ptr _tao_elem)
  {
    ReceivedCredentials_ptr _tao_objptr =
      ReceivedCredentials::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ReceivedCredentials_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<ReceivedCredentials>::insert (
        _tao_any,
        ReceivedCredentials::_tao_any_destructor,
        _tc_ReceivedCredentials,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      ReceivedCredentials_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<ReceivedCredentials>::extract (
          _tao_any,
          ReceivedCredentials::_tao_any_destructor,
          _tc_ReceivedCredentials,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::ReceivedCredentials_ptr _tao_elem)
{
  SecurityLevel2::ReceivedCredentials_ptr _tao_objptr =
    SecurityLevel2::ReceivedCredentials::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::ReceivedCredentials_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::ReceivedCredentials>::insert (
      _tao_any,
      SecurityLevel2::ReceivedCredentials::_tao_any_destructor,
      SecurityLevel2::_tc_ReceivedCredentials,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::ReceivedCredentials_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::ReceivedCredentials>::extract (
        _tao_any,
        SecurityLevel2::ReceivedCredentials::_tao_any_destructor,
        SecurityLevel2::_tc_ReceivedCredentials,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::TargetCredentials>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::TargetCredentials>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::TargetCredentials>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      TargetCredentials_ptr _tao_elem)
  {
    TargetCredentials_ptr _tao_objptr =
      TargetCredentials::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      TargetCredentials_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<TargetCredentials>::insert (
        _tao_any,
        TargetCredentials::_tao_any_destructor,
        _tc_TargetCredentials,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      TargetCredentials_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<TargetCredentials>::extract (
          _tao_any,
          TargetCredentials::_tao_any_destructor,
          _tc_TargetCredentials,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::TargetCredentials_ptr _tao_elem)
{
  SecurityLevel2::TargetCredentials_ptr _tao_objptr =
    SecurityLevel2::TargetCredentials::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::TargetCredentials_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::TargetCredentials>::insert (
      _tao_any,
      SecurityLevel2::TargetCredentials::_tao_any_destructor,
      SecurityLevel2::_tc_TargetCredentials,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::TargetCredentials_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::TargetCredentials>::extract (
        _tao_any,
        SecurityLevel2::TargetCredentials::_tao_any_destructor,
        SecurityLevel2::_tc_TargetCredentials,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::RequiredRights>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      RequiredRights_ptr _tao_elem)
  {
    RequiredRights_ptr _tao_objptr =
      RequiredRights::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      RequiredRights_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<RequiredRights>::insert (
        _tao_any,
        RequiredRights::_tao_any_destructor,
        _tc_RequiredRights,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      RequiredRights_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<RequiredRights>::extract (
          _tao_any,
          RequiredRights::_tao_any_destructor,
          _tc_RequiredRights,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::RequiredRights_ptr _tao_elem)
{
  SecurityLevel2::RequiredRights_ptr _tao_objptr =
    SecurityLevel2::RequiredRights::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::RequiredRights_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::RequiredRights>::insert (
      _tao_any,
      SecurityLevel2::RequiredRights::_tao_any_destructor,
      SecurityLevel2::_tc_RequiredRights,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::RequiredRights_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::RequiredRights>::extract (
        _tao_any,
        SecurityLevel2::RequiredRights::_tao_any_destructor,
        SecurityLevel2::_tc_RequiredRights,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::AuditChannel>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::AuditChannel>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::AuditChannel>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AuditChannel_ptr _tao_elem)
  {
    AuditChannel_ptr _tao_objptr =
      AuditChannel::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AuditChannel_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AuditChannel>::insert (
        _tao_any,
        AuditChannel::_tao_any_destructor,
        _tc_AuditChannel,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AuditChannel_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AuditChannel>::extract (
          _tao_any,
          AuditChannel::_tao_any_destructor,
          _tc_AuditChannel,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::AuditChannel_ptr _tao_elem)
{
  SecurityLevel2::AuditChannel_ptr _tao_objptr =
    SecurityLevel2::AuditChannel::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::AuditChannel_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::AuditChannel>::insert (
      _tao_any,
      SecurityLevel2::AuditChannel::_tao_any_destructor,
      SecurityLevel2::_tc_AuditChannel,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::AuditChannel_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::AuditChannel>::extract (
        _tao_any,
        SecurityLevel2::AuditChannel::_tao_any_destructor,
        SecurityLevel2::_tc_AuditChannel,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::AuditDecision>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::AuditDecision>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::AuditDecision>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AuditDecision_ptr _tao_elem)
  {
    AuditDecision_ptr _tao_objptr =
      AuditDecision::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AuditDecision_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AuditDecision>::insert (
        _tao_any,
        AuditDecision::_tao_any_destructor,
        _tc_AuditDecision,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AuditDecision_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AuditDecision>::extract (
          _tao_any,
          AuditDecision::_tao_any_destructor,
          _tc_AuditDecision,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::AuditDecision_ptr _tao_elem)
{
  SecurityLevel2::AuditDecision_ptr _tao_objptr =
    SecurityLevel2::AuditDecision::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::AuditDecision_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::AuditDecision>::insert (
      _tao_any,
      SecurityLevel2::AuditDecision::_tao_any_destructor,
      SecurityLevel2::_tc_AuditDecision,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::AuditDecision_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::AuditDecision>::extract (
        _tao_any,
        SecurityLevel2::AuditDecision::_tao_any_destructor,
        SecurityLevel2::_tc_AuditDecision,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::AccessDecision>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::AccessDecision>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::AccessDecision>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AccessDecision_ptr _tao_elem)
  {
    AccessDecision_ptr _tao_objptr =
      AccessDecision::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AccessDecision_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AccessDecision>::insert (
        _tao_any,
        AccessDecision::_tao_any_destructor,
        _tc_AccessDecision,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AccessDecision_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AccessDecision>::extract (
          _tao_any,
          AccessDecision::_tao_any_destructor,
          _tc_AccessDecision,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::AccessDecision_ptr _tao_elem)
{
  SecurityLevel2::AccessDecision_ptr _tao_objptr =
    SecurityLevel2::AccessDecision::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::AccessDecision_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::AccessDecision>::insert (
      _tao_any,
      SecurityLevel2::AccessDecision::_tao_any_destructor,
      SecurityLevel2::_tc_AccessDecision,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::AccessDecision_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::AccessDecision>::extract (
        _tao_any,
        SecurityLevel2::AccessDecision::_tao_any_destructor,
        SecurityLevel2::_tc_AccessDecision,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::QOPPolicy>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::QOPPolicy>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::QOPPolicy>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      QOPPolicy_ptr _tao_elem)
  {
    QOPPolicy_ptr _tao_objptr =
      QOPPolicy::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      QOPPolicy_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<QOPPolicy>::insert (
        _tao_any,
        QOPPolicy::_tao_any_destructor,
        _tc_QOPPolicy,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      QOPPolicy_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<QOPPolicy>::extract (
          _tao_any,
          QOPPolicy::_tao_any_destructor,
          _tc_QOPPolicy,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::QOPPolicy_ptr _tao_elem)
{
  SecurityLevel2::QOPPolicy_ptr _tao_objptr =
    SecurityLevel2::QOPPolicy::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::QOPPolicy_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::QOPPolicy>::insert (
      _tao_any,
      SecurityLevel2::QOPPolicy::_tao_any_destructor,
      SecurityLevel2::_tc_QOPPolicy,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::QOPPolicy_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::QOPPolicy>::extract (
        _tao_any,
        SecurityLevel2::QOPPolicy::_tao_any_destructor,
        SecurityLevel2::_tc_QOPPolicy,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::MechanismPolicy>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::MechanismPolicy>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::MechanismPolicy>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      MechanismPolicy_ptr _tao_elem)
  {
    MechanismPolicy_ptr _tao_objptr =
      MechanismPolicy::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      MechanismPolicy_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<MechanismPolicy>::insert (
        _tao_any,
        MechanismPolicy::_tao_any_destructor,
        _tc_MechanismPolicy,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      MechanismPolicy_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<MechanismPolicy>::extract (
          _tao_any,
          MechanismPolicy::_tao_any_destructor,
          _tc_MechanismPolicy,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::MechanismPolicy_ptr _tao_elem)
{
  SecurityLevel2::MechanismPolicy_ptr _tao_objptr =
    SecurityLevel2::MechanismPolicy::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::MechanismPolicy_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::MechanismPolicy>::insert (
      _tao_any,
      SecurityLevel2::MechanismPolicy::_tao_any_destructor,
      SecurityLevel2::_tc_MechanismPolicy,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::MechanismPolicy_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::MechanismPolicy>::extract (
        _tao_any,
        SecurityLevel2::MechanismPolicy::_tao_any_destructor,
        SecurityLevel2::_tc_MechanismPolicy,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::InvocationCredentialsPolicy>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::InvocationCredentialsPolicy>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::InvocationCredentialsPolicy>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      InvocationCredentialsPolicy_ptr _tao_elem)
  {
    InvocationCredentialsPolicy_ptr _tao_objptr =
      InvocationCredentialsPolicy::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      InvocationCredentialsPolicy_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<InvocationCredentialsPolicy>::insert (
        _tao_any,
        InvocationCredentialsPolicy::_tao_any_destructor,
        _tc_InvocationCredentialsPolicy,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      InvocationCredentialsPolicy_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<InvocationCredentialsPolicy>::extract (
          _tao_any,
          InvocationCredentialsPolicy::_tao_any_destructor,
          _tc_InvocationCredentialsPolicy,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::InvocationCredentialsPolicy_ptr _tao_elem)
{
  SecurityLevel2::InvocationCredentialsPolicy_ptr _tao_objptr =
    SecurityLevel2::InvocationCredentialsPolicy::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::InvocationCredentialsPolicy_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::InvocationCredentialsPolicy>::insert (
      _tao_any,
      SecurityLevel2::InvocationCredentialsPolicy::_tao_any_destructor,
      SecurityLevel2::_tc_InvocationCredentialsPolicy,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::InvocationCredentialsPolicy_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::InvocationCredentialsPolicy>::extract (
        _tao_any,
        SecurityLevel2::InvocationCredentialsPolicy::_tao_any_destructor,
        SecurityLevel2::_tc_InvocationCredentialsPolicy,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::EstablishTrustPolicy>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::EstablishTrustPolicy>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::EstablishTrustPolicy>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      EstablishTrustPolicy_ptr _tao_elem)
  {
    EstablishTrustPolicy_ptr _tao_objptr =
      EstablishTrustPolicy::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      EstablishTrustPolicy_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<EstablishTrustPolicy>::insert (
        _tao_any,
        EstablishTrustPolicy::_tao_any_destructor,
        _tc_EstablishTrustPolicy,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      EstablishTrustPolicy_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<EstablishTrustPolicy>::extract (
          _tao_any,
          EstablishTrustPolicy::_tao_any_destructor,
          _tc_EstablishTrustPolicy,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::EstablishTrustPolicy_ptr _tao_elem)
{
  SecurityLevel2::EstablishTrustPolicy_ptr _tao_objptr =
    SecurityLevel2::EstablishTrustPolicy::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::EstablishTrustPolicy_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::EstablishTrustPolicy>::insert (
      _tao_any,
      SecurityLevel2::EstablishTrustPolicy::_tao_any_destructor,
      SecurityLevel2::_tc_EstablishTrustPolicy,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::EstablishTrustPolicy_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::EstablishTrustPolicy>::extract (
        _tao_any,
        SecurityLevel2::EstablishTrustPolicy::_tao_any_destructor,
        SecurityLevel2::_tc_EstablishTrustPolicy,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::DelegationDirectivePolicy>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::DelegationDirectivePolicy>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::DelegationDirectivePolicy>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DelegationDirectivePolicy_ptr _tao_elem)
  {
    DelegationDirectivePolicy_ptr _tao_objptr =
      DelegationDirectivePolicy::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DelegationDirectivePolicy_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<DelegationDirectivePolicy>::insert (
        _tao_any,
        DelegationDirectivePolicy::_tao_any_destructor,
        _tc_DelegationDirectivePolicy,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DelegationDirectivePolicy_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<DelegationDirectivePolicy>::extract (
          _tao_any,
          DelegationDirectivePolicy::_tao_any_destructor,
          _tc_DelegationDirectivePolicy,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::DelegationDirectivePolicy_ptr _tao_elem)
{
  SecurityLevel2::DelegationDirectivePolicy_ptr _tao_objptr =
    SecurityLevel2::DelegationDirectivePolicy::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::DelegationDirectivePolicy_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::DelegationDirectivePolicy>::insert (
      _tao_any,
      SecurityLevel2::DelegationDirectivePolicy::_tao_any_destructor,
      SecurityLevel2::_tc_DelegationDirectivePolicy,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::DelegationDirectivePolicy_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::DelegationDirectivePolicy>::extract (
        _tao_any,
        SecurityLevel2::DelegationDirectivePolicy::_tao_any_destructor,
        SecurityLevel2::_tc_DelegationDirectivePolicy,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::SecurityManager>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::SecurityManager>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::SecurityManager>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      SecurityManager_ptr _tao_elem)
  {
    SecurityManager_ptr _tao_objptr =
      SecurityManager::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      SecurityManager_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<SecurityManager>::insert (
        _tao_any,
        SecurityManager::_tao_any_destructor,
        _tc_SecurityManager,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      SecurityManager_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<SecurityManager>::extract (
          _tao_any,
          SecurityManager::_tao_any_destructor,
          _tc_SecurityManager,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::SecurityManager_ptr _tao_elem)
{
  SecurityLevel2::SecurityManager_ptr _tao_objptr =
    SecurityLevel2::SecurityManager::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::SecurityManager_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::SecurityManager>::insert (
      _tao_any,
      SecurityLevel2::SecurityManager::_tao_any_destructor,
      SecurityLevel2::_tc_SecurityManager,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::SecurityManager_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::SecurityManager>::extract (
        _tao_any,
        SecurityLevel2::SecurityManager::_tao_any_destructor,
        SecurityLevel2::_tc_SecurityManager,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::Current>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::Current>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<SecurityLevel2::Current>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SecurityLevel2
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Current_ptr _tao_elem)
  {
    Current_ptr _tao_objptr =
      Current::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Current_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Current>::insert (
        _tao_any,
        Current::_tao_any_destructor,
        _tc_Current,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Current_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Current>::extract (
          _tao_any,
          Current::_tao_any_destructor,
          _tc_Current,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::Current_ptr _tao_elem)
{
  SecurityLevel2::Current_ptr _tao_objptr =
    SecurityLevel2::Current::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SecurityLevel2::Current_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SecurityLevel2::Current>::insert (
      _tao_any,
      SecurityLevel2::Current::_tao_any_destructor,
      SecurityLevel2::_tc_Current,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SecurityLevel2::Current_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SecurityLevel2::Current>::extract (
        _tao_any,
        SecurityLevel2::Current::_tao_any_destructor,
        SecurityLevel2::_tc_Current,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<TAO::SL2::AccessDecision>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<TAO::SL2::AccessDecision>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<TAO::SL2::AccessDecision>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TAO
{
  
  namespace SL2
  {
    

    /// Copying insertion.
    void
    operator<<= (
        ::CORBA::Any &_tao_any,
        AccessDecision_ptr _tao_elem)
    {
      AccessDecision_ptr _tao_objptr =
        AccessDecision::_duplicate (_tao_elem);
      _tao_any <<= &_tao_objptr;
    }

    /// Non-copying insertion.
    void
    operator<<= (
        ::CORBA::Any &_tao_any,
        AccessDecision_ptr *_tao_elem)
    {
      TAO::Any_Impl_T<AccessDecision>::insert (
          _tao_any,
          AccessDecision::_tao_any_destructor,
          _tc_AccessDecision,
          *_tao_elem);
    }

    ::CORBA::Boolean
    operator>>= (
        const ::CORBA::Any &_tao_any,
        AccessDecision_ptr &_tao_elem)
    {
      return
        TAO::Any_Impl_T<AccessDecision>::extract (
            _tao_any,
            AccessDecision::_tao_any_destructor,
            _tc_AccessDecision,
            _tao_elem);
    }
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    TAO::SL2::AccessDecision_ptr _tao_elem)
{
  TAO::SL2::AccessDecision_ptr _tao_objptr =
    TAO::SL2::AccessDecision::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    TAO::SL2::AccessDecision_ptr *_tao_elem)
{
  TAO::Any_Impl_T<TAO::SL2::AccessDecision>::insert (
      _tao_any,
      TAO::SL2::AccessDecision::_tao_any_destructor,
      TAO::SL2::_tc_AccessDecision,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    TAO::SL2::AccessDecision_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<TAO::SL2::AccessDecision>::extract (
        _tao_any,
        TAO::SL2::AccessDecision::_tao_any_destructor,
        TAO::SL2::_tc_AccessDecision,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SecurityLevel2::RequiredRights_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SecurityLevel2::RequiredRights_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::SecurityLevel2::RequiredRights RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        SecurityLevel2__TAO_RequiredRights_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL





TAO_END_VERSIONED_NAMESPACE_DECL


