// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "PortableGroupC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/Value_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Value_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Messaging/Asynch_Invocation_Adapter.h"
#include "tao/Messaging/ExceptionHolder_i.h"
#include "tao/Valuetype/ValueFactory.h"
#include "tao/Object_T.h"
#include "tao/ORB_Core.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "PortableGroupC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PORTABLEGROUP_GROUPIIOPPROFILE_CS_)
#define _PORTABLEGROUP_GROUPIIOPPROFILE_CS_

PortableGroup::GroupIIOPProfile::GroupIIOPProfile (void)
{}

PortableGroup::GroupIIOPProfile::GroupIIOPProfile (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

PortableGroup::GroupIIOPProfile::GroupIIOPProfile (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

PortableGroup::GroupIIOPProfile::GroupIIOPProfile (
    const GroupIIOPProfile &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

PortableGroup::GroupIIOPProfile::~GroupIIOPProfile (void)
{}

void PortableGroup::GroupIIOPProfile::_tao_any_destructor (
    void * _tao_void_pointer)
{
  GroupIIOPProfile * _tao_tmp_pointer =
    static_cast<GroupIIOPProfile *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_PortableGroup_GroupIIOPProfile_GUARD
#define _TAO_TYPECODE_PortableGroup_GroupIIOPProfile_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        PortableGroup_GroupIIOPProfile_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_PortableGroup_GroupIIOPProfile_0 =
        &PortableGroup_GroupIIOPProfile_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_PortableGroup_GroupIIOPProfile_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_GroupIIOPProfile (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/GroupIIOPProfile:1.0",
    "GroupIIOPProfile",
    &TAO::TypeCode::tc_PortableGroup_GroupIIOPProfile_0);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_GroupIIOPProfile =
    &_tao_tc_PortableGroup_GroupIIOPProfile;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_TypeId (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/TypeId:1.0",
    "TypeId",
    &CORBA::_tc_RepositoryId);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_TypeId =
    &_tao_tc_PortableGroup_TypeId;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_ObjectGroup (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/ObjectGroup:1.0",
    "ObjectGroup",
    &CORBA::_tc_Object);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_ObjectGroup =
    &_tao_tc_PortableGroup_ObjectGroup;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PORTABLEGROUP_OBJECTGROUPS_CS_)
#define _PORTABLEGROUP_OBJECTGROUPS_CS_

PortableGroup::ObjectGroups::ObjectGroups (void)
{}

PortableGroup::ObjectGroups::ObjectGroups (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        ObjectGroup,
        ObjectGroup_var
      > (max)
{}

PortableGroup::ObjectGroups::ObjectGroups (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Object_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        ObjectGroup,
        ObjectGroup_var
      >
    (max, length, buffer, release)
{}

PortableGroup::ObjectGroups::ObjectGroups (
    const ObjectGroups &seq)
  : ::TAO::unbounded_object_reference_sequence<
        ObjectGroup,
        ObjectGroup_var
      > (seq)
{}

PortableGroup::ObjectGroups::~ObjectGroups (void)
{}

void PortableGroup::ObjectGroups::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ObjectGroups * _tao_tmp_pointer =
    static_cast<ObjectGroups *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_PortableGroup_ObjectGroups_GUARD
#define _TAO_TYPECODE_PortableGroup_ObjectGroups_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        PortableGroup_ObjectGroups_0 (
          ::CORBA::tk_sequence,
          &PortableGroup::_tc_ObjectGroup,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_PortableGroup_ObjectGroups_0 =
        &PortableGroup_ObjectGroups_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_PortableGroup_ObjectGroups_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_ObjectGroups (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/ObjectGroups:1.0",
    "ObjectGroups",
    &TAO::TypeCode::tc_PortableGroup_ObjectGroups_0);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_ObjectGroups =
    &_tao_tc_PortableGroup_ObjectGroups;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_Name (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/Name:1.0",
    "Name",
    &CosNaming::_tc_Name);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_Name =
    &_tao_tc_PortableGroup_Name;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_Value (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/Value:1.0",
    "Value",
    &CORBA::_tc_any);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_Value =
    &_tao_tc_PortableGroup_Value;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_PortableGroup_Property[] =
      {
        { "nam", &PortableGroup::_tc_Name },
        { "val", &PortableGroup::_tc_Value }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_Property (
  ::CORBA::tk_struct,
  "IDL:omg.org/PortableGroup/Property:1.0",
  "Property",
  _tao_fields_PortableGroup_Property,
  2);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_Property =
    &_tao_tc_PortableGroup_Property;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
PortableGroup::Property::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Property *_tao_tmp_pointer =
    static_cast<Property *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PORTABLEGROUP_PROPERTIES_CS_)
#define _PORTABLEGROUP_PROPERTIES_CS_

PortableGroup::Properties::Properties (void)
{}

PortableGroup::Properties::Properties (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Property
      > (max)
{}

PortableGroup::Properties::Properties (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    PortableGroup::Property * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Property
      >
    (max, length, buffer, release)
{}

PortableGroup::Properties::Properties (
    const Properties &seq)
  : ::TAO::unbounded_value_sequence<
        Property
      > (seq)
{}

PortableGroup::Properties::~Properties (void)
{}

void PortableGroup::Properties::_tao_any_destructor (
    void * _tao_void_pointer)
{
  Properties * _tao_tmp_pointer =
    static_cast<Properties *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_PortableGroup_Properties_GUARD
#define _TAO_TYPECODE_PortableGroup_Properties_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        PortableGroup_Properties_0 (
          ::CORBA::tk_sequence,
          &PortableGroup::_tc_Property,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_PortableGroup_Properties_0 =
        &PortableGroup_Properties_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_PortableGroup_Properties_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_Properties (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/Properties:1.0",
    "Properties",
    &TAO::TypeCode::tc_PortableGroup_Properties_0);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_Properties =
    &_tao_tc_PortableGroup_Properties;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_Location (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/Location:1.0",
    "Location",
    &PortableGroup::_tc_Name);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_Location =
    &_tao_tc_PortableGroup_Location;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PORTABLEGROUP_LOCATIONS_CS_)
#define _PORTABLEGROUP_LOCATIONS_CS_

PortableGroup::Locations::Locations (void)
{}

PortableGroup::Locations::Locations (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Location
      > (max)
{}

PortableGroup::Locations::Locations (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    PortableGroup::Location * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Location
      >
    (max, length, buffer, release)
{}

PortableGroup::Locations::Locations (
    const Locations &seq)
  : ::TAO::unbounded_value_sequence<
        Location
      > (seq)
{}

PortableGroup::Locations::~Locations (void)
{}

void PortableGroup::Locations::_tao_any_destructor (
    void * _tao_void_pointer)
{
  Locations * _tao_tmp_pointer =
    static_cast<Locations *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_PortableGroup_Locations_GUARD
#define _TAO_TYPECODE_PortableGroup_Locations_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        PortableGroup_Locations_0 (
          ::CORBA::tk_sequence,
          &PortableGroup::_tc_Location,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_PortableGroup_Locations_0 =
        &PortableGroup_Locations_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_PortableGroup_Locations_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_Locations (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/Locations:1.0",
    "Locations",
    &TAO::TypeCode::tc_PortableGroup_Locations_0);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_Locations =
    &_tao_tc_PortableGroup_Locations;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_Criteria (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/Criteria:1.0",
    "Criteria",
    &PortableGroup::_tc_Properties);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_Criteria =
    &_tao_tc_PortableGroup_Criteria;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_PortableGroup_FactoryInfo[] =
      {
        { "the_factory", &PortableGroup::_tc_GenericFactory },
        { "the_location", &PortableGroup::_tc_Location },
        { "the_criteria", &PortableGroup::_tc_Criteria }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_FactoryInfo (
  ::CORBA::tk_struct,
  "IDL:omg.org/PortableGroup/FactoryInfo:1.0",
  "FactoryInfo",
  _tao_fields_PortableGroup_FactoryInfo,
  3);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_FactoryInfo =
    &_tao_tc_PortableGroup_FactoryInfo;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
PortableGroup::FactoryInfo::_tao_any_destructor (
    void *_tao_void_pointer)
{
  FactoryInfo *_tao_tmp_pointer =
    static_cast<FactoryInfo *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PORTABLEGROUP_FACTORYINFOS_CS_)
#define _PORTABLEGROUP_FACTORYINFOS_CS_

PortableGroup::FactoryInfos::FactoryInfos (void)
{}

PortableGroup::FactoryInfos::FactoryInfos (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        FactoryInfo
      > (max)
{}

PortableGroup::FactoryInfos::FactoryInfos (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    PortableGroup::FactoryInfo * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        FactoryInfo
      >
    (max, length, buffer, release)
{}

PortableGroup::FactoryInfos::FactoryInfos (
    const FactoryInfos &seq)
  : ::TAO::unbounded_value_sequence<
        FactoryInfo
      > (seq)
{}

PortableGroup::FactoryInfos::~FactoryInfos (void)
{}

void PortableGroup::FactoryInfos::_tao_any_destructor (
    void * _tao_void_pointer)
{
  FactoryInfos * _tao_tmp_pointer =
    static_cast<FactoryInfos *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_PortableGroup_FactoryInfos_GUARD
#define _TAO_TYPECODE_PortableGroup_FactoryInfos_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        PortableGroup_FactoryInfos_0 (
          ::CORBA::tk_sequence,
          &PortableGroup::_tc_FactoryInfo,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_PortableGroup_FactoryInfos_0 =
        &PortableGroup_FactoryInfos_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_PortableGroup_FactoryInfos_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_FactoryInfos (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/FactoryInfos:1.0",
    "FactoryInfos",
    &TAO::TypeCode::tc_PortableGroup_FactoryInfos_0);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_FactoryInfos =
    &_tao_tc_PortableGroup_FactoryInfos;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_MembershipStyleValue (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/MembershipStyleValue:1.0",
    "MembershipStyleValue",
    &CORBA::_tc_long);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_MembershipStyleValue =
    &_tao_tc_PortableGroup_MembershipStyleValue;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_FactoriesValue (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/FactoriesValue:1.0",
    "FactoriesValue",
    &PortableGroup::_tc_FactoryInfos);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_FactoriesValue =
    &_tao_tc_PortableGroup_FactoriesValue;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_InitialNumberMembersValue (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/InitialNumberMembersValue:1.0",
    "InitialNumberMembersValue",
    &CORBA::_tc_ushort);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_InitialNumberMembersValue =
    &_tao_tc_PortableGroup_InitialNumberMembersValue;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_MinimumNumberMembersValue (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/MinimumNumberMembersValue:1.0",
    "MinimumNumberMembersValue",
    &CORBA::_tc_ushort);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_MinimumNumberMembersValue =
    &_tao_tc_PortableGroup_MinimumNumberMembersValue;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

PortableGroup::InterfaceNotFound::InterfaceNotFound (void)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/InterfaceNotFound:1.0",
        "InterfaceNotFound"
      )
{
}

PortableGroup::InterfaceNotFound::~InterfaceNotFound (void)
{
}

PortableGroup::InterfaceNotFound::InterfaceNotFound (const ::PortableGroup::InterfaceNotFound &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableGroup::InterfaceNotFound&
PortableGroup::InterfaceNotFound::operator= (const ::PortableGroup::InterfaceNotFound &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void PortableGroup::InterfaceNotFound::_tao_any_destructor (void *_tao_void_pointer)
{
  InterfaceNotFound *_tao_tmp_pointer =
    static_cast<InterfaceNotFound *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

PortableGroup::InterfaceNotFound *
PortableGroup::InterfaceNotFound::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InterfaceNotFound *> (_tao_excp);
}

const PortableGroup::InterfaceNotFound *
PortableGroup::InterfaceNotFound::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InterfaceNotFound *> (_tao_excp);
}

::CORBA::Exception *PortableGroup::InterfaceNotFound::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::InterfaceNotFound, 0);
  return retval;
}

::CORBA::Exception *
PortableGroup::InterfaceNotFound::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::PortableGroup::InterfaceNotFound (*this),
      0
    );
  return result;
}

void PortableGroup::InterfaceNotFound::_raise (void) const
{
  throw *this;
}

void PortableGroup::InterfaceNotFound::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void PortableGroup::InterfaceNotFound::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableGroup::InterfaceNotFound::_tao_type (void) const
{
  return ::PortableGroup::_tc_InterfaceNotFound;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_PortableGroup_InterfaceNotFound = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_InterfaceNotFound (
  ::CORBA::tk_except,
  "IDL:omg.org/PortableGroup/InterfaceNotFound:1.0",
  "InterfaceNotFound",
  _tao_fields_PortableGroup_InterfaceNotFound,
  0);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_InterfaceNotFound =
    &_tao_tc_PortableGroup_InterfaceNotFound;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

PortableGroup::ObjectGroupNotFound::ObjectGroupNotFound (void)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        "ObjectGroupNotFound"
      )
{
}

PortableGroup::ObjectGroupNotFound::~ObjectGroupNotFound (void)
{
}

PortableGroup::ObjectGroupNotFound::ObjectGroupNotFound (const ::PortableGroup::ObjectGroupNotFound &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableGroup::ObjectGroupNotFound&
PortableGroup::ObjectGroupNotFound::operator= (const ::PortableGroup::ObjectGroupNotFound &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void PortableGroup::ObjectGroupNotFound::_tao_any_destructor (void *_tao_void_pointer)
{
  ObjectGroupNotFound *_tao_tmp_pointer =
    static_cast<ObjectGroupNotFound *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

PortableGroup::ObjectGroupNotFound *
PortableGroup::ObjectGroupNotFound::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ObjectGroupNotFound *> (_tao_excp);
}

const PortableGroup::ObjectGroupNotFound *
PortableGroup::ObjectGroupNotFound::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ObjectGroupNotFound *> (_tao_excp);
}

::CORBA::Exception *PortableGroup::ObjectGroupNotFound::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::ObjectGroupNotFound, 0);
  return retval;
}

::CORBA::Exception *
PortableGroup::ObjectGroupNotFound::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::PortableGroup::ObjectGroupNotFound (*this),
      0
    );
  return result;
}

void PortableGroup::ObjectGroupNotFound::_raise (void) const
{
  throw *this;
}

void PortableGroup::ObjectGroupNotFound::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void PortableGroup::ObjectGroupNotFound::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableGroup::ObjectGroupNotFound::_tao_type (void) const
{
  return ::PortableGroup::_tc_ObjectGroupNotFound;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_PortableGroup_ObjectGroupNotFound = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_ObjectGroupNotFound (
  ::CORBA::tk_except,
  "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
  "ObjectGroupNotFound",
  _tao_fields_PortableGroup_ObjectGroupNotFound,
  0);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_ObjectGroupNotFound =
    &_tao_tc_PortableGroup_ObjectGroupNotFound;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

PortableGroup::MemberNotFound::MemberNotFound (void)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
        "MemberNotFound"
      )
{
}

PortableGroup::MemberNotFound::~MemberNotFound (void)
{
}

PortableGroup::MemberNotFound::MemberNotFound (const ::PortableGroup::MemberNotFound &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableGroup::MemberNotFound&
PortableGroup::MemberNotFound::operator= (const ::PortableGroup::MemberNotFound &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void PortableGroup::MemberNotFound::_tao_any_destructor (void *_tao_void_pointer)
{
  MemberNotFound *_tao_tmp_pointer =
    static_cast<MemberNotFound *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

PortableGroup::MemberNotFound *
PortableGroup::MemberNotFound::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<MemberNotFound *> (_tao_excp);
}

const PortableGroup::MemberNotFound *
PortableGroup::MemberNotFound::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const MemberNotFound *> (_tao_excp);
}

::CORBA::Exception *PortableGroup::MemberNotFound::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::MemberNotFound, 0);
  return retval;
}

::CORBA::Exception *
PortableGroup::MemberNotFound::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::PortableGroup::MemberNotFound (*this),
      0
    );
  return result;
}

void PortableGroup::MemberNotFound::_raise (void) const
{
  throw *this;
}

void PortableGroup::MemberNotFound::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void PortableGroup::MemberNotFound::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableGroup::MemberNotFound::_tao_type (void) const
{
  return ::PortableGroup::_tc_MemberNotFound;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_PortableGroup_MemberNotFound = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_MemberNotFound (
  ::CORBA::tk_except,
  "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
  "MemberNotFound",
  _tao_fields_PortableGroup_MemberNotFound,
  0);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_MemberNotFound =
    &_tao_tc_PortableGroup_MemberNotFound;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

PortableGroup::ObjectNotFound::ObjectNotFound (void)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/ObjectNotFound:1.0",
        "ObjectNotFound"
      )
{
}

PortableGroup::ObjectNotFound::~ObjectNotFound (void)
{
}

PortableGroup::ObjectNotFound::ObjectNotFound (const ::PortableGroup::ObjectNotFound &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableGroup::ObjectNotFound&
PortableGroup::ObjectNotFound::operator= (const ::PortableGroup::ObjectNotFound &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void PortableGroup::ObjectNotFound::_tao_any_destructor (void *_tao_void_pointer)
{
  ObjectNotFound *_tao_tmp_pointer =
    static_cast<ObjectNotFound *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

PortableGroup::ObjectNotFound *
PortableGroup::ObjectNotFound::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ObjectNotFound *> (_tao_excp);
}

const PortableGroup::ObjectNotFound *
PortableGroup::ObjectNotFound::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ObjectNotFound *> (_tao_excp);
}

::CORBA::Exception *PortableGroup::ObjectNotFound::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::ObjectNotFound, 0);
  return retval;
}

::CORBA::Exception *
PortableGroup::ObjectNotFound::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::PortableGroup::ObjectNotFound (*this),
      0
    );
  return result;
}

void PortableGroup::ObjectNotFound::_raise (void) const
{
  throw *this;
}

void PortableGroup::ObjectNotFound::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void PortableGroup::ObjectNotFound::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableGroup::ObjectNotFound::_tao_type (void) const
{
  return ::PortableGroup::_tc_ObjectNotFound;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_PortableGroup_ObjectNotFound = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_ObjectNotFound (
  ::CORBA::tk_except,
  "IDL:omg.org/PortableGroup/ObjectNotFound:1.0",
  "ObjectNotFound",
  _tao_fields_PortableGroup_ObjectNotFound,
  0);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_ObjectNotFound =
    &_tao_tc_PortableGroup_ObjectNotFound;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

PortableGroup::MemberAlreadyPresent::MemberAlreadyPresent (void)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0",
        "MemberAlreadyPresent"
      )
{
}

PortableGroup::MemberAlreadyPresent::~MemberAlreadyPresent (void)
{
}

PortableGroup::MemberAlreadyPresent::MemberAlreadyPresent (const ::PortableGroup::MemberAlreadyPresent &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableGroup::MemberAlreadyPresent&
PortableGroup::MemberAlreadyPresent::operator= (const ::PortableGroup::MemberAlreadyPresent &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void PortableGroup::MemberAlreadyPresent::_tao_any_destructor (void *_tao_void_pointer)
{
  MemberAlreadyPresent *_tao_tmp_pointer =
    static_cast<MemberAlreadyPresent *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

PortableGroup::MemberAlreadyPresent *
PortableGroup::MemberAlreadyPresent::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<MemberAlreadyPresent *> (_tao_excp);
}

const PortableGroup::MemberAlreadyPresent *
PortableGroup::MemberAlreadyPresent::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const MemberAlreadyPresent *> (_tao_excp);
}

::CORBA::Exception *PortableGroup::MemberAlreadyPresent::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::MemberAlreadyPresent, 0);
  return retval;
}

::CORBA::Exception *
PortableGroup::MemberAlreadyPresent::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::PortableGroup::MemberAlreadyPresent (*this),
      0
    );
  return result;
}

void PortableGroup::MemberAlreadyPresent::_raise (void) const
{
  throw *this;
}

void PortableGroup::MemberAlreadyPresent::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void PortableGroup::MemberAlreadyPresent::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableGroup::MemberAlreadyPresent::_tao_type (void) const
{
  return ::PortableGroup::_tc_MemberAlreadyPresent;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_PortableGroup_MemberAlreadyPresent = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_MemberAlreadyPresent (
  ::CORBA::tk_except,
  "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0",
  "MemberAlreadyPresent",
  _tao_fields_PortableGroup_MemberAlreadyPresent,
  0);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_MemberAlreadyPresent =
    &_tao_tc_PortableGroup_MemberAlreadyPresent;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

PortableGroup::ObjectNotCreated::ObjectNotCreated (void)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/ObjectNotCreated:1.0",
        "ObjectNotCreated"
      )
{
}

PortableGroup::ObjectNotCreated::~ObjectNotCreated (void)
{
}

PortableGroup::ObjectNotCreated::ObjectNotCreated (const ::PortableGroup::ObjectNotCreated &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableGroup::ObjectNotCreated&
PortableGroup::ObjectNotCreated::operator= (const ::PortableGroup::ObjectNotCreated &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void PortableGroup::ObjectNotCreated::_tao_any_destructor (void *_tao_void_pointer)
{
  ObjectNotCreated *_tao_tmp_pointer =
    static_cast<ObjectNotCreated *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

PortableGroup::ObjectNotCreated *
PortableGroup::ObjectNotCreated::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ObjectNotCreated *> (_tao_excp);
}

const PortableGroup::ObjectNotCreated *
PortableGroup::ObjectNotCreated::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ObjectNotCreated *> (_tao_excp);
}

::CORBA::Exception *PortableGroup::ObjectNotCreated::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::ObjectNotCreated, 0);
  return retval;
}

::CORBA::Exception *
PortableGroup::ObjectNotCreated::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::PortableGroup::ObjectNotCreated (*this),
      0
    );
  return result;
}

void PortableGroup::ObjectNotCreated::_raise (void) const
{
  throw *this;
}

void PortableGroup::ObjectNotCreated::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void PortableGroup::ObjectNotCreated::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableGroup::ObjectNotCreated::_tao_type (void) const
{
  return ::PortableGroup::_tc_ObjectNotCreated;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_PortableGroup_ObjectNotCreated = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_ObjectNotCreated (
  ::CORBA::tk_except,
  "IDL:omg.org/PortableGroup/ObjectNotCreated:1.0",
  "ObjectNotCreated",
  _tao_fields_PortableGroup_ObjectNotCreated,
  0);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_ObjectNotCreated =
    &_tao_tc_PortableGroup_ObjectNotCreated;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

PortableGroup::ObjectNotAdded::ObjectNotAdded (void)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/ObjectNotAdded:1.0",
        "ObjectNotAdded"
      )
{
}

PortableGroup::ObjectNotAdded::~ObjectNotAdded (void)
{
}

PortableGroup::ObjectNotAdded::ObjectNotAdded (const ::PortableGroup::ObjectNotAdded &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableGroup::ObjectNotAdded&
PortableGroup::ObjectNotAdded::operator= (const ::PortableGroup::ObjectNotAdded &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void PortableGroup::ObjectNotAdded::_tao_any_destructor (void *_tao_void_pointer)
{
  ObjectNotAdded *_tao_tmp_pointer =
    static_cast<ObjectNotAdded *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

PortableGroup::ObjectNotAdded *
PortableGroup::ObjectNotAdded::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ObjectNotAdded *> (_tao_excp);
}

const PortableGroup::ObjectNotAdded *
PortableGroup::ObjectNotAdded::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ObjectNotAdded *> (_tao_excp);
}

::CORBA::Exception *PortableGroup::ObjectNotAdded::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::ObjectNotAdded, 0);
  return retval;
}

::CORBA::Exception *
PortableGroup::ObjectNotAdded::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::PortableGroup::ObjectNotAdded (*this),
      0
    );
  return result;
}

void PortableGroup::ObjectNotAdded::_raise (void) const
{
  throw *this;
}

void PortableGroup::ObjectNotAdded::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void PortableGroup::ObjectNotAdded::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableGroup::ObjectNotAdded::_tao_type (void) const
{
  return ::PortableGroup::_tc_ObjectNotAdded;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_PortableGroup_ObjectNotAdded = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_ObjectNotAdded (
  ::CORBA::tk_except,
  "IDL:omg.org/PortableGroup/ObjectNotAdded:1.0",
  "ObjectNotAdded",
  _tao_fields_PortableGroup_ObjectNotAdded,
  0);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_ObjectNotAdded =
    &_tao_tc_PortableGroup_ObjectNotAdded;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

PortableGroup::TypeConflict::TypeConflict (void)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/TypeConflict:1.0",
        "TypeConflict"
      )
{
}

PortableGroup::TypeConflict::~TypeConflict (void)
{
}

PortableGroup::TypeConflict::TypeConflict (const ::PortableGroup::TypeConflict &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableGroup::TypeConflict&
PortableGroup::TypeConflict::operator= (const ::PortableGroup::TypeConflict &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void PortableGroup::TypeConflict::_tao_any_destructor (void *_tao_void_pointer)
{
  TypeConflict *_tao_tmp_pointer =
    static_cast<TypeConflict *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

PortableGroup::TypeConflict *
PortableGroup::TypeConflict::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<TypeConflict *> (_tao_excp);
}

const PortableGroup::TypeConflict *
PortableGroup::TypeConflict::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const TypeConflict *> (_tao_excp);
}

::CORBA::Exception *PortableGroup::TypeConflict::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::TypeConflict, 0);
  return retval;
}

::CORBA::Exception *
PortableGroup::TypeConflict::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::PortableGroup::TypeConflict (*this),
      0
    );
  return result;
}

void PortableGroup::TypeConflict::_raise (void) const
{
  throw *this;
}

void PortableGroup::TypeConflict::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void PortableGroup::TypeConflict::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableGroup::TypeConflict::_tao_type (void) const
{
  return ::PortableGroup::_tc_TypeConflict;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_PortableGroup_TypeConflict = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_TypeConflict (
  ::CORBA::tk_except,
  "IDL:omg.org/PortableGroup/TypeConflict:1.0",
  "TypeConflict",
  _tao_fields_PortableGroup_TypeConflict,
  0);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_TypeConflict =
    &_tao_tc_PortableGroup_TypeConflict;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

PortableGroup::UnsupportedProperty::UnsupportedProperty (
    const PortableGroup::Name & _tao_nam,
    const ::PortableGroup::Value & _tao_val)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        "UnsupportedProperty"
      )
{
  this->nam = _tao_nam;
  this->val = _tao_val;
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

PortableGroup::UnsupportedProperty::UnsupportedProperty (void)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        "UnsupportedProperty"
      )
{
}

PortableGroup::UnsupportedProperty::~UnsupportedProperty (void)
{
}

PortableGroup::UnsupportedProperty::UnsupportedProperty (const ::PortableGroup::UnsupportedProperty &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->nam = _tao_excp.nam;
  this->val = _tao_excp.val;
}

PortableGroup::UnsupportedProperty&
PortableGroup::UnsupportedProperty::operator= (const ::PortableGroup::UnsupportedProperty &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->nam = _tao_excp.nam;
  this->val = _tao_excp.val;
  return *this;
}

void PortableGroup::UnsupportedProperty::_tao_any_destructor (void *_tao_void_pointer)
{
  UnsupportedProperty *_tao_tmp_pointer =
    static_cast<UnsupportedProperty *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

PortableGroup::UnsupportedProperty *
PortableGroup::UnsupportedProperty::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UnsupportedProperty *> (_tao_excp);
}

const PortableGroup::UnsupportedProperty *
PortableGroup::UnsupportedProperty::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UnsupportedProperty *> (_tao_excp);
}

::CORBA::Exception *PortableGroup::UnsupportedProperty::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::UnsupportedProperty, 0);
  return retval;
}

::CORBA::Exception *
PortableGroup::UnsupportedProperty::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::PortableGroup::UnsupportedProperty (*this),
      0
    );
  return result;
}

void PortableGroup::UnsupportedProperty::_raise (void) const
{
  throw *this;
}

void PortableGroup::UnsupportedProperty::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void PortableGroup::UnsupportedProperty::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableGroup::UnsupportedProperty::_tao_type (void) const
{
  return ::PortableGroup::_tc_UnsupportedProperty;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_PortableGroup_UnsupportedProperty[] =
      {
        { "nam", &PortableGroup::_tc_Name },
        { "val", &PortableGroup::_tc_Value }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_UnsupportedProperty (
  ::CORBA::tk_except,
  "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
  "UnsupportedProperty",
  _tao_fields_PortableGroup_UnsupportedProperty,
  2);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_UnsupportedProperty =
    &_tao_tc_PortableGroup_UnsupportedProperty;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

PortableGroup::InvalidProperty::InvalidProperty (
    const PortableGroup::Name & _tao_nam,
    const ::PortableGroup::Value & _tao_val)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        "InvalidProperty"
      )
{
  this->nam = _tao_nam;
  this->val = _tao_val;
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

PortableGroup::InvalidProperty::InvalidProperty (void)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        "InvalidProperty"
      )
{
}

PortableGroup::InvalidProperty::~InvalidProperty (void)
{
}

PortableGroup::InvalidProperty::InvalidProperty (const ::PortableGroup::InvalidProperty &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->nam = _tao_excp.nam;
  this->val = _tao_excp.val;
}

PortableGroup::InvalidProperty&
PortableGroup::InvalidProperty::operator= (const ::PortableGroup::InvalidProperty &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->nam = _tao_excp.nam;
  this->val = _tao_excp.val;
  return *this;
}

void PortableGroup::InvalidProperty::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidProperty *_tao_tmp_pointer =
    static_cast<InvalidProperty *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

PortableGroup::InvalidProperty *
PortableGroup::InvalidProperty::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidProperty *> (_tao_excp);
}

const PortableGroup::InvalidProperty *
PortableGroup::InvalidProperty::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidProperty *> (_tao_excp);
}

::CORBA::Exception *PortableGroup::InvalidProperty::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::InvalidProperty, 0);
  return retval;
}

::CORBA::Exception *
PortableGroup::InvalidProperty::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::PortableGroup::InvalidProperty (*this),
      0
    );
  return result;
}

void PortableGroup::InvalidProperty::_raise (void) const
{
  throw *this;
}

void PortableGroup::InvalidProperty::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void PortableGroup::InvalidProperty::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableGroup::InvalidProperty::_tao_type (void) const
{
  return ::PortableGroup::_tc_InvalidProperty;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_PortableGroup_InvalidProperty[] =
      {
        { "nam", &PortableGroup::_tc_Name },
        { "val", &PortableGroup::_tc_Value }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_InvalidProperty (
  ::CORBA::tk_except,
  "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
  "InvalidProperty",
  _tao_fields_PortableGroup_InvalidProperty,
  2);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_InvalidProperty =
    &_tao_tc_PortableGroup_InvalidProperty;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

PortableGroup::NoFactory::NoFactory (
    const PortableGroup::Location & _tao_the_location,
    const char * _tao_type_id)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/NoFactory:1.0",
        "NoFactory"
      )
{
  this->the_location = _tao_the_location;
  this->type_id = ::CORBA::string_dup (_tao_type_id);
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

PortableGroup::NoFactory::NoFactory (void)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/NoFactory:1.0",
        "NoFactory"
      )
{
}

PortableGroup::NoFactory::~NoFactory (void)
{
}

PortableGroup::NoFactory::NoFactory (const ::PortableGroup::NoFactory &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->the_location = _tao_excp.the_location;
  this->type_id = ::CORBA::string_dup (_tao_excp.type_id.in ());
}

PortableGroup::NoFactory&
PortableGroup::NoFactory::operator= (const ::PortableGroup::NoFactory &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->the_location = _tao_excp.the_location;
  this->type_id = ::CORBA::string_dup (_tao_excp.type_id.in ());
  return *this;
}

void PortableGroup::NoFactory::_tao_any_destructor (void *_tao_void_pointer)
{
  NoFactory *_tao_tmp_pointer =
    static_cast<NoFactory *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

PortableGroup::NoFactory *
PortableGroup::NoFactory::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NoFactory *> (_tao_excp);
}

const PortableGroup::NoFactory *
PortableGroup::NoFactory::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NoFactory *> (_tao_excp);
}

::CORBA::Exception *PortableGroup::NoFactory::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::NoFactory, 0);
  return retval;
}

::CORBA::Exception *
PortableGroup::NoFactory::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::PortableGroup::NoFactory (*this),
      0
    );
  return result;
}

void PortableGroup::NoFactory::_raise (void) const
{
  throw *this;
}

void PortableGroup::NoFactory::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void PortableGroup::NoFactory::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableGroup::NoFactory::_tao_type (void) const
{
  return ::PortableGroup::_tc_NoFactory;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_PortableGroup_NoFactory[] =
      {
        { "the_location", &PortableGroup::_tc_Location },
        { "type_id", &PortableGroup::_tc_TypeId }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_NoFactory (
  ::CORBA::tk_except,
  "IDL:omg.org/PortableGroup/NoFactory:1.0",
  "NoFactory",
  _tao_fields_PortableGroup_NoFactory,
  2);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_NoFactory =
    &_tao_tc_PortableGroup_NoFactory;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

PortableGroup::InvalidCriteria::InvalidCriteria (
    const PortableGroup::Criteria & _tao_invalid_criteria)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/InvalidCriteria:1.0",
        "InvalidCriteria"
      )
{
  this->invalid_criteria = _tao_invalid_criteria;
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

PortableGroup::InvalidCriteria::InvalidCriteria (void)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/InvalidCriteria:1.0",
        "InvalidCriteria"
      )
{
}

PortableGroup::InvalidCriteria::~InvalidCriteria (void)
{
}

PortableGroup::InvalidCriteria::InvalidCriteria (const ::PortableGroup::InvalidCriteria &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->invalid_criteria = _tao_excp.invalid_criteria;
}

PortableGroup::InvalidCriteria&
PortableGroup::InvalidCriteria::operator= (const ::PortableGroup::InvalidCriteria &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->invalid_criteria = _tao_excp.invalid_criteria;
  return *this;
}

void PortableGroup::InvalidCriteria::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidCriteria *_tao_tmp_pointer =
    static_cast<InvalidCriteria *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

PortableGroup::InvalidCriteria *
PortableGroup::InvalidCriteria::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidCriteria *> (_tao_excp);
}

const PortableGroup::InvalidCriteria *
PortableGroup::InvalidCriteria::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidCriteria *> (_tao_excp);
}

::CORBA::Exception *PortableGroup::InvalidCriteria::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::InvalidCriteria, 0);
  return retval;
}

::CORBA::Exception *
PortableGroup::InvalidCriteria::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::PortableGroup::InvalidCriteria (*this),
      0
    );
  return result;
}

void PortableGroup::InvalidCriteria::_raise (void) const
{
  throw *this;
}

void PortableGroup::InvalidCriteria::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void PortableGroup::InvalidCriteria::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableGroup::InvalidCriteria::_tao_type (void) const
{
  return ::PortableGroup::_tc_InvalidCriteria;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_PortableGroup_InvalidCriteria[] =
      {
        { "invalid_criteria", &PortableGroup::_tc_Criteria }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_InvalidCriteria (
  ::CORBA::tk_except,
  "IDL:omg.org/PortableGroup/InvalidCriteria:1.0",
  "InvalidCriteria",
  _tao_fields_PortableGroup_InvalidCriteria,
  1);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_InvalidCriteria =
    &_tao_tc_PortableGroup_InvalidCriteria;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

PortableGroup::CannotMeetCriteria::CannotMeetCriteria (
    const PortableGroup::Criteria & _tao_unmet_criteria)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0",
        "CannotMeetCriteria"
      )
{
  this->unmet_criteria = _tao_unmet_criteria;
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

PortableGroup::CannotMeetCriteria::CannotMeetCriteria (void)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0",
        "CannotMeetCriteria"
      )
{
}

PortableGroup::CannotMeetCriteria::~CannotMeetCriteria (void)
{
}

PortableGroup::CannotMeetCriteria::CannotMeetCriteria (const ::PortableGroup::CannotMeetCriteria &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->unmet_criteria = _tao_excp.unmet_criteria;
}

PortableGroup::CannotMeetCriteria&
PortableGroup::CannotMeetCriteria::operator= (const ::PortableGroup::CannotMeetCriteria &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->unmet_criteria = _tao_excp.unmet_criteria;
  return *this;
}

void PortableGroup::CannotMeetCriteria::_tao_any_destructor (void *_tao_void_pointer)
{
  CannotMeetCriteria *_tao_tmp_pointer =
    static_cast<CannotMeetCriteria *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

PortableGroup::CannotMeetCriteria *
PortableGroup::CannotMeetCriteria::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<CannotMeetCriteria *> (_tao_excp);
}

const PortableGroup::CannotMeetCriteria *
PortableGroup::CannotMeetCriteria::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const CannotMeetCriteria *> (_tao_excp);
}

::CORBA::Exception *PortableGroup::CannotMeetCriteria::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::CannotMeetCriteria, 0);
  return retval;
}

::CORBA::Exception *
PortableGroup::CannotMeetCriteria::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::PortableGroup::CannotMeetCriteria (*this),
      0
    );
  return result;
}

void PortableGroup::CannotMeetCriteria::_raise (void) const
{
  throw *this;
}

void PortableGroup::CannotMeetCriteria::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void PortableGroup::CannotMeetCriteria::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableGroup::CannotMeetCriteria::_tao_type (void) const
{
  return ::PortableGroup::_tc_CannotMeetCriteria;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_PortableGroup_CannotMeetCriteria[] =
      {
        { "unmet_criteria", &PortableGroup::_tc_Criteria }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_CannotMeetCriteria (
  ::CORBA::tk_except,
  "IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0",
  "CannotMeetCriteria",
  _tao_fields_PortableGroup_CannotMeetCriteria,
  1);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_CannotMeetCriteria =
    &_tao_tc_PortableGroup_CannotMeetCriteria;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for PortableGroup::PropertyManager.

PortableGroup::PropertyManager_ptr
TAO::Objref_Traits<PortableGroup::PropertyManager>::duplicate (
    PortableGroup::PropertyManager_ptr p)
{
  return PortableGroup::PropertyManager::_duplicate (p);
}

void
TAO::Objref_Traits<PortableGroup::PropertyManager>::release (
    PortableGroup::PropertyManager_ptr p)
{
  ::CORBA::release (p);
}

PortableGroup::PropertyManager_ptr
TAO::Objref_Traits<PortableGroup::PropertyManager>::nil (void)
{
  return PortableGroup::PropertyManager::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<PortableGroup::PropertyManager>::marshal (
    const PortableGroup::PropertyManager_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*PortableGroup__TAO_PropertyManager_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::PropertyManager::set_default_properties (
  const ::PortableGroup::Properties & props)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Properties>::in_arg_val _tao_props (props);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_props
    };

  static TAO::Exception_Data
  _tao_PortableGroup_PropertyManager_set_default_properties_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_default_properties",
      22,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_PropertyManager_set_default_properties_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::PortableGroup::Properties *
PortableGroup::PropertyManager::get_default_properties (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::PortableGroup::Properties>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_default_properties",
      22,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::PropertyManager::remove_default_properties (
  const ::PortableGroup::Properties & props)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Properties>::in_arg_val _tao_props (props);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_props
    };

  static TAO::Exception_Data
  _tao_PortableGroup_PropertyManager_remove_default_properties_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_default_properties",
      25,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_PropertyManager_remove_default_properties_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::PropertyManager::set_type_properties (
  const char * type_id,
  const ::PortableGroup::Properties & overrides)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_type_id (type_id);
  TAO::Arg_Traits< ::PortableGroup::Properties>::in_arg_val _tao_overrides (overrides);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_type_id,
      &_tao_overrides
    };

  static TAO::Exception_Data
  _tao_PortableGroup_PropertyManager_set_type_properties_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "set_type_properties",
      19,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_PropertyManager_set_type_properties_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::PortableGroup::Properties *
PortableGroup::PropertyManager::get_type_properties (
  const char * type_id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::PortableGroup::Properties>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_type_id (type_id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_type_id
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_type_properties",
      19,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::PropertyManager::remove_type_properties (
  const char * type_id,
  const ::PortableGroup::Properties & props)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_type_id (type_id);
  TAO::Arg_Traits< ::PortableGroup::Properties>::in_arg_val _tao_props (props);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_type_id,
      &_tao_props
    };

  static TAO::Exception_Data
  _tao_PortableGroup_PropertyManager_remove_type_properties_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "remove_type_properties",
      22,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_PropertyManager_remove_type_properties_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::PropertyManager::set_properties_dynamically (
  ::PortableGroup::ObjectGroup_ptr object_group,
  const ::PortableGroup::Properties & overrides)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);
  TAO::Arg_Traits< ::PortableGroup::Properties>::in_arg_val _tao_overrides (overrides);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_object_group,
      &_tao_overrides
    };

  static TAO::Exception_Data
  _tao_PortableGroup_PropertyManager_set_properties_dynamically_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "set_properties_dynamically",
      26,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_PropertyManager_set_properties_dynamically_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::PortableGroup::Properties *
PortableGroup::PropertyManager::get_properties (
  ::PortableGroup::ObjectGroup_ptr object_group)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::PortableGroup::Properties>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_object_group
    };

  static TAO::Exception_Data
  _tao_PortableGroup_PropertyManager_get_properties_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_properties",
      14,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_PropertyManager_get_properties_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::PropertyManager::sendc_set_default_properties (
  ::PortableGroup::AMI_PropertyManagerHandler_ptr ami_handler,
  const ::PortableGroup::Properties & props)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Properties>::in_arg_val _tao_props (props);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_props
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_default_properties",
      22,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_PropertyManagerHandler::set_default_properties_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::PropertyManager::sendc_get_default_properties (
  ::PortableGroup::AMI_PropertyManagerHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }

  TAO::Argument ** _the_tao_operation_signature = 0;

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      0,
      "get_default_properties",
      22,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_PropertyManagerHandler::get_default_properties_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::PropertyManager::sendc_remove_default_properties (
  ::PortableGroup::AMI_PropertyManagerHandler_ptr ami_handler,
  const ::PortableGroup::Properties & props)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Properties>::in_arg_val _tao_props (props);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_props
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_default_properties",
      25,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_PropertyManagerHandler::remove_default_properties_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::PropertyManager::sendc_set_type_properties (
  ::PortableGroup::AMI_PropertyManagerHandler_ptr ami_handler,
  const char * type_id,
  const ::PortableGroup::Properties & overrides)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_type_id (type_id);
  TAO::Arg_Traits< ::PortableGroup::Properties>::in_arg_val _tao_overrides (overrides);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_type_id,
      &_tao_overrides
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "set_type_properties",
      19,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_PropertyManagerHandler::set_type_properties_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::PropertyManager::sendc_get_type_properties (
  ::PortableGroup::AMI_PropertyManagerHandler_ptr ami_handler,
  const char * type_id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_type_id (type_id);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_type_id
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_type_properties",
      19,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_PropertyManagerHandler::get_type_properties_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::PropertyManager::sendc_remove_type_properties (
  ::PortableGroup::AMI_PropertyManagerHandler_ptr ami_handler,
  const char * type_id,
  const ::PortableGroup::Properties & props)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_type_id (type_id);
  TAO::Arg_Traits< ::PortableGroup::Properties>::in_arg_val _tao_props (props);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_type_id,
      &_tao_props
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "remove_type_properties",
      22,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_PropertyManagerHandler::remove_type_properties_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::PropertyManager::sendc_set_properties_dynamically (
  ::PortableGroup::AMI_PropertyManagerHandler_ptr ami_handler,
  ::PortableGroup::ObjectGroup_ptr object_group,
  const ::PortableGroup::Properties & overrides)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);
  TAO::Arg_Traits< ::PortableGroup::Properties>::in_arg_val _tao_overrides (overrides);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_object_group,
      &_tao_overrides
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "set_properties_dynamically",
      26,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_PropertyManagerHandler::set_properties_dynamically_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::PropertyManager::sendc_get_properties (
  ::PortableGroup::AMI_PropertyManagerHandler_ptr ami_handler,
  ::PortableGroup::ObjectGroup_ptr object_group)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_PropertyManager_Proxy_Broker_ == 0)
    {
      PortableGroup_PropertyManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_object_group
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_properties",
      14,
      this->the_TAO_PropertyManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_PropertyManagerHandler::get_properties_reply_stub
    );
}

PortableGroup::PropertyManager::PropertyManager (void)
 : the_TAO_PropertyManager_Proxy_Broker_ (0)
{
  this->PortableGroup_PropertyManager_setup_collocation ();
}

void
PortableGroup::PropertyManager::PortableGroup_PropertyManager_setup_collocation ()
{
  if (::PortableGroup__TAO_PropertyManager_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_PropertyManager_Proxy_Broker_ =
        ::PortableGroup__TAO_PropertyManager_Proxy_Broker_Factory_function_pointer (this);
    }
}

PortableGroup::PropertyManager::~PropertyManager (void)
{}

void 
PortableGroup::PropertyManager::_tao_any_destructor (void *_tao_void_pointer)
{
  PropertyManager *_tao_tmp_pointer =
    static_cast<PropertyManager *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

PortableGroup::PropertyManager_ptr
PortableGroup::PropertyManager::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<PropertyManager>::narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/PropertyManager:1.0",
        PortableGroup__TAO_PropertyManager_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::PropertyManager_ptr
PortableGroup::PropertyManager::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<PropertyManager>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/PropertyManager:1.0",
        PortableGroup__TAO_PropertyManager_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::PropertyManager_ptr
PortableGroup::PropertyManager::_nil (void)
{
  return 0;
}

PortableGroup::PropertyManager_ptr
PortableGroup::PropertyManager::_duplicate (PropertyManager_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
PortableGroup::PropertyManager::_tao_release (PropertyManager_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
PortableGroup::PropertyManager::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/PropertyManager:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* PortableGroup::PropertyManager::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableGroup/PropertyManager:1.0";
}

::CORBA::Boolean
PortableGroup::PropertyManager::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_PropertyManager (
    ::CORBA::tk_objref,
    "IDL:omg.org/PortableGroup/PropertyManager:1.0",
    "PropertyManager");
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_PropertyManager =
    &_tao_tc_PortableGroup_PropertyManager;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for PortableGroup::AMI_PropertyManagerHandler.

PortableGroup::AMI_PropertyManagerHandler_ptr
TAO::Objref_Traits<PortableGroup::AMI_PropertyManagerHandler>::duplicate (
    PortableGroup::AMI_PropertyManagerHandler_ptr p)
{
  return PortableGroup::AMI_PropertyManagerHandler::_duplicate (p);
}

void
TAO::Objref_Traits<PortableGroup::AMI_PropertyManagerHandler>::release (
    PortableGroup::AMI_PropertyManagerHandler_ptr p)
{
  ::CORBA::release (p);
}

PortableGroup::AMI_PropertyManagerHandler_ptr
TAO::Objref_Traits<PortableGroup::AMI_PropertyManagerHandler>::nil (void)
{
  return PortableGroup::AMI_PropertyManagerHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<PortableGroup::AMI_PropertyManagerHandler>::marshal (
    const PortableGroup::AMI_PropertyManagerHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*PortableGroup__TAO_AMI_PropertyManagerHandler_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::set_default_properties (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_PropertyManagerHandler_set_default_properties_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "set_default_properties",
      22,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_PropertyManagerHandler_set_default_properties_exceptiondata,
      2
    );
}

void
PortableGroup::AMI_PropertyManagerHandler::set_default_properties_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_PropertyManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_PropertyManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->set_default_properties (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
          PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
          PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 2;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->set_default_properties_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::set_default_properties_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_PropertyManagerHandler_set_default_properties_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_default_properties_excep",
      28,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_PropertyManagerHandler_set_default_properties_excep_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::get_default_properties (
  const ::PortableGroup::Properties & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Properties>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_default_properties",
      22,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
PortableGroup::AMI_PropertyManagerHandler::get_default_properties_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_PropertyManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_PropertyManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::PortableGroup::Properties ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_default_properties (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_default_properties_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::get_default_properties_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_default_properties_excep",
      28,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::remove_default_properties (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_PropertyManagerHandler_remove_default_properties_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "remove_default_properties",
      25,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_PropertyManagerHandler_remove_default_properties_exceptiondata,
      2
    );
}

void
PortableGroup::AMI_PropertyManagerHandler::remove_default_properties_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_PropertyManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_PropertyManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->remove_default_properties (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
          PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
          PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 2;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->remove_default_properties_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::remove_default_properties_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_PropertyManagerHandler_remove_default_properties_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_default_properties_excep",
      31,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_PropertyManagerHandler_remove_default_properties_excep_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::set_type_properties (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_PropertyManagerHandler_set_type_properties_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "set_type_properties",
      19,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_PropertyManagerHandler_set_type_properties_exceptiondata,
      2
    );
}

void
PortableGroup::AMI_PropertyManagerHandler::set_type_properties_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_PropertyManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_PropertyManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->set_type_properties (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
          PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
          PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 2;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->set_type_properties_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::set_type_properties_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_PropertyManagerHandler_set_type_properties_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_type_properties_excep",
      25,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_PropertyManagerHandler_set_type_properties_excep_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::get_type_properties (
  const ::PortableGroup::Properties & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Properties>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_type_properties",
      19,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
PortableGroup::AMI_PropertyManagerHandler::get_type_properties_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_PropertyManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_PropertyManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::PortableGroup::Properties ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_type_properties (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_type_properties_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::get_type_properties_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_type_properties_excep",
      25,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::remove_type_properties (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_PropertyManagerHandler_remove_type_properties_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "remove_type_properties",
      22,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_PropertyManagerHandler_remove_type_properties_exceptiondata,
      2
    );
}

void
PortableGroup::AMI_PropertyManagerHandler::remove_type_properties_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_PropertyManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_PropertyManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->remove_type_properties (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
          PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
          PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 2;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->remove_type_properties_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::remove_type_properties_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_PropertyManagerHandler_remove_type_properties_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_type_properties_excep",
      28,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_PropertyManagerHandler_remove_type_properties_excep_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::set_properties_dynamically (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_PropertyManagerHandler_set_properties_dynamically_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "set_properties_dynamically",
      26,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_PropertyManagerHandler_set_properties_dynamically_exceptiondata,
      3
    );
}

void
PortableGroup::AMI_PropertyManagerHandler::set_properties_dynamically_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_PropertyManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_PropertyManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->set_properties_dynamically (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
          PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
          PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
          PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 3;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->set_properties_dynamically_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::set_properties_dynamically_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_PropertyManagerHandler_set_properties_dynamically_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/UnsupportedProperty:1.0",
        PortableGroup::UnsupportedProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_UnsupportedProperty
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_properties_dynamically_excep",
      32,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_PropertyManagerHandler_set_properties_dynamically_excep_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::get_properties (
  const ::PortableGroup::Properties & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Properties>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_PropertyManagerHandler_get_properties_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_properties",
      14,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_PropertyManagerHandler_get_properties_exceptiondata,
      1
    );
}

void
PortableGroup::AMI_PropertyManagerHandler::get_properties_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_PropertyManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_PropertyManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::PortableGroup::Properties ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_properties (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
          PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_properties_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_PropertyManagerHandler::get_properties_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_PropertyManagerHandler_get_properties_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_properties_excep",
      20,
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_PropertyManagerHandler_get_properties_excep_exceptiondata,
      1
    );
}

PortableGroup::AMI_PropertyManagerHandler::AMI_PropertyManagerHandler (void)
 : the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ (0)
{
  this->PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
}

void
PortableGroup::AMI_PropertyManagerHandler::PortableGroup_AMI_PropertyManagerHandler_setup_collocation ()
{
  if (::PortableGroup__TAO_AMI_PropertyManagerHandler_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_AMI_PropertyManagerHandler_Proxy_Broker_ =
        ::PortableGroup__TAO_AMI_PropertyManagerHandler_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->Messaging_ReplyHandler_setup_collocation ();
}

PortableGroup::AMI_PropertyManagerHandler::~AMI_PropertyManagerHandler (void)
{}

void 
PortableGroup::AMI_PropertyManagerHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_PropertyManagerHandler *_tao_tmp_pointer =
    static_cast<AMI_PropertyManagerHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

PortableGroup::AMI_PropertyManagerHandler_ptr
PortableGroup::AMI_PropertyManagerHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_PropertyManagerHandler>::narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/AMI_PropertyManagerHandler:1.0",
        PortableGroup__TAO_AMI_PropertyManagerHandler_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::AMI_PropertyManagerHandler_ptr
PortableGroup::AMI_PropertyManagerHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_PropertyManagerHandler>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/AMI_PropertyManagerHandler:1.0",
        PortableGroup__TAO_AMI_PropertyManagerHandler_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::AMI_PropertyManagerHandler_ptr
PortableGroup::AMI_PropertyManagerHandler::_nil (void)
{
  return 0;
}

PortableGroup::AMI_PropertyManagerHandler_ptr
PortableGroup::AMI_PropertyManagerHandler::_duplicate (AMI_PropertyManagerHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
PortableGroup::AMI_PropertyManagerHandler::_tao_release (AMI_PropertyManagerHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
PortableGroup::AMI_PropertyManagerHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/AMI_PropertyManagerHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* PortableGroup::AMI_PropertyManagerHandler::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableGroup/AMI_PropertyManagerHandler:1.0";
}

::CORBA::Boolean
PortableGroup::AMI_PropertyManagerHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_AMI_PropertyManagerHandler (
    ::CORBA::tk_objref,
    "IDL:omg.org/PortableGroup/AMI_PropertyManagerHandler:1.0",
    "AMI_PropertyManagerHandler");
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_AMI_PropertyManagerHandler =
    &_tao_tc_PortableGroup_AMI_PropertyManagerHandler;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for PortableGroup::ObjectGroupManager.

PortableGroup::ObjectGroupManager_ptr
TAO::Objref_Traits<PortableGroup::ObjectGroupManager>::duplicate (
    PortableGroup::ObjectGroupManager_ptr p)
{
  return PortableGroup::ObjectGroupManager::_duplicate (p);
}

void
TAO::Objref_Traits<PortableGroup::ObjectGroupManager>::release (
    PortableGroup::ObjectGroupManager_ptr p)
{
  ::CORBA::release (p);
}

PortableGroup::ObjectGroupManager_ptr
TAO::Objref_Traits<PortableGroup::ObjectGroupManager>::nil (void)
{
  return PortableGroup::ObjectGroupManager::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<PortableGroup::ObjectGroupManager>::marshal (
    const PortableGroup::ObjectGroupManager_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*PortableGroup__TAO_ObjectGroupManager_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::PortableGroup::ObjectGroup_ptr
PortableGroup::ObjectGroupManager::create_member (
  ::PortableGroup::ObjectGroup_ptr object_group,
  const ::PortableGroup::Location & the_location,
  const char * type_id,
  const ::PortableGroup::Criteria & the_criteria)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);
  TAO::Arg_Traits< char *>::in_arg_val _tao_type_id (type_id);
  TAO::Arg_Traits< ::PortableGroup::Criteria>::in_arg_val _tao_the_criteria (the_criteria);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_object_group,
      &_tao_the_location,
      &_tao_type_id,
      &_tao_the_criteria
    };

  static TAO::Exception_Data
  _tao_PortableGroup_ObjectGroupManager_create_member_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0",
        PortableGroup::MemberAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/NoFactory:1.0",
        PortableGroup::NoFactory::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_NoFactory
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/ObjectNotCreated:1.0",
        PortableGroup::ObjectNotCreated::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectNotCreated
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/InvalidCriteria:1.0",
        PortableGroup::InvalidCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidCriteria
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0",
        PortableGroup::CannotMeetCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_CannotMeetCriteria
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "create_member",
      13,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_ObjectGroupManager_create_member_exceptiondata,
      6
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::PortableGroup::ObjectGroup_ptr
PortableGroup::ObjectGroupManager::add_member (
  ::PortableGroup::ObjectGroup_ptr object_group,
  const ::PortableGroup::Location & the_location,
  ::CORBA::Object_ptr member)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_member (member);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_object_group,
      &_tao_the_location,
      &_tao_member
    };

  static TAO::Exception_Data
  _tao_PortableGroup_ObjectGroupManager_add_member_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0",
        PortableGroup::MemberAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/ObjectNotAdded:1.0",
        PortableGroup::ObjectNotAdded::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectNotAdded
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "add_member",
      10,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_ObjectGroupManager_add_member_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::PortableGroup::ObjectGroup_ptr
PortableGroup::ObjectGroupManager::remove_member (
  ::PortableGroup::ObjectGroup_ptr object_group,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_object_group,
      &_tao_the_location
    };

  static TAO::Exception_Data
  _tao_PortableGroup_ObjectGroupManager_remove_member_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
        PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "remove_member",
      13,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_ObjectGroupManager_remove_member_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::PortableGroup::Locations *
PortableGroup::ObjectGroupManager::locations_of_members (
  ::PortableGroup::ObjectGroup_ptr object_group)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::PortableGroup::Locations>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_object_group
    };

  static TAO::Exception_Data
  _tao_PortableGroup_ObjectGroupManager_locations_of_members_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "locations_of_members",
      20,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_ObjectGroupManager_locations_of_members_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::PortableGroup::ObjectGroups *
PortableGroup::ObjectGroupManager::groups_at_location (
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::PortableGroup::ObjectGroups>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "groups_at_location",
      18,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::PortableGroup::ObjectGroupId
PortableGroup::ObjectGroupManager::get_object_group_id (
  ::PortableGroup::ObjectGroup_ptr object_group)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULongLong>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_object_group
    };

  static TAO::Exception_Data
  _tao_PortableGroup_ObjectGroupManager_get_object_group_id_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_object_group_id",
      19,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_ObjectGroupManager_get_object_group_id_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::PortableGroup::ObjectGroup_ptr
PortableGroup::ObjectGroupManager::get_object_group_ref (
  ::PortableGroup::ObjectGroup_ptr object_group)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_object_group
    };

  static TAO::Exception_Data
  _tao_PortableGroup_ObjectGroupManager_get_object_group_ref_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_object_group_ref",
      20,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_ObjectGroupManager_get_object_group_ref_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Object_ptr
PortableGroup::ObjectGroupManager::get_member_ref (
  ::PortableGroup::ObjectGroup_ptr object_group,
  const ::PortableGroup::Location & loc)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_loc (loc);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_object_group,
      &_tao_loc
    };

  static TAO::Exception_Data
  _tao_PortableGroup_ObjectGroupManager_get_member_ref_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
        PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "get_member_ref",
      14,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_ObjectGroupManager_get_member_ref_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::PortableGroup::ObjectGroup_ptr
PortableGroup::ObjectGroupManager::get_object_group_ref_from_id (
  ::PortableGroup::ObjectGroupId group_id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_group_id (group_id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_group_id
    };

  static TAO::Exception_Data
  _tao_PortableGroup_ObjectGroupManager_get_object_group_ref_from_id_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_object_group_ref_from_id",
      28,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_ObjectGroupManager_get_object_group_ref_from_id_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::ObjectGroupManager::sendc_create_member (
  ::PortableGroup::AMI_ObjectGroupManagerHandler_ptr ami_handler,
  ::PortableGroup::ObjectGroup_ptr object_group,
  const ::PortableGroup::Location & the_location,
  const char * type_id,
  const ::PortableGroup::Criteria & the_criteria)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);
  TAO::Arg_Traits< char *>::in_arg_val _tao_type_id (type_id);
  TAO::Arg_Traits< ::PortableGroup::Criteria>::in_arg_val _tao_the_criteria (the_criteria);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_object_group,
      &_tao_the_location,
      &_tao_type_id,
      &_tao_the_criteria
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "create_member",
      13,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_ObjectGroupManagerHandler::create_member_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::ObjectGroupManager::sendc_add_member (
  ::PortableGroup::AMI_ObjectGroupManagerHandler_ptr ami_handler,
  ::PortableGroup::ObjectGroup_ptr object_group,
  const ::PortableGroup::Location & the_location,
  ::CORBA::Object_ptr member)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_member (member);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_object_group,
      &_tao_the_location,
      &_tao_member
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "add_member",
      10,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_ObjectGroupManagerHandler::add_member_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::ObjectGroupManager::sendc_remove_member (
  ::PortableGroup::AMI_ObjectGroupManagerHandler_ptr ami_handler,
  ::PortableGroup::ObjectGroup_ptr object_group,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_object_group,
      &_tao_the_location
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "remove_member",
      13,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_ObjectGroupManagerHandler::remove_member_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::ObjectGroupManager::sendc_locations_of_members (
  ::PortableGroup::AMI_ObjectGroupManagerHandler_ptr ami_handler,
  ::PortableGroup::ObjectGroup_ptr object_group)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_object_group
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "locations_of_members",
      20,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_ObjectGroupManagerHandler::locations_of_members_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::ObjectGroupManager::sendc_groups_at_location (
  ::PortableGroup::AMI_ObjectGroupManagerHandler_ptr ami_handler,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "groups_at_location",
      18,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_ObjectGroupManagerHandler::groups_at_location_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::ObjectGroupManager::sendc_get_object_group_id (
  ::PortableGroup::AMI_ObjectGroupManagerHandler_ptr ami_handler,
  ::PortableGroup::ObjectGroup_ptr object_group)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_object_group
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_object_group_id",
      19,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_ObjectGroupManagerHandler::get_object_group_id_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::ObjectGroupManager::sendc_get_object_group_ref (
  ::PortableGroup::AMI_ObjectGroupManagerHandler_ptr ami_handler,
  ::PortableGroup::ObjectGroup_ptr object_group)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_object_group
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_object_group_ref",
      20,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_ObjectGroupManagerHandler::get_object_group_ref_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::ObjectGroupManager::sendc_get_member_ref (
  ::PortableGroup::AMI_ObjectGroupManagerHandler_ptr ami_handler,
  ::PortableGroup::ObjectGroup_ptr object_group,
  const ::PortableGroup::Location & loc)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_loc (loc);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_object_group,
      &_tao_loc
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "get_member_ref",
      14,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_ObjectGroupManagerHandler::get_member_ref_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::ObjectGroupManager::sendc_get_object_group_ref_from_id (
  ::PortableGroup::AMI_ObjectGroupManagerHandler_ptr ami_handler,
  ::PortableGroup::ObjectGroupId group_id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ObjectGroupManager_Proxy_Broker_ == 0)
    {
      PortableGroup_ObjectGroupManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_group_id (group_id);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_group_id
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_object_group_ref_from_id",
      28,
      this->the_TAO_ObjectGroupManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_ObjectGroupManagerHandler::get_object_group_ref_from_id_reply_stub
    );
}

PortableGroup::ObjectGroupManager::ObjectGroupManager (void)
 : the_TAO_ObjectGroupManager_Proxy_Broker_ (0)
{
  this->PortableGroup_ObjectGroupManager_setup_collocation ();
}

void
PortableGroup::ObjectGroupManager::PortableGroup_ObjectGroupManager_setup_collocation ()
{
  if (::PortableGroup__TAO_ObjectGroupManager_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_ObjectGroupManager_Proxy_Broker_ =
        ::PortableGroup__TAO_ObjectGroupManager_Proxy_Broker_Factory_function_pointer (this);
    }
}

PortableGroup::ObjectGroupManager::~ObjectGroupManager (void)
{}

void 
PortableGroup::ObjectGroupManager::_tao_any_destructor (void *_tao_void_pointer)
{
  ObjectGroupManager *_tao_tmp_pointer =
    static_cast<ObjectGroupManager *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

PortableGroup::ObjectGroupManager_ptr
PortableGroup::ObjectGroupManager::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ObjectGroupManager>::narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/ObjectGroupManager:1.0",
        PortableGroup__TAO_ObjectGroupManager_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::ObjectGroupManager_ptr
PortableGroup::ObjectGroupManager::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ObjectGroupManager>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/ObjectGroupManager:1.0",
        PortableGroup__TAO_ObjectGroupManager_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::ObjectGroupManager_ptr
PortableGroup::ObjectGroupManager::_nil (void)
{
  return 0;
}

PortableGroup::ObjectGroupManager_ptr
PortableGroup::ObjectGroupManager::_duplicate (ObjectGroupManager_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
PortableGroup::ObjectGroupManager::_tao_release (ObjectGroupManager_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
PortableGroup::ObjectGroupManager::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/ObjectGroupManager:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* PortableGroup::ObjectGroupManager::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableGroup/ObjectGroupManager:1.0";
}

::CORBA::Boolean
PortableGroup::ObjectGroupManager::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_ObjectGroupManager (
    ::CORBA::tk_objref,
    "IDL:omg.org/PortableGroup/ObjectGroupManager:1.0",
    "ObjectGroupManager");
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_ObjectGroupManager =
    &_tao_tc_PortableGroup_ObjectGroupManager;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for PortableGroup::AMI_ObjectGroupManagerHandler.

PortableGroup::AMI_ObjectGroupManagerHandler_ptr
TAO::Objref_Traits<PortableGroup::AMI_ObjectGroupManagerHandler>::duplicate (
    PortableGroup::AMI_ObjectGroupManagerHandler_ptr p)
{
  return PortableGroup::AMI_ObjectGroupManagerHandler::_duplicate (p);
}

void
TAO::Objref_Traits<PortableGroup::AMI_ObjectGroupManagerHandler>::release (
    PortableGroup::AMI_ObjectGroupManagerHandler_ptr p)
{
  ::CORBA::release (p);
}

PortableGroup::AMI_ObjectGroupManagerHandler_ptr
TAO::Objref_Traits<PortableGroup::AMI_ObjectGroupManagerHandler>::nil (void)
{
  return PortableGroup::AMI_ObjectGroupManagerHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<PortableGroup::AMI_ObjectGroupManagerHandler>::marshal (
    const PortableGroup::AMI_ObjectGroupManagerHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*PortableGroup__TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::create_member (
  ::PortableGroup::ObjectGroup_ptr ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_create_member_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0",
        PortableGroup::MemberAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/NoFactory:1.0",
        PortableGroup::NoFactory::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_NoFactory
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/ObjectNotCreated:1.0",
        PortableGroup::ObjectNotCreated::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectNotCreated
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/InvalidCriteria:1.0",
        PortableGroup::InvalidCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidCriteria
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0",
        PortableGroup::CannotMeetCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_CannotMeetCriteria
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "create_member",
      13,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_create_member_exceptiondata,
      6
    );
}

void
PortableGroup::AMI_ObjectGroupManagerHandler::create_member_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_ObjectGroupManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_ObjectGroupManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::PortableGroup::ObjectGroup_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->create_member (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
          PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0",
          PortableGroup::MemberAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_MemberAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/NoFactory:1.0",
          PortableGroup::NoFactory::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_NoFactory
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/ObjectNotCreated:1.0",
          PortableGroup::ObjectNotCreated::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectNotCreated
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/InvalidCriteria:1.0",
          PortableGroup::InvalidCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_InvalidCriteria
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0",
          PortableGroup::CannotMeetCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_CannotMeetCriteria
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 6;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->create_member_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::create_member_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_create_member_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0",
        PortableGroup::MemberAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/NoFactory:1.0",
        PortableGroup::NoFactory::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_NoFactory
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/ObjectNotCreated:1.0",
        PortableGroup::ObjectNotCreated::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectNotCreated
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/InvalidCriteria:1.0",
        PortableGroup::InvalidCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidCriteria
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0",
        PortableGroup::CannotMeetCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_CannotMeetCriteria
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "create_member_excep",
      19,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_create_member_excep_exceptiondata,
      6
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::add_member (
  ::PortableGroup::ObjectGroup_ptr ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_add_member_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0",
        PortableGroup::MemberAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/ObjectNotAdded:1.0",
        PortableGroup::ObjectNotAdded::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectNotAdded
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "add_member",
      10,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_add_member_exceptiondata,
      3
    );
}

void
PortableGroup::AMI_ObjectGroupManagerHandler::add_member_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_ObjectGroupManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_ObjectGroupManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::PortableGroup::ObjectGroup_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->add_member (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
          PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0",
          PortableGroup::MemberAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_MemberAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/ObjectNotAdded:1.0",
          PortableGroup::ObjectNotAdded::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectNotAdded
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 3;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->add_member_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::add_member_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_add_member_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0",
        PortableGroup::MemberAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/ObjectNotAdded:1.0",
        PortableGroup::ObjectNotAdded::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectNotAdded
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "add_member_excep",
      16,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_add_member_excep_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::remove_member (
  ::PortableGroup::ObjectGroup_ptr ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_remove_member_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
        PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_member",
      13,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_remove_member_exceptiondata,
      2
    );
}

void
PortableGroup::AMI_ObjectGroupManagerHandler::remove_member_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_ObjectGroupManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_ObjectGroupManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::PortableGroup::ObjectGroup_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->remove_member (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
          PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
          PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 2;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->remove_member_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::remove_member_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_remove_member_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
        PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_member_excep",
      19,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_remove_member_excep_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::locations_of_members (
  const ::PortableGroup::Locations & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Locations>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_locations_of_members_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "locations_of_members",
      20,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_locations_of_members_exceptiondata,
      1
    );
}

void
PortableGroup::AMI_ObjectGroupManagerHandler::locations_of_members_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_ObjectGroupManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_ObjectGroupManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::PortableGroup::Locations ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->locations_of_members (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
          PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->locations_of_members_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::locations_of_members_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_locations_of_members_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "locations_of_members_excep",
      26,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_locations_of_members_excep_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::groups_at_location (
  const ::PortableGroup::ObjectGroups & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::ObjectGroups>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "groups_at_location",
      18,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
PortableGroup::AMI_ObjectGroupManagerHandler::groups_at_location_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_ObjectGroupManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_ObjectGroupManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::PortableGroup::ObjectGroups ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->groups_at_location (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->groups_at_location_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::groups_at_location_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "groups_at_location_excep",
      24,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::get_object_group_id (
  ::PortableGroup::ObjectGroupId ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_object_group_id_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_object_group_id",
      19,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_object_group_id_exceptiondata,
      1
    );
}

void
PortableGroup::AMI_ObjectGroupManagerHandler::get_object_group_id_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_ObjectGroupManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_ObjectGroupManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::PortableGroup::ObjectGroupId ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_object_group_id (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
          PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_object_group_id_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::get_object_group_id_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_object_group_id_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_object_group_id_excep",
      25,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_object_group_id_excep_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::get_object_group_ref (
  ::PortableGroup::ObjectGroup_ptr ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_object_group_ref_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_object_group_ref",
      20,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_object_group_ref_exceptiondata,
      1
    );
}

void
PortableGroup::AMI_ObjectGroupManagerHandler::get_object_group_ref_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_ObjectGroupManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_ObjectGroupManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::PortableGroup::ObjectGroup_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_object_group_ref (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
          PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_object_group_ref_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::get_object_group_ref_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_object_group_ref_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_object_group_ref_excep",
      26,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_object_group_ref_excep_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::get_member_ref (
  ::CORBA::Object_ptr ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_member_ref_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
        PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_member_ref",
      14,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_member_ref_exceptiondata,
      2
    );
}

void
PortableGroup::AMI_ObjectGroupManagerHandler::get_member_ref_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_ObjectGroupManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_ObjectGroupManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CORBA::Object_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_member_ref (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
          PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
          PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 2;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_member_ref_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::get_member_ref_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_member_ref_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
        PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_member_ref_excep",
      20,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_member_ref_excep_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::get_object_group_ref_from_id (
  ::PortableGroup::ObjectGroup_ptr ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_object_group_ref_from_id_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_object_group_ref_from_id",
      28,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_object_group_ref_from_id_exceptiondata,
      1
    );
}

void
PortableGroup::AMI_ObjectGroupManagerHandler::get_object_group_ref_from_id_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_ObjectGroupManagerHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_ObjectGroupManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::PortableGroup::ObjectGroup_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_object_group_ref_from_id (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
          PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_object_group_ref_from_id_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_ObjectGroupManagerHandler::get_object_group_ref_from_id_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_object_group_ref_from_id_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_object_group_ref_from_id_excep",
      34,
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_ObjectGroupManagerHandler_get_object_group_ref_from_id_excep_exceptiondata,
      1
    );
}

PortableGroup::AMI_ObjectGroupManagerHandler::AMI_ObjectGroupManagerHandler (void)
 : the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ (0)
{
  this->PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
}

void
PortableGroup::AMI_ObjectGroupManagerHandler::PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ()
{
  if (::PortableGroup__TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_ =
        ::PortableGroup__TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->Messaging_ReplyHandler_setup_collocation ();
}

PortableGroup::AMI_ObjectGroupManagerHandler::~AMI_ObjectGroupManagerHandler (void)
{}

void 
PortableGroup::AMI_ObjectGroupManagerHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_ObjectGroupManagerHandler *_tao_tmp_pointer =
    static_cast<AMI_ObjectGroupManagerHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

PortableGroup::AMI_ObjectGroupManagerHandler_ptr
PortableGroup::AMI_ObjectGroupManagerHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_ObjectGroupManagerHandler>::narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/AMI_ObjectGroupManagerHandler:1.0",
        PortableGroup__TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::AMI_ObjectGroupManagerHandler_ptr
PortableGroup::AMI_ObjectGroupManagerHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_ObjectGroupManagerHandler>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/AMI_ObjectGroupManagerHandler:1.0",
        PortableGroup__TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::AMI_ObjectGroupManagerHandler_ptr
PortableGroup::AMI_ObjectGroupManagerHandler::_nil (void)
{
  return 0;
}

PortableGroup::AMI_ObjectGroupManagerHandler_ptr
PortableGroup::AMI_ObjectGroupManagerHandler::_duplicate (AMI_ObjectGroupManagerHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
PortableGroup::AMI_ObjectGroupManagerHandler::_tao_release (AMI_ObjectGroupManagerHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
PortableGroup::AMI_ObjectGroupManagerHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/AMI_ObjectGroupManagerHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* PortableGroup::AMI_ObjectGroupManagerHandler::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableGroup/AMI_ObjectGroupManagerHandler:1.0";
}

::CORBA::Boolean
PortableGroup::AMI_ObjectGroupManagerHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_AMI_ObjectGroupManagerHandler (
    ::CORBA::tk_objref,
    "IDL:omg.org/PortableGroup/AMI_ObjectGroupManagerHandler:1.0",
    "AMI_ObjectGroupManagerHandler");
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_AMI_ObjectGroupManagerHandler =
    &_tao_tc_PortableGroup_AMI_ObjectGroupManagerHandler;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for PortableGroup::GenericFactory.

PortableGroup::GenericFactory_ptr
TAO::Objref_Traits<PortableGroup::GenericFactory>::duplicate (
    PortableGroup::GenericFactory_ptr p)
{
  return PortableGroup::GenericFactory::_duplicate (p);
}

void
TAO::Objref_Traits<PortableGroup::GenericFactory>::release (
    PortableGroup::GenericFactory_ptr p)
{
  ::CORBA::release (p);
}

PortableGroup::GenericFactory_ptr
TAO::Objref_Traits<PortableGroup::GenericFactory>::nil (void)
{
  return PortableGroup::GenericFactory::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<PortableGroup::GenericFactory>::marshal (
    const PortableGroup::GenericFactory_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*PortableGroup__TAO_GenericFactory_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_GenericFactory_FactoryCreationId (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/GenericFactory/FactoryCreationId:1.0",
    "FactoryCreationId",
    &CORBA::_tc_any);
  
::CORBA::TypeCode_ptr const PortableGroup::GenericFactory::_tc_FactoryCreationId =
  &_tao_tc_PortableGroup_GenericFactory_FactoryCreationId;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Object_ptr
PortableGroup::GenericFactory::create_object (
  const char * type_id,
  const ::PortableGroup::Criteria & the_criteria,
  ::PortableGroup::GenericFactory::FactoryCreationId_out factory_creation_id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_GenericFactory_Proxy_Broker_ == 0)
    {
      PortableGroup_GenericFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_type_id (type_id);
  TAO::Arg_Traits< ::PortableGroup::Criteria>::in_arg_val _tao_the_criteria (the_criteria);
  TAO::Arg_Traits< ::CORBA::Any>::out_arg_val _tao_factory_creation_id (factory_creation_id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_type_id,
      &_tao_the_criteria,
      &_tao_factory_creation_id
    };

  static TAO::Exception_Data
  _tao_PortableGroup_GenericFactory_create_object_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/NoFactory:1.0",
        PortableGroup::NoFactory::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_NoFactory
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/ObjectNotCreated:1.0",
        PortableGroup::ObjectNotCreated::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectNotCreated
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/InvalidCriteria:1.0",
        PortableGroup::InvalidCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidCriteria
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0",
        PortableGroup::CannotMeetCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_CannotMeetCriteria
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "create_object",
      13,
      this->the_TAO_GenericFactory_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_GenericFactory_create_object_exceptiondata,
      5
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::GenericFactory::delete_object (
  const ::PortableGroup::GenericFactory::FactoryCreationId & factory_creation_id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_GenericFactory_Proxy_Broker_ == 0)
    {
      PortableGroup_GenericFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Any>::in_arg_val _tao_factory_creation_id (factory_creation_id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_factory_creation_id
    };

  static TAO::Exception_Data
  _tao_PortableGroup_GenericFactory_delete_object_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectNotFound:1.0",
        PortableGroup::ObjectNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "delete_object",
      13,
      this->the_TAO_GenericFactory_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_GenericFactory_delete_object_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::GenericFactory::sendc_create_object (
  ::PortableGroup::AMI_GenericFactoryHandler_ptr ami_handler,
  const char * type_id,
  const ::PortableGroup::Criteria & the_criteria)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_GenericFactory_Proxy_Broker_ == 0)
    {
      PortableGroup_GenericFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_type_id (type_id);
  TAO::Arg_Traits< ::PortableGroup::Criteria>::in_arg_val _tao_the_criteria (the_criteria);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_type_id,
      &_tao_the_criteria
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "create_object",
      13,
      this->the_TAO_GenericFactory_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_GenericFactoryHandler::create_object_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::GenericFactory::sendc_delete_object (
  ::PortableGroup::AMI_GenericFactoryHandler_ptr ami_handler,
  const ::PortableGroup::GenericFactory::FactoryCreationId & factory_creation_id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_GenericFactory_Proxy_Broker_ == 0)
    {
      PortableGroup_GenericFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Any>::in_arg_val _tao_factory_creation_id (factory_creation_id);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_factory_creation_id
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "delete_object",
      13,
      this->the_TAO_GenericFactory_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_GenericFactoryHandler::delete_object_reply_stub
    );
}

PortableGroup::GenericFactory::GenericFactory (void)
 : the_TAO_GenericFactory_Proxy_Broker_ (0)
{
  this->PortableGroup_GenericFactory_setup_collocation ();
}

void
PortableGroup::GenericFactory::PortableGroup_GenericFactory_setup_collocation ()
{
  if (::PortableGroup__TAO_GenericFactory_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_GenericFactory_Proxy_Broker_ =
        ::PortableGroup__TAO_GenericFactory_Proxy_Broker_Factory_function_pointer (this);
    }
}

PortableGroup::GenericFactory::~GenericFactory (void)
{}

void 
PortableGroup::GenericFactory::_tao_any_destructor (void *_tao_void_pointer)
{
  GenericFactory *_tao_tmp_pointer =
    static_cast<GenericFactory *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

PortableGroup::GenericFactory_ptr
PortableGroup::GenericFactory::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<GenericFactory>::narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/GenericFactory:1.0",
        PortableGroup__TAO_GenericFactory_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::GenericFactory_ptr
PortableGroup::GenericFactory::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<GenericFactory>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/GenericFactory:1.0",
        PortableGroup__TAO_GenericFactory_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::GenericFactory_ptr
PortableGroup::GenericFactory::_nil (void)
{
  return 0;
}

PortableGroup::GenericFactory_ptr
PortableGroup::GenericFactory::_duplicate (GenericFactory_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
PortableGroup::GenericFactory::_tao_release (GenericFactory_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
PortableGroup::GenericFactory::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/GenericFactory:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* PortableGroup::GenericFactory::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableGroup/GenericFactory:1.0";
}

::CORBA::Boolean
PortableGroup::GenericFactory::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_GenericFactory (
    ::CORBA::tk_objref,
    "IDL:omg.org/PortableGroup/GenericFactory:1.0",
    "GenericFactory");
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_GenericFactory =
    &_tao_tc_PortableGroup_GenericFactory;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for PortableGroup::AMI_GenericFactoryHandler.

PortableGroup::AMI_GenericFactoryHandler_ptr
TAO::Objref_Traits<PortableGroup::AMI_GenericFactoryHandler>::duplicate (
    PortableGroup::AMI_GenericFactoryHandler_ptr p)
{
  return PortableGroup::AMI_GenericFactoryHandler::_duplicate (p);
}

void
TAO::Objref_Traits<PortableGroup::AMI_GenericFactoryHandler>::release (
    PortableGroup::AMI_GenericFactoryHandler_ptr p)
{
  ::CORBA::release (p);
}

PortableGroup::AMI_GenericFactoryHandler_ptr
TAO::Objref_Traits<PortableGroup::AMI_GenericFactoryHandler>::nil (void)
{
  return PortableGroup::AMI_GenericFactoryHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<PortableGroup::AMI_GenericFactoryHandler>::marshal (
    const PortableGroup::AMI_GenericFactoryHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*PortableGroup__TAO_AMI_GenericFactoryHandler_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_GenericFactoryHandler::create_object (
  ::CORBA::Object_ptr ami_return_val,
  const ::PortableGroup::GenericFactory::FactoryCreationId & factory_creation_id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_GenericFactoryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_GenericFactoryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_ami_return_val (ami_return_val);
  TAO::Arg_Traits< ::CORBA::Any>::in_arg_val _tao_factory_creation_id (factory_creation_id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val,
      &_tao_factory_creation_id
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_GenericFactoryHandler_create_object_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/NoFactory:1.0",
        PortableGroup::NoFactory::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_NoFactory
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/ObjectNotCreated:1.0",
        PortableGroup::ObjectNotCreated::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectNotCreated
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/InvalidCriteria:1.0",
        PortableGroup::InvalidCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidCriteria
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0",
        PortableGroup::CannotMeetCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_CannotMeetCriteria
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "create_object",
      13,
      this->the_TAO_AMI_GenericFactoryHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_GenericFactoryHandler_create_object_exceptiondata,
      5
    );
}

void
PortableGroup::AMI_GenericFactoryHandler::create_object_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_GenericFactoryHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_GenericFactoryHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CORBA::Object_var ami_return_val;
      ::PortableGroup::GenericFactory::FactoryCreationId factory_creation_id;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ()) &&
            (_tao_in >> factory_creation_id)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->create_object (
          
          ami_return_val.in (),
          
          factory_creation_id
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/NoFactory:1.0",
          PortableGroup::NoFactory::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_NoFactory
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/ObjectNotCreated:1.0",
          PortableGroup::ObjectNotCreated::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectNotCreated
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/InvalidCriteria:1.0",
          PortableGroup::InvalidCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_InvalidCriteria
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
          PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0",
          PortableGroup::CannotMeetCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_CannotMeetCriteria
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 5;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->create_object_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_GenericFactoryHandler::create_object_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_GenericFactoryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_GenericFactoryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_GenericFactoryHandler_create_object_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/NoFactory:1.0",
        PortableGroup::NoFactory::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_NoFactory
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/ObjectNotCreated:1.0",
        PortableGroup::ObjectNotCreated::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectNotCreated
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/InvalidCriteria:1.0",
        PortableGroup::InvalidCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidCriteria
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/InvalidProperty:1.0",
        PortableGroup::InvalidProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_InvalidProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/CannotMeetCriteria:1.0",
        PortableGroup::CannotMeetCriteria::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_CannotMeetCriteria
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "create_object_excep",
      19,
      this->the_TAO_AMI_GenericFactoryHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_GenericFactoryHandler_create_object_excep_exceptiondata,
      5
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_GenericFactoryHandler::delete_object (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_GenericFactoryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_GenericFactoryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_GenericFactoryHandler_delete_object_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectNotFound:1.0",
        PortableGroup::ObjectNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "delete_object",
      13,
      this->the_TAO_AMI_GenericFactoryHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_GenericFactoryHandler_delete_object_exceptiondata,
      1
    );
}

void
PortableGroup::AMI_GenericFactoryHandler::delete_object_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_GenericFactoryHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_GenericFactoryHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->delete_object (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/ObjectNotFound:1.0",
          PortableGroup::ObjectNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->delete_object_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_GenericFactoryHandler::delete_object_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_GenericFactoryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_GenericFactoryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_GenericFactoryHandler_delete_object_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectNotFound:1.0",
        PortableGroup::ObjectNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "delete_object_excep",
      19,
      this->the_TAO_AMI_GenericFactoryHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_GenericFactoryHandler_delete_object_excep_exceptiondata,
      1
    );
}

PortableGroup::AMI_GenericFactoryHandler::AMI_GenericFactoryHandler (void)
 : the_TAO_AMI_GenericFactoryHandler_Proxy_Broker_ (0)
{
  this->PortableGroup_AMI_GenericFactoryHandler_setup_collocation ();
}

void
PortableGroup::AMI_GenericFactoryHandler::PortableGroup_AMI_GenericFactoryHandler_setup_collocation ()
{
  if (::PortableGroup__TAO_AMI_GenericFactoryHandler_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_AMI_GenericFactoryHandler_Proxy_Broker_ =
        ::PortableGroup__TAO_AMI_GenericFactoryHandler_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->Messaging_ReplyHandler_setup_collocation ();
}

PortableGroup::AMI_GenericFactoryHandler::~AMI_GenericFactoryHandler (void)
{}

void 
PortableGroup::AMI_GenericFactoryHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_GenericFactoryHandler *_tao_tmp_pointer =
    static_cast<AMI_GenericFactoryHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

PortableGroup::AMI_GenericFactoryHandler_ptr
PortableGroup::AMI_GenericFactoryHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_GenericFactoryHandler>::narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/AMI_GenericFactoryHandler:1.0",
        PortableGroup__TAO_AMI_GenericFactoryHandler_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::AMI_GenericFactoryHandler_ptr
PortableGroup::AMI_GenericFactoryHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_GenericFactoryHandler>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/AMI_GenericFactoryHandler:1.0",
        PortableGroup__TAO_AMI_GenericFactoryHandler_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::AMI_GenericFactoryHandler_ptr
PortableGroup::AMI_GenericFactoryHandler::_nil (void)
{
  return 0;
}

PortableGroup::AMI_GenericFactoryHandler_ptr
PortableGroup::AMI_GenericFactoryHandler::_duplicate (AMI_GenericFactoryHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
PortableGroup::AMI_GenericFactoryHandler::_tao_release (AMI_GenericFactoryHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
PortableGroup::AMI_GenericFactoryHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/AMI_GenericFactoryHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* PortableGroup::AMI_GenericFactoryHandler::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableGroup/AMI_GenericFactoryHandler:1.0";
}

::CORBA::Boolean
PortableGroup::AMI_GenericFactoryHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_AMI_GenericFactoryHandler (
    ::CORBA::tk_objref,
    "IDL:omg.org/PortableGroup/AMI_GenericFactoryHandler:1.0",
    "AMI_GenericFactoryHandler");
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_AMI_GenericFactoryHandler =
    &_tao_tc_PortableGroup_AMI_GenericFactoryHandler;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_RoleName (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/RoleName:1.0",
    "RoleName",
    &CORBA::_tc_Identifier);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_RoleName =
    &_tao_tc_PortableGroup_RoleName;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for PortableGroup::FactoryRegistry.

PortableGroup::FactoryRegistry_ptr
TAO::Objref_Traits<PortableGroup::FactoryRegistry>::duplicate (
    PortableGroup::FactoryRegistry_ptr p)
{
  return PortableGroup::FactoryRegistry::_duplicate (p);
}

void
TAO::Objref_Traits<PortableGroup::FactoryRegistry>::release (
    PortableGroup::FactoryRegistry_ptr p)
{
  ::CORBA::release (p);
}

PortableGroup::FactoryRegistry_ptr
TAO::Objref_Traits<PortableGroup::FactoryRegistry>::nil (void)
{
  return PortableGroup::FactoryRegistry::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<PortableGroup::FactoryRegistry>::marshal (
    const PortableGroup::FactoryRegistry_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*PortableGroup__TAO_FactoryRegistry_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::FactoryRegistry::register_factory (
  const char * role,
  const char * type_id,
  const ::PortableGroup::FactoryInfo & factory_info)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FactoryRegistry_Proxy_Broker_ == 0)
    {
      PortableGroup_FactoryRegistry_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_role (role);
  TAO::Arg_Traits< char *>::in_arg_val _tao_type_id (type_id);
  TAO::Arg_Traits< ::PortableGroup::FactoryInfo>::in_arg_val _tao_factory_info (factory_info);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_role,
      &_tao_type_id,
      &_tao_factory_info
    };

  static TAO::Exception_Data
  _tao_PortableGroup_FactoryRegistry_register_factory_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0",
        PortableGroup::MemberAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/TypeConflict:1.0",
        PortableGroup::TypeConflict::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_TypeConflict
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "register_factory",
      16,
      this->the_TAO_FactoryRegistry_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_FactoryRegistry_register_factory_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::FactoryRegistry::unregister_factory (
  const char * role,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FactoryRegistry_Proxy_Broker_ == 0)
    {
      PortableGroup_FactoryRegistry_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_role (role);
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_role,
      &_tao_the_location
    };

  static TAO::Exception_Data
  _tao_PortableGroup_FactoryRegistry_unregister_factory_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
        PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "unregister_factory",
      18,
      this->the_TAO_FactoryRegistry_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_FactoryRegistry_unregister_factory_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::FactoryRegistry::unregister_factory_by_role (
  const char * role)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FactoryRegistry_Proxy_Broker_ == 0)
    {
      PortableGroup_FactoryRegistry_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_role (role);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_role
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "unregister_factory_by_role",
      26,
      this->the_TAO_FactoryRegistry_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::FactoryRegistry::unregister_factory_by_location (
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FactoryRegistry_Proxy_Broker_ == 0)
    {
      PortableGroup_FactoryRegistry_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "unregister_factory_by_location",
      30,
      this->the_TAO_FactoryRegistry_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::PortableGroup::FactoryInfos *
PortableGroup::FactoryRegistry::list_factories_by_role (
  const char * role,
  ::CORBA::String_out type_id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FactoryRegistry_Proxy_Broker_ == 0)
    {
      PortableGroup_FactoryRegistry_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::PortableGroup::FactoryInfos>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_role (role);
  TAO::Arg_Traits< char *>::out_arg_val _tao_type_id (type_id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_role,
      &_tao_type_id
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "list_factories_by_role",
      22,
      this->the_TAO_FactoryRegistry_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::PortableGroup::FactoryInfos *
PortableGroup::FactoryRegistry::list_factories_by_location (
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FactoryRegistry_Proxy_Broker_ == 0)
    {
      PortableGroup_FactoryRegistry_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::PortableGroup::FactoryInfos>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "list_factories_by_location",
      26,
      this->the_TAO_FactoryRegistry_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::FactoryRegistry::sendc_register_factory (
  ::PortableGroup::AMI_FactoryRegistryHandler_ptr ami_handler,
  const char * role,
  const char * type_id,
  const ::PortableGroup::FactoryInfo & factory_info)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FactoryRegistry_Proxy_Broker_ == 0)
    {
      PortableGroup_FactoryRegistry_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_role (role);
  TAO::Arg_Traits< char *>::in_arg_val _tao_type_id (type_id);
  TAO::Arg_Traits< ::PortableGroup::FactoryInfo>::in_arg_val _tao_factory_info (factory_info);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_role,
      &_tao_type_id,
      &_tao_factory_info
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "register_factory",
      16,
      this->the_TAO_FactoryRegistry_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_FactoryRegistryHandler::register_factory_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::FactoryRegistry::sendc_unregister_factory (
  ::PortableGroup::AMI_FactoryRegistryHandler_ptr ami_handler,
  const char * role,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FactoryRegistry_Proxy_Broker_ == 0)
    {
      PortableGroup_FactoryRegistry_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_role (role);
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_role,
      &_tao_the_location
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "unregister_factory",
      18,
      this->the_TAO_FactoryRegistry_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_FactoryRegistryHandler::unregister_factory_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::FactoryRegistry::sendc_unregister_factory_by_role (
  ::PortableGroup::AMI_FactoryRegistryHandler_ptr ami_handler,
  const char * role)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FactoryRegistry_Proxy_Broker_ == 0)
    {
      PortableGroup_FactoryRegistry_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_role (role);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_role
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "unregister_factory_by_role",
      26,
      this->the_TAO_FactoryRegistry_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_FactoryRegistryHandler::unregister_factory_by_role_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::FactoryRegistry::sendc_unregister_factory_by_location (
  ::PortableGroup::AMI_FactoryRegistryHandler_ptr ami_handler,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FactoryRegistry_Proxy_Broker_ == 0)
    {
      PortableGroup_FactoryRegistry_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "unregister_factory_by_location",
      30,
      this->the_TAO_FactoryRegistry_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_FactoryRegistryHandler::unregister_factory_by_location_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::FactoryRegistry::sendc_list_factories_by_role (
  ::PortableGroup::AMI_FactoryRegistryHandler_ptr ami_handler,
  const char * role)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FactoryRegistry_Proxy_Broker_ == 0)
    {
      PortableGroup_FactoryRegistry_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_role (role);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_role
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "list_factories_by_role",
      22,
      this->the_TAO_FactoryRegistry_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_FactoryRegistryHandler::list_factories_by_role_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::FactoryRegistry::sendc_list_factories_by_location (
  ::PortableGroup::AMI_FactoryRegistryHandler_ptr ami_handler,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FactoryRegistry_Proxy_Broker_ == 0)
    {
      PortableGroup_FactoryRegistry_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "list_factories_by_location",
      26,
      this->the_TAO_FactoryRegistry_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_FactoryRegistryHandler::list_factories_by_location_reply_stub
    );
}

PortableGroup::FactoryRegistry::FactoryRegistry (void)
 : the_TAO_FactoryRegistry_Proxy_Broker_ (0)
{
  this->PortableGroup_FactoryRegistry_setup_collocation ();
}

void
PortableGroup::FactoryRegistry::PortableGroup_FactoryRegistry_setup_collocation ()
{
  if (::PortableGroup__TAO_FactoryRegistry_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_FactoryRegistry_Proxy_Broker_ =
        ::PortableGroup__TAO_FactoryRegistry_Proxy_Broker_Factory_function_pointer (this);
    }
}

PortableGroup::FactoryRegistry::~FactoryRegistry (void)
{}

void 
PortableGroup::FactoryRegistry::_tao_any_destructor (void *_tao_void_pointer)
{
  FactoryRegistry *_tao_tmp_pointer =
    static_cast<FactoryRegistry *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

PortableGroup::FactoryRegistry_ptr
PortableGroup::FactoryRegistry::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FactoryRegistry>::narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/FactoryRegistry:1.0",
        PortableGroup__TAO_FactoryRegistry_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::FactoryRegistry_ptr
PortableGroup::FactoryRegistry::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FactoryRegistry>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/FactoryRegistry:1.0",
        PortableGroup__TAO_FactoryRegistry_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::FactoryRegistry_ptr
PortableGroup::FactoryRegistry::_nil (void)
{
  return 0;
}

PortableGroup::FactoryRegistry_ptr
PortableGroup::FactoryRegistry::_duplicate (FactoryRegistry_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
PortableGroup::FactoryRegistry::_tao_release (FactoryRegistry_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
PortableGroup::FactoryRegistry::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/FactoryRegistry:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* PortableGroup::FactoryRegistry::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableGroup/FactoryRegistry:1.0";
}

::CORBA::Boolean
PortableGroup::FactoryRegistry::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_FactoryRegistry (
    ::CORBA::tk_objref,
    "IDL:omg.org/PortableGroup/FactoryRegistry:1.0",
    "FactoryRegistry");
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_FactoryRegistry =
    &_tao_tc_PortableGroup_FactoryRegistry;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for PortableGroup::AMI_FactoryRegistryHandler.

PortableGroup::AMI_FactoryRegistryHandler_ptr
TAO::Objref_Traits<PortableGroup::AMI_FactoryRegistryHandler>::duplicate (
    PortableGroup::AMI_FactoryRegistryHandler_ptr p)
{
  return PortableGroup::AMI_FactoryRegistryHandler::_duplicate (p);
}

void
TAO::Objref_Traits<PortableGroup::AMI_FactoryRegistryHandler>::release (
    PortableGroup::AMI_FactoryRegistryHandler_ptr p)
{
  ::CORBA::release (p);
}

PortableGroup::AMI_FactoryRegistryHandler_ptr
TAO::Objref_Traits<PortableGroup::AMI_FactoryRegistryHandler>::nil (void)
{
  return PortableGroup::AMI_FactoryRegistryHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<PortableGroup::AMI_FactoryRegistryHandler>::marshal (
    const PortableGroup::AMI_FactoryRegistryHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*PortableGroup__TAO_AMI_FactoryRegistryHandler_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_FactoryRegistryHandler::register_factory (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_FactoryRegistryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_FactoryRegistryHandler_register_factory_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0",
        PortableGroup::MemberAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/TypeConflict:1.0",
        PortableGroup::TypeConflict::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_TypeConflict
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "register_factory",
      16,
      this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_FactoryRegistryHandler_register_factory_exceptiondata,
      2
    );
}

void
PortableGroup::AMI_FactoryRegistryHandler::register_factory_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_FactoryRegistryHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_FactoryRegistryHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->register_factory (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0",
          PortableGroup::MemberAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_MemberAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/TypeConflict:1.0",
          PortableGroup::TypeConflict::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_TypeConflict
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 2;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->register_factory_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_FactoryRegistryHandler::register_factory_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_FactoryRegistryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_FactoryRegistryHandler_register_factory_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/MemberAlreadyPresent:1.0",
        PortableGroup::MemberAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/TypeConflict:1.0",
        PortableGroup::TypeConflict::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_TypeConflict
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "register_factory_excep",
      22,
      this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_FactoryRegistryHandler_register_factory_excep_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_FactoryRegistryHandler::unregister_factory (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_FactoryRegistryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_FactoryRegistryHandler_unregister_factory_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
        PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "unregister_factory",
      18,
      this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_FactoryRegistryHandler_unregister_factory_exceptiondata,
      1
    );
}

void
PortableGroup::AMI_FactoryRegistryHandler::unregister_factory_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_FactoryRegistryHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_FactoryRegistryHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->unregister_factory (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
          PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->unregister_factory_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_FactoryRegistryHandler::unregister_factory_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_FactoryRegistryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_PortableGroup_AMI_FactoryRegistryHandler_unregister_factory_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
        PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "unregister_factory_excep",
      24,
      this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_PortableGroup_AMI_FactoryRegistryHandler_unregister_factory_excep_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_FactoryRegistryHandler::unregister_factory_by_role (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_FactoryRegistryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "unregister_factory_by_role",
      26,
      this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
PortableGroup::AMI_FactoryRegistryHandler::unregister_factory_by_role_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_FactoryRegistryHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_FactoryRegistryHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->unregister_factory_by_role (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->unregister_factory_by_role_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_FactoryRegistryHandler::unregister_factory_by_role_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_FactoryRegistryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "unregister_factory_by_role_excep",
      32,
      this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_FactoryRegistryHandler::unregister_factory_by_location (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_FactoryRegistryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "unregister_factory_by_location",
      30,
      this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
PortableGroup::AMI_FactoryRegistryHandler::unregister_factory_by_location_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_FactoryRegistryHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_FactoryRegistryHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->unregister_factory_by_location (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->unregister_factory_by_location_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_FactoryRegistryHandler::unregister_factory_by_location_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_FactoryRegistryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "unregister_factory_by_location_excep",
      36,
      this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_FactoryRegistryHandler::list_factories_by_role (
  const ::PortableGroup::FactoryInfos & ami_return_val,
  const char * type_id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_FactoryRegistryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::FactoryInfos>::in_arg_val _tao_ami_return_val (ami_return_val);
  TAO::Arg_Traits< char *>::in_arg_val _tao_type_id (type_id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val,
      &_tao_type_id
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "list_factories_by_role",
      22,
      this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
PortableGroup::AMI_FactoryRegistryHandler::list_factories_by_role_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_FactoryRegistryHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_FactoryRegistryHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::PortableGroup::FactoryInfos ami_return_val;
      ::CORBA::String_var type_id;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val) &&
            (_tao_in >> type_id.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->list_factories_by_role (
          
          ami_return_val,
          
          type_id.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->list_factories_by_role_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_FactoryRegistryHandler::list_factories_by_role_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_FactoryRegistryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "list_factories_by_role_excep",
      28,
      this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_FactoryRegistryHandler::list_factories_by_location (
  const ::PortableGroup::FactoryInfos & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_FactoryRegistryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::FactoryInfos>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "list_factories_by_location",
      26,
      this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
PortableGroup::AMI_FactoryRegistryHandler::list_factories_by_location_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_FactoryRegistryHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_FactoryRegistryHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::PortableGroup::FactoryInfos ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->list_factories_by_location (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->list_factories_by_location_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_FactoryRegistryHandler::list_factories_by_location_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_FactoryRegistryHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "list_factories_by_location_excep",
      32,
      this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

PortableGroup::AMI_FactoryRegistryHandler::AMI_FactoryRegistryHandler (void)
 : the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_ (0)
{
  this->PortableGroup_AMI_FactoryRegistryHandler_setup_collocation ();
}

void
PortableGroup::AMI_FactoryRegistryHandler::PortableGroup_AMI_FactoryRegistryHandler_setup_collocation ()
{
  if (::PortableGroup__TAO_AMI_FactoryRegistryHandler_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_AMI_FactoryRegistryHandler_Proxy_Broker_ =
        ::PortableGroup__TAO_AMI_FactoryRegistryHandler_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->Messaging_ReplyHandler_setup_collocation ();
}

PortableGroup::AMI_FactoryRegistryHandler::~AMI_FactoryRegistryHandler (void)
{}

void 
PortableGroup::AMI_FactoryRegistryHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_FactoryRegistryHandler *_tao_tmp_pointer =
    static_cast<AMI_FactoryRegistryHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

PortableGroup::AMI_FactoryRegistryHandler_ptr
PortableGroup::AMI_FactoryRegistryHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_FactoryRegistryHandler>::narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/AMI_FactoryRegistryHandler:1.0",
        PortableGroup__TAO_AMI_FactoryRegistryHandler_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::AMI_FactoryRegistryHandler_ptr
PortableGroup::AMI_FactoryRegistryHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_FactoryRegistryHandler>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/AMI_FactoryRegistryHandler:1.0",
        PortableGroup__TAO_AMI_FactoryRegistryHandler_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::AMI_FactoryRegistryHandler_ptr
PortableGroup::AMI_FactoryRegistryHandler::_nil (void)
{
  return 0;
}

PortableGroup::AMI_FactoryRegistryHandler_ptr
PortableGroup::AMI_FactoryRegistryHandler::_duplicate (AMI_FactoryRegistryHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
PortableGroup::AMI_FactoryRegistryHandler::_tao_release (AMI_FactoryRegistryHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
PortableGroup::AMI_FactoryRegistryHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/AMI_FactoryRegistryHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* PortableGroup::AMI_FactoryRegistryHandler::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableGroup/AMI_FactoryRegistryHandler:1.0";
}

::CORBA::Boolean
PortableGroup::AMI_FactoryRegistryHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_AMI_FactoryRegistryHandler (
    ::CORBA::tk_objref,
    "IDL:omg.org/PortableGroup/AMI_FactoryRegistryHandler:1.0",
    "AMI_FactoryRegistryHandler");
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_AMI_FactoryRegistryHandler =
    &_tao_tc_PortableGroup_AMI_FactoryRegistryHandler;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for PortableGroup::TAO_UpdateObjectGroup.

PortableGroup::TAO_UpdateObjectGroup_ptr
TAO::Objref_Traits<PortableGroup::TAO_UpdateObjectGroup>::duplicate (
    PortableGroup::TAO_UpdateObjectGroup_ptr p)
{
  return PortableGroup::TAO_UpdateObjectGroup::_duplicate (p);
}

void
TAO::Objref_Traits<PortableGroup::TAO_UpdateObjectGroup>::release (
    PortableGroup::TAO_UpdateObjectGroup_ptr p)
{
  ::CORBA::release (p);
}

PortableGroup::TAO_UpdateObjectGroup_ptr
TAO::Objref_Traits<PortableGroup::TAO_UpdateObjectGroup>::nil (void)
{
  return PortableGroup::TAO_UpdateObjectGroup::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<PortableGroup::TAO_UpdateObjectGroup>::marshal (
    const PortableGroup::TAO_UpdateObjectGroup_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*PortableGroup__TAO_TAO_UpdateObjectGroup_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::TAO_UpdateObjectGroup::tao_update_object_group (
  const char * iogr,
  ::PortableGroup::ObjectGroupRefVersion version,
  ::CORBA::Boolean is_primary)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_TAO_UpdateObjectGroup_Proxy_Broker_ == 0)
    {
      PortableGroup_TAO_UpdateObjectGroup_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_iogr (iogr);
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_version (version);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_primary (is_primary);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_iogr,
      &_tao_version,
      &_tao_is_primary
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "tao_update_object_group",
      23,
      this->the_TAO_TAO_UpdateObjectGroup_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
PortableGroup::TAO_UpdateObjectGroup::sendc_tao_update_object_group (
  ::PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr ami_handler,
  const char * iogr,
  ::PortableGroup::ObjectGroupRefVersion version,
  ::CORBA::Boolean is_primary)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_TAO_UpdateObjectGroup_Proxy_Broker_ == 0)
    {
      PortableGroup_TAO_UpdateObjectGroup_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_iogr (iogr);
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_version (version);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_primary (is_primary);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_iogr,
      &_tao_version,
      &_tao_is_primary
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "tao_update_object_group",
      23,
      this->the_TAO_TAO_UpdateObjectGroup_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &PortableGroup::AMI_TAO_UpdateObjectGroupHandler::tao_update_object_group_reply_stub
    );
}

PortableGroup::TAO_UpdateObjectGroup::TAO_UpdateObjectGroup (void)
 : the_TAO_TAO_UpdateObjectGroup_Proxy_Broker_ (0)
{
  this->PortableGroup_TAO_UpdateObjectGroup_setup_collocation ();
}

void
PortableGroup::TAO_UpdateObjectGroup::PortableGroup_TAO_UpdateObjectGroup_setup_collocation ()
{
  if (::PortableGroup__TAO_TAO_UpdateObjectGroup_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_TAO_UpdateObjectGroup_Proxy_Broker_ =
        ::PortableGroup__TAO_TAO_UpdateObjectGroup_Proxy_Broker_Factory_function_pointer (this);
    }
}

PortableGroup::TAO_UpdateObjectGroup::~TAO_UpdateObjectGroup (void)
{}

void 
PortableGroup::TAO_UpdateObjectGroup::_tao_any_destructor (void *_tao_void_pointer)
{
  TAO_UpdateObjectGroup *_tao_tmp_pointer =
    static_cast<TAO_UpdateObjectGroup *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

PortableGroup::TAO_UpdateObjectGroup_ptr
PortableGroup::TAO_UpdateObjectGroup::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<TAO_UpdateObjectGroup>::narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/TAO_UpdateObjectGroup:1.0",
        PortableGroup__TAO_TAO_UpdateObjectGroup_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::TAO_UpdateObjectGroup_ptr
PortableGroup::TAO_UpdateObjectGroup::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<TAO_UpdateObjectGroup>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/TAO_UpdateObjectGroup:1.0",
        PortableGroup__TAO_TAO_UpdateObjectGroup_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::TAO_UpdateObjectGroup_ptr
PortableGroup::TAO_UpdateObjectGroup::_nil (void)
{
  return 0;
}

PortableGroup::TAO_UpdateObjectGroup_ptr
PortableGroup::TAO_UpdateObjectGroup::_duplicate (TAO_UpdateObjectGroup_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
PortableGroup::TAO_UpdateObjectGroup::_tao_release (TAO_UpdateObjectGroup_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
PortableGroup::TAO_UpdateObjectGroup::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/TAO_UpdateObjectGroup:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* PortableGroup::TAO_UpdateObjectGroup::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableGroup/TAO_UpdateObjectGroup:1.0";
}

::CORBA::Boolean
PortableGroup::TAO_UpdateObjectGroup::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_TAO_UpdateObjectGroup (
    ::CORBA::tk_objref,
    "IDL:omg.org/PortableGroup/TAO_UpdateObjectGroup:1.0",
    "TAO_UpdateObjectGroup");
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_TAO_UpdateObjectGroup =
    &_tao_tc_PortableGroup_TAO_UpdateObjectGroup;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for PortableGroup::AMI_TAO_UpdateObjectGroupHandler.

PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr
TAO::Objref_Traits<PortableGroup::AMI_TAO_UpdateObjectGroupHandler>::duplicate (
    PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr p)
{
  return PortableGroup::AMI_TAO_UpdateObjectGroupHandler::_duplicate (p);
}

void
TAO::Objref_Traits<PortableGroup::AMI_TAO_UpdateObjectGroupHandler>::release (
    PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr p)
{
  ::CORBA::release (p);
}

PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr
TAO::Objref_Traits<PortableGroup::AMI_TAO_UpdateObjectGroupHandler>::nil (void)
{
  return PortableGroup::AMI_TAO_UpdateObjectGroupHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<PortableGroup::AMI_TAO_UpdateObjectGroupHandler>::marshal (
    const PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*PortableGroup__TAO_AMI_TAO_UpdateObjectGroupHandler_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_TAO_UpdateObjectGroupHandler::tao_update_object_group (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_TAO_UpdateObjectGroupHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_TAO_UpdateObjectGroupHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "tao_update_object_group",
      23,
      this->the_TAO_AMI_TAO_UpdateObjectGroupHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
PortableGroup::AMI_TAO_UpdateObjectGroupHandler::tao_update_object_group_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  PortableGroup::AMI_TAO_UpdateObjectGroupHandler_var _tao_reply_handler_object =
    PortableGroup::AMI_TAO_UpdateObjectGroupHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->tao_update_object_group (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->tao_update_object_group_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
PortableGroup::AMI_TAO_UpdateObjectGroupHandler::tao_update_object_group_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_TAO_UpdateObjectGroupHandler_Proxy_Broker_ == 0)
    {
      PortableGroup_AMI_TAO_UpdateObjectGroupHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "tao_update_object_group_excep",
      29,
      this->the_TAO_AMI_TAO_UpdateObjectGroupHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

PortableGroup::AMI_TAO_UpdateObjectGroupHandler::AMI_TAO_UpdateObjectGroupHandler (void)
 : the_TAO_AMI_TAO_UpdateObjectGroupHandler_Proxy_Broker_ (0)
{
  this->PortableGroup_AMI_TAO_UpdateObjectGroupHandler_setup_collocation ();
}

void
PortableGroup::AMI_TAO_UpdateObjectGroupHandler::PortableGroup_AMI_TAO_UpdateObjectGroupHandler_setup_collocation ()
{
  if (::PortableGroup__TAO_AMI_TAO_UpdateObjectGroupHandler_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_AMI_TAO_UpdateObjectGroupHandler_Proxy_Broker_ =
        ::PortableGroup__TAO_AMI_TAO_UpdateObjectGroupHandler_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->Messaging_ReplyHandler_setup_collocation ();
}

PortableGroup::AMI_TAO_UpdateObjectGroupHandler::~AMI_TAO_UpdateObjectGroupHandler (void)
{}

void 
PortableGroup::AMI_TAO_UpdateObjectGroupHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_TAO_UpdateObjectGroupHandler *_tao_tmp_pointer =
    static_cast<AMI_TAO_UpdateObjectGroupHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr
PortableGroup::AMI_TAO_UpdateObjectGroupHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_TAO_UpdateObjectGroupHandler>::narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/AMI_TAO_UpdateObjectGroupHandler:1.0",
        PortableGroup__TAO_AMI_TAO_UpdateObjectGroupHandler_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr
PortableGroup::AMI_TAO_UpdateObjectGroupHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_TAO_UpdateObjectGroupHandler>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/PortableGroup/AMI_TAO_UpdateObjectGroupHandler:1.0",
        PortableGroup__TAO_AMI_TAO_UpdateObjectGroupHandler_Proxy_Broker_Factory_function_pointer
      );
}

PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr
PortableGroup::AMI_TAO_UpdateObjectGroupHandler::_nil (void)
{
  return 0;
}

PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr
PortableGroup::AMI_TAO_UpdateObjectGroupHandler::_duplicate (AMI_TAO_UpdateObjectGroupHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
PortableGroup::AMI_TAO_UpdateObjectGroupHandler::_tao_release (AMI_TAO_UpdateObjectGroupHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
PortableGroup::AMI_TAO_UpdateObjectGroupHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/AMI_TAO_UpdateObjectGroupHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* PortableGroup::AMI_TAO_UpdateObjectGroupHandler::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableGroup/AMI_TAO_UpdateObjectGroupHandler:1.0";
}

::CORBA::Boolean
PortableGroup::AMI_TAO_UpdateObjectGroupHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_AMI_TAO_UpdateObjectGroupHandler (
    ::CORBA::tk_objref,
    "IDL:omg.org/PortableGroup/AMI_TAO_UpdateObjectGroupHandler:1.0",
    "AMI_TAO_UpdateObjectGroupHandler");
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_AMI_TAO_UpdateObjectGroupHandler =
    &_tao_tc_PortableGroup_AMI_TAO_UpdateObjectGroupHandler;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

PortableGroup::NotAGroupObject::NotAGroupObject (void)
  : ::CORBA::UserException (
        "IDL:omg.org/PortableGroup/NotAGroupObject:1.0",
        "NotAGroupObject"
      )
{
}

PortableGroup::NotAGroupObject::~NotAGroupObject (void)
{
}

PortableGroup::NotAGroupObject::NotAGroupObject (const ::PortableGroup::NotAGroupObject &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableGroup::NotAGroupObject&
PortableGroup::NotAGroupObject::operator= (const ::PortableGroup::NotAGroupObject &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void PortableGroup::NotAGroupObject::_tao_any_destructor (void *_tao_void_pointer)
{
  NotAGroupObject *_tao_tmp_pointer =
    static_cast<NotAGroupObject *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

PortableGroup::NotAGroupObject *
PortableGroup::NotAGroupObject::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NotAGroupObject *> (_tao_excp);
}

const PortableGroup::NotAGroupObject *
PortableGroup::NotAGroupObject::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NotAGroupObject *> (_tao_excp);
}

::CORBA::Exception *PortableGroup::NotAGroupObject::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableGroup::NotAGroupObject, 0);
  return retval;
}

::CORBA::Exception *
PortableGroup::NotAGroupObject::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::PortableGroup::NotAGroupObject (*this),
      0
    );
  return result;
}

void PortableGroup::NotAGroupObject::_raise (void) const
{
  throw *this;
}

void PortableGroup::NotAGroupObject::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void PortableGroup::NotAGroupObject::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableGroup::NotAGroupObject::_tao_type (void) const
{
  return ::PortableGroup::_tc_NotAGroupObject;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_PortableGroup_NotAGroupObject = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_PortableGroup_NotAGroupObject (
  ::CORBA::tk_except,
  "IDL:omg.org/PortableGroup/NotAGroupObject:1.0",
  "NotAGroupObject",
  _tao_fields_PortableGroup_NotAGroupObject,
  0);


namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_NotAGroupObject =
    &_tao_tc_PortableGroup_NotAGroupObject;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PORTABLEGROUP_IDS_CS_)
#define _PORTABLEGROUP_IDS_CS_

PortableGroup::IDs::IDs (void)
{}

PortableGroup::IDs::IDs (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        PortableServer::ObjectId
      > (max)
{}

PortableGroup::IDs::IDs (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    PortableServer::ObjectId * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        PortableServer::ObjectId
      >
    (max, length, buffer, release)
{}

PortableGroup::IDs::IDs (
    const IDs &seq)
  : ::TAO::unbounded_value_sequence<
        PortableServer::ObjectId
      > (seq)
{}

PortableGroup::IDs::~IDs (void)
{}

void PortableGroup::IDs::_tao_any_destructor (
    void * _tao_void_pointer)
{
  IDs * _tao_tmp_pointer =
    static_cast<IDs *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_PortableGroup_IDs_GUARD
#define _TAO_TYPECODE_PortableGroup_IDs_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        PortableGroup_IDs_0 (
          ::CORBA::tk_sequence,
          &PortableServer::_tc_ObjectId,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_PortableGroup_IDs_0 =
        &PortableGroup_IDs_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_PortableGroup_IDs_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_IDs (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableGroup/IDs:1.0",
    "IDs",
    &TAO::TypeCode::tc_PortableGroup_IDs_0);
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_IDs =
    &_tao_tc_PortableGroup_IDs;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for PortableGroup::GOA.

PortableGroup::GOA_ptr
TAO::Objref_Traits<PortableGroup::GOA>::duplicate (
    PortableGroup::GOA_ptr p)
{
  return PortableGroup::GOA::_duplicate (p);
}

void
TAO::Objref_Traits<PortableGroup::GOA>::release (
    PortableGroup::GOA_ptr p)
{
  ::CORBA::release (p);
}

PortableGroup::GOA_ptr
TAO::Objref_Traits<PortableGroup::GOA>::nil (void)
{
  return PortableGroup::GOA::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<PortableGroup::GOA>::marshal (
    const PortableGroup::GOA_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

PortableGroup::GOA::GOA (void)
{}

PortableGroup::GOA::~GOA (void)
{}

void 
PortableGroup::GOA::_tao_any_destructor (void *_tao_void_pointer)
{
  GOA *_tao_tmp_pointer =
    static_cast<GOA *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

PortableGroup::GOA_ptr
PortableGroup::GOA::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return GOA::_duplicate (
      dynamic_cast<GOA_ptr> (_tao_objref)
    );
}

PortableGroup::GOA_ptr
PortableGroup::GOA::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return GOA::_duplicate (
      dynamic_cast<GOA_ptr> (_tao_objref)
    );
}

PortableGroup::GOA_ptr
PortableGroup::GOA::_nil (void)
{
  return 0;
}

PortableGroup::GOA_ptr
PortableGroup::GOA::_duplicate (GOA_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
PortableGroup::GOA::_tao_release (GOA_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
PortableGroup::GOA::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableServer/POA:2.3"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/GOA:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* PortableGroup::GOA::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableGroup/GOA:1.0";
}

::CORBA::Boolean
PortableGroup::GOA::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_PortableGroup_GOA (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/PortableGroup/GOA:1.0",
    "GOA");
  

namespace PortableGroup
{
  ::CORBA::TypeCode_ptr const _tc_GOA =
    &_tao_tc_PortableGroup_GOA;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::GroupIIOPProfile &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::PortableGroup::GroupIIOPProfile *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::PortableGroup::GroupIIOPProfile>::insert_copy (
          _tao_any,
          ::PortableGroup::GroupIIOPProfile::_tao_any_destructor,
          ::PortableGroup::_tc_GroupIIOPProfile,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::GroupIIOPProfile *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::GroupIIOPProfile>::insert (
        _tao_any,
        ::PortableGroup::GroupIIOPProfile::_tao_any_destructor,
        ::PortableGroup::_tc_GroupIIOPProfile,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::GroupIIOPProfile *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::GroupIIOPProfile *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::GroupIIOPProfile *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::GroupIIOPProfile>::extract (
          _tao_any,
          ::PortableGroup::GroupIIOPProfile::_tao_any_destructor,
          ::PortableGroup::_tc_GroupIIOPProfile,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::GroupIIOPProfile &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<PortableGroup::GroupIIOPProfile *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<PortableGroup::GroupIIOPProfile>::insert_copy (
        _tao_any,
        PortableGroup::GroupIIOPProfile::_tao_any_destructor,
        PortableGroup::_tc_GroupIIOPProfile,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::GroupIIOPProfile *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::GroupIIOPProfile>::insert (
      _tao_any,
      PortableGroup::GroupIIOPProfile::_tao_any_destructor,
      PortableGroup::_tc_GroupIIOPProfile,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::GroupIIOPProfile *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::GroupIIOPProfile *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::GroupIIOPProfile *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::GroupIIOPProfile>::extract (
        _tao_any,
        PortableGroup::GroupIIOPProfile::_tao_any_destructor,
        PortableGroup::_tc_GroupIIOPProfile,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::ObjectGroups &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::PortableGroup::ObjectGroups *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectGroups>::insert_copy (
          _tao_any,
          ::PortableGroup::ObjectGroups::_tao_any_destructor,
          ::PortableGroup::_tc_ObjectGroups,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::ObjectGroups *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectGroups>::insert (
        _tao_any,
        ::PortableGroup::ObjectGroups::_tao_any_destructor,
        ::PortableGroup::_tc_ObjectGroups,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::ObjectGroups *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::ObjectGroups *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::ObjectGroups *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectGroups>::extract (
          _tao_any,
          ::PortableGroup::ObjectGroups::_tao_any_destructor,
          ::PortableGroup::_tc_ObjectGroups,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::ObjectGroups &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<PortableGroup::ObjectGroups *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<PortableGroup::ObjectGroups>::insert_copy (
        _tao_any,
        PortableGroup::ObjectGroups::_tao_any_destructor,
        PortableGroup::_tc_ObjectGroups,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::ObjectGroups *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::ObjectGroups>::insert (
      _tao_any,
      PortableGroup::ObjectGroups::_tao_any_destructor,
      PortableGroup::_tc_ObjectGroups,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::ObjectGroups *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::ObjectGroups *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::ObjectGroups *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::ObjectGroups>::extract (
        _tao_any,
        PortableGroup::ObjectGroups::_tao_any_destructor,
        PortableGroup::_tc_ObjectGroups,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::Property &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::PortableGroup::Property *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::PortableGroup::Property>::insert_copy (
          _tao_any,
          ::PortableGroup::Property::_tao_any_destructor,
          ::PortableGroup::_tc_Property,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      PortableGroup::Property *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::Property>::insert (
        _tao_any,
        ::PortableGroup::Property::_tao_any_destructor,
        ::PortableGroup::_tc_Property,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::Property *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::Property *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::Property *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::Property>::extract (
          _tao_any,
          ::PortableGroup::Property::_tao_any_destructor,
          ::PortableGroup::_tc_Property,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::Property &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<PortableGroup::Property *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<PortableGroup::Property>::insert_copy (
        _tao_any,
        PortableGroup::Property::_tao_any_destructor,
        PortableGroup::_tc_Property,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::Property *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::Property>::insert (
      _tao_any,
      PortableGroup::Property::_tao_any_destructor,
      PortableGroup::_tc_Property,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::Property *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::Property *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::Property *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::Property>::extract (
        _tao_any,
        PortableGroup::Property::_tao_any_destructor,
        PortableGroup::_tc_Property,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::Properties &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::PortableGroup::Properties *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::PortableGroup::Properties>::insert_copy (
          _tao_any,
          ::PortableGroup::Properties::_tao_any_destructor,
          ::PortableGroup::_tc_Properties,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::Properties *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::Properties>::insert (
        _tao_any,
        ::PortableGroup::Properties::_tao_any_destructor,
        ::PortableGroup::_tc_Properties,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::Properties *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::Properties *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::Properties *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::Properties>::extract (
          _tao_any,
          ::PortableGroup::Properties::_tao_any_destructor,
          ::PortableGroup::_tc_Properties,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::Properties &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<PortableGroup::Properties *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<PortableGroup::Properties>::insert_copy (
        _tao_any,
        PortableGroup::Properties::_tao_any_destructor,
        PortableGroup::_tc_Properties,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::Properties *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::Properties>::insert (
      _tao_any,
      PortableGroup::Properties::_tao_any_destructor,
      PortableGroup::_tc_Properties,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::Properties *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::Properties *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::Properties *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::Properties>::extract (
        _tao_any,
        PortableGroup::Properties::_tao_any_destructor,
        PortableGroup::_tc_Properties,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::Locations &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::PortableGroup::Locations *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::PortableGroup::Locations>::insert_copy (
          _tao_any,
          ::PortableGroup::Locations::_tao_any_destructor,
          ::PortableGroup::_tc_Locations,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::Locations *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::Locations>::insert (
        _tao_any,
        ::PortableGroup::Locations::_tao_any_destructor,
        ::PortableGroup::_tc_Locations,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::Locations *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::Locations *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::Locations *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::Locations>::extract (
          _tao_any,
          ::PortableGroup::Locations::_tao_any_destructor,
          ::PortableGroup::_tc_Locations,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::Locations &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<PortableGroup::Locations *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<PortableGroup::Locations>::insert_copy (
        _tao_any,
        PortableGroup::Locations::_tao_any_destructor,
        PortableGroup::_tc_Locations,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::Locations *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::Locations>::insert (
      _tao_any,
      PortableGroup::Locations::_tao_any_destructor,
      PortableGroup::_tc_Locations,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::Locations *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::Locations *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::Locations *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::Locations>::extract (
        _tao_any,
        PortableGroup::Locations::_tao_any_destructor,
        PortableGroup::_tc_Locations,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::FactoryInfo &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::PortableGroup::FactoryInfo *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::PortableGroup::FactoryInfo>::insert_copy (
          _tao_any,
          ::PortableGroup::FactoryInfo::_tao_any_destructor,
          ::PortableGroup::_tc_FactoryInfo,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      PortableGroup::FactoryInfo *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::FactoryInfo>::insert (
        _tao_any,
        ::PortableGroup::FactoryInfo::_tao_any_destructor,
        ::PortableGroup::_tc_FactoryInfo,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::FactoryInfo *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::FactoryInfo *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::FactoryInfo *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::FactoryInfo>::extract (
          _tao_any,
          ::PortableGroup::FactoryInfo::_tao_any_destructor,
          ::PortableGroup::_tc_FactoryInfo,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::FactoryInfo &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<PortableGroup::FactoryInfo *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<PortableGroup::FactoryInfo>::insert_copy (
        _tao_any,
        PortableGroup::FactoryInfo::_tao_any_destructor,
        PortableGroup::_tc_FactoryInfo,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::FactoryInfo *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::FactoryInfo>::insert (
      _tao_any,
      PortableGroup::FactoryInfo::_tao_any_destructor,
      PortableGroup::_tc_FactoryInfo,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::FactoryInfo *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::FactoryInfo *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::FactoryInfo *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::FactoryInfo>::extract (
        _tao_any,
        PortableGroup::FactoryInfo::_tao_any_destructor,
        PortableGroup::_tc_FactoryInfo,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::FactoryInfos &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::PortableGroup::FactoryInfos *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::PortableGroup::FactoryInfos>::insert_copy (
          _tao_any,
          ::PortableGroup::FactoryInfos::_tao_any_destructor,
          ::PortableGroup::_tc_FactoryInfos,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::FactoryInfos *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::FactoryInfos>::insert (
        _tao_any,
        ::PortableGroup::FactoryInfos::_tao_any_destructor,
        ::PortableGroup::_tc_FactoryInfos,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::FactoryInfos *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::FactoryInfos *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::FactoryInfos *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::FactoryInfos>::extract (
          _tao_any,
          ::PortableGroup::FactoryInfos::_tao_any_destructor,
          ::PortableGroup::_tc_FactoryInfos,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::FactoryInfos &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<PortableGroup::FactoryInfos *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<PortableGroup::FactoryInfos>::insert_copy (
        _tao_any,
        PortableGroup::FactoryInfos::_tao_any_destructor,
        PortableGroup::_tc_FactoryInfos,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::FactoryInfos *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::FactoryInfos>::insert (
      _tao_any,
      PortableGroup::FactoryInfos::_tao_any_destructor,
      PortableGroup::_tc_FactoryInfos,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::FactoryInfos *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::FactoryInfos *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::FactoryInfos *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::FactoryInfos>::extract (
        _tao_any,
        PortableGroup::FactoryInfos::_tao_any_destructor,
        PortableGroup::_tc_FactoryInfos,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<PortableGroup::InterfaceNotFound>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::InterfaceNotFound &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::InterfaceNotFound>::insert_copy (
        _tao_any,
        ::PortableGroup::InterfaceNotFound::_tao_any_destructor,
        ::PortableGroup::_tc_InterfaceNotFound,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::InterfaceNotFound *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::InterfaceNotFound>::insert (
        _tao_any,
        ::PortableGroup::InterfaceNotFound::_tao_any_destructor,
        ::PortableGroup::_tc_InterfaceNotFound,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::InterfaceNotFound *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::InterfaceNotFound *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::InterfaceNotFound *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::InterfaceNotFound>::extract (
          _tao_any,
          ::PortableGroup::InterfaceNotFound::_tao_any_destructor,
          ::PortableGroup::_tc_InterfaceNotFound,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::InterfaceNotFound &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::InterfaceNotFound>::insert_copy (
      _tao_any,
      PortableGroup::InterfaceNotFound::_tao_any_destructor,
      PortableGroup::_tc_InterfaceNotFound,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::InterfaceNotFound *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::InterfaceNotFound>::insert (
      _tao_any,
      PortableGroup::InterfaceNotFound::_tao_any_destructor,
      PortableGroup::_tc_InterfaceNotFound,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::InterfaceNotFound *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::InterfaceNotFound *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::InterfaceNotFound *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::InterfaceNotFound>::extract (
        _tao_any,
        PortableGroup::InterfaceNotFound::_tao_any_destructor,
        PortableGroup::_tc_InterfaceNotFound,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<PortableGroup::ObjectGroupNotFound>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::ObjectGroupNotFound &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectGroupNotFound>::insert_copy (
        _tao_any,
        ::PortableGroup::ObjectGroupNotFound::_tao_any_destructor,
        ::PortableGroup::_tc_ObjectGroupNotFound,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::ObjectGroupNotFound *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectGroupNotFound>::insert (
        _tao_any,
        ::PortableGroup::ObjectGroupNotFound::_tao_any_destructor,
        ::PortableGroup::_tc_ObjectGroupNotFound,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::ObjectGroupNotFound *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::ObjectGroupNotFound *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::ObjectGroupNotFound *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectGroupNotFound>::extract (
          _tao_any,
          ::PortableGroup::ObjectGroupNotFound::_tao_any_destructor,
          ::PortableGroup::_tc_ObjectGroupNotFound,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::ObjectGroupNotFound &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::ObjectGroupNotFound>::insert_copy (
      _tao_any,
      PortableGroup::ObjectGroupNotFound::_tao_any_destructor,
      PortableGroup::_tc_ObjectGroupNotFound,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::ObjectGroupNotFound *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::ObjectGroupNotFound>::insert (
      _tao_any,
      PortableGroup::ObjectGroupNotFound::_tao_any_destructor,
      PortableGroup::_tc_ObjectGroupNotFound,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::ObjectGroupNotFound *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::ObjectGroupNotFound *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::ObjectGroupNotFound *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::ObjectGroupNotFound>::extract (
        _tao_any,
        PortableGroup::ObjectGroupNotFound::_tao_any_destructor,
        PortableGroup::_tc_ObjectGroupNotFound,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<PortableGroup::MemberNotFound>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::MemberNotFound &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::MemberNotFound>::insert_copy (
        _tao_any,
        ::PortableGroup::MemberNotFound::_tao_any_destructor,
        ::PortableGroup::_tc_MemberNotFound,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::MemberNotFound *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::MemberNotFound>::insert (
        _tao_any,
        ::PortableGroup::MemberNotFound::_tao_any_destructor,
        ::PortableGroup::_tc_MemberNotFound,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::MemberNotFound *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::MemberNotFound *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::MemberNotFound *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::MemberNotFound>::extract (
          _tao_any,
          ::PortableGroup::MemberNotFound::_tao_any_destructor,
          ::PortableGroup::_tc_MemberNotFound,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::MemberNotFound &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::MemberNotFound>::insert_copy (
      _tao_any,
      PortableGroup::MemberNotFound::_tao_any_destructor,
      PortableGroup::_tc_MemberNotFound,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::MemberNotFound *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::MemberNotFound>::insert (
      _tao_any,
      PortableGroup::MemberNotFound::_tao_any_destructor,
      PortableGroup::_tc_MemberNotFound,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::MemberNotFound *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::MemberNotFound *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::MemberNotFound *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::MemberNotFound>::extract (
        _tao_any,
        PortableGroup::MemberNotFound::_tao_any_destructor,
        PortableGroup::_tc_MemberNotFound,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<PortableGroup::ObjectNotFound>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::ObjectNotFound &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectNotFound>::insert_copy (
        _tao_any,
        ::PortableGroup::ObjectNotFound::_tao_any_destructor,
        ::PortableGroup::_tc_ObjectNotFound,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::ObjectNotFound *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectNotFound>::insert (
        _tao_any,
        ::PortableGroup::ObjectNotFound::_tao_any_destructor,
        ::PortableGroup::_tc_ObjectNotFound,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::ObjectNotFound *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::ObjectNotFound *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::ObjectNotFound *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectNotFound>::extract (
          _tao_any,
          ::PortableGroup::ObjectNotFound::_tao_any_destructor,
          ::PortableGroup::_tc_ObjectNotFound,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::ObjectNotFound &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::ObjectNotFound>::insert_copy (
      _tao_any,
      PortableGroup::ObjectNotFound::_tao_any_destructor,
      PortableGroup::_tc_ObjectNotFound,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::ObjectNotFound *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::ObjectNotFound>::insert (
      _tao_any,
      PortableGroup::ObjectNotFound::_tao_any_destructor,
      PortableGroup::_tc_ObjectNotFound,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::ObjectNotFound *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::ObjectNotFound *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::ObjectNotFound *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::ObjectNotFound>::extract (
        _tao_any,
        PortableGroup::ObjectNotFound::_tao_any_destructor,
        PortableGroup::_tc_ObjectNotFound,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<PortableGroup::MemberAlreadyPresent>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::MemberAlreadyPresent &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::MemberAlreadyPresent>::insert_copy (
        _tao_any,
        ::PortableGroup::MemberAlreadyPresent::_tao_any_destructor,
        ::PortableGroup::_tc_MemberAlreadyPresent,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::MemberAlreadyPresent *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::MemberAlreadyPresent>::insert (
        _tao_any,
        ::PortableGroup::MemberAlreadyPresent::_tao_any_destructor,
        ::PortableGroup::_tc_MemberAlreadyPresent,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::MemberAlreadyPresent *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::MemberAlreadyPresent *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::MemberAlreadyPresent *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::MemberAlreadyPresent>::extract (
          _tao_any,
          ::PortableGroup::MemberAlreadyPresent::_tao_any_destructor,
          ::PortableGroup::_tc_MemberAlreadyPresent,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::MemberAlreadyPresent &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::MemberAlreadyPresent>::insert_copy (
      _tao_any,
      PortableGroup::MemberAlreadyPresent::_tao_any_destructor,
      PortableGroup::_tc_MemberAlreadyPresent,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::MemberAlreadyPresent *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::MemberAlreadyPresent>::insert (
      _tao_any,
      PortableGroup::MemberAlreadyPresent::_tao_any_destructor,
      PortableGroup::_tc_MemberAlreadyPresent,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::MemberAlreadyPresent *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::MemberAlreadyPresent *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::MemberAlreadyPresent *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::MemberAlreadyPresent>::extract (
        _tao_any,
        PortableGroup::MemberAlreadyPresent::_tao_any_destructor,
        PortableGroup::_tc_MemberAlreadyPresent,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<PortableGroup::ObjectNotCreated>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::ObjectNotCreated &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectNotCreated>::insert_copy (
        _tao_any,
        ::PortableGroup::ObjectNotCreated::_tao_any_destructor,
        ::PortableGroup::_tc_ObjectNotCreated,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::ObjectNotCreated *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectNotCreated>::insert (
        _tao_any,
        ::PortableGroup::ObjectNotCreated::_tao_any_destructor,
        ::PortableGroup::_tc_ObjectNotCreated,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::ObjectNotCreated *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::ObjectNotCreated *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::ObjectNotCreated *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectNotCreated>::extract (
          _tao_any,
          ::PortableGroup::ObjectNotCreated::_tao_any_destructor,
          ::PortableGroup::_tc_ObjectNotCreated,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::ObjectNotCreated &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::ObjectNotCreated>::insert_copy (
      _tao_any,
      PortableGroup::ObjectNotCreated::_tao_any_destructor,
      PortableGroup::_tc_ObjectNotCreated,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::ObjectNotCreated *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::ObjectNotCreated>::insert (
      _tao_any,
      PortableGroup::ObjectNotCreated::_tao_any_destructor,
      PortableGroup::_tc_ObjectNotCreated,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::ObjectNotCreated *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::ObjectNotCreated *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::ObjectNotCreated *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::ObjectNotCreated>::extract (
        _tao_any,
        PortableGroup::ObjectNotCreated::_tao_any_destructor,
        PortableGroup::_tc_ObjectNotCreated,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<PortableGroup::ObjectNotAdded>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::ObjectNotAdded &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectNotAdded>::insert_copy (
        _tao_any,
        ::PortableGroup::ObjectNotAdded::_tao_any_destructor,
        ::PortableGroup::_tc_ObjectNotAdded,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::ObjectNotAdded *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectNotAdded>::insert (
        _tao_any,
        ::PortableGroup::ObjectNotAdded::_tao_any_destructor,
        ::PortableGroup::_tc_ObjectNotAdded,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::ObjectNotAdded *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::ObjectNotAdded *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::ObjectNotAdded *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::ObjectNotAdded>::extract (
          _tao_any,
          ::PortableGroup::ObjectNotAdded::_tao_any_destructor,
          ::PortableGroup::_tc_ObjectNotAdded,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::ObjectNotAdded &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::ObjectNotAdded>::insert_copy (
      _tao_any,
      PortableGroup::ObjectNotAdded::_tao_any_destructor,
      PortableGroup::_tc_ObjectNotAdded,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::ObjectNotAdded *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::ObjectNotAdded>::insert (
      _tao_any,
      PortableGroup::ObjectNotAdded::_tao_any_destructor,
      PortableGroup::_tc_ObjectNotAdded,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::ObjectNotAdded *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::ObjectNotAdded *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::ObjectNotAdded *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::ObjectNotAdded>::extract (
        _tao_any,
        PortableGroup::ObjectNotAdded::_tao_any_destructor,
        PortableGroup::_tc_ObjectNotAdded,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<PortableGroup::TypeConflict>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::TypeConflict &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::TypeConflict>::insert_copy (
        _tao_any,
        ::PortableGroup::TypeConflict::_tao_any_destructor,
        ::PortableGroup::_tc_TypeConflict,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::TypeConflict *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::TypeConflict>::insert (
        _tao_any,
        ::PortableGroup::TypeConflict::_tao_any_destructor,
        ::PortableGroup::_tc_TypeConflict,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::TypeConflict *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::TypeConflict *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::TypeConflict *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::TypeConflict>::extract (
          _tao_any,
          ::PortableGroup::TypeConflict::_tao_any_destructor,
          ::PortableGroup::_tc_TypeConflict,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::TypeConflict &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::TypeConflict>::insert_copy (
      _tao_any,
      PortableGroup::TypeConflict::_tao_any_destructor,
      PortableGroup::_tc_TypeConflict,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::TypeConflict *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::TypeConflict>::insert (
      _tao_any,
      PortableGroup::TypeConflict::_tao_any_destructor,
      PortableGroup::_tc_TypeConflict,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::TypeConflict *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::TypeConflict *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::TypeConflict *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::TypeConflict>::extract (
        _tao_any,
        PortableGroup::TypeConflict::_tao_any_destructor,
        PortableGroup::_tc_TypeConflict,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<PortableGroup::UnsupportedProperty>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::UnsupportedProperty &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::UnsupportedProperty>::insert_copy (
        _tao_any,
        ::PortableGroup::UnsupportedProperty::_tao_any_destructor,
        ::PortableGroup::_tc_UnsupportedProperty,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::UnsupportedProperty *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::UnsupportedProperty>::insert (
        _tao_any,
        ::PortableGroup::UnsupportedProperty::_tao_any_destructor,
        ::PortableGroup::_tc_UnsupportedProperty,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::UnsupportedProperty *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::UnsupportedProperty *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::UnsupportedProperty *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::UnsupportedProperty>::extract (
          _tao_any,
          ::PortableGroup::UnsupportedProperty::_tao_any_destructor,
          ::PortableGroup::_tc_UnsupportedProperty,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::UnsupportedProperty &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::UnsupportedProperty>::insert_copy (
      _tao_any,
      PortableGroup::UnsupportedProperty::_tao_any_destructor,
      PortableGroup::_tc_UnsupportedProperty,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::UnsupportedProperty *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::UnsupportedProperty>::insert (
      _tao_any,
      PortableGroup::UnsupportedProperty::_tao_any_destructor,
      PortableGroup::_tc_UnsupportedProperty,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::UnsupportedProperty *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::UnsupportedProperty *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::UnsupportedProperty *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::UnsupportedProperty>::extract (
        _tao_any,
        PortableGroup::UnsupportedProperty::_tao_any_destructor,
        PortableGroup::_tc_UnsupportedProperty,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<PortableGroup::InvalidProperty>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::InvalidProperty &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::InvalidProperty>::insert_copy (
        _tao_any,
        ::PortableGroup::InvalidProperty::_tao_any_destructor,
        ::PortableGroup::_tc_InvalidProperty,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::InvalidProperty *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::InvalidProperty>::insert (
        _tao_any,
        ::PortableGroup::InvalidProperty::_tao_any_destructor,
        ::PortableGroup::_tc_InvalidProperty,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::InvalidProperty *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::InvalidProperty *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::InvalidProperty *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::InvalidProperty>::extract (
          _tao_any,
          ::PortableGroup::InvalidProperty::_tao_any_destructor,
          ::PortableGroup::_tc_InvalidProperty,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::InvalidProperty &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::InvalidProperty>::insert_copy (
      _tao_any,
      PortableGroup::InvalidProperty::_tao_any_destructor,
      PortableGroup::_tc_InvalidProperty,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::InvalidProperty *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::InvalidProperty>::insert (
      _tao_any,
      PortableGroup::InvalidProperty::_tao_any_destructor,
      PortableGroup::_tc_InvalidProperty,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::InvalidProperty *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::InvalidProperty *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::InvalidProperty *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::InvalidProperty>::extract (
        _tao_any,
        PortableGroup::InvalidProperty::_tao_any_destructor,
        PortableGroup::_tc_InvalidProperty,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<PortableGroup::NoFactory>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::NoFactory &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::NoFactory>::insert_copy (
        _tao_any,
        ::PortableGroup::NoFactory::_tao_any_destructor,
        ::PortableGroup::_tc_NoFactory,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::NoFactory *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::NoFactory>::insert (
        _tao_any,
        ::PortableGroup::NoFactory::_tao_any_destructor,
        ::PortableGroup::_tc_NoFactory,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::NoFactory *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::NoFactory *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::NoFactory *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::NoFactory>::extract (
          _tao_any,
          ::PortableGroup::NoFactory::_tao_any_destructor,
          ::PortableGroup::_tc_NoFactory,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::NoFactory &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::NoFactory>::insert_copy (
      _tao_any,
      PortableGroup::NoFactory::_tao_any_destructor,
      PortableGroup::_tc_NoFactory,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::NoFactory *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::NoFactory>::insert (
      _tao_any,
      PortableGroup::NoFactory::_tao_any_destructor,
      PortableGroup::_tc_NoFactory,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::NoFactory *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::NoFactory *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::NoFactory *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::NoFactory>::extract (
        _tao_any,
        PortableGroup::NoFactory::_tao_any_destructor,
        PortableGroup::_tc_NoFactory,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<PortableGroup::InvalidCriteria>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::InvalidCriteria &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::InvalidCriteria>::insert_copy (
        _tao_any,
        ::PortableGroup::InvalidCriteria::_tao_any_destructor,
        ::PortableGroup::_tc_InvalidCriteria,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::InvalidCriteria *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::InvalidCriteria>::insert (
        _tao_any,
        ::PortableGroup::InvalidCriteria::_tao_any_destructor,
        ::PortableGroup::_tc_InvalidCriteria,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::InvalidCriteria *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::InvalidCriteria *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::InvalidCriteria *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::InvalidCriteria>::extract (
          _tao_any,
          ::PortableGroup::InvalidCriteria::_tao_any_destructor,
          ::PortableGroup::_tc_InvalidCriteria,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::InvalidCriteria &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::InvalidCriteria>::insert_copy (
      _tao_any,
      PortableGroup::InvalidCriteria::_tao_any_destructor,
      PortableGroup::_tc_InvalidCriteria,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::InvalidCriteria *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::InvalidCriteria>::insert (
      _tao_any,
      PortableGroup::InvalidCriteria::_tao_any_destructor,
      PortableGroup::_tc_InvalidCriteria,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::InvalidCriteria *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::InvalidCriteria *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::InvalidCriteria *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::InvalidCriteria>::extract (
        _tao_any,
        PortableGroup::InvalidCriteria::_tao_any_destructor,
        PortableGroup::_tc_InvalidCriteria,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<PortableGroup::CannotMeetCriteria>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::CannotMeetCriteria &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::CannotMeetCriteria>::insert_copy (
        _tao_any,
        ::PortableGroup::CannotMeetCriteria::_tao_any_destructor,
        ::PortableGroup::_tc_CannotMeetCriteria,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::CannotMeetCriteria *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::CannotMeetCriteria>::insert (
        _tao_any,
        ::PortableGroup::CannotMeetCriteria::_tao_any_destructor,
        ::PortableGroup::_tc_CannotMeetCriteria,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::CannotMeetCriteria *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::CannotMeetCriteria *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::CannotMeetCriteria *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::CannotMeetCriteria>::extract (
          _tao_any,
          ::PortableGroup::CannotMeetCriteria::_tao_any_destructor,
          ::PortableGroup::_tc_CannotMeetCriteria,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::CannotMeetCriteria &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::CannotMeetCriteria>::insert_copy (
      _tao_any,
      PortableGroup::CannotMeetCriteria::_tao_any_destructor,
      PortableGroup::_tc_CannotMeetCriteria,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::CannotMeetCriteria *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::CannotMeetCriteria>::insert (
      _tao_any,
      PortableGroup::CannotMeetCriteria::_tao_any_destructor,
      PortableGroup::_tc_CannotMeetCriteria,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::CannotMeetCriteria *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::CannotMeetCriteria *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::CannotMeetCriteria *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::CannotMeetCriteria>::extract (
        _tao_any,
        PortableGroup::CannotMeetCriteria::_tao_any_destructor,
        PortableGroup::_tc_CannotMeetCriteria,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableGroup::PropertyManager>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      PropertyManager_ptr _tao_elem)
  {
    PropertyManager_ptr _tao_objptr =
      PropertyManager::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      PropertyManager_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<PropertyManager>::insert (
        _tao_any,
        PropertyManager::_tao_any_destructor,
        _tc_PropertyManager,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      PropertyManager_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<PropertyManager>::extract (
          _tao_any,
          PropertyManager::_tao_any_destructor,
          _tc_PropertyManager,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::PropertyManager_ptr _tao_elem)
{
  PortableGroup::PropertyManager_ptr _tao_objptr =
    PortableGroup::PropertyManager::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::PropertyManager_ptr *_tao_elem)
{
  TAO::Any_Impl_T<PortableGroup::PropertyManager>::insert (
      _tao_any,
      PortableGroup::PropertyManager::_tao_any_destructor,
      PortableGroup::_tc_PropertyManager,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::PropertyManager_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<PortableGroup::PropertyManager>::extract (
        _tao_any,
        PortableGroup::PropertyManager::_tao_any_destructor,
        PortableGroup::_tc_PropertyManager,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableGroup::AMI_PropertyManagerHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_PropertyManagerHandler_ptr _tao_elem)
  {
    AMI_PropertyManagerHandler_ptr _tao_objptr =
      AMI_PropertyManagerHandler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_PropertyManagerHandler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AMI_PropertyManagerHandler>::insert (
        _tao_any,
        AMI_PropertyManagerHandler::_tao_any_destructor,
        _tc_AMI_PropertyManagerHandler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMI_PropertyManagerHandler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AMI_PropertyManagerHandler>::extract (
          _tao_any,
          AMI_PropertyManagerHandler::_tao_any_destructor,
          _tc_AMI_PropertyManagerHandler,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::AMI_PropertyManagerHandler_ptr _tao_elem)
{
  PortableGroup::AMI_PropertyManagerHandler_ptr _tao_objptr =
    PortableGroup::AMI_PropertyManagerHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::AMI_PropertyManagerHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<PortableGroup::AMI_PropertyManagerHandler>::insert (
      _tao_any,
      PortableGroup::AMI_PropertyManagerHandler::_tao_any_destructor,
      PortableGroup::_tc_AMI_PropertyManagerHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::AMI_PropertyManagerHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<PortableGroup::AMI_PropertyManagerHandler>::extract (
        _tao_any,
        PortableGroup::AMI_PropertyManagerHandler::_tao_any_destructor,
        PortableGroup::_tc_AMI_PropertyManagerHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableGroup::ObjectGroupManager>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ObjectGroupManager_ptr _tao_elem)
  {
    ObjectGroupManager_ptr _tao_objptr =
      ObjectGroupManager::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ObjectGroupManager_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<ObjectGroupManager>::insert (
        _tao_any,
        ObjectGroupManager::_tao_any_destructor,
        _tc_ObjectGroupManager,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      ObjectGroupManager_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<ObjectGroupManager>::extract (
          _tao_any,
          ObjectGroupManager::_tao_any_destructor,
          _tc_ObjectGroupManager,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::ObjectGroupManager_ptr _tao_elem)
{
  PortableGroup::ObjectGroupManager_ptr _tao_objptr =
    PortableGroup::ObjectGroupManager::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::ObjectGroupManager_ptr *_tao_elem)
{
  TAO::Any_Impl_T<PortableGroup::ObjectGroupManager>::insert (
      _tao_any,
      PortableGroup::ObjectGroupManager::_tao_any_destructor,
      PortableGroup::_tc_ObjectGroupManager,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::ObjectGroupManager_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<PortableGroup::ObjectGroupManager>::extract (
        _tao_any,
        PortableGroup::ObjectGroupManager::_tao_any_destructor,
        PortableGroup::_tc_ObjectGroupManager,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableGroup::AMI_ObjectGroupManagerHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_ObjectGroupManagerHandler_ptr _tao_elem)
  {
    AMI_ObjectGroupManagerHandler_ptr _tao_objptr =
      AMI_ObjectGroupManagerHandler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_ObjectGroupManagerHandler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AMI_ObjectGroupManagerHandler>::insert (
        _tao_any,
        AMI_ObjectGroupManagerHandler::_tao_any_destructor,
        _tc_AMI_ObjectGroupManagerHandler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMI_ObjectGroupManagerHandler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AMI_ObjectGroupManagerHandler>::extract (
          _tao_any,
          AMI_ObjectGroupManagerHandler::_tao_any_destructor,
          _tc_AMI_ObjectGroupManagerHandler,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::AMI_ObjectGroupManagerHandler_ptr _tao_elem)
{
  PortableGroup::AMI_ObjectGroupManagerHandler_ptr _tao_objptr =
    PortableGroup::AMI_ObjectGroupManagerHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::AMI_ObjectGroupManagerHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<PortableGroup::AMI_ObjectGroupManagerHandler>::insert (
      _tao_any,
      PortableGroup::AMI_ObjectGroupManagerHandler::_tao_any_destructor,
      PortableGroup::_tc_AMI_ObjectGroupManagerHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::AMI_ObjectGroupManagerHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<PortableGroup::AMI_ObjectGroupManagerHandler>::extract (
        _tao_any,
        PortableGroup::AMI_ObjectGroupManagerHandler::_tao_any_destructor,
        PortableGroup::_tc_AMI_ObjectGroupManagerHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableGroup::GenericFactory>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      GenericFactory_ptr _tao_elem)
  {
    GenericFactory_ptr _tao_objptr =
      GenericFactory::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      GenericFactory_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<GenericFactory>::insert (
        _tao_any,
        GenericFactory::_tao_any_destructor,
        _tc_GenericFactory,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      GenericFactory_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<GenericFactory>::extract (
          _tao_any,
          GenericFactory::_tao_any_destructor,
          _tc_GenericFactory,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::GenericFactory_ptr _tao_elem)
{
  PortableGroup::GenericFactory_ptr _tao_objptr =
    PortableGroup::GenericFactory::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::GenericFactory_ptr *_tao_elem)
{
  TAO::Any_Impl_T<PortableGroup::GenericFactory>::insert (
      _tao_any,
      PortableGroup::GenericFactory::_tao_any_destructor,
      PortableGroup::_tc_GenericFactory,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::GenericFactory_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<PortableGroup::GenericFactory>::extract (
        _tao_any,
        PortableGroup::GenericFactory::_tao_any_destructor,
        PortableGroup::_tc_GenericFactory,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableGroup::AMI_GenericFactoryHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_GenericFactoryHandler_ptr _tao_elem)
  {
    AMI_GenericFactoryHandler_ptr _tao_objptr =
      AMI_GenericFactoryHandler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_GenericFactoryHandler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AMI_GenericFactoryHandler>::insert (
        _tao_any,
        AMI_GenericFactoryHandler::_tao_any_destructor,
        _tc_AMI_GenericFactoryHandler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMI_GenericFactoryHandler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AMI_GenericFactoryHandler>::extract (
          _tao_any,
          AMI_GenericFactoryHandler::_tao_any_destructor,
          _tc_AMI_GenericFactoryHandler,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::AMI_GenericFactoryHandler_ptr _tao_elem)
{
  PortableGroup::AMI_GenericFactoryHandler_ptr _tao_objptr =
    PortableGroup::AMI_GenericFactoryHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::AMI_GenericFactoryHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<PortableGroup::AMI_GenericFactoryHandler>::insert (
      _tao_any,
      PortableGroup::AMI_GenericFactoryHandler::_tao_any_destructor,
      PortableGroup::_tc_AMI_GenericFactoryHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::AMI_GenericFactoryHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<PortableGroup::AMI_GenericFactoryHandler>::extract (
        _tao_any,
        PortableGroup::AMI_GenericFactoryHandler::_tao_any_destructor,
        PortableGroup::_tc_AMI_GenericFactoryHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableGroup::FactoryRegistry>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FactoryRegistry_ptr _tao_elem)
  {
    FactoryRegistry_ptr _tao_objptr =
      FactoryRegistry::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FactoryRegistry_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<FactoryRegistry>::insert (
        _tao_any,
        FactoryRegistry::_tao_any_destructor,
        _tc_FactoryRegistry,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      FactoryRegistry_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<FactoryRegistry>::extract (
          _tao_any,
          FactoryRegistry::_tao_any_destructor,
          _tc_FactoryRegistry,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::FactoryRegistry_ptr _tao_elem)
{
  PortableGroup::FactoryRegistry_ptr _tao_objptr =
    PortableGroup::FactoryRegistry::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::FactoryRegistry_ptr *_tao_elem)
{
  TAO::Any_Impl_T<PortableGroup::FactoryRegistry>::insert (
      _tao_any,
      PortableGroup::FactoryRegistry::_tao_any_destructor,
      PortableGroup::_tc_FactoryRegistry,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::FactoryRegistry_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<PortableGroup::FactoryRegistry>::extract (
        _tao_any,
        PortableGroup::FactoryRegistry::_tao_any_destructor,
        PortableGroup::_tc_FactoryRegistry,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableGroup::AMI_FactoryRegistryHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_FactoryRegistryHandler_ptr _tao_elem)
  {
    AMI_FactoryRegistryHandler_ptr _tao_objptr =
      AMI_FactoryRegistryHandler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_FactoryRegistryHandler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AMI_FactoryRegistryHandler>::insert (
        _tao_any,
        AMI_FactoryRegistryHandler::_tao_any_destructor,
        _tc_AMI_FactoryRegistryHandler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMI_FactoryRegistryHandler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AMI_FactoryRegistryHandler>::extract (
          _tao_any,
          AMI_FactoryRegistryHandler::_tao_any_destructor,
          _tc_AMI_FactoryRegistryHandler,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::AMI_FactoryRegistryHandler_ptr _tao_elem)
{
  PortableGroup::AMI_FactoryRegistryHandler_ptr _tao_objptr =
    PortableGroup::AMI_FactoryRegistryHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::AMI_FactoryRegistryHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<PortableGroup::AMI_FactoryRegistryHandler>::insert (
      _tao_any,
      PortableGroup::AMI_FactoryRegistryHandler::_tao_any_destructor,
      PortableGroup::_tc_AMI_FactoryRegistryHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::AMI_FactoryRegistryHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<PortableGroup::AMI_FactoryRegistryHandler>::extract (
        _tao_any,
        PortableGroup::AMI_FactoryRegistryHandler::_tao_any_destructor,
        PortableGroup::_tc_AMI_FactoryRegistryHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableGroup::TAO_UpdateObjectGroup>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      TAO_UpdateObjectGroup_ptr _tao_elem)
  {
    TAO_UpdateObjectGroup_ptr _tao_objptr =
      TAO_UpdateObjectGroup::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      TAO_UpdateObjectGroup_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<TAO_UpdateObjectGroup>::insert (
        _tao_any,
        TAO_UpdateObjectGroup::_tao_any_destructor,
        _tc_TAO_UpdateObjectGroup,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      TAO_UpdateObjectGroup_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<TAO_UpdateObjectGroup>::extract (
          _tao_any,
          TAO_UpdateObjectGroup::_tao_any_destructor,
          _tc_TAO_UpdateObjectGroup,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::TAO_UpdateObjectGroup_ptr _tao_elem)
{
  PortableGroup::TAO_UpdateObjectGroup_ptr _tao_objptr =
    PortableGroup::TAO_UpdateObjectGroup::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::TAO_UpdateObjectGroup_ptr *_tao_elem)
{
  TAO::Any_Impl_T<PortableGroup::TAO_UpdateObjectGroup>::insert (
      _tao_any,
      PortableGroup::TAO_UpdateObjectGroup::_tao_any_destructor,
      PortableGroup::_tc_TAO_UpdateObjectGroup,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::TAO_UpdateObjectGroup_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<PortableGroup::TAO_UpdateObjectGroup>::extract (
        _tao_any,
        PortableGroup::TAO_UpdateObjectGroup::_tao_any_destructor,
        PortableGroup::_tc_TAO_UpdateObjectGroup,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableGroup::AMI_TAO_UpdateObjectGroupHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_TAO_UpdateObjectGroupHandler_ptr _tao_elem)
  {
    AMI_TAO_UpdateObjectGroupHandler_ptr _tao_objptr =
      AMI_TAO_UpdateObjectGroupHandler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_TAO_UpdateObjectGroupHandler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AMI_TAO_UpdateObjectGroupHandler>::insert (
        _tao_any,
        AMI_TAO_UpdateObjectGroupHandler::_tao_any_destructor,
        _tc_AMI_TAO_UpdateObjectGroupHandler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMI_TAO_UpdateObjectGroupHandler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AMI_TAO_UpdateObjectGroupHandler>::extract (
          _tao_any,
          AMI_TAO_UpdateObjectGroupHandler::_tao_any_destructor,
          _tc_AMI_TAO_UpdateObjectGroupHandler,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr _tao_elem)
{
  PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr _tao_objptr =
    PortableGroup::AMI_TAO_UpdateObjectGroupHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<PortableGroup::AMI_TAO_UpdateObjectGroupHandler>::insert (
      _tao_any,
      PortableGroup::AMI_TAO_UpdateObjectGroupHandler::_tao_any_destructor,
      PortableGroup::_tc_AMI_TAO_UpdateObjectGroupHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<PortableGroup::AMI_TAO_UpdateObjectGroupHandler>::extract (
        _tao_any,
        PortableGroup::AMI_TAO_UpdateObjectGroupHandler::_tao_any_destructor,
        PortableGroup::_tc_AMI_TAO_UpdateObjectGroupHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<PortableGroup::NotAGroupObject>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::NotAGroupObject &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::NotAGroupObject>::insert_copy (
        _tao_any,
        ::PortableGroup::NotAGroupObject::_tao_any_destructor,
        ::PortableGroup::_tc_NotAGroupObject,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::NotAGroupObject *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::NotAGroupObject>::insert (
        _tao_any,
        ::PortableGroup::NotAGroupObject::_tao_any_destructor,
        ::PortableGroup::_tc_NotAGroupObject,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::NotAGroupObject *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::NotAGroupObject *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::NotAGroupObject *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::NotAGroupObject>::extract (
          _tao_any,
          ::PortableGroup::NotAGroupObject::_tao_any_destructor,
          ::PortableGroup::_tc_NotAGroupObject,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::NotAGroupObject &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::NotAGroupObject>::insert_copy (
      _tao_any,
      PortableGroup::NotAGroupObject::_tao_any_destructor,
      PortableGroup::_tc_NotAGroupObject,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::NotAGroupObject *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::NotAGroupObject>::insert (
      _tao_any,
      PortableGroup::NotAGroupObject::_tao_any_destructor,
      PortableGroup::_tc_NotAGroupObject,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::NotAGroupObject *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::NotAGroupObject *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::NotAGroupObject *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::NotAGroupObject>::extract (
        _tao_any,
        PortableGroup::NotAGroupObject::_tao_any_destructor,
        PortableGroup::_tc_NotAGroupObject,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableGroup::IDs &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::PortableGroup::IDs *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::PortableGroup::IDs>::insert_copy (
          _tao_any,
          ::PortableGroup::IDs::_tao_any_destructor,
          ::PortableGroup::_tc_IDs,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableGroup::IDs *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableGroup::IDs>::insert (
        _tao_any,
        ::PortableGroup::IDs::_tao_any_destructor,
        ::PortableGroup::_tc_IDs,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableGroup::IDs *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableGroup::IDs *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableGroup::IDs *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableGroup::IDs>::extract (
          _tao_any,
          ::PortableGroup::IDs::_tao_any_destructor,
          ::PortableGroup::_tc_IDs,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableGroup::IDs &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<PortableGroup::IDs *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<PortableGroup::IDs>::insert_copy (
        _tao_any,
        PortableGroup::IDs::_tao_any_destructor,
        PortableGroup::_tc_IDs,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::IDs *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableGroup::IDs>::insert (
      _tao_any,
      PortableGroup::IDs::_tao_any_destructor,
      PortableGroup::_tc_IDs,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::IDs *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableGroup::IDs *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableGroup::IDs *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableGroup::IDs>::extract (
        _tao_any,
        PortableGroup::IDs::_tao_any_destructor,
        PortableGroup::_tc_IDs,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableGroup::GOA>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableGroup::GOA>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableGroup::GOA>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableGroup
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      GOA_ptr _tao_elem)
  {
    GOA_ptr _tao_objptr =
      GOA::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      GOA_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<GOA>::insert (
        _tao_any,
        GOA::_tao_any_destructor,
        _tc_GOA,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      GOA_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<GOA>::extract (
          _tao_any,
          GOA::_tao_any_destructor,
          _tc_GOA,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::GOA_ptr _tao_elem)
{
  PortableGroup::GOA_ptr _tao_objptr =
    PortableGroup::GOA::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableGroup::GOA_ptr *_tao_elem)
{
  TAO::Any_Impl_T<PortableGroup::GOA>::insert (
      _tao_any,
      PortableGroup::GOA::_tao_any_destructor,
      PortableGroup::_tc_GOA,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableGroup::GOA_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<PortableGroup::GOA>::extract (
        _tao_any,
        PortableGroup::GOA::_tao_any_destructor,
        PortableGroup::_tc_GOA,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_PortableGroup_GroupIIOPProfile_CPP_
#define _TAO_CDR_OP_PortableGroup_GroupIIOPProfile_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::GroupIIOPProfile &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::GroupIIOPProfile &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_PortableGroup_GroupIIOPProfile_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_PortableGroup_ObjectGroups_CPP_
#define _TAO_CDR_OP_PortableGroup_ObjectGroups_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::ObjectGroups &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::ObjectGroups &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_PortableGroup_ObjectGroups_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::Property &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.nam) &&
    (strm << _tao_aggregate.val);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::Property &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.nam) &&
    (strm >> _tao_aggregate.val);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_PortableGroup_Properties_CPP_
#define _TAO_CDR_OP_PortableGroup_Properties_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::Properties &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::Properties &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_PortableGroup_Properties_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_PortableGroup_Locations_CPP_
#define _TAO_CDR_OP_PortableGroup_Locations_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::Locations &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::Locations &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_PortableGroup_Locations_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::FactoryInfo &_tao_aggregate)
{
  return
    ::CORBA::Object::marshal (
        _tao_aggregate.the_factory.in (),
        strm
      ) &&
    (strm << _tao_aggregate.the_location) &&
    (strm << _tao_aggregate.the_criteria);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::FactoryInfo &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.the_factory.out ()) &&
    (strm >> _tao_aggregate.the_location) &&
    (strm >> _tao_aggregate.the_criteria);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_PortableGroup_FactoryInfos_CPP_
#define _TAO_CDR_OP_PortableGroup_FactoryInfos_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::FactoryInfos &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::FactoryInfos &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_PortableGroup_FactoryInfos_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::InterfaceNotFound &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    PortableGroup::InterfaceNotFound&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::ObjectGroupNotFound &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    PortableGroup::ObjectGroupNotFound&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::MemberNotFound &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    PortableGroup::MemberNotFound&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::ObjectNotFound &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    PortableGroup::ObjectNotFound&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::MemberAlreadyPresent &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    PortableGroup::MemberAlreadyPresent&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::ObjectNotCreated &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    PortableGroup::ObjectNotCreated&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::ObjectNotAdded &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    PortableGroup::ObjectNotAdded&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::TypeConflict &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    PortableGroup::TypeConflict&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::UnsupportedProperty &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.nam) &&
        (strm << _tao_aggregate.val)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::UnsupportedProperty &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.nam) &&
    (strm >> _tao_aggregate.val)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::InvalidProperty &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.nam) &&
        (strm << _tao_aggregate.val)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::InvalidProperty &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.nam) &&
    (strm >> _tao_aggregate.val)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::NoFactory &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.the_location) &&
        (strm << _tao_aggregate.type_id.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::NoFactory &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.the_location) &&
    (strm >> _tao_aggregate.type_id.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::InvalidCriteria &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.invalid_criteria)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::InvalidCriteria &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.invalid_criteria)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::CannotMeetCriteria &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.unmet_criteria)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::CannotMeetCriteria &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.unmet_criteria)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::PropertyManager_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::PropertyManager_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::PortableGroup::PropertyManager RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        PortableGroup__TAO_PropertyManager_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::AMI_PropertyManagerHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::AMI_PropertyManagerHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::PortableGroup::AMI_PropertyManagerHandler RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        PortableGroup__TAO_AMI_PropertyManagerHandler_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::ObjectGroupManager_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::ObjectGroupManager_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::PortableGroup::ObjectGroupManager RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        PortableGroup__TAO_ObjectGroupManager_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::AMI_ObjectGroupManagerHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::AMI_ObjectGroupManagerHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::PortableGroup::AMI_ObjectGroupManagerHandler RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        PortableGroup__TAO_AMI_ObjectGroupManagerHandler_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::GenericFactory_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::GenericFactory_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::PortableGroup::GenericFactory RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        PortableGroup__TAO_GenericFactory_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::AMI_GenericFactoryHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::AMI_GenericFactoryHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::PortableGroup::AMI_GenericFactoryHandler RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        PortableGroup__TAO_AMI_GenericFactoryHandler_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::FactoryRegistry_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::FactoryRegistry_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::PortableGroup::FactoryRegistry RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        PortableGroup__TAO_FactoryRegistry_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::AMI_FactoryRegistryHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::AMI_FactoryRegistryHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::PortableGroup::AMI_FactoryRegistryHandler RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        PortableGroup__TAO_AMI_FactoryRegistryHandler_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::TAO_UpdateObjectGroup_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::TAO_UpdateObjectGroup_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::PortableGroup::TAO_UpdateObjectGroup RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        PortableGroup__TAO_TAO_UpdateObjectGroup_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::AMI_TAO_UpdateObjectGroupHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::PortableGroup::AMI_TAO_UpdateObjectGroupHandler RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        PortableGroup__TAO_AMI_TAO_UpdateObjectGroupHandler_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::NotAGroupObject &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    PortableGroup::NotAGroupObject&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_PortableGroup_IDs_CPP_
#define _TAO_CDR_OP_PortableGroup_IDs_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableGroup::IDs &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableGroup::IDs &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_PortableGroup_IDs_CPP_ */


TAO_END_VERSIONED_NAMESPACE_DECL


