// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "SecurityC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/CDR.h"
#include "tao/ORB_Core.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"

#if !defined (__ACE_INLINE__)
#include "SecurityC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_SecurityName (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/SecurityName:1.8",
    "SecurityName",
    &CORBA::_tc_string);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_SecurityName =
    &_tao_tc_Security_SecurityName;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_SECURITY_OPAQUE_CS_)
#define _SECURITY_OPAQUE_CS_

Security::Opaque::Opaque (void)
{}

Security::Opaque::Opaque (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

Security::Opaque::Opaque (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

Security::Opaque::Opaque (
    const Opaque &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

Security::Opaque::~Opaque (void)
{}

void Security::Opaque::_tao_any_destructor (
    void * _tao_void_pointer)
{
  Opaque * _tao_tmp_pointer =
    static_cast<Opaque *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_Security_Opaque_GUARD
#define _TAO_TYPECODE_Security_Opaque_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Security_Opaque_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Security_Opaque_0 =
        &Security_Opaque_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_Security_Opaque_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_Opaque (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/Opaque:1.8",
    "Opaque",
    &TAO::TypeCode::tc_Security_Opaque_0);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_Opaque =
    &_tao_tc_Security_Opaque;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Security_ExtensibleFamily[] =
      {
        { "family_definer", &CORBA::_tc_ushort },
        { "family", &CORBA::_tc_ushort }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Security_ExtensibleFamily (
  ::CORBA::tk_struct,
  "IDL:omg.org/Security/ExtensibleFamily:1.8",
  "ExtensibleFamily",
  _tao_fields_Security_ExtensibleFamily,
  2);


namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_ExtensibleFamily =
    &_tao_tc_Security_ExtensibleFamily;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
Security::ExtensibleFamily::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ExtensibleFamily *_tao_tmp_pointer =
    static_cast<ExtensibleFamily *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_SECURITY_OID_CS_)
#define _SECURITY_OID_CS_

Security::OID::OID (void)
{}

Security::OID::OID (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

Security::OID::OID (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

Security::OID::OID (
    const OID &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

Security::OID::~OID (void)
{}

void Security::OID::_tao_any_destructor (
    void * _tao_void_pointer)
{
  OID * _tao_tmp_pointer =
    static_cast<OID *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_Security_OID_GUARD
#define _TAO_TYPECODE_Security_OID_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Security_OID_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Security_OID_0 =
        &Security_OID_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_Security_OID_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_OID (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/OID:1.8",
    "OID",
    &TAO::TypeCode::tc_Security_OID_0);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_OID =
    &_tao_tc_Security_OID;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_SECURITY_OIDLIST_CS_)
#define _SECURITY_OIDLIST_CS_

Security::OIDList::OIDList (void)
{}

Security::OIDList::OIDList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        OID
      > (max)
{}

Security::OIDList::OIDList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Security::OID * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        OID
      >
    (max, length, buffer, release)
{}

Security::OIDList::OIDList (
    const OIDList &seq)
  : ::TAO::unbounded_value_sequence<
        OID
      > (seq)
{}

Security::OIDList::~OIDList (void)
{}

void Security::OIDList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  OIDList * _tao_tmp_pointer =
    static_cast<OIDList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_Security_OIDList_GUARD
#define _TAO_TYPECODE_Security_OIDList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Security_OIDList_0 (
          ::CORBA::tk_sequence,
          &Security::_tc_OID,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Security_OIDList_0 =
        &Security_OIDList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_Security_OIDList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_OIDList (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/OIDList:1.8",
    "OIDList",
    &TAO::TypeCode::tc_Security_OIDList_0);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_OIDList =
    &_tao_tc_Security_OIDList;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_SecurityAttributeType (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/SecurityAttributeType:1.8",
    "SecurityAttributeType",
    &CORBA::_tc_ulong);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_SecurityAttributeType =
    &_tao_tc_Security_SecurityAttributeType;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Security_AttributeType[] =
      {
        { "attribute_family", &Security::_tc_ExtensibleFamily },
        { "attribute_type", &Security::_tc_SecurityAttributeType }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Security_AttributeType (
  ::CORBA::tk_struct,
  "IDL:omg.org/Security/AttributeType:1.8",
  "AttributeType",
  _tao_fields_Security_AttributeType,
  2);


namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_AttributeType =
    &_tao_tc_Security_AttributeType;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
Security::AttributeType::_tao_any_destructor (
    void *_tao_void_pointer)
{
  AttributeType *_tao_tmp_pointer =
    static_cast<AttributeType *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_SECURITY_ATTRIBUTETYPELIST_CS_)
#define _SECURITY_ATTRIBUTETYPELIST_CS_

Security::AttributeTypeList::AttributeTypeList (void)
{}

Security::AttributeTypeList::AttributeTypeList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        AttributeType
      > (max)
{}

Security::AttributeTypeList::AttributeTypeList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Security::AttributeType * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        AttributeType
      >
    (max, length, buffer, release)
{}

Security::AttributeTypeList::AttributeTypeList (
    const AttributeTypeList &seq)
  : ::TAO::unbounded_value_sequence<
        AttributeType
      > (seq)
{}

Security::AttributeTypeList::~AttributeTypeList (void)
{}

void Security::AttributeTypeList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  AttributeTypeList * _tao_tmp_pointer =
    static_cast<AttributeTypeList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_Security_AttributeTypeList_GUARD
#define _TAO_TYPECODE_Security_AttributeTypeList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Security_AttributeTypeList_0 (
          ::CORBA::tk_sequence,
          &Security::_tc_AttributeType,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Security_AttributeTypeList_0 =
        &Security_AttributeTypeList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_Security_AttributeTypeList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_AttributeTypeList (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/AttributeTypeList:1.8",
    "AttributeTypeList",
    &TAO::TypeCode::tc_Security_AttributeTypeList_0);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_AttributeTypeList =
    &_tao_tc_Security_AttributeTypeList;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Security_SecAttribute[] =
      {
        { "attribute_type", &Security::_tc_AttributeType },
        { "defining_authority", &Security::_tc_OID },
        { "value", &Security::_tc_Opaque }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Security_SecAttribute (
  ::CORBA::tk_struct,
  "IDL:omg.org/Security/SecAttribute:1.8",
  "SecAttribute",
  _tao_fields_Security_SecAttribute,
  3);


namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_SecAttribute =
    &_tao_tc_Security_SecAttribute;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
Security::SecAttribute::_tao_any_destructor (
    void *_tao_void_pointer)
{
  SecAttribute *_tao_tmp_pointer =
    static_cast<SecAttribute *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_SECURITY_ATTRIBUTELIST_CS_)
#define _SECURITY_ATTRIBUTELIST_CS_

Security::AttributeList::AttributeList (void)
{}

Security::AttributeList::AttributeList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        SecAttribute
      > (max)
{}

Security::AttributeList::AttributeList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Security::SecAttribute * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        SecAttribute
      >
    (max, length, buffer, release)
{}

Security::AttributeList::AttributeList (
    const AttributeList &seq)
  : ::TAO::unbounded_value_sequence<
        SecAttribute
      > (seq)
{}

Security::AttributeList::~AttributeList (void)
{}

void Security::AttributeList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  AttributeList * _tao_tmp_pointer =
    static_cast<AttributeList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_Security_AttributeList_GUARD
#define _TAO_TYPECODE_Security_AttributeList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Security_AttributeList_0 (
          ::CORBA::tk_sequence,
          &Security::_tc_SecAttribute,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Security_AttributeList_0 =
        &Security_AttributeList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_Security_AttributeList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_AttributeList (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/AttributeList:1.8",
    "AttributeList",
    &TAO::TypeCode::tc_Security_AttributeList_0);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_AttributeList =
    &_tao_tc_Security_AttributeList;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_AuthenticationStatus[] =
  {
    "SecAuthSuccess",
    "SecAuthFailure",
    "SecAuthContinue",
    "SecAuthExpired"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_AuthenticationStatus (
    "IDL:omg.org/Security/AuthenticationStatus:1.8",
    "AuthenticationStatus",
    _tao_enumerators_Security_AuthenticationStatus,
    4);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_AuthenticationStatus =
    &_tao_tc_Security_AuthenticationStatus;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_AssociationStatus[] =
  {
    "SecAssocSuccess",
    "SecAssocFailure",
    "SecAssocContinue"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_AssociationStatus (
    "IDL:omg.org/Security/AssociationStatus:1.8",
    "AssociationStatus",
    _tao_enumerators_Security_AssociationStatus,
    3);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_AssociationStatus =
    &_tao_tc_Security_AssociationStatus;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_AuthenticationMethod (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/AuthenticationMethod:1.8",
    "AuthenticationMethod",
    &CORBA::_tc_ulong);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_AuthenticationMethod =
    &_tao_tc_Security_AuthenticationMethod;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_SECURITY_AUTHENTICATIONMETHODLIST_CS_)
#define _SECURITY_AUTHENTICATIONMETHODLIST_CS_

Security::AuthenticationMethodList::AuthenticationMethodList (void)
{}

Security::AuthenticationMethodList::AuthenticationMethodList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        AuthenticationMethod
      > (max)
{}

Security::AuthenticationMethodList::AuthenticationMethodList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::ULong * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        AuthenticationMethod
      >
    (max, length, buffer, release)
{}

Security::AuthenticationMethodList::AuthenticationMethodList (
    const AuthenticationMethodList &seq)
  : ::TAO::unbounded_value_sequence<
        AuthenticationMethod
      > (seq)
{}

Security::AuthenticationMethodList::~AuthenticationMethodList (void)
{}

void Security::AuthenticationMethodList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  AuthenticationMethodList * _tao_tmp_pointer =
    static_cast<AuthenticationMethodList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_Security_AuthenticationMethodList_GUARD
#define _TAO_TYPECODE_Security_AuthenticationMethodList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Security_AuthenticationMethodList_0 (
          ::CORBA::tk_sequence,
          &Security::_tc_AuthenticationMethod,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Security_AuthenticationMethodList_0 =
        &Security_AuthenticationMethodList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_Security_AuthenticationMethodList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_AuthenticationMethodList (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/AuthenticationMethodList:1.8",
    "AuthenticationMethodList",
    &TAO::TypeCode::tc_Security_AuthenticationMethodList_0);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_AuthenticationMethodList =
    &_tao_tc_Security_AuthenticationMethodList;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_InvocationCredentialsType[] =
  {
    "SecOwnCredentials",
    "SecReceivedCredentials",
    "SecTargetCredentials"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_InvocationCredentialsType (
    "IDL:omg.org/Security/InvocationCredentialsType:1.8",
    "InvocationCredentialsType",
    _tao_enumerators_Security_InvocationCredentialsType,
    3);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_InvocationCredentialsType =
    &_tao_tc_Security_InvocationCredentialsType;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Security_Right[] =
      {
        { "rights_family", &Security::_tc_ExtensibleFamily },
        { "the_right", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Security_Right (
  ::CORBA::tk_struct,
  "IDL:omg.org/Security/Right:1.8",
  "Right",
  _tao_fields_Security_Right,
  2);


namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_Right =
    &_tao_tc_Security_Right;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
Security::Right::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Right *_tao_tmp_pointer =
    static_cast<Right *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_SECURITY_RIGHTSLIST_CS_)
#define _SECURITY_RIGHTSLIST_CS_

Security::RightsList::RightsList (void)
{}

Security::RightsList::RightsList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Right
      > (max)
{}

Security::RightsList::RightsList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Security::Right * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Right
      >
    (max, length, buffer, release)
{}

Security::RightsList::RightsList (
    const RightsList &seq)
  : ::TAO::unbounded_value_sequence<
        Right
      > (seq)
{}

Security::RightsList::~RightsList (void)
{}

void Security::RightsList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  RightsList * _tao_tmp_pointer =
    static_cast<RightsList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_Security_RightsList_GUARD
#define _TAO_TYPECODE_Security_RightsList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Security_RightsList_0 (
          ::CORBA::tk_sequence,
          &Security::_tc_Right,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Security_RightsList_0 =
        &Security_RightsList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_Security_RightsList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_RightsList (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/RightsList:1.8",
    "RightsList",
    &TAO::TypeCode::tc_Security_RightsList_0);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_RightsList =
    &_tao_tc_Security_RightsList;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_RightsCombinator[] =
  {
    "SecAllRights",
    "SecAnyRight"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_RightsCombinator (
    "IDL:omg.org/Security/RightsCombinator:1.8",
    "RightsCombinator",
    _tao_enumerators_Security_RightsCombinator,
    2);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_RightsCombinator =
    &_tao_tc_Security_RightsCombinator;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_DelegationState[] =
  {
    "SecInitiator",
    "SecDelegate"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_DelegationState (
    "IDL:omg.org/Security/DelegationState:1.8",
    "DelegationState",
    _tao_enumerators_Security_DelegationState,
    2);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_DelegationState =
    &_tao_tc_Security_DelegationState;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_DelegationDirective[] =
  {
    "Delegate",
    "NoDelegate"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_DelegationDirective (
    "IDL:omg.org/Security/DelegationDirective:1.8",
    "DelegationDirective",
    _tao_enumerators_Security_DelegationDirective,
    2);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_DelegationDirective =
    &_tao_tc_Security_DelegationDirective;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_UtcT (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/UtcT:1.8",
    "UtcT",
    &TimeBase::_tc_UtcT);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_UtcT =
    &_tao_tc_Security_UtcT;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_IntervalT (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/IntervalT:1.8",
    "IntervalT",
    &TimeBase::_tc_IntervalT);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_IntervalT =
    &_tao_tc_Security_IntervalT;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_TimeT (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/TimeT:1.8",
    "TimeT",
    &TimeBase::_tc_TimeT);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_TimeT =
    &_tao_tc_Security_TimeT;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_SecurityFeature[] =
  {
    "SecNoDelegation",
    "SecSimpleDelegation",
    "SecCompositeDelegation",
    "SecNoProtection",
    "SecIntegrity",
    "SecConfidentiality",
    "SecIntegrityAndConfidentiality",
    "SecDetectReplay",
    "SecDetectMisordering",
    "SecEstablishTrustInTarget",
    "SecEstablishTrustInClient"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_SecurityFeature (
    "IDL:omg.org/Security/SecurityFeature:1.8",
    "SecurityFeature",
    _tao_enumerators_Security_SecurityFeature,
    11);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_SecurityFeature =
    &_tao_tc_Security_SecurityFeature;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_QOP[] =
  {
    "SecQOPNoProtection",
    "SecQOPIntegrity",
    "SecQOPConfidentiality",
    "SecQOPIntegrityAndConfidentiality"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_QOP (
    "IDL:omg.org/Security/QOP:1.8",
    "QOP",
    _tao_enumerators_Security_QOP,
    4);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_QOP =
    &_tao_tc_Security_QOP;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_SecurityContextType[] =
  {
    "SecClientSecurityContext",
    "SecServerSecurityContext"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_SecurityContextType (
    "IDL:omg.org/Security/SecurityContextType:1.8",
    "SecurityContextType",
    _tao_enumerators_Security_SecurityContextType,
    2);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_SecurityContextType =
    &_tao_tc_Security_SecurityContextType;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_SecurityContextState[] =
  {
    "SecContextInitialized",
    "SecContextContinued",
    "SecContextClientEstablished",
    "SecContextEstablished",
    "SecContextEstablishExpired",
    "SecContextExpired",
    "SecContextInvalid"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_SecurityContextState (
    "IDL:omg.org/Security/SecurityContextState:1.8",
    "SecurityContextState",
    _tao_enumerators_Security_SecurityContextState,
    7);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_SecurityContextState =
    &_tao_tc_Security_SecurityContextState;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Security_ChannelBindings[] =
      {
        { "initiator_addrtype", &CORBA::_tc_ulong },
        { "initiator_address", &CORBA::_tc_OctetSeq },
        { "acceptor_addrtype", &CORBA::_tc_ulong },
        { "acceptor_address", &CORBA::_tc_OctetSeq },
        { "application_data", &CORBA::_tc_OctetSeq }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Security_ChannelBindings (
  ::CORBA::tk_struct,
  "IDL:omg.org/Security/ChannelBindings:1.8",
  "ChannelBindings",
  _tao_fields_Security_ChannelBindings,
  5);


namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_ChannelBindings =
    &_tao_tc_Security_ChannelBindings;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
Security::ChannelBindings::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ChannelBindings *_tao_tmp_pointer =
    static_cast<ChannelBindings *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Security_OpaqueBuffer[] =
      {
        { "buffer", &Security::_tc_Opaque },
        { "startpos", &CORBA::_tc_ulong },
        { "endpos", &CORBA::_tc_ulong }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Security_OpaqueBuffer (
  ::CORBA::tk_struct,
  "IDL:omg.org/Security/OpaqueBuffer:1.8",
  "OpaqueBuffer",
  _tao_fields_Security_OpaqueBuffer,
  3);


namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_OpaqueBuffer =
    &_tao_tc_Security_OpaqueBuffer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
Security::OpaqueBuffer::_tao_any_destructor (
    void *_tao_void_pointer)
{
  OpaqueBuffer *_tao_tmp_pointer =
    static_cast<OpaqueBuffer *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_AssociationOptions (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/AssociationOptions:1.8",
    "AssociationOptions",
    &CORBA::_tc_ushort);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_AssociationOptions =
    &_tao_tc_Security_AssociationOptions;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_RequiresSupports[] =
  {
    "SecRequires",
    "SecSupports"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_RequiresSupports (
    "IDL:omg.org/Security/RequiresSupports:1.8",
    "RequiresSupports",
    _tao_enumerators_Security_RequiresSupports,
    2);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_RequiresSupports =
    &_tao_tc_Security_RequiresSupports;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_CommunicationDirection[] =
  {
    "SecDirectionBoth",
    "SecDirectionRequest",
    "SecDirectionReply"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_CommunicationDirection (
    "IDL:omg.org/Security/CommunicationDirection:1.8",
    "CommunicationDirection",
    _tao_enumerators_Security_CommunicationDirection,
    3);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_CommunicationDirection =
    &_tao_tc_Security_CommunicationDirection;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_MechanismType (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/MechanismType:1.8",
    "MechanismType",
    &CORBA::_tc_string);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_MechanismType =
    &_tao_tc_Security_MechanismType;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_SECURITY_MECHANISMTYPELIST_CS_)
#define _SECURITY_MECHANISMTYPELIST_CS_

Security::MechanismTypeList::MechanismTypeList (void)
{}

Security::MechanismTypeList::MechanismTypeList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_basic_string_sequence<char> (max)
{}

Security::MechanismTypeList::MechanismTypeList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Char * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_basic_string_sequence<char>
    (max, length, buffer, release)
{}

Security::MechanismTypeList::MechanismTypeList (
    const MechanismTypeList &seq)
  : ::TAO::unbounded_basic_string_sequence<char> (seq)
{}

Security::MechanismTypeList::~MechanismTypeList (void)
{}

void Security::MechanismTypeList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  MechanismTypeList * _tao_tmp_pointer =
    static_cast<MechanismTypeList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_Security_MechanismTypeList_GUARD
#define _TAO_TYPECODE_Security_MechanismTypeList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Security_MechanismTypeList_0 (
          ::CORBA::tk_sequence,
          &Security::_tc_MechanismType,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Security_MechanismTypeList_0 =
        &Security_MechanismTypeList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_Security_MechanismTypeList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_MechanismTypeList (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/MechanismTypeList:1.8",
    "MechanismTypeList",
    &TAO::TypeCode::tc_Security_MechanismTypeList_0);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_MechanismTypeList =
    &_tao_tc_Security_MechanismTypeList;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Security_OptionsDirectionPair[] =
      {
        { "options", &Security::_tc_AssociationOptions },
        { "direction", &Security::_tc_CommunicationDirection }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Security_OptionsDirectionPair (
  ::CORBA::tk_struct,
  "IDL:omg.org/Security/OptionsDirectionPair:1.8",
  "OptionsDirectionPair",
  _tao_fields_Security_OptionsDirectionPair,
  2);


namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_OptionsDirectionPair =
    &_tao_tc_Security_OptionsDirectionPair;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
Security::OptionsDirectionPair::_tao_any_destructor (
    void *_tao_void_pointer)
{
  OptionsDirectionPair *_tao_tmp_pointer =
    static_cast<OptionsDirectionPair *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_SECURITY_OPTIONSDIRECTIONPAIRLIST_CS_)
#define _SECURITY_OPTIONSDIRECTIONPAIRLIST_CS_

Security::OptionsDirectionPairList::OptionsDirectionPairList (void)
{}

Security::OptionsDirectionPairList::OptionsDirectionPairList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        OptionsDirectionPair
      > (max)
{}

Security::OptionsDirectionPairList::OptionsDirectionPairList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Security::OptionsDirectionPair * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        OptionsDirectionPair
      >
    (max, length, buffer, release)
{}

Security::OptionsDirectionPairList::OptionsDirectionPairList (
    const OptionsDirectionPairList &seq)
  : ::TAO::unbounded_value_sequence<
        OptionsDirectionPair
      > (seq)
{}

Security::OptionsDirectionPairList::~OptionsDirectionPairList (void)
{}

void Security::OptionsDirectionPairList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  OptionsDirectionPairList * _tao_tmp_pointer =
    static_cast<OptionsDirectionPairList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_Security_OptionsDirectionPairList_GUARD
#define _TAO_TYPECODE_Security_OptionsDirectionPairList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Security_OptionsDirectionPairList_0 (
          ::CORBA::tk_sequence,
          &Security::_tc_OptionsDirectionPair,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Security_OptionsDirectionPairList_0 =
        &Security_OptionsDirectionPairList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_Security_OptionsDirectionPairList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_OptionsDirectionPairList (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/OptionsDirectionPairList:1.8",
    "OptionsDirectionPairList",
    &TAO::TypeCode::tc_Security_OptionsDirectionPairList_0);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_OptionsDirectionPairList =
    &_tao_tc_Security_OptionsDirectionPairList;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_DelegationMode[] =
  {
    "SecDelModeNoDelegation",
    "SecDelModeSimpleDelegation",
    "SecDelModeCompositeDelegation"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_DelegationMode (
    "IDL:omg.org/Security/DelegationMode:1.8",
    "DelegationMode",
    _tao_enumerators_Security_DelegationMode,
    3);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_DelegationMode =
    &_tao_tc_Security_DelegationMode;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Security_MechandOptions[] =
      {
        { "mechanism_type", &Security::_tc_MechanismType },
        { "options_supported", &Security::_tc_AssociationOptions }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Security_MechandOptions (
  ::CORBA::tk_struct,
  "IDL:omg.org/Security/MechandOptions:1.8",
  "MechandOptions",
  _tao_fields_Security_MechandOptions,
  2);


namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_MechandOptions =
    &_tao_tc_Security_MechandOptions;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
Security::MechandOptions::_tao_any_destructor (
    void *_tao_void_pointer)
{
  MechandOptions *_tao_tmp_pointer =
    static_cast<MechandOptions *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_SECURITY_MECHANDOPTIONSLIST_CS_)
#define _SECURITY_MECHANDOPTIONSLIST_CS_

Security::MechandOptionsList::MechandOptionsList (void)
{}

Security::MechandOptionsList::MechandOptionsList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        MechandOptions
      > (max)
{}

Security::MechandOptionsList::MechandOptionsList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Security::MechandOptions * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        MechandOptions
      >
    (max, length, buffer, release)
{}

Security::MechandOptionsList::MechandOptionsList (
    const MechandOptionsList &seq)
  : ::TAO::unbounded_value_sequence<
        MechandOptions
      > (seq)
{}

Security::MechandOptionsList::~MechandOptionsList (void)
{}

void Security::MechandOptionsList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  MechandOptionsList * _tao_tmp_pointer =
    static_cast<MechandOptionsList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_Security_MechandOptionsList_GUARD
#define _TAO_TYPECODE_Security_MechandOptionsList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Security_MechandOptionsList_0 (
          ::CORBA::tk_sequence,
          &Security::_tc_MechandOptions,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Security_MechandOptionsList_0 =
        &Security_MechandOptionsList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_Security_MechandOptionsList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_MechandOptionsList (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/MechandOptionsList:1.8",
    "MechandOptionsList",
    &TAO::TypeCode::tc_Security_MechandOptionsList_0);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_MechandOptionsList =
    &_tao_tc_Security_MechandOptionsList;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Security_EstablishTrust[] =
      {
        { "trust_in_client", &CORBA::_tc_boolean },
        { "trust_in_target", &CORBA::_tc_boolean }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Security_EstablishTrust (
  ::CORBA::tk_struct,
  "IDL:omg.org/Security/EstablishTrust:1.8",
  "EstablishTrust",
  _tao_fields_Security_EstablishTrust,
  2);


namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_EstablishTrust =
    &_tao_tc_Security_EstablishTrust;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
Security::EstablishTrust::_tao_any_destructor (
    void *_tao_void_pointer)
{
  EstablishTrust *_tao_tmp_pointer =
    static_cast<EstablishTrust *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_AuditChannelId (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/AuditChannelId:1.8",
    "AuditChannelId",
    &CORBA::_tc_ulong);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_AuditChannelId =
    &_tao_tc_Security_AuditChannelId;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_EventType (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/EventType:1.8",
    "EventType",
    &CORBA::_tc_ushort);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_EventType =
    &_tao_tc_Security_EventType;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_DayOfTheWeek[] =
  {
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Sunday"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_DayOfTheWeek (
    "IDL:omg.org/Security/DayOfTheWeek:1.8",
    "DayOfTheWeek",
    _tao_enumerators_Security_DayOfTheWeek,
    7);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_DayOfTheWeek =
    &_tao_tc_Security_DayOfTheWeek;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Security_AuditCombinator[] =
  {
    "SecAllSelectors",
    "SecAnySelector"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Security_AuditCombinator (
    "IDL:omg.org/Security/AuditCombinator:1.8",
    "AuditCombinator",
    _tao_enumerators_Security_AuditCombinator,
    2);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_AuditCombinator =
    &_tao_tc_Security_AuditCombinator;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Security_AuditEventType[] =
      {
        { "event_family", &Security::_tc_ExtensibleFamily },
        { "event_type", &Security::_tc_EventType }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Security_AuditEventType (
  ::CORBA::tk_struct,
  "IDL:omg.org/Security/AuditEventType:1.8",
  "AuditEventType",
  _tao_fields_Security_AuditEventType,
  2);


namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_AuditEventType =
    &_tao_tc_Security_AuditEventType;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
Security::AuditEventType::_tao_any_destructor (
    void *_tao_void_pointer)
{
  AuditEventType *_tao_tmp_pointer =
    static_cast<AuditEventType *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_SECURITY_AUDITEVENTTYPELIST_CS_)
#define _SECURITY_AUDITEVENTTYPELIST_CS_

Security::AuditEventTypeList::AuditEventTypeList (void)
{}

Security::AuditEventTypeList::AuditEventTypeList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        AuditEventType
      > (max)
{}

Security::AuditEventTypeList::AuditEventTypeList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Security::AuditEventType * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        AuditEventType
      >
    (max, length, buffer, release)
{}

Security::AuditEventTypeList::AuditEventTypeList (
    const AuditEventTypeList &seq)
  : ::TAO::unbounded_value_sequence<
        AuditEventType
      > (seq)
{}

Security::AuditEventTypeList::~AuditEventTypeList (void)
{}

void Security::AuditEventTypeList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  AuditEventTypeList * _tao_tmp_pointer =
    static_cast<AuditEventTypeList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_Security_AuditEventTypeList_GUARD
#define _TAO_TYPECODE_Security_AuditEventTypeList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Security_AuditEventTypeList_0 (
          ::CORBA::tk_sequence,
          &Security::_tc_AuditEventType,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Security_AuditEventTypeList_0 =
        &Security_AuditEventTypeList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_Security_AuditEventTypeList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_AuditEventTypeList (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/AuditEventTypeList:1.8",
    "AuditEventTypeList",
    &TAO::TypeCode::tc_Security_AuditEventTypeList_0);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_AuditEventTypeList =
    &_tao_tc_Security_AuditEventTypeList;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_SelectorType (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/SelectorType:1.8",
    "SelectorType",
    &CORBA::_tc_ulong);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_SelectorType =
    &_tao_tc_Security_SelectorType;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Security_SelectorValue[] =
      {
        { "selector", &Security::_tc_SelectorType },
        { "value", &CORBA::_tc_any }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Security_SelectorValue (
  ::CORBA::tk_struct,
  "IDL:omg.org/Security/SelectorValue:1.8",
  "SelectorValue",
  _tao_fields_Security_SelectorValue,
  2);


namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_SelectorValue =
    &_tao_tc_Security_SelectorValue;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
Security::SelectorValue::_tao_any_destructor (
    void *_tao_void_pointer)
{
  SelectorValue *_tao_tmp_pointer =
    static_cast<SelectorValue *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_SECURITY_SELECTORVALUELIST_CS_)
#define _SECURITY_SELECTORVALUELIST_CS_

Security::SelectorValueList::SelectorValueList (void)
{}

Security::SelectorValueList::SelectorValueList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        SelectorValue
      > (max)
{}

Security::SelectorValueList::SelectorValueList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Security::SelectorValue * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        SelectorValue
      >
    (max, length, buffer, release)
{}

Security::SelectorValueList::SelectorValueList (
    const SelectorValueList &seq)
  : ::TAO::unbounded_value_sequence<
        SelectorValue
      > (seq)
{}

Security::SelectorValueList::~SelectorValueList (void)
{}

void Security::SelectorValueList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  SelectorValueList * _tao_tmp_pointer =
    static_cast<SelectorValueList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_Security_SelectorValueList_GUARD
#define _TAO_TYPECODE_Security_SelectorValueList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Security_SelectorValueList_0 (
          ::CORBA::tk_sequence,
          &Security::_tc_SelectorValue,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Security_SelectorValueList_0 =
        &Security_SelectorValueList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_Security_SelectorValueList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Security_SelectorValueList (
    ::CORBA::tk_alias,
    "IDL:omg.org/Security/SelectorValueList:1.8",
    "SelectorValueList",
    &TAO::TypeCode::tc_Security_SelectorValueList_0);
  

namespace Security
{
  ::CORBA::TypeCode_ptr const _tc_SelectorValueList =
    &_tao_tc_Security_SelectorValueList;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::Opaque &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::Opaque *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::Opaque>::insert_copy (
          _tao_any,
          ::Security::Opaque::_tao_any_destructor,
          ::Security::_tc_Opaque,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::Opaque *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::Opaque>::insert (
        _tao_any,
        ::Security::Opaque::_tao_any_destructor,
        ::Security::_tc_Opaque,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::Opaque *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::Opaque *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::Opaque *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::Opaque>::extract (
          _tao_any,
          ::Security::Opaque::_tao_any_destructor,
          ::Security::_tc_Opaque,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::Opaque &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::Opaque *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::Opaque>::insert_copy (
        _tao_any,
        Security::Opaque::_tao_any_destructor,
        Security::_tc_Opaque,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::Opaque *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::Opaque>::insert (
      _tao_any,
      Security::Opaque::_tao_any_destructor,
      Security::_tc_Opaque,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::Opaque *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::Opaque *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::Opaque *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::Opaque>::extract (
        _tao_any,
        Security::Opaque::_tao_any_destructor,
        Security::_tc_Opaque,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::ExtensibleFamily &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::ExtensibleFamily *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::ExtensibleFamily>::insert_copy (
          _tao_any,
          ::Security::ExtensibleFamily::_tao_any_destructor,
          ::Security::_tc_ExtensibleFamily,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      Security::ExtensibleFamily *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::ExtensibleFamily>::insert (
        _tao_any,
        ::Security::ExtensibleFamily::_tao_any_destructor,
        ::Security::_tc_ExtensibleFamily,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::ExtensibleFamily *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::ExtensibleFamily *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::ExtensibleFamily *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::ExtensibleFamily>::extract (
          _tao_any,
          ::Security::ExtensibleFamily::_tao_any_destructor,
          ::Security::_tc_ExtensibleFamily,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::ExtensibleFamily &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::ExtensibleFamily *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::ExtensibleFamily>::insert_copy (
        _tao_any,
        Security::ExtensibleFamily::_tao_any_destructor,
        Security::_tc_ExtensibleFamily,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::ExtensibleFamily *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::ExtensibleFamily>::insert (
      _tao_any,
      Security::ExtensibleFamily::_tao_any_destructor,
      Security::_tc_ExtensibleFamily,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::ExtensibleFamily *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::ExtensibleFamily *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::ExtensibleFamily *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::ExtensibleFamily>::extract (
        _tao_any,
        Security::ExtensibleFamily::_tao_any_destructor,
        Security::_tc_ExtensibleFamily,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::OID &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::OID *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::OID>::insert_copy (
          _tao_any,
          ::Security::OID::_tao_any_destructor,
          ::Security::_tc_OID,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::OID *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::OID>::insert (
        _tao_any,
        ::Security::OID::_tao_any_destructor,
        ::Security::_tc_OID,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::OID *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::OID *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::OID *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::OID>::extract (
          _tao_any,
          ::Security::OID::_tao_any_destructor,
          ::Security::_tc_OID,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::OID &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::OID *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::OID>::insert_copy (
        _tao_any,
        Security::OID::_tao_any_destructor,
        Security::_tc_OID,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::OID *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::OID>::insert (
      _tao_any,
      Security::OID::_tao_any_destructor,
      Security::_tc_OID,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::OID *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::OID *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::OID *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::OID>::extract (
        _tao_any,
        Security::OID::_tao_any_destructor,
        Security::_tc_OID,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::OIDList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::OIDList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::OIDList>::insert_copy (
          _tao_any,
          ::Security::OIDList::_tao_any_destructor,
          ::Security::_tc_OIDList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::OIDList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::OIDList>::insert (
        _tao_any,
        ::Security::OIDList::_tao_any_destructor,
        ::Security::_tc_OIDList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::OIDList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::OIDList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::OIDList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::OIDList>::extract (
          _tao_any,
          ::Security::OIDList::_tao_any_destructor,
          ::Security::_tc_OIDList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::OIDList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::OIDList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::OIDList>::insert_copy (
        _tao_any,
        Security::OIDList::_tao_any_destructor,
        Security::_tc_OIDList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::OIDList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::OIDList>::insert (
      _tao_any,
      Security::OIDList::_tao_any_destructor,
      Security::_tc_OIDList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::OIDList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::OIDList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::OIDList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::OIDList>::extract (
        _tao_any,
        Security::OIDList::_tao_any_destructor,
        Security::_tc_OIDList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::AttributeType &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::AttributeType *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::AttributeType>::insert_copy (
          _tao_any,
          ::Security::AttributeType::_tao_any_destructor,
          ::Security::_tc_AttributeType,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      Security::AttributeType *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::AttributeType>::insert (
        _tao_any,
        ::Security::AttributeType::_tao_any_destructor,
        ::Security::_tc_AttributeType,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::AttributeType *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::AttributeType *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::AttributeType *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::AttributeType>::extract (
          _tao_any,
          ::Security::AttributeType::_tao_any_destructor,
          ::Security::_tc_AttributeType,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::AttributeType &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::AttributeType *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::AttributeType>::insert_copy (
        _tao_any,
        Security::AttributeType::_tao_any_destructor,
        Security::_tc_AttributeType,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::AttributeType *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::AttributeType>::insert (
      _tao_any,
      Security::AttributeType::_tao_any_destructor,
      Security::_tc_AttributeType,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::AttributeType *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::AttributeType *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::AttributeType *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::AttributeType>::extract (
        _tao_any,
        Security::AttributeType::_tao_any_destructor,
        Security::_tc_AttributeType,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::AttributeTypeList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::AttributeTypeList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::AttributeTypeList>::insert_copy (
          _tao_any,
          ::Security::AttributeTypeList::_tao_any_destructor,
          ::Security::_tc_AttributeTypeList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::AttributeTypeList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::AttributeTypeList>::insert (
        _tao_any,
        ::Security::AttributeTypeList::_tao_any_destructor,
        ::Security::_tc_AttributeTypeList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::AttributeTypeList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::AttributeTypeList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::AttributeTypeList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::AttributeTypeList>::extract (
          _tao_any,
          ::Security::AttributeTypeList::_tao_any_destructor,
          ::Security::_tc_AttributeTypeList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::AttributeTypeList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::AttributeTypeList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::AttributeTypeList>::insert_copy (
        _tao_any,
        Security::AttributeTypeList::_tao_any_destructor,
        Security::_tc_AttributeTypeList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::AttributeTypeList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::AttributeTypeList>::insert (
      _tao_any,
      Security::AttributeTypeList::_tao_any_destructor,
      Security::_tc_AttributeTypeList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::AttributeTypeList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::AttributeTypeList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::AttributeTypeList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::AttributeTypeList>::extract (
        _tao_any,
        Security::AttributeTypeList::_tao_any_destructor,
        Security::_tc_AttributeTypeList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::SecAttribute &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::SecAttribute *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::SecAttribute>::insert_copy (
          _tao_any,
          ::Security::SecAttribute::_tao_any_destructor,
          ::Security::_tc_SecAttribute,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      Security::SecAttribute *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::SecAttribute>::insert (
        _tao_any,
        ::Security::SecAttribute::_tao_any_destructor,
        ::Security::_tc_SecAttribute,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::SecAttribute *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::SecAttribute *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::SecAttribute *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::SecAttribute>::extract (
          _tao_any,
          ::Security::SecAttribute::_tao_any_destructor,
          ::Security::_tc_SecAttribute,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::SecAttribute &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::SecAttribute *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::SecAttribute>::insert_copy (
        _tao_any,
        Security::SecAttribute::_tao_any_destructor,
        Security::_tc_SecAttribute,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::SecAttribute *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::SecAttribute>::insert (
      _tao_any,
      Security::SecAttribute::_tao_any_destructor,
      Security::_tc_SecAttribute,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::SecAttribute *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::SecAttribute *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::SecAttribute *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::SecAttribute>::extract (
        _tao_any,
        Security::SecAttribute::_tao_any_destructor,
        Security::_tc_SecAttribute,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::AttributeList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::AttributeList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::AttributeList>::insert_copy (
          _tao_any,
          ::Security::AttributeList::_tao_any_destructor,
          ::Security::_tc_AttributeList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::AttributeList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::AttributeList>::insert (
        _tao_any,
        ::Security::AttributeList::_tao_any_destructor,
        ::Security::_tc_AttributeList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::AttributeList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::AttributeList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::AttributeList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::AttributeList>::extract (
          _tao_any,
          ::Security::AttributeList::_tao_any_destructor,
          ::Security::_tc_AttributeList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::AttributeList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::AttributeList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::AttributeList>::insert_copy (
        _tao_any,
        Security::AttributeList::_tao_any_destructor,
        Security::_tc_AttributeList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::AttributeList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::AttributeList>::insert (
      _tao_any,
      Security::AttributeList::_tao_any_destructor,
      Security::_tc_AttributeList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::AttributeList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::AttributeList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::AttributeList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::AttributeList>::extract (
        _tao_any,
        Security::AttributeList::_tao_any_destructor,
        Security::_tc_AttributeList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::AuthenticationStatus _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::AuthenticationStatus>::insert (
        _tao_any,
        ::Security::_tc_AuthenticationStatus,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::AuthenticationStatus &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::AuthenticationStatus>::extract (
          _tao_any,
          ::Security::_tc_AuthenticationStatus,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::AuthenticationStatus _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::AuthenticationStatus>::insert (
      _tao_any,
      Security::_tc_AuthenticationStatus,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::AuthenticationStatus &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::AuthenticationStatus>::extract (
        _tao_any,
        Security::_tc_AuthenticationStatus,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::AssociationStatus _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::AssociationStatus>::insert (
        _tao_any,
        ::Security::_tc_AssociationStatus,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::AssociationStatus &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::AssociationStatus>::extract (
          _tao_any,
          ::Security::_tc_AssociationStatus,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::AssociationStatus _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::AssociationStatus>::insert (
      _tao_any,
      Security::_tc_AssociationStatus,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::AssociationStatus &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::AssociationStatus>::extract (
        _tao_any,
        Security::_tc_AssociationStatus,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::AuthenticationMethodList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::AuthenticationMethodList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::AuthenticationMethodList>::insert_copy (
          _tao_any,
          ::Security::AuthenticationMethodList::_tao_any_destructor,
          ::Security::_tc_AuthenticationMethodList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::AuthenticationMethodList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::AuthenticationMethodList>::insert (
        _tao_any,
        ::Security::AuthenticationMethodList::_tao_any_destructor,
        ::Security::_tc_AuthenticationMethodList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::AuthenticationMethodList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::AuthenticationMethodList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::AuthenticationMethodList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::AuthenticationMethodList>::extract (
          _tao_any,
          ::Security::AuthenticationMethodList::_tao_any_destructor,
          ::Security::_tc_AuthenticationMethodList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::AuthenticationMethodList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::AuthenticationMethodList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::AuthenticationMethodList>::insert_copy (
        _tao_any,
        Security::AuthenticationMethodList::_tao_any_destructor,
        Security::_tc_AuthenticationMethodList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::AuthenticationMethodList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::AuthenticationMethodList>::insert (
      _tao_any,
      Security::AuthenticationMethodList::_tao_any_destructor,
      Security::_tc_AuthenticationMethodList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::AuthenticationMethodList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::AuthenticationMethodList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::AuthenticationMethodList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::AuthenticationMethodList>::extract (
        _tao_any,
        Security::AuthenticationMethodList::_tao_any_destructor,
        Security::_tc_AuthenticationMethodList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::InvocationCredentialsType _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::InvocationCredentialsType>::insert (
        _tao_any,
        ::Security::_tc_InvocationCredentialsType,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::InvocationCredentialsType &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::InvocationCredentialsType>::extract (
          _tao_any,
          ::Security::_tc_InvocationCredentialsType,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::InvocationCredentialsType _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::InvocationCredentialsType>::insert (
      _tao_any,
      Security::_tc_InvocationCredentialsType,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::InvocationCredentialsType &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::InvocationCredentialsType>::extract (
        _tao_any,
        Security::_tc_InvocationCredentialsType,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::Right &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::Right *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::Right>::insert_copy (
          _tao_any,
          ::Security::Right::_tao_any_destructor,
          ::Security::_tc_Right,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      Security::Right *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::Right>::insert (
        _tao_any,
        ::Security::Right::_tao_any_destructor,
        ::Security::_tc_Right,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::Right *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::Right *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::Right *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::Right>::extract (
          _tao_any,
          ::Security::Right::_tao_any_destructor,
          ::Security::_tc_Right,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::Right &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::Right *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::Right>::insert_copy (
        _tao_any,
        Security::Right::_tao_any_destructor,
        Security::_tc_Right,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::Right *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::Right>::insert (
      _tao_any,
      Security::Right::_tao_any_destructor,
      Security::_tc_Right,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::Right *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::Right *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::Right *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::Right>::extract (
        _tao_any,
        Security::Right::_tao_any_destructor,
        Security::_tc_Right,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::RightsList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::RightsList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::RightsList>::insert_copy (
          _tao_any,
          ::Security::RightsList::_tao_any_destructor,
          ::Security::_tc_RightsList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::RightsList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::RightsList>::insert (
        _tao_any,
        ::Security::RightsList::_tao_any_destructor,
        ::Security::_tc_RightsList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::RightsList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::RightsList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::RightsList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::RightsList>::extract (
          _tao_any,
          ::Security::RightsList::_tao_any_destructor,
          ::Security::_tc_RightsList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::RightsList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::RightsList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::RightsList>::insert_copy (
        _tao_any,
        Security::RightsList::_tao_any_destructor,
        Security::_tc_RightsList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::RightsList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::RightsList>::insert (
      _tao_any,
      Security::RightsList::_tao_any_destructor,
      Security::_tc_RightsList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::RightsList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::RightsList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::RightsList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::RightsList>::extract (
        _tao_any,
        Security::RightsList::_tao_any_destructor,
        Security::_tc_RightsList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::RightsCombinator _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::RightsCombinator>::insert (
        _tao_any,
        ::Security::_tc_RightsCombinator,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::RightsCombinator &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::RightsCombinator>::extract (
          _tao_any,
          ::Security::_tc_RightsCombinator,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::RightsCombinator _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::RightsCombinator>::insert (
      _tao_any,
      Security::_tc_RightsCombinator,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::RightsCombinator &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::RightsCombinator>::extract (
        _tao_any,
        Security::_tc_RightsCombinator,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::DelegationState _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::DelegationState>::insert (
        _tao_any,
        ::Security::_tc_DelegationState,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::DelegationState &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::DelegationState>::extract (
          _tao_any,
          ::Security::_tc_DelegationState,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::DelegationState _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::DelegationState>::insert (
      _tao_any,
      Security::_tc_DelegationState,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::DelegationState &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::DelegationState>::extract (
        _tao_any,
        Security::_tc_DelegationState,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::DelegationDirective _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::DelegationDirective>::insert (
        _tao_any,
        ::Security::_tc_DelegationDirective,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::DelegationDirective &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::DelegationDirective>::extract (
          _tao_any,
          ::Security::_tc_DelegationDirective,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::DelegationDirective _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::DelegationDirective>::insert (
      _tao_any,
      Security::_tc_DelegationDirective,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::DelegationDirective &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::DelegationDirective>::extract (
        _tao_any,
        Security::_tc_DelegationDirective,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::SecurityFeature _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::SecurityFeature>::insert (
        _tao_any,
        ::Security::_tc_SecurityFeature,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::SecurityFeature &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::SecurityFeature>::extract (
          _tao_any,
          ::Security::_tc_SecurityFeature,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::SecurityFeature _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::SecurityFeature>::insert (
      _tao_any,
      Security::_tc_SecurityFeature,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::SecurityFeature &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::SecurityFeature>::extract (
        _tao_any,
        Security::_tc_SecurityFeature,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::QOP _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::QOP>::insert (
        _tao_any,
        ::Security::_tc_QOP,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::QOP &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::QOP>::extract (
          _tao_any,
          ::Security::_tc_QOP,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::QOP _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::QOP>::insert (
      _tao_any,
      Security::_tc_QOP,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::QOP &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::QOP>::extract (
        _tao_any,
        Security::_tc_QOP,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::SecurityContextType _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::SecurityContextType>::insert (
        _tao_any,
        ::Security::_tc_SecurityContextType,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::SecurityContextType &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::SecurityContextType>::extract (
          _tao_any,
          ::Security::_tc_SecurityContextType,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::SecurityContextType _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::SecurityContextType>::insert (
      _tao_any,
      Security::_tc_SecurityContextType,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::SecurityContextType &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::SecurityContextType>::extract (
        _tao_any,
        Security::_tc_SecurityContextType,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::SecurityContextState _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::SecurityContextState>::insert (
        _tao_any,
        ::Security::_tc_SecurityContextState,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::SecurityContextState &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::SecurityContextState>::extract (
          _tao_any,
          ::Security::_tc_SecurityContextState,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::SecurityContextState _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::SecurityContextState>::insert (
      _tao_any,
      Security::_tc_SecurityContextState,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::SecurityContextState &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::SecurityContextState>::extract (
        _tao_any,
        Security::_tc_SecurityContextState,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::ChannelBindings &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::ChannelBindings *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::ChannelBindings>::insert_copy (
          _tao_any,
          ::Security::ChannelBindings::_tao_any_destructor,
          ::Security::_tc_ChannelBindings,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      Security::ChannelBindings *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::ChannelBindings>::insert (
        _tao_any,
        ::Security::ChannelBindings::_tao_any_destructor,
        ::Security::_tc_ChannelBindings,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::ChannelBindings *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::ChannelBindings *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::ChannelBindings *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::ChannelBindings>::extract (
          _tao_any,
          ::Security::ChannelBindings::_tao_any_destructor,
          ::Security::_tc_ChannelBindings,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::ChannelBindings &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::ChannelBindings *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::ChannelBindings>::insert_copy (
        _tao_any,
        Security::ChannelBindings::_tao_any_destructor,
        Security::_tc_ChannelBindings,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::ChannelBindings *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::ChannelBindings>::insert (
      _tao_any,
      Security::ChannelBindings::_tao_any_destructor,
      Security::_tc_ChannelBindings,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::ChannelBindings *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::ChannelBindings *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::ChannelBindings *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::ChannelBindings>::extract (
        _tao_any,
        Security::ChannelBindings::_tao_any_destructor,
        Security::_tc_ChannelBindings,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::OpaqueBuffer &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::OpaqueBuffer *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::OpaqueBuffer>::insert_copy (
          _tao_any,
          ::Security::OpaqueBuffer::_tao_any_destructor,
          ::Security::_tc_OpaqueBuffer,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      Security::OpaqueBuffer *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::OpaqueBuffer>::insert (
        _tao_any,
        ::Security::OpaqueBuffer::_tao_any_destructor,
        ::Security::_tc_OpaqueBuffer,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::OpaqueBuffer *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::OpaqueBuffer *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::OpaqueBuffer *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::OpaqueBuffer>::extract (
          _tao_any,
          ::Security::OpaqueBuffer::_tao_any_destructor,
          ::Security::_tc_OpaqueBuffer,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::OpaqueBuffer &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::OpaqueBuffer *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::OpaqueBuffer>::insert_copy (
        _tao_any,
        Security::OpaqueBuffer::_tao_any_destructor,
        Security::_tc_OpaqueBuffer,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::OpaqueBuffer *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::OpaqueBuffer>::insert (
      _tao_any,
      Security::OpaqueBuffer::_tao_any_destructor,
      Security::_tc_OpaqueBuffer,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::OpaqueBuffer *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::OpaqueBuffer *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::OpaqueBuffer *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::OpaqueBuffer>::extract (
        _tao_any,
        Security::OpaqueBuffer::_tao_any_destructor,
        Security::_tc_OpaqueBuffer,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::RequiresSupports _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::RequiresSupports>::insert (
        _tao_any,
        ::Security::_tc_RequiresSupports,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::RequiresSupports &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::RequiresSupports>::extract (
          _tao_any,
          ::Security::_tc_RequiresSupports,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::RequiresSupports _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::RequiresSupports>::insert (
      _tao_any,
      Security::_tc_RequiresSupports,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::RequiresSupports &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::RequiresSupports>::extract (
        _tao_any,
        Security::_tc_RequiresSupports,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::CommunicationDirection _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::CommunicationDirection>::insert (
        _tao_any,
        ::Security::_tc_CommunicationDirection,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::CommunicationDirection &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::CommunicationDirection>::extract (
          _tao_any,
          ::Security::_tc_CommunicationDirection,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::CommunicationDirection _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::CommunicationDirection>::insert (
      _tao_any,
      Security::_tc_CommunicationDirection,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::CommunicationDirection &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::CommunicationDirection>::extract (
        _tao_any,
        Security::_tc_CommunicationDirection,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::MechanismTypeList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::MechanismTypeList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::MechanismTypeList>::insert_copy (
          _tao_any,
          ::Security::MechanismTypeList::_tao_any_destructor,
          ::Security::_tc_MechanismTypeList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::MechanismTypeList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::MechanismTypeList>::insert (
        _tao_any,
        ::Security::MechanismTypeList::_tao_any_destructor,
        ::Security::_tc_MechanismTypeList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::MechanismTypeList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::MechanismTypeList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::MechanismTypeList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::MechanismTypeList>::extract (
          _tao_any,
          ::Security::MechanismTypeList::_tao_any_destructor,
          ::Security::_tc_MechanismTypeList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::MechanismTypeList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::MechanismTypeList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::MechanismTypeList>::insert_copy (
        _tao_any,
        Security::MechanismTypeList::_tao_any_destructor,
        Security::_tc_MechanismTypeList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::MechanismTypeList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::MechanismTypeList>::insert (
      _tao_any,
      Security::MechanismTypeList::_tao_any_destructor,
      Security::_tc_MechanismTypeList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::MechanismTypeList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::MechanismTypeList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::MechanismTypeList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::MechanismTypeList>::extract (
        _tao_any,
        Security::MechanismTypeList::_tao_any_destructor,
        Security::_tc_MechanismTypeList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::OptionsDirectionPair &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::OptionsDirectionPair *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::OptionsDirectionPair>::insert_copy (
          _tao_any,
          ::Security::OptionsDirectionPair::_tao_any_destructor,
          ::Security::_tc_OptionsDirectionPair,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      Security::OptionsDirectionPair *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::OptionsDirectionPair>::insert (
        _tao_any,
        ::Security::OptionsDirectionPair::_tao_any_destructor,
        ::Security::_tc_OptionsDirectionPair,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::OptionsDirectionPair *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::OptionsDirectionPair *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::OptionsDirectionPair *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::OptionsDirectionPair>::extract (
          _tao_any,
          ::Security::OptionsDirectionPair::_tao_any_destructor,
          ::Security::_tc_OptionsDirectionPair,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::OptionsDirectionPair &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::OptionsDirectionPair *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::OptionsDirectionPair>::insert_copy (
        _tao_any,
        Security::OptionsDirectionPair::_tao_any_destructor,
        Security::_tc_OptionsDirectionPair,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::OptionsDirectionPair *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::OptionsDirectionPair>::insert (
      _tao_any,
      Security::OptionsDirectionPair::_tao_any_destructor,
      Security::_tc_OptionsDirectionPair,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::OptionsDirectionPair *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::OptionsDirectionPair *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::OptionsDirectionPair *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::OptionsDirectionPair>::extract (
        _tao_any,
        Security::OptionsDirectionPair::_tao_any_destructor,
        Security::_tc_OptionsDirectionPair,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::OptionsDirectionPairList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::OptionsDirectionPairList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::OptionsDirectionPairList>::insert_copy (
          _tao_any,
          ::Security::OptionsDirectionPairList::_tao_any_destructor,
          ::Security::_tc_OptionsDirectionPairList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::OptionsDirectionPairList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::OptionsDirectionPairList>::insert (
        _tao_any,
        ::Security::OptionsDirectionPairList::_tao_any_destructor,
        ::Security::_tc_OptionsDirectionPairList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::OptionsDirectionPairList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::OptionsDirectionPairList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::OptionsDirectionPairList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::OptionsDirectionPairList>::extract (
          _tao_any,
          ::Security::OptionsDirectionPairList::_tao_any_destructor,
          ::Security::_tc_OptionsDirectionPairList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::OptionsDirectionPairList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::OptionsDirectionPairList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::OptionsDirectionPairList>::insert_copy (
        _tao_any,
        Security::OptionsDirectionPairList::_tao_any_destructor,
        Security::_tc_OptionsDirectionPairList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::OptionsDirectionPairList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::OptionsDirectionPairList>::insert (
      _tao_any,
      Security::OptionsDirectionPairList::_tao_any_destructor,
      Security::_tc_OptionsDirectionPairList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::OptionsDirectionPairList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::OptionsDirectionPairList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::OptionsDirectionPairList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::OptionsDirectionPairList>::extract (
        _tao_any,
        Security::OptionsDirectionPairList::_tao_any_destructor,
        Security::_tc_OptionsDirectionPairList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::DelegationMode _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::DelegationMode>::insert (
        _tao_any,
        ::Security::_tc_DelegationMode,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::DelegationMode &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::DelegationMode>::extract (
          _tao_any,
          ::Security::_tc_DelegationMode,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::DelegationMode _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::DelegationMode>::insert (
      _tao_any,
      Security::_tc_DelegationMode,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::DelegationMode &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::DelegationMode>::extract (
        _tao_any,
        Security::_tc_DelegationMode,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::MechandOptions &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::MechandOptions *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::MechandOptions>::insert_copy (
          _tao_any,
          ::Security::MechandOptions::_tao_any_destructor,
          ::Security::_tc_MechandOptions,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      Security::MechandOptions *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::MechandOptions>::insert (
        _tao_any,
        ::Security::MechandOptions::_tao_any_destructor,
        ::Security::_tc_MechandOptions,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::MechandOptions *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::MechandOptions *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::MechandOptions *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::MechandOptions>::extract (
          _tao_any,
          ::Security::MechandOptions::_tao_any_destructor,
          ::Security::_tc_MechandOptions,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::MechandOptions &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::MechandOptions *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::MechandOptions>::insert_copy (
        _tao_any,
        Security::MechandOptions::_tao_any_destructor,
        Security::_tc_MechandOptions,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::MechandOptions *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::MechandOptions>::insert (
      _tao_any,
      Security::MechandOptions::_tao_any_destructor,
      Security::_tc_MechandOptions,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::MechandOptions *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::MechandOptions *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::MechandOptions *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::MechandOptions>::extract (
        _tao_any,
        Security::MechandOptions::_tao_any_destructor,
        Security::_tc_MechandOptions,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::MechandOptionsList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::MechandOptionsList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::MechandOptionsList>::insert_copy (
          _tao_any,
          ::Security::MechandOptionsList::_tao_any_destructor,
          ::Security::_tc_MechandOptionsList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::MechandOptionsList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::MechandOptionsList>::insert (
        _tao_any,
        ::Security::MechandOptionsList::_tao_any_destructor,
        ::Security::_tc_MechandOptionsList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::MechandOptionsList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::MechandOptionsList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::MechandOptionsList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::MechandOptionsList>::extract (
          _tao_any,
          ::Security::MechandOptionsList::_tao_any_destructor,
          ::Security::_tc_MechandOptionsList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::MechandOptionsList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::MechandOptionsList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::MechandOptionsList>::insert_copy (
        _tao_any,
        Security::MechandOptionsList::_tao_any_destructor,
        Security::_tc_MechandOptionsList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::MechandOptionsList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::MechandOptionsList>::insert (
      _tao_any,
      Security::MechandOptionsList::_tao_any_destructor,
      Security::_tc_MechandOptionsList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::MechandOptionsList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::MechandOptionsList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::MechandOptionsList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::MechandOptionsList>::extract (
        _tao_any,
        Security::MechandOptionsList::_tao_any_destructor,
        Security::_tc_MechandOptionsList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::EstablishTrust &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::EstablishTrust *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::EstablishTrust>::insert_copy (
          _tao_any,
          ::Security::EstablishTrust::_tao_any_destructor,
          ::Security::_tc_EstablishTrust,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      Security::EstablishTrust *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::EstablishTrust>::insert (
        _tao_any,
        ::Security::EstablishTrust::_tao_any_destructor,
        ::Security::_tc_EstablishTrust,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::EstablishTrust *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::EstablishTrust *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::EstablishTrust *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::EstablishTrust>::extract (
          _tao_any,
          ::Security::EstablishTrust::_tao_any_destructor,
          ::Security::_tc_EstablishTrust,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::EstablishTrust &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::EstablishTrust *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::EstablishTrust>::insert_copy (
        _tao_any,
        Security::EstablishTrust::_tao_any_destructor,
        Security::_tc_EstablishTrust,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::EstablishTrust *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::EstablishTrust>::insert (
      _tao_any,
      Security::EstablishTrust::_tao_any_destructor,
      Security::_tc_EstablishTrust,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::EstablishTrust *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::EstablishTrust *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::EstablishTrust *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::EstablishTrust>::extract (
        _tao_any,
        Security::EstablishTrust::_tao_any_destructor,
        Security::_tc_EstablishTrust,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::DayOfTheWeek _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::DayOfTheWeek>::insert (
        _tao_any,
        ::Security::_tc_DayOfTheWeek,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::DayOfTheWeek &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::DayOfTheWeek>::extract (
          _tao_any,
          ::Security::_tc_DayOfTheWeek,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::DayOfTheWeek _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::DayOfTheWeek>::insert (
      _tao_any,
      Security::_tc_DayOfTheWeek,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::DayOfTheWeek &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::DayOfTheWeek>::extract (
        _tao_any,
        Security::_tc_DayOfTheWeek,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::AuditCombinator _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Security::AuditCombinator>::insert (
        _tao_any,
        ::Security::_tc_AuditCombinator,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::AuditCombinator &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Security::AuditCombinator>::extract (
          _tao_any,
          ::Security::_tc_AuditCombinator,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::AuditCombinator _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Security::AuditCombinator>::insert (
      _tao_any,
      Security::_tc_AuditCombinator,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::AuditCombinator &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Security::AuditCombinator>::extract (
        _tao_any,
        Security::_tc_AuditCombinator,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::AuditEventType &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::AuditEventType *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::AuditEventType>::insert_copy (
          _tao_any,
          ::Security::AuditEventType::_tao_any_destructor,
          ::Security::_tc_AuditEventType,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      Security::AuditEventType *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::AuditEventType>::insert (
        _tao_any,
        ::Security::AuditEventType::_tao_any_destructor,
        ::Security::_tc_AuditEventType,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::AuditEventType *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::AuditEventType *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::AuditEventType *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::AuditEventType>::extract (
          _tao_any,
          ::Security::AuditEventType::_tao_any_destructor,
          ::Security::_tc_AuditEventType,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::AuditEventType &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::AuditEventType *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::AuditEventType>::insert_copy (
        _tao_any,
        Security::AuditEventType::_tao_any_destructor,
        Security::_tc_AuditEventType,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::AuditEventType *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::AuditEventType>::insert (
      _tao_any,
      Security::AuditEventType::_tao_any_destructor,
      Security::_tc_AuditEventType,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::AuditEventType *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::AuditEventType *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::AuditEventType *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::AuditEventType>::extract (
        _tao_any,
        Security::AuditEventType::_tao_any_destructor,
        Security::_tc_AuditEventType,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::AuditEventTypeList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::AuditEventTypeList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::AuditEventTypeList>::insert_copy (
          _tao_any,
          ::Security::AuditEventTypeList::_tao_any_destructor,
          ::Security::_tc_AuditEventTypeList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::AuditEventTypeList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::AuditEventTypeList>::insert (
        _tao_any,
        ::Security::AuditEventTypeList::_tao_any_destructor,
        ::Security::_tc_AuditEventTypeList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::AuditEventTypeList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::AuditEventTypeList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::AuditEventTypeList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::AuditEventTypeList>::extract (
          _tao_any,
          ::Security::AuditEventTypeList::_tao_any_destructor,
          ::Security::_tc_AuditEventTypeList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::AuditEventTypeList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::AuditEventTypeList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::AuditEventTypeList>::insert_copy (
        _tao_any,
        Security::AuditEventTypeList::_tao_any_destructor,
        Security::_tc_AuditEventTypeList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::AuditEventTypeList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::AuditEventTypeList>::insert (
      _tao_any,
      Security::AuditEventTypeList::_tao_any_destructor,
      Security::_tc_AuditEventTypeList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::AuditEventTypeList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::AuditEventTypeList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::AuditEventTypeList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::AuditEventTypeList>::extract (
        _tao_any,
        Security::AuditEventTypeList::_tao_any_destructor,
        Security::_tc_AuditEventTypeList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::SelectorValue &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::SelectorValue *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::SelectorValue>::insert_copy (
          _tao_any,
          ::Security::SelectorValue::_tao_any_destructor,
          ::Security::_tc_SelectorValue,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      Security::SelectorValue *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::SelectorValue>::insert (
        _tao_any,
        ::Security::SelectorValue::_tao_any_destructor,
        ::Security::_tc_SelectorValue,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::SelectorValue *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::SelectorValue *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::SelectorValue *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::SelectorValue>::extract (
          _tao_any,
          ::Security::SelectorValue::_tao_any_destructor,
          ::Security::_tc_SelectorValue,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::SelectorValue &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::SelectorValue *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::SelectorValue>::insert_copy (
        _tao_any,
        Security::SelectorValue::_tao_any_destructor,
        Security::_tc_SelectorValue,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::SelectorValue *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::SelectorValue>::insert (
      _tao_any,
      Security::SelectorValue::_tao_any_destructor,
      Security::_tc_SelectorValue,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::SelectorValue *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::SelectorValue *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::SelectorValue *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::SelectorValue>::extract (
        _tao_any,
        Security::SelectorValue::_tao_any_destructor,
        Security::_tc_SelectorValue,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Security
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Security::SelectorValueList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::Security::SelectorValueList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::Security::SelectorValueList>::insert_copy (
          _tao_any,
          ::Security::SelectorValueList::_tao_any_destructor,
          ::Security::_tc_SelectorValueList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Security::SelectorValueList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Security::SelectorValueList>::insert (
        _tao_any,
        ::Security::SelectorValueList::_tao_any_destructor,
        ::Security::_tc_SelectorValueList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Security::SelectorValueList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::Security::SelectorValueList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Security::SelectorValueList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::Security::SelectorValueList>::extract (
          _tao_any,
          ::Security::SelectorValueList::_tao_any_destructor,
          ::Security::_tc_SelectorValueList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Security::SelectorValueList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Security::SelectorValueList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Security::SelectorValueList>::insert_copy (
        _tao_any,
        Security::SelectorValueList::_tao_any_destructor,
        Security::_tc_SelectorValueList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Security::SelectorValueList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Security::SelectorValueList>::insert (
      _tao_any,
      Security::SelectorValueList::_tao_any_destructor,
      Security::_tc_SelectorValueList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Security::SelectorValueList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Security::SelectorValueList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Security::SelectorValueList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Security::SelectorValueList>::extract (
        _tao_any,
        Security::SelectorValueList::_tao_any_destructor,
        Security::_tc_SelectorValueList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_Security_Opaque_CPP_
#define _TAO_CDR_OP_Security_Opaque_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::Opaque &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::Opaque &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_Security_Opaque_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::ExtensibleFamily &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.family_definer) &&
    (strm << _tao_aggregate.family);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::ExtensibleFamily &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.family_definer) &&
    (strm >> _tao_aggregate.family);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_Security_OID_CPP_
#define _TAO_CDR_OP_Security_OID_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::OID &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::OID &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_Security_OID_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_Security_OIDList_CPP_
#define _TAO_CDR_OP_Security_OIDList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::OIDList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::OIDList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_Security_OIDList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::AttributeType &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.attribute_family) &&
    (strm << _tao_aggregate.attribute_type);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::AttributeType &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.attribute_family) &&
    (strm >> _tao_aggregate.attribute_type);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_Security_AttributeTypeList_CPP_
#define _TAO_CDR_OP_Security_AttributeTypeList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::AttributeTypeList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::AttributeTypeList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_Security_AttributeTypeList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::SecAttribute &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.attribute_type) &&
    (strm << _tao_aggregate.defining_authority) &&
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::SecAttribute &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.attribute_type) &&
    (strm >> _tao_aggregate.defining_authority) &&
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_Security_AttributeList_CPP_
#define _TAO_CDR_OP_Security_AttributeList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::AttributeList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::AttributeList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_Security_AttributeList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::AuthenticationStatus _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::AuthenticationStatus & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::AuthenticationStatus> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::AssociationStatus _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::AssociationStatus & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::AssociationStatus> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_Security_AuthenticationMethodList_CPP_
#define _TAO_CDR_OP_Security_AuthenticationMethodList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::AuthenticationMethodList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::AuthenticationMethodList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_Security_AuthenticationMethodList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::InvocationCredentialsType _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::InvocationCredentialsType & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::InvocationCredentialsType> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::Right &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.rights_family) &&
    (strm << _tao_aggregate.the_right.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::Right &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.rights_family) &&
    (strm >> _tao_aggregate.the_right.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_Security_RightsList_CPP_
#define _TAO_CDR_OP_Security_RightsList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::RightsList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::RightsList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_Security_RightsList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::RightsCombinator _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::RightsCombinator & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::RightsCombinator> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::DelegationState _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::DelegationState & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::DelegationState> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::DelegationDirective _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::DelegationDirective & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::DelegationDirective> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::SecurityFeature _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::SecurityFeature & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::SecurityFeature> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::QOP _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::QOP & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::QOP> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::SecurityContextType _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::SecurityContextType & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::SecurityContextType> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::SecurityContextState _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::SecurityContextState & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::SecurityContextState> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::ChannelBindings &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.initiator_addrtype) &&
    (strm << _tao_aggregate.initiator_address) &&
    (strm << _tao_aggregate.acceptor_addrtype) &&
    (strm << _tao_aggregate.acceptor_address) &&
    (strm << _tao_aggregate.application_data);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::ChannelBindings &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.initiator_addrtype) &&
    (strm >> _tao_aggregate.initiator_address) &&
    (strm >> _tao_aggregate.acceptor_addrtype) &&
    (strm >> _tao_aggregate.acceptor_address) &&
    (strm >> _tao_aggregate.application_data);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::OpaqueBuffer &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.buffer) &&
    (strm << _tao_aggregate.startpos) &&
    (strm << _tao_aggregate.endpos);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::OpaqueBuffer &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.buffer) &&
    (strm >> _tao_aggregate.startpos) &&
    (strm >> _tao_aggregate.endpos);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::RequiresSupports _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::RequiresSupports & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::RequiresSupports> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::CommunicationDirection _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::CommunicationDirection & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::CommunicationDirection> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_Security_MechanismTypeList_CPP_
#define _TAO_CDR_OP_Security_MechanismTypeList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::MechanismTypeList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::MechanismTypeList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_Security_MechanismTypeList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::OptionsDirectionPair &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.options) &&
    (strm << _tao_aggregate.direction);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::OptionsDirectionPair &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.options) &&
    (strm >> _tao_aggregate.direction);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_Security_OptionsDirectionPairList_CPP_
#define _TAO_CDR_OP_Security_OptionsDirectionPairList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::OptionsDirectionPairList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::OptionsDirectionPairList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_Security_OptionsDirectionPairList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::DelegationMode _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::DelegationMode & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::DelegationMode> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::MechandOptions &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.mechanism_type.in ()) &&
    (strm << _tao_aggregate.options_supported);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::MechandOptions &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.mechanism_type.out ()) &&
    (strm >> _tao_aggregate.options_supported);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_Security_MechandOptionsList_CPP_
#define _TAO_CDR_OP_Security_MechandOptionsList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::MechandOptionsList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::MechandOptionsList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_Security_MechandOptionsList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::EstablishTrust &_tao_aggregate)
{
  return
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.trust_in_client)) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.trust_in_target));
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::EstablishTrust &_tao_aggregate)
{
  return
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.trust_in_client)) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.trust_in_target));
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::DayOfTheWeek _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::DayOfTheWeek & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::DayOfTheWeek> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Security::AuditCombinator _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Security::AuditCombinator & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Security::AuditCombinator> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::AuditEventType &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.event_family) &&
    (strm << _tao_aggregate.event_type);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::AuditEventType &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.event_family) &&
    (strm >> _tao_aggregate.event_type);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_Security_AuditEventTypeList_CPP_
#define _TAO_CDR_OP_Security_AuditEventTypeList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::AuditEventTypeList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::AuditEventTypeList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_Security_AuditEventTypeList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::SelectorValue &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.selector) &&
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::SelectorValue &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.selector) &&
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_Security_SelectorValueList_CPP_
#define _TAO_CDR_OP_Security_SelectorValueList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Security::SelectorValueList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Security::SelectorValueList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_Security_SelectorValueList_CPP_ */


TAO_END_VERSIONED_NAMESPACE_DECL


