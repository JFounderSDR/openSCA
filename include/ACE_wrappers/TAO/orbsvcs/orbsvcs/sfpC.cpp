// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "sfpC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/CDR.h"
#include "tao/ORB_Core.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Array_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"

#if !defined (__ACE_INLINE__)
#include "sfpC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_flowProtocol_my_seq_ulong (
    ::CORBA::tk_alias,
    "IDL:flowProtocol/my_seq_ulong:1.0",
    "my_seq_ulong",
    &CORBA::_tc_ULongSeq);
  

namespace flowProtocol
{
  ::CORBA::TypeCode_ptr const _tc_my_seq_ulong =
    &_tao_tc_flowProtocol_my_seq_ulong;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_array/array_cs.cpp:100

flowProtocol::cmagic_nr_slice *
flowProtocol::cmagic_nr_dup (const flowProtocol::cmagic_nr_slice *_tao_src_array)
{
  flowProtocol::cmagic_nr_slice *_tao_dup_array =
    flowProtocol::cmagic_nr_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <flowProtocol::cmagic_nr_slice *> (0);
    }
  
  flowProtocol::cmagic_nr_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

flowProtocol::cmagic_nr_slice *
flowProtocol::cmagic_nr_alloc (void)
{
  flowProtocol::cmagic_nr_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Char[4], 0);
  return retval;
}

void
flowProtocol::cmagic_nr_free (
    flowProtocol::cmagic_nr_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void 
flowProtocol::cmagic_nr_copy (
    flowProtocol::cmagic_nr_slice * _tao_to,
    const flowProtocol::cmagic_nr_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 4; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:297


#ifndef _TAO_TYPECODE_flowProtocol_cmagic_nr_GUARD
#define _TAO_TYPECODE_flowProtocol_cmagic_nr_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        flowProtocol_cmagic_nr_4 (
          ::CORBA::tk_array,
          &CORBA::_tc_char,
          4U);
        
      ::CORBA::TypeCode_ptr const tc_flowProtocol_cmagic_nr =
        &flowProtocol_cmagic_nr_4;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_flowProtocol_cmagic_nr_GUARD */
static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_flowProtocol_cmagic_nr (
    ::CORBA::tk_alias,
    "IDL:flowProtocol/cmagic_nr:1.0",
    "cmagic_nr",
    &TAO::TypeCode::tc_flowProtocol_cmagic_nr);
  

namespace flowProtocol
{
  ::CORBA::TypeCode_ptr const _tc_cmagic_nr =
    &_tao_tc_flowProtocol_cmagic_nr;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_flowProtocol_MsgType[] =
  {
    "Start_Msg",
    "EndofStream_Msg",
    "SimpleFrame_Msg",
    "SequencedFrame_Msg",
    "Frame_Msg",
    "SpecialFrame_Msg",
    "StartReply_Msg",
    "Credit_Msg",
    "Fragment_Msg"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_flowProtocol_MsgType (
    "IDL:flowProtocol/MsgType:1.0",
    "MsgType",
    _tao_enumerators_flowProtocol_MsgType,
    9);
  

namespace flowProtocol
{
  ::CORBA::TypeCode_ptr const _tc_MsgType =
    &_tao_tc_flowProtocol_MsgType;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:297

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_flowProtocol_frameHeader[] =
      {
        { "magic_number", &flowProtocol::_tc_cmagic_nr },
        { "flags", &CORBA::_tc_octet },
        { "message_type", &CORBA::_tc_octet },
        { "message_size", &CORBA::_tc_ulong }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_flowProtocol_frameHeader (
  ::CORBA::tk_struct,
  "IDL:flowProtocol/frameHeader:1.0",
  "frameHeader",
  _tao_fields_flowProtocol_frameHeader,
  4);


namespace flowProtocol
{
  ::CORBA::TypeCode_ptr const _tc_frameHeader =
    &_tao_tc_flowProtocol_frameHeader;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
flowProtocol::frameHeader::_tao_any_destructor (
    void *_tao_void_pointer)
{
  frameHeader *_tao_tmp_pointer =
    static_cast<frameHeader *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:297

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_flowProtocol_fragment[] =
      {
        { "magic_number", &flowProtocol::_tc_cmagic_nr },
        { "flags", &CORBA::_tc_octet },
        { "frag_number", &CORBA::_tc_ulong },
        { "sequence_num", &CORBA::_tc_ulong },
        { "frag_sz", &CORBA::_tc_ulong },
        { "source_id", &CORBA::_tc_ulong }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_flowProtocol_fragment (
  ::CORBA::tk_struct,
  "IDL:flowProtocol/fragment:1.0",
  "fragment",
  _tao_fields_flowProtocol_fragment,
  6);


namespace flowProtocol
{
  ::CORBA::TypeCode_ptr const _tc_fragment =
    &_tao_tc_flowProtocol_fragment;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
flowProtocol::fragment::_tao_any_destructor (
    void *_tao_void_pointer)
{
  fragment *_tao_tmp_pointer =
    static_cast<fragment *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:297

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_flowProtocol_Start[] =
      {
        { "magic_number", &flowProtocol::_tc_cmagic_nr },
        { "major_version", &CORBA::_tc_octet },
        { "minor_version", &CORBA::_tc_octet },
        { "flags", &CORBA::_tc_octet }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_flowProtocol_Start (
  ::CORBA::tk_struct,
  "IDL:flowProtocol/Start:1.0",
  "Start",
  _tao_fields_flowProtocol_Start,
  4);


namespace flowProtocol
{
  ::CORBA::TypeCode_ptr const _tc_Start =
    &_tao_tc_flowProtocol_Start;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
flowProtocol::Start::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Start *_tao_tmp_pointer =
    static_cast<Start *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:297

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_flowProtocol_StartReply[] =
      {
        { "magic_number", &flowProtocol::_tc_cmagic_nr },
        { "flags", &CORBA::_tc_octet }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_flowProtocol_StartReply (
  ::CORBA::tk_struct,
  "IDL:flowProtocol/StartReply:1.0",
  "StartReply",
  _tao_fields_flowProtocol_StartReply,
  2);


namespace flowProtocol
{
  ::CORBA::TypeCode_ptr const _tc_StartReply =
    &_tao_tc_flowProtocol_StartReply;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
flowProtocol::StartReply::_tao_any_destructor (
    void *_tao_void_pointer)
{
  StartReply *_tao_tmp_pointer =
    static_cast<StartReply *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_flowProtocol_sequencedFrame[] =
      {
        { "sequence_num", &CORBA::_tc_ulong }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_flowProtocol_sequencedFrame (
  ::CORBA::tk_struct,
  "IDL:flowProtocol/sequencedFrame:1.0",
  "sequencedFrame",
  _tao_fields_flowProtocol_sequencedFrame,
  1);


namespace flowProtocol
{
  ::CORBA::TypeCode_ptr const _tc_sequencedFrame =
    &_tao_tc_flowProtocol_sequencedFrame;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
flowProtocol::sequencedFrame::_tao_any_destructor (
    void *_tao_void_pointer)
{
  sequencedFrame *_tao_tmp_pointer =
    static_cast<sequencedFrame *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_flowProtocol_frame[] =
      {
        { "timestamp", &CORBA::_tc_ulong },
        { "synchSource", &CORBA::_tc_ulong },
        { "source_ids", &flowProtocol::_tc_my_seq_ulong },
        { "sequence_num", &CORBA::_tc_ulong }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_flowProtocol_frame (
  ::CORBA::tk_struct,
  "IDL:flowProtocol/frame:1.0",
  "frame",
  _tao_fields_flowProtocol_frame,
  4);


namespace flowProtocol
{
  ::CORBA::TypeCode_ptr const _tc_frame =
    &_tao_tc_flowProtocol_frame;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
flowProtocol::frame::_tao_any_destructor (
    void *_tao_void_pointer)
{
  frame *_tao_tmp_pointer =
    static_cast<frame *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_flowProtocol_frameID (
    ::CORBA::tk_alias,
    "IDL:flowProtocol/frameID:1.0",
    "frameID",
    &CORBA::_tc_ulong);
  

namespace flowProtocol
{
  ::CORBA::TypeCode_ptr const _tc_frameID =
    &_tao_tc_flowProtocol_frameID;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_flowProtocol_specialFrame[] =
      {
        { "context_id", &flowProtocol::_tc_frameID },
        { "context_data", &CORBA::_tc_OctetSeq }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_flowProtocol_specialFrame (
  ::CORBA::tk_struct,
  "IDL:flowProtocol/specialFrame:1.0",
  "specialFrame",
  _tao_fields_flowProtocol_specialFrame,
  2);


namespace flowProtocol
{
  ::CORBA::TypeCode_ptr const _tc_specialFrame =
    &_tao_tc_flowProtocol_specialFrame;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
flowProtocol::specialFrame::_tao_any_destructor (
    void *_tao_void_pointer)
{
  specialFrame *_tao_tmp_pointer =
    static_cast<specialFrame *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:297

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_flowProtocol_credit[] =
      {
        { "magic_number", &flowProtocol::_tc_cmagic_nr },
        { "cred_num", &CORBA::_tc_ulong }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_flowProtocol_credit (
  ::CORBA::tk_struct,
  "IDL:flowProtocol/credit:1.0",
  "credit",
  _tao_fields_flowProtocol_credit,
  2);


namespace flowProtocol
{
  ::CORBA::TypeCode_ptr const _tc_credit =
    &_tao_tc_flowProtocol_credit;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
flowProtocol::credit::_tao_any_destructor (
    void *_tao_void_pointer)
{
  credit *_tao_tmp_pointer =
    static_cast<credit *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_array/any_op_cs.cpp:45



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    const flowProtocol::cmagic_nr_forany &_tao_elem
  )
{
  TAO::Any_Array_Impl_T<
      flowProtocol::cmagic_nr_slice,
      flowProtocol::cmagic_nr_forany
    >::insert (
        _tao_any,
        flowProtocol::cmagic_nr_forany::_tao_any_destructor,
        flowProtocol::_tc_cmagic_nr,
        _tao_elem.nocopy ()
          ? _tao_elem.ptr ()
          : flowProtocol::cmagic_nr_dup (_tao_elem.in ())
      );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    flowProtocol::cmagic_nr_forany &_tao_elem
  )
{
  return
    TAO::Any_Array_Impl_T<
        flowProtocol::cmagic_nr_slice,
        flowProtocol::cmagic_nr_forany
      >::extract (
          _tao_any,
          flowProtocol::cmagic_nr_forany::_tao_any_destructor,
          flowProtocol::_tc_cmagic_nr,
          _tao_elem.out ()
        );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace flowProtocol
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::flowProtocol::MsgType _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::flowProtocol::MsgType>::insert (
        _tao_any,
        ::flowProtocol::_tc_MsgType,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::flowProtocol::MsgType &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::flowProtocol::MsgType>::extract (
          _tao_any,
          ::flowProtocol::_tc_MsgType,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    flowProtocol::MsgType _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<flowProtocol::MsgType>::insert (
      _tao_any,
      flowProtocol::_tc_MsgType,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    flowProtocol::MsgType &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<flowProtocol::MsgType>::extract (
        _tao_any,
        flowProtocol::_tc_MsgType,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace flowProtocol
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::flowProtocol::frameHeader &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::flowProtocol::frameHeader *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::flowProtocol::frameHeader>::insert_copy (
          _tao_any,
          ::flowProtocol::frameHeader::_tao_any_destructor,
          ::flowProtocol::_tc_frameHeader,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      flowProtocol::frameHeader *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::flowProtocol::frameHeader>::insert (
        _tao_any,
        ::flowProtocol::frameHeader::_tao_any_destructor,
        ::flowProtocol::_tc_frameHeader,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::flowProtocol::frameHeader *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::flowProtocol::frameHeader *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::flowProtocol::frameHeader *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::flowProtocol::frameHeader>::extract (
          _tao_any,
          ::flowProtocol::frameHeader::_tao_any_destructor,
          ::flowProtocol::_tc_frameHeader,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const flowProtocol::frameHeader &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<flowProtocol::frameHeader *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<flowProtocol::frameHeader>::insert_copy (
        _tao_any,
        flowProtocol::frameHeader::_tao_any_destructor,
        flowProtocol::_tc_frameHeader,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    flowProtocol::frameHeader *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<flowProtocol::frameHeader>::insert (
      _tao_any,
      flowProtocol::frameHeader::_tao_any_destructor,
      flowProtocol::_tc_frameHeader,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    flowProtocol::frameHeader *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const flowProtocol::frameHeader *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const flowProtocol::frameHeader *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<flowProtocol::frameHeader>::extract (
        _tao_any,
        flowProtocol::frameHeader::_tao_any_destructor,
        flowProtocol::_tc_frameHeader,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace flowProtocol
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::flowProtocol::fragment &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::flowProtocol::fragment *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::flowProtocol::fragment>::insert_copy (
          _tao_any,
          ::flowProtocol::fragment::_tao_any_destructor,
          ::flowProtocol::_tc_fragment,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      flowProtocol::fragment *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::flowProtocol::fragment>::insert (
        _tao_any,
        ::flowProtocol::fragment::_tao_any_destructor,
        ::flowProtocol::_tc_fragment,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::flowProtocol::fragment *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::flowProtocol::fragment *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::flowProtocol::fragment *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::flowProtocol::fragment>::extract (
          _tao_any,
          ::flowProtocol::fragment::_tao_any_destructor,
          ::flowProtocol::_tc_fragment,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const flowProtocol::fragment &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<flowProtocol::fragment *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<flowProtocol::fragment>::insert_copy (
        _tao_any,
        flowProtocol::fragment::_tao_any_destructor,
        flowProtocol::_tc_fragment,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    flowProtocol::fragment *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<flowProtocol::fragment>::insert (
      _tao_any,
      flowProtocol::fragment::_tao_any_destructor,
      flowProtocol::_tc_fragment,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    flowProtocol::fragment *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const flowProtocol::fragment *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const flowProtocol::fragment *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<flowProtocol::fragment>::extract (
        _tao_any,
        flowProtocol::fragment::_tao_any_destructor,
        flowProtocol::_tc_fragment,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace flowProtocol
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::flowProtocol::Start &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::flowProtocol::Start *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::flowProtocol::Start>::insert_copy (
          _tao_any,
          ::flowProtocol::Start::_tao_any_destructor,
          ::flowProtocol::_tc_Start,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      flowProtocol::Start *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::flowProtocol::Start>::insert (
        _tao_any,
        ::flowProtocol::Start::_tao_any_destructor,
        ::flowProtocol::_tc_Start,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::flowProtocol::Start *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::flowProtocol::Start *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::flowProtocol::Start *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::flowProtocol::Start>::extract (
          _tao_any,
          ::flowProtocol::Start::_tao_any_destructor,
          ::flowProtocol::_tc_Start,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const flowProtocol::Start &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<flowProtocol::Start *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<flowProtocol::Start>::insert_copy (
        _tao_any,
        flowProtocol::Start::_tao_any_destructor,
        flowProtocol::_tc_Start,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    flowProtocol::Start *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<flowProtocol::Start>::insert (
      _tao_any,
      flowProtocol::Start::_tao_any_destructor,
      flowProtocol::_tc_Start,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    flowProtocol::Start *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const flowProtocol::Start *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const flowProtocol::Start *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<flowProtocol::Start>::extract (
        _tao_any,
        flowProtocol::Start::_tao_any_destructor,
        flowProtocol::_tc_Start,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace flowProtocol
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::flowProtocol::StartReply &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::flowProtocol::StartReply *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::flowProtocol::StartReply>::insert_copy (
          _tao_any,
          ::flowProtocol::StartReply::_tao_any_destructor,
          ::flowProtocol::_tc_StartReply,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      flowProtocol::StartReply *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::flowProtocol::StartReply>::insert (
        _tao_any,
        ::flowProtocol::StartReply::_tao_any_destructor,
        ::flowProtocol::_tc_StartReply,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::flowProtocol::StartReply *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::flowProtocol::StartReply *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::flowProtocol::StartReply *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::flowProtocol::StartReply>::extract (
          _tao_any,
          ::flowProtocol::StartReply::_tao_any_destructor,
          ::flowProtocol::_tc_StartReply,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const flowProtocol::StartReply &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<flowProtocol::StartReply *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<flowProtocol::StartReply>::insert_copy (
        _tao_any,
        flowProtocol::StartReply::_tao_any_destructor,
        flowProtocol::_tc_StartReply,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    flowProtocol::StartReply *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<flowProtocol::StartReply>::insert (
      _tao_any,
      flowProtocol::StartReply::_tao_any_destructor,
      flowProtocol::_tc_StartReply,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    flowProtocol::StartReply *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const flowProtocol::StartReply *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const flowProtocol::StartReply *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<flowProtocol::StartReply>::extract (
        _tao_any,
        flowProtocol::StartReply::_tao_any_destructor,
        flowProtocol::_tc_StartReply,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace flowProtocol
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::flowProtocol::sequencedFrame &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::flowProtocol::sequencedFrame *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::flowProtocol::sequencedFrame>::insert_copy (
          _tao_any,
          ::flowProtocol::sequencedFrame::_tao_any_destructor,
          ::flowProtocol::_tc_sequencedFrame,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      flowProtocol::sequencedFrame *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::flowProtocol::sequencedFrame>::insert (
        _tao_any,
        ::flowProtocol::sequencedFrame::_tao_any_destructor,
        ::flowProtocol::_tc_sequencedFrame,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::flowProtocol::sequencedFrame *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::flowProtocol::sequencedFrame *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::flowProtocol::sequencedFrame *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::flowProtocol::sequencedFrame>::extract (
          _tao_any,
          ::flowProtocol::sequencedFrame::_tao_any_destructor,
          ::flowProtocol::_tc_sequencedFrame,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const flowProtocol::sequencedFrame &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<flowProtocol::sequencedFrame *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<flowProtocol::sequencedFrame>::insert_copy (
        _tao_any,
        flowProtocol::sequencedFrame::_tao_any_destructor,
        flowProtocol::_tc_sequencedFrame,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    flowProtocol::sequencedFrame *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<flowProtocol::sequencedFrame>::insert (
      _tao_any,
      flowProtocol::sequencedFrame::_tao_any_destructor,
      flowProtocol::_tc_sequencedFrame,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    flowProtocol::sequencedFrame *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const flowProtocol::sequencedFrame *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const flowProtocol::sequencedFrame *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<flowProtocol::sequencedFrame>::extract (
        _tao_any,
        flowProtocol::sequencedFrame::_tao_any_destructor,
        flowProtocol::_tc_sequencedFrame,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace flowProtocol
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::flowProtocol::frame &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::flowProtocol::frame *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::flowProtocol::frame>::insert_copy (
          _tao_any,
          ::flowProtocol::frame::_tao_any_destructor,
          ::flowProtocol::_tc_frame,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      flowProtocol::frame *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::flowProtocol::frame>::insert (
        _tao_any,
        ::flowProtocol::frame::_tao_any_destructor,
        ::flowProtocol::_tc_frame,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::flowProtocol::frame *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::flowProtocol::frame *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::flowProtocol::frame *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::flowProtocol::frame>::extract (
          _tao_any,
          ::flowProtocol::frame::_tao_any_destructor,
          ::flowProtocol::_tc_frame,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const flowProtocol::frame &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<flowProtocol::frame *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<flowProtocol::frame>::insert_copy (
        _tao_any,
        flowProtocol::frame::_tao_any_destructor,
        flowProtocol::_tc_frame,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    flowProtocol::frame *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<flowProtocol::frame>::insert (
      _tao_any,
      flowProtocol::frame::_tao_any_destructor,
      flowProtocol::_tc_frame,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    flowProtocol::frame *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const flowProtocol::frame *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const flowProtocol::frame *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<flowProtocol::frame>::extract (
        _tao_any,
        flowProtocol::frame::_tao_any_destructor,
        flowProtocol::_tc_frame,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace flowProtocol
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::flowProtocol::specialFrame &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::flowProtocol::specialFrame *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::flowProtocol::specialFrame>::insert_copy (
          _tao_any,
          ::flowProtocol::specialFrame::_tao_any_destructor,
          ::flowProtocol::_tc_specialFrame,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      flowProtocol::specialFrame *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::flowProtocol::specialFrame>::insert (
        _tao_any,
        ::flowProtocol::specialFrame::_tao_any_destructor,
        ::flowProtocol::_tc_specialFrame,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::flowProtocol::specialFrame *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::flowProtocol::specialFrame *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::flowProtocol::specialFrame *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::flowProtocol::specialFrame>::extract (
          _tao_any,
          ::flowProtocol::specialFrame::_tao_any_destructor,
          ::flowProtocol::_tc_specialFrame,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const flowProtocol::specialFrame &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<flowProtocol::specialFrame *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<flowProtocol::specialFrame>::insert_copy (
        _tao_any,
        flowProtocol::specialFrame::_tao_any_destructor,
        flowProtocol::_tc_specialFrame,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    flowProtocol::specialFrame *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<flowProtocol::specialFrame>::insert (
      _tao_any,
      flowProtocol::specialFrame::_tao_any_destructor,
      flowProtocol::_tc_specialFrame,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    flowProtocol::specialFrame *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const flowProtocol::specialFrame *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const flowProtocol::specialFrame *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<flowProtocol::specialFrame>::extract (
        _tao_any,
        flowProtocol::specialFrame::_tao_any_destructor,
        flowProtocol::_tc_specialFrame,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace flowProtocol
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::flowProtocol::credit &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::flowProtocol::credit *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::flowProtocol::credit>::insert_copy (
          _tao_any,
          ::flowProtocol::credit::_tao_any_destructor,
          ::flowProtocol::_tc_credit,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      flowProtocol::credit *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::flowProtocol::credit>::insert (
        _tao_any,
        ::flowProtocol::credit::_tao_any_destructor,
        ::flowProtocol::_tc_credit,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::flowProtocol::credit *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::flowProtocol::credit *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::flowProtocol::credit *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::flowProtocol::credit>::extract (
          _tao_any,
          ::flowProtocol::credit::_tao_any_destructor,
          ::flowProtocol::_tc_credit,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const flowProtocol::credit &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<flowProtocol::credit *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<flowProtocol::credit>::insert_copy (
        _tao_any,
        flowProtocol::credit::_tao_any_destructor,
        flowProtocol::_tc_credit,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    flowProtocol::credit *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<flowProtocol::credit>::insert (
      _tao_any,
      flowProtocol::credit::_tao_any_destructor,
      flowProtocol::_tc_credit,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    flowProtocol::credit *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const flowProtocol::credit *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const flowProtocol::credit *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<flowProtocol::credit>::extract (
        _tao_any,
        flowProtocol::credit::_tao_any_destructor,
        flowProtocol::_tc_credit,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_array/cdr_op_cs.cpp:171



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const flowProtocol::cmagic_nr_forany &_tao_array
  )
{
  return
    strm.write_char_array (
        reinterpret_cast <const ACE_CDR::Char *> (_tao_array.in ()),
        4
      );
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    flowProtocol::cmagic_nr_forany &_tao_array
  )
{
  return
    strm.read_char_array (
        reinterpret_cast <ACE_CDR::Char *> (_tao_array.out ()),
        4
      );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, flowProtocol::MsgType _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, flowProtocol::MsgType & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<flowProtocol::MsgType> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const flowProtocol::frameHeader &_tao_aggregate)
{
  flowProtocol::cmagic_nr_forany _tao_aggregate_magic_number
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((flowProtocol::cmagic_nr_slice*) (
      #else
      (const_cast<
          flowProtocol::cmagic_nr_slice*> (
      #endif
          _tao_aggregate.magic_number
        )
    );
  return
    (strm << _tao_aggregate_magic_number) &&
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.flags)) &&
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.message_type)) &&
    (strm << _tao_aggregate.message_size);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    flowProtocol::frameHeader &_tao_aggregate)
{
  flowProtocol::cmagic_nr_forany _tao_aggregate_magic_number
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((flowProtocol::cmagic_nr_slice*) (
      #else
      (const_cast<
          flowProtocol::cmagic_nr_slice*> (
      #endif
          _tao_aggregate.magic_number
        )
    );
  return
    (strm >> _tao_aggregate_magic_number) &&
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.flags)) &&
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.message_type)) &&
    (strm >> _tao_aggregate.message_size);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const flowProtocol::fragment &_tao_aggregate)
{
  flowProtocol::cmagic_nr_forany _tao_aggregate_magic_number
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((flowProtocol::cmagic_nr_slice*) (
      #else
      (const_cast<
          flowProtocol::cmagic_nr_slice*> (
      #endif
          _tao_aggregate.magic_number
        )
    );
  return
    (strm << _tao_aggregate_magic_number) &&
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.flags)) &&
    (strm << _tao_aggregate.frag_number) &&
    (strm << _tao_aggregate.sequence_num) &&
    (strm << _tao_aggregate.frag_sz) &&
    (strm << _tao_aggregate.source_id);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    flowProtocol::fragment &_tao_aggregate)
{
  flowProtocol::cmagic_nr_forany _tao_aggregate_magic_number
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((flowProtocol::cmagic_nr_slice*) (
      #else
      (const_cast<
          flowProtocol::cmagic_nr_slice*> (
      #endif
          _tao_aggregate.magic_number
        )
    );
  return
    (strm >> _tao_aggregate_magic_number) &&
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.flags)) &&
    (strm >> _tao_aggregate.frag_number) &&
    (strm >> _tao_aggregate.sequence_num) &&
    (strm >> _tao_aggregate.frag_sz) &&
    (strm >> _tao_aggregate.source_id);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const flowProtocol::Start &_tao_aggregate)
{
  flowProtocol::cmagic_nr_forany _tao_aggregate_magic_number
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((flowProtocol::cmagic_nr_slice*) (
      #else
      (const_cast<
          flowProtocol::cmagic_nr_slice*> (
      #endif
          _tao_aggregate.magic_number
        )
    );
  return
    (strm << _tao_aggregate_magic_number) &&
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.major_version)) &&
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.minor_version)) &&
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.flags));
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    flowProtocol::Start &_tao_aggregate)
{
  flowProtocol::cmagic_nr_forany _tao_aggregate_magic_number
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((flowProtocol::cmagic_nr_slice*) (
      #else
      (const_cast<
          flowProtocol::cmagic_nr_slice*> (
      #endif
          _tao_aggregate.magic_number
        )
    );
  return
    (strm >> _tao_aggregate_magic_number) &&
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.major_version)) &&
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.minor_version)) &&
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.flags));
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const flowProtocol::StartReply &_tao_aggregate)
{
  flowProtocol::cmagic_nr_forany _tao_aggregate_magic_number
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((flowProtocol::cmagic_nr_slice*) (
      #else
      (const_cast<
          flowProtocol::cmagic_nr_slice*> (
      #endif
          _tao_aggregate.magic_number
        )
    );
  return
    (strm << _tao_aggregate_magic_number) &&
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.flags));
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    flowProtocol::StartReply &_tao_aggregate)
{
  flowProtocol::cmagic_nr_forany _tao_aggregate_magic_number
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((flowProtocol::cmagic_nr_slice*) (
      #else
      (const_cast<
          flowProtocol::cmagic_nr_slice*> (
      #endif
          _tao_aggregate.magic_number
        )
    );
  return
    (strm >> _tao_aggregate_magic_number) &&
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.flags));
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const flowProtocol::sequencedFrame &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.sequence_num);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    flowProtocol::sequencedFrame &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.sequence_num);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const flowProtocol::frame &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.timestamp) &&
    (strm << _tao_aggregate.synchSource) &&
    (strm << _tao_aggregate.source_ids) &&
    (strm << _tao_aggregate.sequence_num);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    flowProtocol::frame &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.timestamp) &&
    (strm >> _tao_aggregate.synchSource) &&
    (strm >> _tao_aggregate.source_ids) &&
    (strm >> _tao_aggregate.sequence_num);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const flowProtocol::specialFrame &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.context_id) &&
    (strm << _tao_aggregate.context_data);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    flowProtocol::specialFrame &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.context_id) &&
    (strm >> _tao_aggregate.context_data);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const flowProtocol::credit &_tao_aggregate)
{
  flowProtocol::cmagic_nr_forany _tao_aggregate_magic_number
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((flowProtocol::cmagic_nr_slice*) (
      #else
      (const_cast<
          flowProtocol::cmagic_nr_slice*> (
      #endif
          _tao_aggregate.magic_number
        )
    );
  return
    (strm << _tao_aggregate_magic_number) &&
    (strm << _tao_aggregate.cred_num);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    flowProtocol::credit &_tao_aggregate)
{
  flowProtocol::cmagic_nr_forany _tao_aggregate_magic_number
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((flowProtocol::cmagic_nr_slice*) (
      #else
      (const_cast<
          flowProtocol::cmagic_nr_slice*> (
      #endif
          _tao_aggregate.magic_number
        )
    );
  return
    (strm >> _tao_aggregate_magic_number) &&
    (strm >> _tao_aggregate.cred_num);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL





TAO_END_VERSIONED_NAMESPACE_DECL


