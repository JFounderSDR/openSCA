// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "CosTradingReposC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/TypeCode_Case_T.h"
#include "tao/AnyTypeCode/Union_TypeCode_Static.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "CosTradingReposC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosTradingRepos::ServiceTypeRepository.

CosTradingRepos::ServiceTypeRepository_ptr
TAO::Objref_Traits<CosTradingRepos::ServiceTypeRepository>::duplicate (
    CosTradingRepos::ServiceTypeRepository_ptr p)
{
  return CosTradingRepos::ServiceTypeRepository::_duplicate (p);
}

void
TAO::Objref_Traits<CosTradingRepos::ServiceTypeRepository>::release (
    CosTradingRepos::ServiceTypeRepository_ptr p)
{
  ::CORBA::release (p);
}

CosTradingRepos::ServiceTypeRepository_ptr
TAO::Objref_Traits<CosTradingRepos::ServiceTypeRepository>::nil (void)
{
  return CosTradingRepos::ServiceTypeRepository::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosTradingRepos::ServiceTypeRepository>::marshal (
    const CosTradingRepos::ServiceTypeRepository_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosTradingRepos__TAO_ServiceTypeRepository_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADINGREPOS_SERVICETYPEREPOSITORY_SERVICETYPENAMESEQ_CS_)
#define _COSTRADINGREPOS_SERVICETYPEREPOSITORY_SERVICETYPENAMESEQ_CS_

CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq::ServiceTypeNameSeq (void)
{}

CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq::ServiceTypeNameSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_basic_string_sequence<char> (max)
{}

CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq::ServiceTypeNameSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Char * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_basic_string_sequence<char>
    (max, length, buffer, release)
{}

CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq::ServiceTypeNameSeq (
    const ServiceTypeNameSeq &seq)
  : ::TAO::unbounded_basic_string_sequence<char> (seq)
{}

CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq::~ServiceTypeNameSeq (void)
{}

void CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ServiceTypeNameSeq * _tao_tmp_pointer =
    static_cast<ServiceTypeNameSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTradingRepos_ServiceTypeRepository_ServiceTypeNameSeq_GUARD
#define _TAO_TYPECODE_CosTradingRepos_ServiceTypeRepository_ServiceTypeNameSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTradingRepos_ServiceTypeRepository_ServiceTypeNameSeq_0 (
          ::CORBA::tk_sequence,
          &CosTrading::_tc_ServiceTypeName,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTradingRepos_ServiceTypeRepository_ServiceTypeNameSeq_0 =
        &CosTradingRepos_ServiceTypeRepository_ServiceTypeNameSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTradingRepos_ServiceTypeRepository_ServiceTypeNameSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingRepos_ServiceTypeRepository_ServiceTypeNameSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/ServiceTypeNameSeq:1.0",
    "ServiceTypeNameSeq",
    &TAO::TypeCode::tc_CosTradingRepos_ServiceTypeRepository_ServiceTypeNameSeq_0);
  
::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeNameSeq =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_ServiceTypeNameSeq;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_CosTradingRepos_ServiceTypeRepository_PropertyMode[] =
  {
    "PROP_NORMAL",
    "PROP_READONLY",
    "PROP_MANDATORY",
    "PROP_MANDATORY_READONLY"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingRepos_ServiceTypeRepository_PropertyMode (
    "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/PropertyMode:1.0",
    "PropertyMode",
    _tao_enumerators_CosTradingRepos_ServiceTypeRepository_PropertyMode,
    4);
  
::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_PropertyMode =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_PropertyMode;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTradingRepos_ServiceTypeRepository_PropStruct[] =
      {
        { "name", &CosTrading::_tc_PropertyName },
        { "value_type", &CORBA::_tc_TypeCode },
        { "mode", &CosTradingRepos::ServiceTypeRepository::_tc_PropertyMode }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTradingRepos_ServiceTypeRepository_PropStruct (
  ::CORBA::tk_struct,
  "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/PropStruct:1.0",
  "PropStruct",
  _tao_fields_CosTradingRepos_ServiceTypeRepository_PropStruct,
  3);

::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_PropStruct =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_PropStruct;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosTradingRepos::ServiceTypeRepository::PropStruct::_tao_any_destructor (
    void *_tao_void_pointer)
{
  PropStruct *_tao_tmp_pointer =
    static_cast<PropStruct *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADINGREPOS_SERVICETYPEREPOSITORY_PROPSTRUCTSEQ_CS_)
#define _COSTRADINGREPOS_SERVICETYPEREPOSITORY_PROPSTRUCTSEQ_CS_

CosTradingRepos::ServiceTypeRepository::PropStructSeq::PropStructSeq (void)
{}

CosTradingRepos::ServiceTypeRepository::PropStructSeq::PropStructSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        PropStruct
      > (max)
{}

CosTradingRepos::ServiceTypeRepository::PropStructSeq::PropStructSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CosTradingRepos::ServiceTypeRepository::PropStruct * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        PropStruct
      >
    (max, length, buffer, release)
{}

CosTradingRepos::ServiceTypeRepository::PropStructSeq::PropStructSeq (
    const PropStructSeq &seq)
  : ::TAO::unbounded_value_sequence<
        PropStruct
      > (seq)
{}

CosTradingRepos::ServiceTypeRepository::PropStructSeq::~PropStructSeq (void)
{}

void CosTradingRepos::ServiceTypeRepository::PropStructSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  PropStructSeq * _tao_tmp_pointer =
    static_cast<PropStructSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTradingRepos_ServiceTypeRepository_PropStructSeq_GUARD
#define _TAO_TYPECODE_CosTradingRepos_ServiceTypeRepository_PropStructSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTradingRepos_ServiceTypeRepository_PropStructSeq_0 (
          ::CORBA::tk_sequence,
          &CosTradingRepos::ServiceTypeRepository::_tc_PropStruct,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTradingRepos_ServiceTypeRepository_PropStructSeq_0 =
        &CosTradingRepos_ServiceTypeRepository_PropStructSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTradingRepos_ServiceTypeRepository_PropStructSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingRepos_ServiceTypeRepository_PropStructSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/PropStructSeq:1.0",
    "PropStructSeq",
    &TAO::TypeCode::tc_CosTradingRepos_ServiceTypeRepository_PropStructSeq_0);
  
::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_PropStructSeq =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_PropStructSeq;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingRepos_ServiceTypeRepository_Identifier (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/Identifier:1.0",
    "Identifier",
    &CosTrading::_tc_Istring);
  
::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_Identifier =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_Identifier;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTradingRepos_ServiceTypeRepository_IncarnationNumber[] =
      {
        { "high", &CORBA::_tc_ulong },
        { "low", &CORBA::_tc_ulong }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTradingRepos_ServiceTypeRepository_IncarnationNumber (
  ::CORBA::tk_struct,
  "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/IncarnationNumber:1.0",
  "IncarnationNumber",
  _tao_fields_CosTradingRepos_ServiceTypeRepository_IncarnationNumber,
  2);

::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_IncarnationNumber =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_IncarnationNumber;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosTradingRepos::ServiceTypeRepository::IncarnationNumber::_tao_any_destructor (
    void *_tao_void_pointer)
{
  IncarnationNumber *_tao_tmp_pointer =
    static_cast<IncarnationNumber *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTradingRepos_ServiceTypeRepository_TypeStruct[] =
      {
        { "if_name", &CosTradingRepos::ServiceTypeRepository::_tc_Identifier },
        { "props", &CosTradingRepos::ServiceTypeRepository::_tc_PropStructSeq },
        { "super_types", &CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeNameSeq },
        { "masked", &CORBA::_tc_boolean },
        { "incarnation", &CosTradingRepos::ServiceTypeRepository::_tc_IncarnationNumber }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTradingRepos_ServiceTypeRepository_TypeStruct (
  ::CORBA::tk_struct,
  "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/TypeStruct:1.0",
  "TypeStruct",
  _tao_fields_CosTradingRepos_ServiceTypeRepository_TypeStruct,
  5);

::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_TypeStruct =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_TypeStruct;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosTradingRepos::ServiceTypeRepository::TypeStruct::_tao_any_destructor (
    void *_tao_void_pointer)
{
  TypeStruct *_tao_tmp_pointer =
    static_cast<TypeStruct *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_CosTradingRepos_ServiceTypeRepository_ListOption[] =
  {
    "all",
    "since"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingRepos_ServiceTypeRepository_ListOption (
    "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/ListOption:1.0",
    "ListOption",
    _tao_enumerators_CosTradingRepos_ServiceTypeRepository_ListOption,
    2);
  
::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_ListOption =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_ListOption;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_union/union_cs.cpp:82

CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes::SpecifiedServiceTypes (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = (CosTradingRepos::ServiceTypeRepository::ListOption) -1;
}

CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes::SpecifiedServiceTypes (const ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case CosTradingRepos::ServiceTypeRepository::all:
    {
      this->u_.all__ = u.u_.all__;
    }
    break;
    case CosTradingRepos::ServiceTypeRepository::since:
    {
      this->u_.incarnation_ = u.u_.incarnation_;
    }
    break;
    default:
    break;
  }
}

CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes::~SpecifiedServiceTypes (void)
{
  // Finalize.
  this->_reset ();
}

void CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes::_tao_any_destructor (void *_tao_void_pointer)
{
  SpecifiedServiceTypes *tmp =
    static_cast<SpecifiedServiceTypes *> (_tao_void_pointer);
  delete tmp;
}

CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes &
CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes::operator= (const ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case CosTradingRepos::ServiceTypeRepository::all:
    {
      this->u_.all__ = u.u_.all__;
    }
    break;
    case CosTradingRepos::ServiceTypeRepository::since:
    {
      this->u_.incarnation_ = u.u_.incarnation_;
    }
    break;
    default:
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes::_reset (void)
{
  switch (this->disc_)
  {
    
    case CosTradingRepos::ServiceTypeRepository::all:
      break;
    case CosTradingRepos::ServiceTypeRepository::since:
      break;
    default:
    break;
  }
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/union_typecode.cpp:66

static TAO::TypeCode::Case_T<CosTradingRepos::ServiceTypeRepository::ListOption, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_CosTradingRepos_ServiceTypeRepository_SpecifiedServiceTypes__0 (CosTradingRepos::ServiceTypeRepository::all, "all_", &CORBA::_tc_boolean);
static TAO::TypeCode::Case_T<CosTradingRepos::ServiceTypeRepository::ListOption, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_CosTradingRepos_ServiceTypeRepository_SpecifiedServiceTypes__1 (CosTradingRepos::ServiceTypeRepository::since, "incarnation", &CosTradingRepos::ServiceTypeRepository::_tc_IncarnationNumber);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_CosTradingRepos_ServiceTypeRepository_SpecifiedServiceTypes[] =
  {
    &_tao_cases_CosTradingRepos_ServiceTypeRepository_SpecifiedServiceTypes__0,
    &_tao_cases_CosTradingRepos_ServiceTypeRepository_SpecifiedServiceTypes__1
    
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingRepos_ServiceTypeRepository_SpecifiedServiceTypes (
    "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/SpecifiedServiceTypes:1.0",
    "SpecifiedServiceTypes",
    &CosTradingRepos::ServiceTypeRepository::_tc_ListOption,
    _tao_cases_CosTradingRepos_ServiceTypeRepository_SpecifiedServiceTypes,
    2, -1);
  
::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_SpecifiedServiceTypes =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_SpecifiedServiceTypes;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::ServiceTypeExists (
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/ServiceTypeExists:1.0",
        "ServiceTypeExists"
      )
{
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::ServiceTypeExists (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/ServiceTypeExists:1.0",
        "ServiceTypeExists"
      )
{
}

CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::~ServiceTypeExists (void)
{
}

CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::ServiceTypeExists (const ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTradingRepos::ServiceTypeRepository::ServiceTypeExists&
CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::operator= (const ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_tao_any_destructor (void *_tao_void_pointer)
{
  ServiceTypeExists *_tao_tmp_pointer =
    static_cast<ServiceTypeExists *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTradingRepos::ServiceTypeRepository::ServiceTypeExists *
CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ServiceTypeExists *> (_tao_excp);
}

const CosTradingRepos::ServiceTypeRepository::ServiceTypeExists *
CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ServiceTypeExists *> (_tao_excp);
}

::CORBA::Exception *CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists, 0);
  return retval;
}

::CORBA::Exception *
CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists (*this),
      0
    );
  return result;
}

void CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_raise (void) const
{
  throw *this;
}

void CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_tao_type (void) const
{
  return ::CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeExists;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTradingRepos_ServiceTypeRepository_ServiceTypeExists[] =
      {
        { "name", &CosTrading::_tc_ServiceTypeName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTradingRepos_ServiceTypeRepository_ServiceTypeExists (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/ServiceTypeExists:1.0",
  "ServiceTypeExists",
  _tao_fields_CosTradingRepos_ServiceTypeRepository_ServiceTypeExists,
  1);

::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeExists =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_ServiceTypeExists;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::InterfaceTypeMismatch (
    const char * _tao_base_service,
    const char * _tao_base_if,
    const char * _tao_derived_service,
    const char * _tao_derived_if)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/InterfaceTypeMismatch:1.0",
        "InterfaceTypeMismatch"
      )
{
  this->base_service = ::CORBA::string_dup (_tao_base_service);
  this->base_if = ::CORBA::string_dup (_tao_base_if);
  this->derived_service = ::CORBA::string_dup (_tao_derived_service);
  this->derived_if = ::CORBA::string_dup (_tao_derived_if);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::InterfaceTypeMismatch (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/InterfaceTypeMismatch:1.0",
        "InterfaceTypeMismatch"
      )
{
}

CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::~InterfaceTypeMismatch (void)
{
}

CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::InterfaceTypeMismatch (const ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->base_service = ::CORBA::string_dup (_tao_excp.base_service.in ());
  this->base_if = ::CORBA::string_dup (_tao_excp.base_if.in ());
  this->derived_service = ::CORBA::string_dup (_tao_excp.derived_service.in ());
  this->derived_if = ::CORBA::string_dup (_tao_excp.derived_if.in ());
}

CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch&
CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::operator= (const ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->base_service = ::CORBA::string_dup (_tao_excp.base_service.in ());
  this->base_if = ::CORBA::string_dup (_tao_excp.base_if.in ());
  this->derived_service = ::CORBA::string_dup (_tao_excp.derived_service.in ());
  this->derived_if = ::CORBA::string_dup (_tao_excp.derived_if.in ());
  return *this;
}

void CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_tao_any_destructor (void *_tao_void_pointer)
{
  InterfaceTypeMismatch *_tao_tmp_pointer =
    static_cast<InterfaceTypeMismatch *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch *
CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InterfaceTypeMismatch *> (_tao_excp);
}

const CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch *
CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InterfaceTypeMismatch *> (_tao_excp);
}

::CORBA::Exception *CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch, 0);
  return retval;
}

::CORBA::Exception *
CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch (*this),
      0
    );
  return result;
}

void CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_raise (void) const
{
  throw *this;
}

void CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_tao_type (void) const
{
  return ::CosTradingRepos::ServiceTypeRepository::_tc_InterfaceTypeMismatch;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTradingRepos_ServiceTypeRepository_InterfaceTypeMismatch[] =
      {
        { "base_service", &CosTrading::_tc_ServiceTypeName },
        { "base_if", &CosTradingRepos::ServiceTypeRepository::_tc_Identifier },
        { "derived_service", &CosTrading::_tc_ServiceTypeName },
        { "derived_if", &CosTradingRepos::ServiceTypeRepository::_tc_Identifier }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTradingRepos_ServiceTypeRepository_InterfaceTypeMismatch (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/InterfaceTypeMismatch:1.0",
  "InterfaceTypeMismatch",
  _tao_fields_CosTradingRepos_ServiceTypeRepository_InterfaceTypeMismatch,
  4);

::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_InterfaceTypeMismatch =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_InterfaceTypeMismatch;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTradingRepos::ServiceTypeRepository::HasSubTypes::HasSubTypes (
    const char * _tao_the_type,
    const char * _tao_sub_type)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/HasSubTypes:1.0",
        "HasSubTypes"
      )
{
  this->the_type = ::CORBA::string_dup (_tao_the_type);
  this->sub_type = ::CORBA::string_dup (_tao_sub_type);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTradingRepos::ServiceTypeRepository::HasSubTypes::HasSubTypes (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/HasSubTypes:1.0",
        "HasSubTypes"
      )
{
}

CosTradingRepos::ServiceTypeRepository::HasSubTypes::~HasSubTypes (void)
{
}

CosTradingRepos::ServiceTypeRepository::HasSubTypes::HasSubTypes (const ::CosTradingRepos::ServiceTypeRepository::HasSubTypes &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->the_type = ::CORBA::string_dup (_tao_excp.the_type.in ());
  this->sub_type = ::CORBA::string_dup (_tao_excp.sub_type.in ());
}

CosTradingRepos::ServiceTypeRepository::HasSubTypes&
CosTradingRepos::ServiceTypeRepository::HasSubTypes::operator= (const ::CosTradingRepos::ServiceTypeRepository::HasSubTypes &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->the_type = ::CORBA::string_dup (_tao_excp.the_type.in ());
  this->sub_type = ::CORBA::string_dup (_tao_excp.sub_type.in ());
  return *this;
}

void CosTradingRepos::ServiceTypeRepository::HasSubTypes::_tao_any_destructor (void *_tao_void_pointer)
{
  HasSubTypes *_tao_tmp_pointer =
    static_cast<HasSubTypes *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTradingRepos::ServiceTypeRepository::HasSubTypes *
CosTradingRepos::ServiceTypeRepository::HasSubTypes::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<HasSubTypes *> (_tao_excp);
}

const CosTradingRepos::ServiceTypeRepository::HasSubTypes *
CosTradingRepos::ServiceTypeRepository::HasSubTypes::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const HasSubTypes *> (_tao_excp);
}

::CORBA::Exception *CosTradingRepos::ServiceTypeRepository::HasSubTypes::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTradingRepos::ServiceTypeRepository::HasSubTypes, 0);
  return retval;
}

::CORBA::Exception *
CosTradingRepos::ServiceTypeRepository::HasSubTypes::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTradingRepos::ServiceTypeRepository::HasSubTypes (*this),
      0
    );
  return result;
}

void CosTradingRepos::ServiceTypeRepository::HasSubTypes::_raise (void) const
{
  throw *this;
}

void CosTradingRepos::ServiceTypeRepository::HasSubTypes::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTradingRepos::ServiceTypeRepository::HasSubTypes::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTradingRepos::ServiceTypeRepository::HasSubTypes::_tao_type (void) const
{
  return ::CosTradingRepos::ServiceTypeRepository::_tc_HasSubTypes;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTradingRepos_ServiceTypeRepository_HasSubTypes[] =
      {
        { "the_type", &CosTrading::_tc_ServiceTypeName },
        { "sub_type", &CosTrading::_tc_ServiceTypeName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTradingRepos_ServiceTypeRepository_HasSubTypes (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/HasSubTypes:1.0",
  "HasSubTypes",
  _tao_fields_CosTradingRepos_ServiceTypeRepository_HasSubTypes,
  2);

::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_HasSubTypes =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_HasSubTypes;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTradingRepos::ServiceTypeRepository::AlreadyMasked::AlreadyMasked (
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/AlreadyMasked:1.0",
        "AlreadyMasked"
      )
{
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTradingRepos::ServiceTypeRepository::AlreadyMasked::AlreadyMasked (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/AlreadyMasked:1.0",
        "AlreadyMasked"
      )
{
}

CosTradingRepos::ServiceTypeRepository::AlreadyMasked::~AlreadyMasked (void)
{
}

CosTradingRepos::ServiceTypeRepository::AlreadyMasked::AlreadyMasked (const ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTradingRepos::ServiceTypeRepository::AlreadyMasked&
CosTradingRepos::ServiceTypeRepository::AlreadyMasked::operator= (const ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_tao_any_destructor (void *_tao_void_pointer)
{
  AlreadyMasked *_tao_tmp_pointer =
    static_cast<AlreadyMasked *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTradingRepos::ServiceTypeRepository::AlreadyMasked *
CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<AlreadyMasked *> (_tao_excp);
}

const CosTradingRepos::ServiceTypeRepository::AlreadyMasked *
CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const AlreadyMasked *> (_tao_excp);
}

::CORBA::Exception *CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked, 0);
  return retval;
}

::CORBA::Exception *
CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked (*this),
      0
    );
  return result;
}

void CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_raise (void) const
{
  throw *this;
}

void CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_tao_type (void) const
{
  return ::CosTradingRepos::ServiceTypeRepository::_tc_AlreadyMasked;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTradingRepos_ServiceTypeRepository_AlreadyMasked[] =
      {
        { "name", &CosTrading::_tc_ServiceTypeName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTradingRepos_ServiceTypeRepository_AlreadyMasked (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/AlreadyMasked:1.0",
  "AlreadyMasked",
  _tao_fields_CosTradingRepos_ServiceTypeRepository_AlreadyMasked,
  1);

::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_AlreadyMasked =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_AlreadyMasked;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTradingRepos::ServiceTypeRepository::NotMasked::NotMasked (
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/NotMasked:1.0",
        "NotMasked"
      )
{
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTradingRepos::ServiceTypeRepository::NotMasked::NotMasked (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/NotMasked:1.0",
        "NotMasked"
      )
{
}

CosTradingRepos::ServiceTypeRepository::NotMasked::~NotMasked (void)
{
}

CosTradingRepos::ServiceTypeRepository::NotMasked::NotMasked (const ::CosTradingRepos::ServiceTypeRepository::NotMasked &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTradingRepos::ServiceTypeRepository::NotMasked&
CosTradingRepos::ServiceTypeRepository::NotMasked::operator= (const ::CosTradingRepos::ServiceTypeRepository::NotMasked &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTradingRepos::ServiceTypeRepository::NotMasked::_tao_any_destructor (void *_tao_void_pointer)
{
  NotMasked *_tao_tmp_pointer =
    static_cast<NotMasked *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTradingRepos::ServiceTypeRepository::NotMasked *
CosTradingRepos::ServiceTypeRepository::NotMasked::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NotMasked *> (_tao_excp);
}

const CosTradingRepos::ServiceTypeRepository::NotMasked *
CosTradingRepos::ServiceTypeRepository::NotMasked::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NotMasked *> (_tao_excp);
}

::CORBA::Exception *CosTradingRepos::ServiceTypeRepository::NotMasked::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTradingRepos::ServiceTypeRepository::NotMasked, 0);
  return retval;
}

::CORBA::Exception *
CosTradingRepos::ServiceTypeRepository::NotMasked::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTradingRepos::ServiceTypeRepository::NotMasked (*this),
      0
    );
  return result;
}

void CosTradingRepos::ServiceTypeRepository::NotMasked::_raise (void) const
{
  throw *this;
}

void CosTradingRepos::ServiceTypeRepository::NotMasked::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTradingRepos::ServiceTypeRepository::NotMasked::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTradingRepos::ServiceTypeRepository::NotMasked::_tao_type (void) const
{
  return ::CosTradingRepos::ServiceTypeRepository::_tc_NotMasked;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTradingRepos_ServiceTypeRepository_NotMasked[] =
      {
        { "name", &CosTrading::_tc_ServiceTypeName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTradingRepos_ServiceTypeRepository_NotMasked (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/NotMasked:1.0",
  "NotMasked",
  _tao_fields_CosTradingRepos_ServiceTypeRepository_NotMasked,
  1);

::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_NotMasked =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_NotMasked;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::ValueTypeRedefinition (
    const char * _tao_type_1,
    const CosTradingRepos::ServiceTypeRepository::PropStruct & _tao_definition_1,
    const char * _tao_type_2,
    const CosTradingRepos::ServiceTypeRepository::PropStruct & _tao_definition_2)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/ValueTypeRedefinition:1.0",
        "ValueTypeRedefinition"
      )
{
  this->type_1 = ::CORBA::string_dup (_tao_type_1);
  this->definition_1 = _tao_definition_1;
  this->type_2 = ::CORBA::string_dup (_tao_type_2);
  this->definition_2 = _tao_definition_2;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::ValueTypeRedefinition (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/ValueTypeRedefinition:1.0",
        "ValueTypeRedefinition"
      )
{
}

CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::~ValueTypeRedefinition (void)
{
}

CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::ValueTypeRedefinition (const ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->type_1 = ::CORBA::string_dup (_tao_excp.type_1.in ());
  this->definition_1 = _tao_excp.definition_1;
  this->type_2 = ::CORBA::string_dup (_tao_excp.type_2.in ());
  this->definition_2 = _tao_excp.definition_2;
}

CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition&
CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::operator= (const ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->type_1 = ::CORBA::string_dup (_tao_excp.type_1.in ());
  this->definition_1 = _tao_excp.definition_1;
  this->type_2 = ::CORBA::string_dup (_tao_excp.type_2.in ());
  this->definition_2 = _tao_excp.definition_2;
  return *this;
}

void CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_tao_any_destructor (void *_tao_void_pointer)
{
  ValueTypeRedefinition *_tao_tmp_pointer =
    static_cast<ValueTypeRedefinition *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition *
CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ValueTypeRedefinition *> (_tao_excp);
}

const CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition *
CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ValueTypeRedefinition *> (_tao_excp);
}

::CORBA::Exception *CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition, 0);
  return retval;
}

::CORBA::Exception *
CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition (*this),
      0
    );
  return result;
}

void CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_raise (void) const
{
  throw *this;
}

void CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_tao_type (void) const
{
  return ::CosTradingRepos::ServiceTypeRepository::_tc_ValueTypeRedefinition;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTradingRepos_ServiceTypeRepository_ValueTypeRedefinition[] =
      {
        { "type_1", &CosTrading::_tc_ServiceTypeName },
        { "definition_1", &CosTradingRepos::ServiceTypeRepository::_tc_PropStruct },
        { "type_2", &CosTrading::_tc_ServiceTypeName },
        { "definition_2", &CosTradingRepos::ServiceTypeRepository::_tc_PropStruct }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTradingRepos_ServiceTypeRepository_ValueTypeRedefinition (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/ValueTypeRedefinition:1.0",
  "ValueTypeRedefinition",
  _tao_fields_CosTradingRepos_ServiceTypeRepository_ValueTypeRedefinition,
  4);

::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_ValueTypeRedefinition =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_ValueTypeRedefinition;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::DuplicateServiceTypeName (
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/DuplicateServiceTypeName:1.0",
        "DuplicateServiceTypeName"
      )
{
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::DuplicateServiceTypeName (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/DuplicateServiceTypeName:1.0",
        "DuplicateServiceTypeName"
      )
{
}

CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::~DuplicateServiceTypeName (void)
{
}

CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::DuplicateServiceTypeName (const ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName&
CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::operator= (const ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_tao_any_destructor (void *_tao_void_pointer)
{
  DuplicateServiceTypeName *_tao_tmp_pointer =
    static_cast<DuplicateServiceTypeName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName *
CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<DuplicateServiceTypeName *> (_tao_excp);
}

const CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName *
CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const DuplicateServiceTypeName *> (_tao_excp);
}

::CORBA::Exception *CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName, 0);
  return retval;
}

::CORBA::Exception *
CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName (*this),
      0
    );
  return result;
}

void CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_raise (void) const
{
  throw *this;
}

void CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_tao_type (void) const
{
  return ::CosTradingRepos::ServiceTypeRepository::_tc_DuplicateServiceTypeName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTradingRepos_ServiceTypeRepository_DuplicateServiceTypeName[] =
      {
        { "name", &CosTrading::_tc_ServiceTypeName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTradingRepos_ServiceTypeRepository_DuplicateServiceTypeName (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/DuplicateServiceTypeName:1.0",
  "DuplicateServiceTypeName",
  _tao_fields_CosTradingRepos_ServiceTypeRepository_DuplicateServiceTypeName,
  1);

::CORBA::TypeCode_ptr const CosTradingRepos::ServiceTypeRepository::_tc_DuplicateServiceTypeName =
  &_tao_tc_CosTradingRepos_ServiceTypeRepository_DuplicateServiceTypeName;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTradingRepos::ServiceTypeRepository::IncarnationNumber
CosTradingRepos::ServiceTypeRepository::incarnation (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ServiceTypeRepository_Proxy_Broker_ == 0)
    {
      CosTradingRepos_ServiceTypeRepository_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTradingRepos::ServiceTypeRepository::IncarnationNumber>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_incarnation",
      16,
      this->the_TAO_ServiceTypeRepository_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTradingRepos::ServiceTypeRepository::IncarnationNumber
CosTradingRepos::ServiceTypeRepository::add_type (
  const char * name,
  const char * if_name,
  const ::CosTradingRepos::ServiceTypeRepository::PropStructSeq & props,
  const ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq & super_types)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ServiceTypeRepository_Proxy_Broker_ == 0)
    {
      CosTradingRepos_ServiceTypeRepository_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTradingRepos::ServiceTypeRepository::IncarnationNumber>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);
  TAO::Arg_Traits< char *>::in_arg_val _tao_if_name (if_name);
  TAO::Arg_Traits< ::CosTradingRepos::ServiceTypeRepository::PropStructSeq>::in_arg_val _tao_props (props);
  TAO::Arg_Traits< ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq>::in_arg_val _tao_super_types (super_types);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_name,
      &_tao_if_name,
      &_tao_props,
      &_tao_super_types
    };

  static TAO::Exception_Data
  _tao_CosTradingRepos_ServiceTypeRepository_add_type_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/IllegalServiceType:1.0",
        CosTrading::IllegalServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/ServiceTypeExists:1.0",
        CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeExists
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/InterfaceTypeMismatch:1.0",
        CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTradingRepos::ServiceTypeRepository::_tc_InterfaceTypeMismatch
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/IllegalPropertyName:1.0",
        CosTrading::IllegalPropertyName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalPropertyName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/DuplicatePropertyName:1.0",
        CosTrading::DuplicatePropertyName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_DuplicatePropertyName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/ValueTypeRedefinition:1.0",
        CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTradingRepos::ServiceTypeRepository::_tc_ValueTypeRedefinition
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownServiceType:1.0",
        CosTrading::UnknownServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/DuplicateServiceTypeName:1.0",
        CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTradingRepos::ServiceTypeRepository::_tc_DuplicateServiceTypeName
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "add_type",
      8,
      this->the_TAO_ServiceTypeRepository_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTradingRepos_ServiceTypeRepository_add_type_exceptiondata,
      8
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTradingRepos::ServiceTypeRepository::remove_type (
  const char * name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ServiceTypeRepository_Proxy_Broker_ == 0)
    {
      CosTradingRepos_ServiceTypeRepository_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_name
    };

  static TAO::Exception_Data
  _tao_CosTradingRepos_ServiceTypeRepository_remove_type_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/IllegalServiceType:1.0",
        CosTrading::IllegalServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownServiceType:1.0",
        CosTrading::UnknownServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/HasSubTypes:1.0",
        CosTradingRepos::ServiceTypeRepository::HasSubTypes::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTradingRepos::ServiceTypeRepository::_tc_HasSubTypes
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_type",
      11,
      this->the_TAO_ServiceTypeRepository_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTradingRepos_ServiceTypeRepository_remove_type_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq *
CosTradingRepos::ServiceTypeRepository::list_types (
  const ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes & which_types)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ServiceTypeRepository_Proxy_Broker_ == 0)
    {
      CosTradingRepos_ServiceTypeRepository_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes>::in_arg_val _tao_which_types (which_types);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_which_types
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "list_types",
      10,
      this->the_TAO_ServiceTypeRepository_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTradingRepos::ServiceTypeRepository::TypeStruct *
CosTradingRepos::ServiceTypeRepository::describe_type (
  const char * name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ServiceTypeRepository_Proxy_Broker_ == 0)
    {
      CosTradingRepos_ServiceTypeRepository_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTradingRepos::ServiceTypeRepository::TypeStruct>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_name
    };

  static TAO::Exception_Data
  _tao_CosTradingRepos_ServiceTypeRepository_describe_type_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/IllegalServiceType:1.0",
        CosTrading::IllegalServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownServiceType:1.0",
        CosTrading::UnknownServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "describe_type",
      13,
      this->the_TAO_ServiceTypeRepository_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTradingRepos_ServiceTypeRepository_describe_type_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTradingRepos::ServiceTypeRepository::TypeStruct *
CosTradingRepos::ServiceTypeRepository::fully_describe_type (
  const char * name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ServiceTypeRepository_Proxy_Broker_ == 0)
    {
      CosTradingRepos_ServiceTypeRepository_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTradingRepos::ServiceTypeRepository::TypeStruct>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_name
    };

  static TAO::Exception_Data
  _tao_CosTradingRepos_ServiceTypeRepository_fully_describe_type_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/IllegalServiceType:1.0",
        CosTrading::IllegalServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownServiceType:1.0",
        CosTrading::UnknownServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "fully_describe_type",
      19,
      this->the_TAO_ServiceTypeRepository_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTradingRepos_ServiceTypeRepository_fully_describe_type_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTradingRepos::ServiceTypeRepository::mask_type (
  const char * name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ServiceTypeRepository_Proxy_Broker_ == 0)
    {
      CosTradingRepos_ServiceTypeRepository_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_name
    };

  static TAO::Exception_Data
  _tao_CosTradingRepos_ServiceTypeRepository_mask_type_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/IllegalServiceType:1.0",
        CosTrading::IllegalServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownServiceType:1.0",
        CosTrading::UnknownServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/AlreadyMasked:1.0",
        CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTradingRepos::ServiceTypeRepository::_tc_AlreadyMasked
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "mask_type",
      9,
      this->the_TAO_ServiceTypeRepository_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTradingRepos_ServiceTypeRepository_mask_type_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTradingRepos::ServiceTypeRepository::unmask_type (
  const char * name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ServiceTypeRepository_Proxy_Broker_ == 0)
    {
      CosTradingRepos_ServiceTypeRepository_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_name
    };

  static TAO::Exception_Data
  _tao_CosTradingRepos_ServiceTypeRepository_unmask_type_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/IllegalServiceType:1.0",
        CosTrading::IllegalServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownServiceType:1.0",
        CosTrading::UnknownServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository/NotMasked:1.0",
        CosTradingRepos::ServiceTypeRepository::NotMasked::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTradingRepos::ServiceTypeRepository::_tc_NotMasked
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "unmask_type",
      11,
      this->the_TAO_ServiceTypeRepository_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTradingRepos_ServiceTypeRepository_unmask_type_exceptiondata,
      3
    );
}

CosTradingRepos::ServiceTypeRepository::ServiceTypeRepository (void)
 : the_TAO_ServiceTypeRepository_Proxy_Broker_ (0)
{
  this->CosTradingRepos_ServiceTypeRepository_setup_collocation ();
}

void
CosTradingRepos::ServiceTypeRepository::CosTradingRepos_ServiceTypeRepository_setup_collocation ()
{
  if (::CosTradingRepos__TAO_ServiceTypeRepository_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_ServiceTypeRepository_Proxy_Broker_ =
        ::CosTradingRepos__TAO_ServiceTypeRepository_Proxy_Broker_Factory_function_pointer (this);
    }
}

CosTradingRepos::ServiceTypeRepository::~ServiceTypeRepository (void)
{}

void 
CosTradingRepos::ServiceTypeRepository::_tao_any_destructor (void *_tao_void_pointer)
{
  ServiceTypeRepository *_tao_tmp_pointer =
    static_cast<ServiceTypeRepository *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosTradingRepos::ServiceTypeRepository_ptr
CosTradingRepos::ServiceTypeRepository::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ServiceTypeRepository>::narrow (
        _tao_objref,
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository:1.0",
        CosTradingRepos__TAO_ServiceTypeRepository_Proxy_Broker_Factory_function_pointer
      );
}

CosTradingRepos::ServiceTypeRepository_ptr
CosTradingRepos::ServiceTypeRepository::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ServiceTypeRepository>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosTradingRepos/ServiceTypeRepository:1.0",
        CosTradingRepos__TAO_ServiceTypeRepository_Proxy_Broker_Factory_function_pointer
      );
}

CosTradingRepos::ServiceTypeRepository_ptr
CosTradingRepos::ServiceTypeRepository::_nil (void)
{
  return 0;
}

CosTradingRepos::ServiceTypeRepository_ptr
CosTradingRepos::ServiceTypeRepository::_duplicate (ServiceTypeRepository_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosTradingRepos::ServiceTypeRepository::_tao_release (ServiceTypeRepository_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosTradingRepos::ServiceTypeRepository::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTradingRepos/ServiceTypeRepository:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosTradingRepos::ServiceTypeRepository::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosTradingRepos/ServiceTypeRepository:1.0";
}

::CORBA::Boolean
CosTradingRepos::ServiceTypeRepository::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingRepos_ServiceTypeRepository (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosTradingRepos/ServiceTypeRepository:1.0",
    "ServiceTypeRepository");
  

namespace CosTradingRepos
{
  ::CORBA::TypeCode_ptr const _tc_ServiceTypeRepository =
    &_tao_tc_CosTradingRepos_ServiceTypeRepository;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADINGSEQUENCES_SHORTSEQ_CS_)
#define _COSTRADINGSEQUENCES_SHORTSEQ_CS_

CosTradingSequences::ShortSeq::ShortSeq (void)
{}

CosTradingSequences::ShortSeq::ShortSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Short
      > (max)
{}

CosTradingSequences::ShortSeq::ShortSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Short * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Short
      >
    (max, length, buffer, release)
{}

CosTradingSequences::ShortSeq::ShortSeq (
    const ShortSeq &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Short
      > (seq)
{}

CosTradingSequences::ShortSeq::~ShortSeq (void)
{}

void CosTradingSequences::ShortSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ShortSeq * _tao_tmp_pointer =
    static_cast<ShortSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTradingSequences_ShortSeq_GUARD
#define _TAO_TYPECODE_CosTradingSequences_ShortSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTradingSequences_ShortSeq_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_short,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTradingSequences_ShortSeq_0 =
        &CosTradingSequences_ShortSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTradingSequences_ShortSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingSequences_ShortSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTradingSequences/ShortSeq:1.0",
    "ShortSeq",
    &TAO::TypeCode::tc_CosTradingSequences_ShortSeq_0);
  

namespace CosTradingSequences
{
  ::CORBA::TypeCode_ptr const _tc_ShortSeq =
    &_tao_tc_CosTradingSequences_ShortSeq;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADINGSEQUENCES_USHORTSEQ_CS_)
#define _COSTRADINGSEQUENCES_USHORTSEQ_CS_

CosTradingSequences::UShortSeq::UShortSeq (void)
{}

CosTradingSequences::UShortSeq::UShortSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::UShort
      > (max)
{}

CosTradingSequences::UShortSeq::UShortSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::UShort * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::UShort
      >
    (max, length, buffer, release)
{}

CosTradingSequences::UShortSeq::UShortSeq (
    const UShortSeq &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::UShort
      > (seq)
{}

CosTradingSequences::UShortSeq::~UShortSeq (void)
{}

void CosTradingSequences::UShortSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  UShortSeq * _tao_tmp_pointer =
    static_cast<UShortSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTradingSequences_UShortSeq_GUARD
#define _TAO_TYPECODE_CosTradingSequences_UShortSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTradingSequences_UShortSeq_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_ushort,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTradingSequences_UShortSeq_0 =
        &CosTradingSequences_UShortSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTradingSequences_UShortSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingSequences_UShortSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTradingSequences/UShortSeq:1.0",
    "UShortSeq",
    &TAO::TypeCode::tc_CosTradingSequences_UShortSeq_0);
  

namespace CosTradingSequences
{
  ::CORBA::TypeCode_ptr const _tc_UShortSeq =
    &_tao_tc_CosTradingSequences_UShortSeq;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADINGSEQUENCES_LONGSEQ_CS_)
#define _COSTRADINGSEQUENCES_LONGSEQ_CS_

CosTradingSequences::LongSeq::LongSeq (void)
{}

CosTradingSequences::LongSeq::LongSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      > (max)
{}

CosTradingSequences::LongSeq::LongSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      >
    (max, length, buffer, release)
{}

CosTradingSequences::LongSeq::LongSeq (
    const LongSeq &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      > (seq)
{}

CosTradingSequences::LongSeq::~LongSeq (void)
{}

void CosTradingSequences::LongSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  LongSeq * _tao_tmp_pointer =
    static_cast<LongSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTradingSequences_LongSeq_GUARD
#define _TAO_TYPECODE_CosTradingSequences_LongSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTradingSequences_LongSeq_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_long,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTradingSequences_LongSeq_0 =
        &CosTradingSequences_LongSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTradingSequences_LongSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingSequences_LongSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTradingSequences/LongSeq:1.0",
    "LongSeq",
    &TAO::TypeCode::tc_CosTradingSequences_LongSeq_0);
  

namespace CosTradingSequences
{
  ::CORBA::TypeCode_ptr const _tc_LongSeq =
    &_tao_tc_CosTradingSequences_LongSeq;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADINGSEQUENCES_ULONGSEQ_CS_)
#define _COSTRADINGSEQUENCES_ULONGSEQ_CS_

CosTradingSequences::ULongSeq::ULongSeq (void)
{}

CosTradingSequences::ULongSeq::ULongSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::ULong
      > (max)
{}

CosTradingSequences::ULongSeq::ULongSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::ULong * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::ULong
      >
    (max, length, buffer, release)
{}

CosTradingSequences::ULongSeq::ULongSeq (
    const ULongSeq &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::ULong
      > (seq)
{}

CosTradingSequences::ULongSeq::~ULongSeq (void)
{}

void CosTradingSequences::ULongSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ULongSeq * _tao_tmp_pointer =
    static_cast<ULongSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTradingSequences_ULongSeq_GUARD
#define _TAO_TYPECODE_CosTradingSequences_ULongSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTradingSequences_ULongSeq_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_ulong,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTradingSequences_ULongSeq_0 =
        &CosTradingSequences_ULongSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTradingSequences_ULongSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingSequences_ULongSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTradingSequences/ULongSeq:1.0",
    "ULongSeq",
    &TAO::TypeCode::tc_CosTradingSequences_ULongSeq_0);
  

namespace CosTradingSequences
{
  ::CORBA::TypeCode_ptr const _tc_ULongSeq =
    &_tao_tc_CosTradingSequences_ULongSeq;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADINGSEQUENCES_BOOLEANSEQ_CS_)
#define _COSTRADINGSEQUENCES_BOOLEANSEQ_CS_

CosTradingSequences::BooleanSeq::BooleanSeq (void)
{}

CosTradingSequences::BooleanSeq::BooleanSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Boolean
      > (max)
{}

CosTradingSequences::BooleanSeq::BooleanSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Boolean * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Boolean
      >
    (max, length, buffer, release)
{}

CosTradingSequences::BooleanSeq::BooleanSeq (
    const BooleanSeq &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Boolean
      > (seq)
{}

CosTradingSequences::BooleanSeq::~BooleanSeq (void)
{}

void CosTradingSequences::BooleanSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  BooleanSeq * _tao_tmp_pointer =
    static_cast<BooleanSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTradingSequences_BooleanSeq_GUARD
#define _TAO_TYPECODE_CosTradingSequences_BooleanSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTradingSequences_BooleanSeq_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_boolean,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTradingSequences_BooleanSeq_0 =
        &CosTradingSequences_BooleanSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTradingSequences_BooleanSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingSequences_BooleanSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTradingSequences/BooleanSeq:1.0",
    "BooleanSeq",
    &TAO::TypeCode::tc_CosTradingSequences_BooleanSeq_0);
  

namespace CosTradingSequences
{
  ::CORBA::TypeCode_ptr const _tc_BooleanSeq =
    &_tao_tc_CosTradingSequences_BooleanSeq;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADINGSEQUENCES_FLOATSEQ_CS_)
#define _COSTRADINGSEQUENCES_FLOATSEQ_CS_

CosTradingSequences::FloatSeq::FloatSeq (void)
{}

CosTradingSequences::FloatSeq::FloatSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Float
      > (max)
{}

CosTradingSequences::FloatSeq::FloatSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Float * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Float
      >
    (max, length, buffer, release)
{}

CosTradingSequences::FloatSeq::FloatSeq (
    const FloatSeq &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Float
      > (seq)
{}

CosTradingSequences::FloatSeq::~FloatSeq (void)
{}

void CosTradingSequences::FloatSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  FloatSeq * _tao_tmp_pointer =
    static_cast<FloatSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTradingSequences_FloatSeq_GUARD
#define _TAO_TYPECODE_CosTradingSequences_FloatSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTradingSequences_FloatSeq_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_float,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTradingSequences_FloatSeq_0 =
        &CosTradingSequences_FloatSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTradingSequences_FloatSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingSequences_FloatSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTradingSequences/FloatSeq:1.0",
    "FloatSeq",
    &TAO::TypeCode::tc_CosTradingSequences_FloatSeq_0);
  

namespace CosTradingSequences
{
  ::CORBA::TypeCode_ptr const _tc_FloatSeq =
    &_tao_tc_CosTradingSequences_FloatSeq;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADINGSEQUENCES_DOUBLESEQ_CS_)
#define _COSTRADINGSEQUENCES_DOUBLESEQ_CS_

CosTradingSequences::DoubleSeq::DoubleSeq (void)
{}

CosTradingSequences::DoubleSeq::DoubleSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Double
      > (max)
{}

CosTradingSequences::DoubleSeq::DoubleSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Double * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Double
      >
    (max, length, buffer, release)
{}

CosTradingSequences::DoubleSeq::DoubleSeq (
    const DoubleSeq &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Double
      > (seq)
{}

CosTradingSequences::DoubleSeq::~DoubleSeq (void)
{}

void CosTradingSequences::DoubleSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  DoubleSeq * _tao_tmp_pointer =
    static_cast<DoubleSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTradingSequences_DoubleSeq_GUARD
#define _TAO_TYPECODE_CosTradingSequences_DoubleSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTradingSequences_DoubleSeq_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_double,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTradingSequences_DoubleSeq_0 =
        &CosTradingSequences_DoubleSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTradingSequences_DoubleSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingSequences_DoubleSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTradingSequences/DoubleSeq:1.0",
    "DoubleSeq",
    &TAO::TypeCode::tc_CosTradingSequences_DoubleSeq_0);
  

namespace CosTradingSequences
{
  ::CORBA::TypeCode_ptr const _tc_DoubleSeq =
    &_tao_tc_CosTradingSequences_DoubleSeq;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADINGSEQUENCES_STRINGSEQ_CS_)
#define _COSTRADINGSEQUENCES_STRINGSEQ_CS_

CosTradingSequences::StringSeq::StringSeq (void)
{}

CosTradingSequences::StringSeq::StringSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_basic_string_sequence<char> (max)
{}

CosTradingSequences::StringSeq::StringSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Char * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_basic_string_sequence<char>
    (max, length, buffer, release)
{}

CosTradingSequences::StringSeq::StringSeq (
    const StringSeq &seq)
  : ::TAO::unbounded_basic_string_sequence<char> (seq)
{}

CosTradingSequences::StringSeq::~StringSeq (void)
{}

void CosTradingSequences::StringSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  StringSeq * _tao_tmp_pointer =
    static_cast<StringSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTradingSequences_StringSeq_GUARD
#define _TAO_TYPECODE_CosTradingSequences_StringSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTradingSequences_StringSeq_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_string,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTradingSequences_StringSeq_0 =
        &CosTradingSequences_StringSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTradingSequences_StringSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTradingSequences_StringSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTradingSequences/StringSeq:1.0",
    "StringSeq",
    &TAO::TypeCode::tc_CosTradingSequences_StringSeq_0);
  

namespace CosTradingSequences
{
  ::CORBA::TypeCode_ptr const _tc_StringSeq =
    &_tao_tc_CosTradingSequences_StringSeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosTradingRepos::ServiceTypeRepository>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ServiceTypeRepository_ptr _tao_elem)
  {
    ServiceTypeRepository_ptr _tao_objptr =
      ServiceTypeRepository::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ServiceTypeRepository_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<ServiceTypeRepository>::insert (
        _tao_any,
        ServiceTypeRepository::_tao_any_destructor,
        _tc_ServiceTypeRepository,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      ServiceTypeRepository_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<ServiceTypeRepository>::extract (
          _tao_any,
          ServiceTypeRepository::_tao_any_destructor,
          _tc_ServiceTypeRepository,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository_ptr _tao_elem)
{
  CosTradingRepos::ServiceTypeRepository_ptr _tao_objptr =
    CosTradingRepos::ServiceTypeRepository::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosTradingRepos::ServiceTypeRepository>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::_tao_any_destructor,
      CosTradingRepos::_tc_ServiceTypeRepository,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosTradingRepos::ServiceTypeRepository>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::_tao_any_destructor,
        CosTradingRepos::_tc_ServiceTypeRepository,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq>::insert_copy (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeNameSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeNameSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeNameSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq>::insert_copy (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeNameSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeNameSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeNameSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::PropertyMode _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::CosTradingRepos::ServiceTypeRepository::PropertyMode>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::_tc_PropertyMode,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::PropertyMode &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::CosTradingRepos::ServiceTypeRepository::PropertyMode>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::_tc_PropertyMode,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::PropertyMode _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<CosTradingRepos::ServiceTypeRepository::PropertyMode>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::_tc_PropertyMode,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::PropertyMode &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<CosTradingRepos::ServiceTypeRepository::PropertyMode>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::_tc_PropertyMode,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::PropStruct &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTradingRepos::ServiceTypeRepository::PropStruct *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::PropStruct>::insert_copy (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::PropStruct::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_PropStruct,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosTradingRepos::ServiceTypeRepository::PropStruct *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::PropStruct>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::PropStruct::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_PropStruct,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::PropStruct *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingRepos::ServiceTypeRepository::PropStruct *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::PropStruct *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::PropStruct>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::PropStruct::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_PropStruct,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::PropStruct &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTradingRepos::ServiceTypeRepository::PropStruct *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::PropStruct>::insert_copy (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::PropStruct::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_PropStruct,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::PropStruct *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::PropStruct>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::PropStruct::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_PropStruct,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::PropStruct *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingRepos::ServiceTypeRepository::PropStruct *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::PropStruct *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::PropStruct>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::PropStruct::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_PropStruct,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::PropStructSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTradingRepos::ServiceTypeRepository::PropStructSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::PropStructSeq>::insert_copy (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::PropStructSeq::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_PropStructSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::PropStructSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::PropStructSeq>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::PropStructSeq::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_PropStructSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::PropStructSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingRepos::ServiceTypeRepository::PropStructSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::PropStructSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::PropStructSeq>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::PropStructSeq::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_PropStructSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::PropStructSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTradingRepos::ServiceTypeRepository::PropStructSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::PropStructSeq>::insert_copy (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::PropStructSeq::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_PropStructSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::PropStructSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::PropStructSeq>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::PropStructSeq::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_PropStructSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::PropStructSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingRepos::ServiceTypeRepository::PropStructSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::PropStructSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::PropStructSeq>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::PropStructSeq::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_PropStructSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::IncarnationNumber &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTradingRepos::ServiceTypeRepository::IncarnationNumber *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::IncarnationNumber>::insert_copy (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::IncarnationNumber::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_IncarnationNumber,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosTradingRepos::ServiceTypeRepository::IncarnationNumber *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::IncarnationNumber>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::IncarnationNumber::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_IncarnationNumber,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::IncarnationNumber *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingRepos::ServiceTypeRepository::IncarnationNumber *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::IncarnationNumber *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::IncarnationNumber>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::IncarnationNumber::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_IncarnationNumber,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::IncarnationNumber &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTradingRepos::ServiceTypeRepository::IncarnationNumber *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::IncarnationNumber>::insert_copy (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::IncarnationNumber::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_IncarnationNumber,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::IncarnationNumber *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::IncarnationNumber>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::IncarnationNumber::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_IncarnationNumber,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::IncarnationNumber *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingRepos::ServiceTypeRepository::IncarnationNumber *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::IncarnationNumber *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::IncarnationNumber>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::IncarnationNumber::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_IncarnationNumber,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::TypeStruct &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTradingRepos::ServiceTypeRepository::TypeStruct *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::TypeStruct>::insert_copy (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::TypeStruct::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_TypeStruct,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosTradingRepos::ServiceTypeRepository::TypeStruct *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::TypeStruct>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::TypeStruct::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_TypeStruct,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::TypeStruct *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingRepos::ServiceTypeRepository::TypeStruct *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::TypeStruct *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::TypeStruct>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::TypeStruct::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_TypeStruct,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::TypeStruct &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTradingRepos::ServiceTypeRepository::TypeStruct *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::TypeStruct>::insert_copy (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::TypeStruct::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_TypeStruct,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::TypeStruct *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::TypeStruct>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::TypeStruct::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_TypeStruct,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::TypeStruct *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingRepos::ServiceTypeRepository::TypeStruct *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::TypeStruct *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::TypeStruct>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::TypeStruct::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_TypeStruct,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::ListOption _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::CosTradingRepos::ServiceTypeRepository::ListOption>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::_tc_ListOption,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::ListOption &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::CosTradingRepos::ServiceTypeRepository::ListOption>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::_tc_ListOption,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::ListOption _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<CosTradingRepos::ServiceTypeRepository::ListOption>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::_tc_ListOption,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::ListOption &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<CosTradingRepos::ServiceTypeRepository::ListOption>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::_tc_ListOption,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_union/any_op_cs.cpp:45



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes>::insert_copy (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_SpecifiedServiceTypes,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_SpecifiedServiceTypes,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_SpecifiedServiceTypes,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes>::insert_copy (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_SpecifiedServiceTypes,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_SpecifiedServiceTypes,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_SpecifiedServiceTypes,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::ServiceTypeExists>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists>::insert_copy (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeExists,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeExists,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeExists,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::ServiceTypeExists &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::ServiceTypeExists>::insert_copy (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeExists,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::ServiceTypeExists *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::ServiceTypeExists>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeExists,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::ServiceTypeExists *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingRepos::ServiceTypeRepository::ServiceTypeExists *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::ServiceTypeExists *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::ServiceTypeExists>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::ServiceTypeExists::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_ServiceTypeExists,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch>::insert_copy (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_InterfaceTypeMismatch,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_InterfaceTypeMismatch,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_InterfaceTypeMismatch,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch>::insert_copy (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_InterfaceTypeMismatch,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_InterfaceTypeMismatch,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_InterfaceTypeMismatch,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::HasSubTypes>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::HasSubTypes &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::HasSubTypes>::insert_copy (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::HasSubTypes::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_HasSubTypes,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::HasSubTypes *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::HasSubTypes>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::HasSubTypes::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_HasSubTypes,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::HasSubTypes *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingRepos::ServiceTypeRepository::HasSubTypes *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::HasSubTypes *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::HasSubTypes>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::HasSubTypes::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_HasSubTypes,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::HasSubTypes &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::HasSubTypes>::insert_copy (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::HasSubTypes::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_HasSubTypes,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::HasSubTypes *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::HasSubTypes>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::HasSubTypes::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_HasSubTypes,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::HasSubTypes *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingRepos::ServiceTypeRepository::HasSubTypes *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::HasSubTypes *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::HasSubTypes>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::HasSubTypes::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_HasSubTypes,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::AlreadyMasked>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked>::insert_copy (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_AlreadyMasked,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_AlreadyMasked,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_AlreadyMasked,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::AlreadyMasked &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::AlreadyMasked>::insert_copy (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_AlreadyMasked,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::AlreadyMasked *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::AlreadyMasked>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_AlreadyMasked,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::AlreadyMasked *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingRepos::ServiceTypeRepository::AlreadyMasked *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::AlreadyMasked *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::AlreadyMasked>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::AlreadyMasked::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_AlreadyMasked,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::NotMasked>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::NotMasked &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::NotMasked>::insert_copy (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::NotMasked::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_NotMasked,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::NotMasked *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::NotMasked>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::NotMasked::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_NotMasked,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::NotMasked *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingRepos::ServiceTypeRepository::NotMasked *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::NotMasked *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::NotMasked>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::NotMasked::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_NotMasked,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::NotMasked &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::NotMasked>::insert_copy (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::NotMasked::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_NotMasked,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::NotMasked *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::NotMasked>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::NotMasked::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_NotMasked,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::NotMasked *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingRepos::ServiceTypeRepository::NotMasked *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::NotMasked *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::NotMasked>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::NotMasked::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_NotMasked,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition>::insert_copy (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_ValueTypeRedefinition,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_ValueTypeRedefinition,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_ValueTypeRedefinition,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition>::insert_copy (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_ValueTypeRedefinition,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_ValueTypeRedefinition,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_ValueTypeRedefinition,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingRepos
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName>::insert_copy (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_DuplicateServiceTypeName,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName>::insert (
        _tao_any,
        ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_tao_any_destructor,
        ::CosTradingRepos::ServiceTypeRepository::_tc_DuplicateServiceTypeName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName>::extract (
          _tao_any,
          ::CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_tao_any_destructor,
          ::CosTradingRepos::ServiceTypeRepository::_tc_DuplicateServiceTypeName,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName>::insert_copy (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_DuplicateServiceTypeName,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName>::insert (
      _tao_any,
      CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_tao_any_destructor,
      CosTradingRepos::ServiceTypeRepository::_tc_DuplicateServiceTypeName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName>::extract (
        _tao_any,
        CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName::_tao_any_destructor,
        CosTradingRepos::ServiceTypeRepository::_tc_DuplicateServiceTypeName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingSequences
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::ShortSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTradingSequences::ShortSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::ShortSeq>::insert_copy (
          _tao_any,
          ::CosTradingSequences::ShortSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_ShortSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingSequences::ShortSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingSequences::ShortSeq>::insert (
        _tao_any,
        ::CosTradingSequences::ShortSeq::_tao_any_destructor,
        ::CosTradingSequences::_tc_ShortSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingSequences::ShortSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingSequences::ShortSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::ShortSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::ShortSeq>::extract (
          _tao_any,
          ::CosTradingSequences::ShortSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_ShortSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingSequences::ShortSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTradingSequences::ShortSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTradingSequences::ShortSeq>::insert_copy (
        _tao_any,
        CosTradingSequences::ShortSeq::_tao_any_destructor,
        CosTradingSequences::_tc_ShortSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingSequences::ShortSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingSequences::ShortSeq>::insert (
      _tao_any,
      CosTradingSequences::ShortSeq::_tao_any_destructor,
      CosTradingSequences::_tc_ShortSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingSequences::ShortSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingSequences::ShortSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingSequences::ShortSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingSequences::ShortSeq>::extract (
        _tao_any,
        CosTradingSequences::ShortSeq::_tao_any_destructor,
        CosTradingSequences::_tc_ShortSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingSequences
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::UShortSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTradingSequences::UShortSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::UShortSeq>::insert_copy (
          _tao_any,
          ::CosTradingSequences::UShortSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_UShortSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingSequences::UShortSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingSequences::UShortSeq>::insert (
        _tao_any,
        ::CosTradingSequences::UShortSeq::_tao_any_destructor,
        ::CosTradingSequences::_tc_UShortSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingSequences::UShortSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingSequences::UShortSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::UShortSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::UShortSeq>::extract (
          _tao_any,
          ::CosTradingSequences::UShortSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_UShortSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingSequences::UShortSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTradingSequences::UShortSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTradingSequences::UShortSeq>::insert_copy (
        _tao_any,
        CosTradingSequences::UShortSeq::_tao_any_destructor,
        CosTradingSequences::_tc_UShortSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingSequences::UShortSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingSequences::UShortSeq>::insert (
      _tao_any,
      CosTradingSequences::UShortSeq::_tao_any_destructor,
      CosTradingSequences::_tc_UShortSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingSequences::UShortSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingSequences::UShortSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingSequences::UShortSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingSequences::UShortSeq>::extract (
        _tao_any,
        CosTradingSequences::UShortSeq::_tao_any_destructor,
        CosTradingSequences::_tc_UShortSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingSequences
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::LongSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTradingSequences::LongSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::LongSeq>::insert_copy (
          _tao_any,
          ::CosTradingSequences::LongSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_LongSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingSequences::LongSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingSequences::LongSeq>::insert (
        _tao_any,
        ::CosTradingSequences::LongSeq::_tao_any_destructor,
        ::CosTradingSequences::_tc_LongSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingSequences::LongSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingSequences::LongSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::LongSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::LongSeq>::extract (
          _tao_any,
          ::CosTradingSequences::LongSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_LongSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingSequences::LongSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTradingSequences::LongSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTradingSequences::LongSeq>::insert_copy (
        _tao_any,
        CosTradingSequences::LongSeq::_tao_any_destructor,
        CosTradingSequences::_tc_LongSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingSequences::LongSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingSequences::LongSeq>::insert (
      _tao_any,
      CosTradingSequences::LongSeq::_tao_any_destructor,
      CosTradingSequences::_tc_LongSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingSequences::LongSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingSequences::LongSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingSequences::LongSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingSequences::LongSeq>::extract (
        _tao_any,
        CosTradingSequences::LongSeq::_tao_any_destructor,
        CosTradingSequences::_tc_LongSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingSequences
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::ULongSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTradingSequences::ULongSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::ULongSeq>::insert_copy (
          _tao_any,
          ::CosTradingSequences::ULongSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_ULongSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingSequences::ULongSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingSequences::ULongSeq>::insert (
        _tao_any,
        ::CosTradingSequences::ULongSeq::_tao_any_destructor,
        ::CosTradingSequences::_tc_ULongSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingSequences::ULongSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingSequences::ULongSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::ULongSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::ULongSeq>::extract (
          _tao_any,
          ::CosTradingSequences::ULongSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_ULongSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingSequences::ULongSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTradingSequences::ULongSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTradingSequences::ULongSeq>::insert_copy (
        _tao_any,
        CosTradingSequences::ULongSeq::_tao_any_destructor,
        CosTradingSequences::_tc_ULongSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingSequences::ULongSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingSequences::ULongSeq>::insert (
      _tao_any,
      CosTradingSequences::ULongSeq::_tao_any_destructor,
      CosTradingSequences::_tc_ULongSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingSequences::ULongSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingSequences::ULongSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingSequences::ULongSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingSequences::ULongSeq>::extract (
        _tao_any,
        CosTradingSequences::ULongSeq::_tao_any_destructor,
        CosTradingSequences::_tc_ULongSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingSequences
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::BooleanSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTradingSequences::BooleanSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::BooleanSeq>::insert_copy (
          _tao_any,
          ::CosTradingSequences::BooleanSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_BooleanSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingSequences::BooleanSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingSequences::BooleanSeq>::insert (
        _tao_any,
        ::CosTradingSequences::BooleanSeq::_tao_any_destructor,
        ::CosTradingSequences::_tc_BooleanSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingSequences::BooleanSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingSequences::BooleanSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::BooleanSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::BooleanSeq>::extract (
          _tao_any,
          ::CosTradingSequences::BooleanSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_BooleanSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingSequences::BooleanSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTradingSequences::BooleanSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTradingSequences::BooleanSeq>::insert_copy (
        _tao_any,
        CosTradingSequences::BooleanSeq::_tao_any_destructor,
        CosTradingSequences::_tc_BooleanSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingSequences::BooleanSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingSequences::BooleanSeq>::insert (
      _tao_any,
      CosTradingSequences::BooleanSeq::_tao_any_destructor,
      CosTradingSequences::_tc_BooleanSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingSequences::BooleanSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingSequences::BooleanSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingSequences::BooleanSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingSequences::BooleanSeq>::extract (
        _tao_any,
        CosTradingSequences::BooleanSeq::_tao_any_destructor,
        CosTradingSequences::_tc_BooleanSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingSequences
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::FloatSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTradingSequences::FloatSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::FloatSeq>::insert_copy (
          _tao_any,
          ::CosTradingSequences::FloatSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_FloatSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingSequences::FloatSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingSequences::FloatSeq>::insert (
        _tao_any,
        ::CosTradingSequences::FloatSeq::_tao_any_destructor,
        ::CosTradingSequences::_tc_FloatSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingSequences::FloatSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingSequences::FloatSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::FloatSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::FloatSeq>::extract (
          _tao_any,
          ::CosTradingSequences::FloatSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_FloatSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingSequences::FloatSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTradingSequences::FloatSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTradingSequences::FloatSeq>::insert_copy (
        _tao_any,
        CosTradingSequences::FloatSeq::_tao_any_destructor,
        CosTradingSequences::_tc_FloatSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingSequences::FloatSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingSequences::FloatSeq>::insert (
      _tao_any,
      CosTradingSequences::FloatSeq::_tao_any_destructor,
      CosTradingSequences::_tc_FloatSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingSequences::FloatSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingSequences::FloatSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingSequences::FloatSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingSequences::FloatSeq>::extract (
        _tao_any,
        CosTradingSequences::FloatSeq::_tao_any_destructor,
        CosTradingSequences::_tc_FloatSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingSequences
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::DoubleSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTradingSequences::DoubleSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::DoubleSeq>::insert_copy (
          _tao_any,
          ::CosTradingSequences::DoubleSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_DoubleSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingSequences::DoubleSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingSequences::DoubleSeq>::insert (
        _tao_any,
        ::CosTradingSequences::DoubleSeq::_tao_any_destructor,
        ::CosTradingSequences::_tc_DoubleSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingSequences::DoubleSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingSequences::DoubleSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::DoubleSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::DoubleSeq>::extract (
          _tao_any,
          ::CosTradingSequences::DoubleSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_DoubleSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingSequences::DoubleSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTradingSequences::DoubleSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTradingSequences::DoubleSeq>::insert_copy (
        _tao_any,
        CosTradingSequences::DoubleSeq::_tao_any_destructor,
        CosTradingSequences::_tc_DoubleSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingSequences::DoubleSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingSequences::DoubleSeq>::insert (
      _tao_any,
      CosTradingSequences::DoubleSeq::_tao_any_destructor,
      CosTradingSequences::_tc_DoubleSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingSequences::DoubleSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingSequences::DoubleSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingSequences::DoubleSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingSequences::DoubleSeq>::extract (
        _tao_any,
        CosTradingSequences::DoubleSeq::_tao_any_destructor,
        CosTradingSequences::_tc_DoubleSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTradingSequences
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::StringSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTradingSequences::StringSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::StringSeq>::insert_copy (
          _tao_any,
          ::CosTradingSequences::StringSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_StringSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTradingSequences::StringSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTradingSequences::StringSeq>::insert (
        _tao_any,
        ::CosTradingSequences::StringSeq::_tao_any_destructor,
        ::CosTradingSequences::_tc_StringSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTradingSequences::StringSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTradingSequences::StringSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTradingSequences::StringSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTradingSequences::StringSeq>::extract (
          _tao_any,
          ::CosTradingSequences::StringSeq::_tao_any_destructor,
          ::CosTradingSequences::_tc_StringSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTradingSequences::StringSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTradingSequences::StringSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTradingSequences::StringSeq>::insert_copy (
        _tao_any,
        CosTradingSequences::StringSeq::_tao_any_destructor,
        CosTradingSequences::_tc_StringSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTradingSequences::StringSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTradingSequences::StringSeq>::insert (
      _tao_any,
      CosTradingSequences::StringSeq::_tao_any_destructor,
      CosTradingSequences::_tc_StringSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTradingSequences::StringSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTradingSequences::StringSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTradingSequences::StringSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTradingSequences::StringSeq>::extract (
        _tao_any,
        CosTradingSequences::StringSeq::_tao_any_destructor,
        CosTradingSequences::_tc_StringSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTradingRepos_ServiceTypeRepository_ServiceTypeNameSeq_CPP_
#define _TAO_CDR_OP_CosTradingRepos_ServiceTypeRepository_ServiceTypeNameSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingRepos::ServiceTypeRepository::ServiceTypeNameSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTradingRepos_ServiceTypeRepository_ServiceTypeNameSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CosTradingRepos::ServiceTypeRepository::PropertyMode _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, CosTradingRepos::ServiceTypeRepository::PropertyMode & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<CosTradingRepos::ServiceTypeRepository::PropertyMode> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingRepos::ServiceTypeRepository::PropStruct &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.value_type.in ()) &&
    (strm << _tao_aggregate.mode);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingRepos::ServiceTypeRepository::PropStruct &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.value_type.out ()) &&
    (strm >> _tao_aggregate.mode);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTradingRepos_ServiceTypeRepository_PropStructSeq_CPP_
#define _TAO_CDR_OP_CosTradingRepos_ServiceTypeRepository_PropStructSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingRepos::ServiceTypeRepository::PropStructSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingRepos::ServiceTypeRepository::PropStructSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTradingRepos_ServiceTypeRepository_PropStructSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingRepos::ServiceTypeRepository::IncarnationNumber &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.high) &&
    (strm << _tao_aggregate.low);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingRepos::ServiceTypeRepository::IncarnationNumber &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.high) &&
    (strm >> _tao_aggregate.low);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingRepos::ServiceTypeRepository::TypeStruct &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.if_name.in ()) &&
    (strm << _tao_aggregate.props) &&
    (strm << _tao_aggregate.super_types) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.masked)) &&
    (strm << _tao_aggregate.incarnation);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingRepos::ServiceTypeRepository::TypeStruct &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.if_name.out ()) &&
    (strm >> _tao_aggregate.props) &&
    (strm >> _tao_aggregate.super_types) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.masked)) &&
    (strm >> _tao_aggregate.incarnation);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CosTradingRepos::ServiceTypeRepository::ListOption _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, CosTradingRepos::ServiceTypeRepository::ListOption & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<CosTradingRepos::ServiceTypeRepository::ListOption> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_union/cdr_op_cs.cpp:82



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case CosTradingRepos::ServiceTypeRepository::all:
      {
        result = strm << ::ACE_OutputCDR::from_boolean (_tao_union.all_ ());
      }
      break;
    case CosTradingRepos::ServiceTypeRepository::since:
      {
        result = strm << _tao_union.incarnation ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingRepos::ServiceTypeRepository::SpecifiedServiceTypes &_tao_union
  )
{
  CosTradingRepos::ServiceTypeRepository::ListOption _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case CosTradingRepos::ServiceTypeRepository::all:
      {
        ::CORBA::Boolean _tao_union_tmp;
        ::ACE_InputCDR::to_boolean _tao_union_helper (_tao_union_tmp);
        result = strm >> _tao_union_helper;

        if (result)
          {
            _tao_union.all_ (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case CosTradingRepos::ServiceTypeRepository::since:
      {
        CosTradingRepos::ServiceTypeRepository::IncarnationNumber _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.incarnation (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatability, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingRepos::ServiceTypeRepository::ServiceTypeExists &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingRepos::ServiceTypeRepository::ServiceTypeExists &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.base_service.in ()) &&
        (strm << _tao_aggregate.base_if.in ()) &&
        (strm << _tao_aggregate.derived_service.in ()) &&
        (strm << _tao_aggregate.derived_if.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingRepos::ServiceTypeRepository::InterfaceTypeMismatch &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.base_service.out ()) &&
    (strm >> _tao_aggregate.base_if.out ()) &&
    (strm >> _tao_aggregate.derived_service.out ()) &&
    (strm >> _tao_aggregate.derived_if.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingRepos::ServiceTypeRepository::HasSubTypes &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.the_type.in ()) &&
        (strm << _tao_aggregate.sub_type.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingRepos::ServiceTypeRepository::HasSubTypes &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.the_type.out ()) &&
    (strm >> _tao_aggregate.sub_type.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingRepos::ServiceTypeRepository::AlreadyMasked &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingRepos::ServiceTypeRepository::AlreadyMasked &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingRepos::ServiceTypeRepository::NotMasked &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingRepos::ServiceTypeRepository::NotMasked &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.type_1.in ()) &&
        (strm << _tao_aggregate.definition_1) &&
        (strm << _tao_aggregate.type_2.in ()) &&
        (strm << _tao_aggregate.definition_2)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingRepos::ServiceTypeRepository::ValueTypeRedefinition &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.type_1.out ()) &&
    (strm >> _tao_aggregate.definition_1) &&
    (strm >> _tao_aggregate.type_2.out ()) &&
    (strm >> _tao_aggregate.definition_2)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingRepos::ServiceTypeRepository::DuplicateServiceTypeName &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingRepos::ServiceTypeRepository_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingRepos::ServiceTypeRepository_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosTradingRepos::ServiceTypeRepository RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosTradingRepos__TAO_ServiceTypeRepository_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTradingSequences_ShortSeq_CPP_
#define _TAO_CDR_OP_CosTradingSequences_ShortSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingSequences::ShortSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingSequences::ShortSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTradingSequences_ShortSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTradingSequences_UShortSeq_CPP_
#define _TAO_CDR_OP_CosTradingSequences_UShortSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingSequences::UShortSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingSequences::UShortSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTradingSequences_UShortSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTradingSequences_LongSeq_CPP_
#define _TAO_CDR_OP_CosTradingSequences_LongSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingSequences::LongSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingSequences::LongSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTradingSequences_LongSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTradingSequences_ULongSeq_CPP_
#define _TAO_CDR_OP_CosTradingSequences_ULongSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingSequences::ULongSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingSequences::ULongSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTradingSequences_ULongSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTradingSequences_BooleanSeq_CPP_
#define _TAO_CDR_OP_CosTradingSequences_BooleanSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingSequences::BooleanSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingSequences::BooleanSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTradingSequences_BooleanSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTradingSequences_FloatSeq_CPP_
#define _TAO_CDR_OP_CosTradingSequences_FloatSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingSequences::FloatSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingSequences::FloatSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTradingSequences_FloatSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTradingSequences_DoubleSeq_CPP_
#define _TAO_CDR_OP_CosTradingSequences_DoubleSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingSequences::DoubleSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingSequences::DoubleSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTradingSequences_DoubleSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTradingSequences_StringSeq_CPP_
#define _TAO_CDR_OP_CosTradingSequences_StringSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTradingSequences::StringSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTradingSequences::StringSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTradingSequences_StringSeq_CPP_ */


TAO_END_VERSIONED_NAMESPACE_DECL


