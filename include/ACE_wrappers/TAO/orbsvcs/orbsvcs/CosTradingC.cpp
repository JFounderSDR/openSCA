// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "CosTradingC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/TypeCode_Case_T.h"
#include "tao/AnyTypeCode/Union_TypeCode_Static.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/ORB_Core.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "CosTradingC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_Istring (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/Istring:1.0",
    "Istring",
    &CORBA::_tc_string);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_Istring =
    &_tao_tc_CosTrading_Istring;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_TypeRepository (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/TypeRepository:1.0",
    "TypeRepository",
    &CORBA::_tc_Object);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_TypeRepository =
    &_tao_tc_CosTrading_TypeRepository;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_PropertyName (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/PropertyName:1.0",
    "PropertyName",
    &CosTrading::_tc_Istring);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_PropertyName =
    &_tao_tc_CosTrading_PropertyName;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADING_PROPERTYNAMESEQ_CS_)
#define _COSTRADING_PROPERTYNAMESEQ_CS_

CosTrading::PropertyNameSeq::PropertyNameSeq (void)
{}

CosTrading::PropertyNameSeq::PropertyNameSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_basic_string_sequence<char> (max)
{}

CosTrading::PropertyNameSeq::PropertyNameSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Char * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_basic_string_sequence<char>
    (max, length, buffer, release)
{}

CosTrading::PropertyNameSeq::PropertyNameSeq (
    const PropertyNameSeq &seq)
  : ::TAO::unbounded_basic_string_sequence<char> (seq)
{}

CosTrading::PropertyNameSeq::~PropertyNameSeq (void)
{}

void CosTrading::PropertyNameSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  PropertyNameSeq * _tao_tmp_pointer =
    static_cast<PropertyNameSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTrading_PropertyNameSeq_GUARD
#define _TAO_TYPECODE_CosTrading_PropertyNameSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTrading_PropertyNameSeq_0 (
          ::CORBA::tk_sequence,
          &CosTrading::_tc_PropertyName,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTrading_PropertyNameSeq_0 =
        &CosTrading_PropertyNameSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTrading_PropertyNameSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_PropertyNameSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/PropertyNameSeq:1.0",
    "PropertyNameSeq",
    &TAO::TypeCode::tc_CosTrading_PropertyNameSeq_0);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_PropertyNameSeq =
    &_tao_tc_CosTrading_PropertyNameSeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_PropertyValue (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/PropertyValue:1.0",
    "PropertyValue",
    &CORBA::_tc_any);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_PropertyValue =
    &_tao_tc_CosTrading_PropertyValue;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Property[] =
      {
        { "name", &CosTrading::_tc_PropertyName },
        { "value", &CosTrading::_tc_PropertyValue }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Property (
  ::CORBA::tk_struct,
  "IDL:omg.org/CosTrading/Property:1.0",
  "Property",
  _tao_fields_CosTrading_Property,
  2);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_Property =
    &_tao_tc_CosTrading_Property;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosTrading::Property::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Property *_tao_tmp_pointer =
    static_cast<Property *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADING_PROPERTYSEQ_CS_)
#define _COSTRADING_PROPERTYSEQ_CS_

CosTrading::PropertySeq::PropertySeq (void)
{}

CosTrading::PropertySeq::PropertySeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Property
      > (max)
{}

CosTrading::PropertySeq::PropertySeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CosTrading::Property * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Property
      >
    (max, length, buffer, release)
{}

CosTrading::PropertySeq::PropertySeq (
    const PropertySeq &seq)
  : ::TAO::unbounded_value_sequence<
        Property
      > (seq)
{}

CosTrading::PropertySeq::~PropertySeq (void)
{}

void CosTrading::PropertySeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  PropertySeq * _tao_tmp_pointer =
    static_cast<PropertySeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTrading_PropertySeq_GUARD
#define _TAO_TYPECODE_CosTrading_PropertySeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTrading_PropertySeq_0 (
          ::CORBA::tk_sequence,
          &CosTrading::_tc_Property,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTrading_PropertySeq_0 =
        &CosTrading_PropertySeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTrading_PropertySeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_PropertySeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/PropertySeq:1.0",
    "PropertySeq",
    &TAO::TypeCode::tc_CosTrading_PropertySeq_0);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_PropertySeq =
    &_tao_tc_CosTrading_PropertySeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Offer[] =
      {
        { "reference", &CORBA::_tc_Object },
        { "properties", &CosTrading::_tc_PropertySeq }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Offer (
  ::CORBA::tk_struct,
  "IDL:omg.org/CosTrading/Offer:1.0",
  "Offer",
  _tao_fields_CosTrading_Offer,
  2);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_Offer =
    &_tao_tc_CosTrading_Offer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosTrading::Offer::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Offer *_tao_tmp_pointer =
    static_cast<Offer *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADING_OFFERSEQ_CS_)
#define _COSTRADING_OFFERSEQ_CS_

CosTrading::OfferSeq::OfferSeq (void)
{}

CosTrading::OfferSeq::OfferSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Offer
      > (max)
{}

CosTrading::OfferSeq::OfferSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CosTrading::Offer * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Offer
      >
    (max, length, buffer, release)
{}

CosTrading::OfferSeq::OfferSeq (
    const OfferSeq &seq)
  : ::TAO::unbounded_value_sequence<
        Offer
      > (seq)
{}

CosTrading::OfferSeq::~OfferSeq (void)
{}

void CosTrading::OfferSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  OfferSeq * _tao_tmp_pointer =
    static_cast<OfferSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTrading_OfferSeq_GUARD
#define _TAO_TYPECODE_CosTrading_OfferSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTrading_OfferSeq_0 (
          ::CORBA::tk_sequence,
          &CosTrading::_tc_Offer,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTrading_OfferSeq_0 =
        &CosTrading_OfferSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTrading_OfferSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_OfferSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/OfferSeq:1.0",
    "OfferSeq",
    &TAO::TypeCode::tc_CosTrading_OfferSeq_0);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_OfferSeq =
    &_tao_tc_CosTrading_OfferSeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_OfferId (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/OfferId:1.0",
    "OfferId",
    &CORBA::_tc_string);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_OfferId =
    &_tao_tc_CosTrading_OfferId;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADING_OFFERIDSEQ_CS_)
#define _COSTRADING_OFFERIDSEQ_CS_

CosTrading::OfferIdSeq::OfferIdSeq (void)
{}

CosTrading::OfferIdSeq::OfferIdSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_basic_string_sequence<char> (max)
{}

CosTrading::OfferIdSeq::OfferIdSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Char * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_basic_string_sequence<char>
    (max, length, buffer, release)
{}

CosTrading::OfferIdSeq::OfferIdSeq (
    const OfferIdSeq &seq)
  : ::TAO::unbounded_basic_string_sequence<char> (seq)
{}

CosTrading::OfferIdSeq::~OfferIdSeq (void)
{}

void CosTrading::OfferIdSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  OfferIdSeq * _tao_tmp_pointer =
    static_cast<OfferIdSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTrading_OfferIdSeq_GUARD
#define _TAO_TYPECODE_CosTrading_OfferIdSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTrading_OfferIdSeq_0 (
          ::CORBA::tk_sequence,
          &CosTrading::_tc_OfferId,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTrading_OfferIdSeq_0 =
        &CosTrading_OfferIdSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTrading_OfferIdSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_OfferIdSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/OfferIdSeq:1.0",
    "OfferIdSeq",
    &TAO::TypeCode::tc_CosTrading_OfferIdSeq_0);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_OfferIdSeq =
    &_tao_tc_CosTrading_OfferIdSeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_ServiceTypeName (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/ServiceTypeName:1.0",
    "ServiceTypeName",
    &CosTrading::_tc_Istring);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_ServiceTypeName =
    &_tao_tc_CosTrading_ServiceTypeName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_Constraint (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/Constraint:1.0",
    "Constraint",
    &CosTrading::_tc_Istring);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_Constraint =
    &_tao_tc_CosTrading_Constraint;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_CosTrading_FollowOption[] =
  {
    "local_only",
    "if_no_local",
    "always"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_FollowOption (
    "IDL:omg.org/CosTrading/FollowOption:1.0",
    "FollowOption",
    _tao_enumerators_CosTrading_FollowOption,
    3);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_FollowOption =
    &_tao_tc_CosTrading_FollowOption;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_LinkName (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/LinkName:1.0",
    "LinkName",
    &CosTrading::_tc_Istring);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_LinkName =
    &_tao_tc_CosTrading_LinkName;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADING_LINKNAMESEQ_CS_)
#define _COSTRADING_LINKNAMESEQ_CS_

CosTrading::LinkNameSeq::LinkNameSeq (void)
{}

CosTrading::LinkNameSeq::LinkNameSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_basic_string_sequence<char> (max)
{}

CosTrading::LinkNameSeq::LinkNameSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Char * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_basic_string_sequence<char>
    (max, length, buffer, release)
{}

CosTrading::LinkNameSeq::LinkNameSeq (
    const LinkNameSeq &seq)
  : ::TAO::unbounded_basic_string_sequence<char> (seq)
{}

CosTrading::LinkNameSeq::~LinkNameSeq (void)
{}

void CosTrading::LinkNameSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  LinkNameSeq * _tao_tmp_pointer =
    static_cast<LinkNameSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTrading_LinkNameSeq_GUARD
#define _TAO_TYPECODE_CosTrading_LinkNameSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTrading_LinkNameSeq_0 (
          ::CORBA::tk_sequence,
          &CosTrading::_tc_LinkName,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTrading_LinkNameSeq_0 =
        &CosTrading_LinkNameSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTrading_LinkNameSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_LinkNameSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/LinkNameSeq:1.0",
    "LinkNameSeq",
    &TAO::TypeCode::tc_CosTrading_LinkNameSeq_0);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_LinkNameSeq =
    &_tao_tc_CosTrading_LinkNameSeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_TraderName (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/TraderName:1.0",
    "TraderName",
    &CosTrading::_tc_LinkNameSeq);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_TraderName =
    &_tao_tc_CosTrading_TraderName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_PolicyName (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/PolicyName:1.0",
    "PolicyName",
    &CORBA::_tc_string);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_PolicyName =
    &_tao_tc_CosTrading_PolicyName;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADING_POLICYNAMESEQ_CS_)
#define _COSTRADING_POLICYNAMESEQ_CS_

CosTrading::PolicyNameSeq::PolicyNameSeq (void)
{}

CosTrading::PolicyNameSeq::PolicyNameSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_basic_string_sequence<char> (max)
{}

CosTrading::PolicyNameSeq::PolicyNameSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Char * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_basic_string_sequence<char>
    (max, length, buffer, release)
{}

CosTrading::PolicyNameSeq::PolicyNameSeq (
    const PolicyNameSeq &seq)
  : ::TAO::unbounded_basic_string_sequence<char> (seq)
{}

CosTrading::PolicyNameSeq::~PolicyNameSeq (void)
{}

void CosTrading::PolicyNameSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  PolicyNameSeq * _tao_tmp_pointer =
    static_cast<PolicyNameSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTrading_PolicyNameSeq_GUARD
#define _TAO_TYPECODE_CosTrading_PolicyNameSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTrading_PolicyNameSeq_0 (
          ::CORBA::tk_sequence,
          &CosTrading::_tc_PolicyName,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTrading_PolicyNameSeq_0 =
        &CosTrading_PolicyNameSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTrading_PolicyNameSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_PolicyNameSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/PolicyNameSeq:1.0",
    "PolicyNameSeq",
    &TAO::TypeCode::tc_CosTrading_PolicyNameSeq_0);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_PolicyNameSeq =
    &_tao_tc_CosTrading_PolicyNameSeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_PolicyValue (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/PolicyValue:1.0",
    "PolicyValue",
    &CORBA::_tc_any);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_PolicyValue =
    &_tao_tc_CosTrading_PolicyValue;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Policy[] =
      {
        { "name", &CosTrading::_tc_PolicyName },
        { "value", &CosTrading::_tc_PolicyValue }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Policy (
  ::CORBA::tk_struct,
  "IDL:omg.org/CosTrading/Policy:1.0",
  "Policy",
  _tao_fields_CosTrading_Policy,
  2);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_Policy =
    &_tao_tc_CosTrading_Policy;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosTrading::Policy::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Policy *_tao_tmp_pointer =
    static_cast<Policy *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADING_POLICYSEQ_CS_)
#define _COSTRADING_POLICYSEQ_CS_

CosTrading::PolicySeq::PolicySeq (void)
{}

CosTrading::PolicySeq::PolicySeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Policy
      > (max)
{}

CosTrading::PolicySeq::PolicySeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CosTrading::Policy * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Policy
      >
    (max, length, buffer, release)
{}

CosTrading::PolicySeq::PolicySeq (
    const PolicySeq &seq)
  : ::TAO::unbounded_value_sequence<
        Policy
      > (seq)
{}

CosTrading::PolicySeq::~PolicySeq (void)
{}

void CosTrading::PolicySeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  PolicySeq * _tao_tmp_pointer =
    static_cast<PolicySeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTrading_PolicySeq_GUARD
#define _TAO_TYPECODE_CosTrading_PolicySeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTrading_PolicySeq_0 (
          ::CORBA::tk_sequence,
          &CosTrading::_tc_Policy,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTrading_PolicySeq_0 =
        &CosTrading_PolicySeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTrading_PolicySeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_PolicySeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/PolicySeq:1.0",
    "PolicySeq",
    &TAO::TypeCode::tc_CosTrading_PolicySeq_0);
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_PolicySeq =
    &_tao_tc_CosTrading_PolicySeq;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::UnknownMaxLeft::UnknownMaxLeft (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/UnknownMaxLeft:1.0",
        "UnknownMaxLeft"
      )
{
}

CosTrading::UnknownMaxLeft::~UnknownMaxLeft (void)
{
}

CosTrading::UnknownMaxLeft::UnknownMaxLeft (const ::CosTrading::UnknownMaxLeft &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CosTrading::UnknownMaxLeft&
CosTrading::UnknownMaxLeft::operator= (const ::CosTrading::UnknownMaxLeft &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CosTrading::UnknownMaxLeft::_tao_any_destructor (void *_tao_void_pointer)
{
  UnknownMaxLeft *_tao_tmp_pointer =
    static_cast<UnknownMaxLeft *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::UnknownMaxLeft *
CosTrading::UnknownMaxLeft::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UnknownMaxLeft *> (_tao_excp);
}

const CosTrading::UnknownMaxLeft *
CosTrading::UnknownMaxLeft::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UnknownMaxLeft *> (_tao_excp);
}

::CORBA::Exception *CosTrading::UnknownMaxLeft::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::UnknownMaxLeft, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::UnknownMaxLeft::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::UnknownMaxLeft (*this),
      0
    );
  return result;
}

void CosTrading::UnknownMaxLeft::_raise (void) const
{
  throw *this;
}

void CosTrading::UnknownMaxLeft::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::UnknownMaxLeft::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::UnknownMaxLeft::_tao_type (void) const
{
  return ::CosTrading::_tc_UnknownMaxLeft;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CosTrading_UnknownMaxLeft = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_UnknownMaxLeft (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/UnknownMaxLeft:1.0",
  "UnknownMaxLeft",
  _tao_fields_CosTrading_UnknownMaxLeft,
  0);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_UnknownMaxLeft =
    &_tao_tc_CosTrading_UnknownMaxLeft;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::NotImplemented::NotImplemented (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/NotImplemented:1.0",
        "NotImplemented"
      )
{
}

CosTrading::NotImplemented::~NotImplemented (void)
{
}

CosTrading::NotImplemented::NotImplemented (const ::CosTrading::NotImplemented &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CosTrading::NotImplemented&
CosTrading::NotImplemented::operator= (const ::CosTrading::NotImplemented &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CosTrading::NotImplemented::_tao_any_destructor (void *_tao_void_pointer)
{
  NotImplemented *_tao_tmp_pointer =
    static_cast<NotImplemented *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::NotImplemented *
CosTrading::NotImplemented::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NotImplemented *> (_tao_excp);
}

const CosTrading::NotImplemented *
CosTrading::NotImplemented::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NotImplemented *> (_tao_excp);
}

::CORBA::Exception *CosTrading::NotImplemented::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::NotImplemented, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::NotImplemented::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::NotImplemented (*this),
      0
    );
  return result;
}

void CosTrading::NotImplemented::_raise (void) const
{
  throw *this;
}

void CosTrading::NotImplemented::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::NotImplemented::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::NotImplemented::_tao_type (void) const
{
  return ::CosTrading::_tc_NotImplemented;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CosTrading_NotImplemented = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_NotImplemented (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/NotImplemented:1.0",
  "NotImplemented",
  _tao_fields_CosTrading_NotImplemented,
  0);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_NotImplemented =
    &_tao_tc_CosTrading_NotImplemented;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::IllegalServiceType::IllegalServiceType (
    const char * _tao_type)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/IllegalServiceType:1.0",
        "IllegalServiceType"
      )
{
  this->type = ::CORBA::string_dup (_tao_type);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::IllegalServiceType::IllegalServiceType (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/IllegalServiceType:1.0",
        "IllegalServiceType"
      )
{
}

CosTrading::IllegalServiceType::~IllegalServiceType (void)
{
}

CosTrading::IllegalServiceType::IllegalServiceType (const ::CosTrading::IllegalServiceType &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
}

CosTrading::IllegalServiceType&
CosTrading::IllegalServiceType::operator= (const ::CosTrading::IllegalServiceType &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
  return *this;
}

void CosTrading::IllegalServiceType::_tao_any_destructor (void *_tao_void_pointer)
{
  IllegalServiceType *_tao_tmp_pointer =
    static_cast<IllegalServiceType *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::IllegalServiceType *
CosTrading::IllegalServiceType::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<IllegalServiceType *> (_tao_excp);
}

const CosTrading::IllegalServiceType *
CosTrading::IllegalServiceType::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const IllegalServiceType *> (_tao_excp);
}

::CORBA::Exception *CosTrading::IllegalServiceType::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::IllegalServiceType, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::IllegalServiceType::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::IllegalServiceType (*this),
      0
    );
  return result;
}

void CosTrading::IllegalServiceType::_raise (void) const
{
  throw *this;
}

void CosTrading::IllegalServiceType::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::IllegalServiceType::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::IllegalServiceType::_tao_type (void) const
{
  return ::CosTrading::_tc_IllegalServiceType;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_IllegalServiceType[] =
      {
        { "type", &CosTrading::_tc_ServiceTypeName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_IllegalServiceType (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/IllegalServiceType:1.0",
  "IllegalServiceType",
  _tao_fields_CosTrading_IllegalServiceType,
  1);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_IllegalServiceType =
    &_tao_tc_CosTrading_IllegalServiceType;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::UnknownServiceType::UnknownServiceType (
    const char * _tao_type)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/UnknownServiceType:1.0",
        "UnknownServiceType"
      )
{
  this->type = ::CORBA::string_dup (_tao_type);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::UnknownServiceType::UnknownServiceType (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/UnknownServiceType:1.0",
        "UnknownServiceType"
      )
{
}

CosTrading::UnknownServiceType::~UnknownServiceType (void)
{
}

CosTrading::UnknownServiceType::UnknownServiceType (const ::CosTrading::UnknownServiceType &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
}

CosTrading::UnknownServiceType&
CosTrading::UnknownServiceType::operator= (const ::CosTrading::UnknownServiceType &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
  return *this;
}

void CosTrading::UnknownServiceType::_tao_any_destructor (void *_tao_void_pointer)
{
  UnknownServiceType *_tao_tmp_pointer =
    static_cast<UnknownServiceType *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::UnknownServiceType *
CosTrading::UnknownServiceType::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UnknownServiceType *> (_tao_excp);
}

const CosTrading::UnknownServiceType *
CosTrading::UnknownServiceType::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UnknownServiceType *> (_tao_excp);
}

::CORBA::Exception *CosTrading::UnknownServiceType::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::UnknownServiceType, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::UnknownServiceType::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::UnknownServiceType (*this),
      0
    );
  return result;
}

void CosTrading::UnknownServiceType::_raise (void) const
{
  throw *this;
}

void CosTrading::UnknownServiceType::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::UnknownServiceType::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::UnknownServiceType::_tao_type (void) const
{
  return ::CosTrading::_tc_UnknownServiceType;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_UnknownServiceType[] =
      {
        { "type", &CosTrading::_tc_ServiceTypeName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_UnknownServiceType (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/UnknownServiceType:1.0",
  "UnknownServiceType",
  _tao_fields_CosTrading_UnknownServiceType,
  1);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_UnknownServiceType =
    &_tao_tc_CosTrading_UnknownServiceType;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::IllegalPropertyName::IllegalPropertyName (
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/IllegalPropertyName:1.0",
        "IllegalPropertyName"
      )
{
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::IllegalPropertyName::IllegalPropertyName (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/IllegalPropertyName:1.0",
        "IllegalPropertyName"
      )
{
}

CosTrading::IllegalPropertyName::~IllegalPropertyName (void)
{
}

CosTrading::IllegalPropertyName::IllegalPropertyName (const ::CosTrading::IllegalPropertyName &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTrading::IllegalPropertyName&
CosTrading::IllegalPropertyName::operator= (const ::CosTrading::IllegalPropertyName &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTrading::IllegalPropertyName::_tao_any_destructor (void *_tao_void_pointer)
{
  IllegalPropertyName *_tao_tmp_pointer =
    static_cast<IllegalPropertyName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::IllegalPropertyName *
CosTrading::IllegalPropertyName::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<IllegalPropertyName *> (_tao_excp);
}

const CosTrading::IllegalPropertyName *
CosTrading::IllegalPropertyName::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const IllegalPropertyName *> (_tao_excp);
}

::CORBA::Exception *CosTrading::IllegalPropertyName::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::IllegalPropertyName, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::IllegalPropertyName::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::IllegalPropertyName (*this),
      0
    );
  return result;
}

void CosTrading::IllegalPropertyName::_raise (void) const
{
  throw *this;
}

void CosTrading::IllegalPropertyName::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::IllegalPropertyName::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::IllegalPropertyName::_tao_type (void) const
{
  return ::CosTrading::_tc_IllegalPropertyName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_IllegalPropertyName[] =
      {
        { "name", &CosTrading::_tc_PropertyName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_IllegalPropertyName (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/IllegalPropertyName:1.0",
  "IllegalPropertyName",
  _tao_fields_CosTrading_IllegalPropertyName,
  1);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_IllegalPropertyName =
    &_tao_tc_CosTrading_IllegalPropertyName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::DuplicatePropertyName::DuplicatePropertyName (
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/DuplicatePropertyName:1.0",
        "DuplicatePropertyName"
      )
{
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::DuplicatePropertyName::DuplicatePropertyName (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/DuplicatePropertyName:1.0",
        "DuplicatePropertyName"
      )
{
}

CosTrading::DuplicatePropertyName::~DuplicatePropertyName (void)
{
}

CosTrading::DuplicatePropertyName::DuplicatePropertyName (const ::CosTrading::DuplicatePropertyName &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTrading::DuplicatePropertyName&
CosTrading::DuplicatePropertyName::operator= (const ::CosTrading::DuplicatePropertyName &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTrading::DuplicatePropertyName::_tao_any_destructor (void *_tao_void_pointer)
{
  DuplicatePropertyName *_tao_tmp_pointer =
    static_cast<DuplicatePropertyName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::DuplicatePropertyName *
CosTrading::DuplicatePropertyName::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<DuplicatePropertyName *> (_tao_excp);
}

const CosTrading::DuplicatePropertyName *
CosTrading::DuplicatePropertyName::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const DuplicatePropertyName *> (_tao_excp);
}

::CORBA::Exception *CosTrading::DuplicatePropertyName::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::DuplicatePropertyName, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::DuplicatePropertyName::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::DuplicatePropertyName (*this),
      0
    );
  return result;
}

void CosTrading::DuplicatePropertyName::_raise (void) const
{
  throw *this;
}

void CosTrading::DuplicatePropertyName::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::DuplicatePropertyName::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::DuplicatePropertyName::_tao_type (void) const
{
  return ::CosTrading::_tc_DuplicatePropertyName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_DuplicatePropertyName[] =
      {
        { "name", &CosTrading::_tc_PropertyName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_DuplicatePropertyName (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/DuplicatePropertyName:1.0",
  "DuplicatePropertyName",
  _tao_fields_CosTrading_DuplicatePropertyName,
  1);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_DuplicatePropertyName =
    &_tao_tc_CosTrading_DuplicatePropertyName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::PropertyTypeMismatch::PropertyTypeMismatch (
    const char * _tao_type,
    const CosTrading::Property & _tao_prop)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/PropertyTypeMismatch:1.0",
        "PropertyTypeMismatch"
      )
{
  this->type = ::CORBA::string_dup (_tao_type);
  this->prop = _tao_prop;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::PropertyTypeMismatch::PropertyTypeMismatch (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/PropertyTypeMismatch:1.0",
        "PropertyTypeMismatch"
      )
{
}

CosTrading::PropertyTypeMismatch::~PropertyTypeMismatch (void)
{
}

CosTrading::PropertyTypeMismatch::PropertyTypeMismatch (const ::CosTrading::PropertyTypeMismatch &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
  this->prop = _tao_excp.prop;
}

CosTrading::PropertyTypeMismatch&
CosTrading::PropertyTypeMismatch::operator= (const ::CosTrading::PropertyTypeMismatch &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
  this->prop = _tao_excp.prop;
  return *this;
}

void CosTrading::PropertyTypeMismatch::_tao_any_destructor (void *_tao_void_pointer)
{
  PropertyTypeMismatch *_tao_tmp_pointer =
    static_cast<PropertyTypeMismatch *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::PropertyTypeMismatch *
CosTrading::PropertyTypeMismatch::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<PropertyTypeMismatch *> (_tao_excp);
}

const CosTrading::PropertyTypeMismatch *
CosTrading::PropertyTypeMismatch::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const PropertyTypeMismatch *> (_tao_excp);
}

::CORBA::Exception *CosTrading::PropertyTypeMismatch::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::PropertyTypeMismatch, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::PropertyTypeMismatch::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::PropertyTypeMismatch (*this),
      0
    );
  return result;
}

void CosTrading::PropertyTypeMismatch::_raise (void) const
{
  throw *this;
}

void CosTrading::PropertyTypeMismatch::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::PropertyTypeMismatch::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::PropertyTypeMismatch::_tao_type (void) const
{
  return ::CosTrading::_tc_PropertyTypeMismatch;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_PropertyTypeMismatch[] =
      {
        { "type", &CosTrading::_tc_ServiceTypeName },
        { "prop", &CosTrading::_tc_Property }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_PropertyTypeMismatch (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/PropertyTypeMismatch:1.0",
  "PropertyTypeMismatch",
  _tao_fields_CosTrading_PropertyTypeMismatch,
  2);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_PropertyTypeMismatch =
    &_tao_tc_CosTrading_PropertyTypeMismatch;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::MissingMandatoryProperty::MissingMandatoryProperty (
    const char * _tao_type,
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/MissingMandatoryProperty:1.0",
        "MissingMandatoryProperty"
      )
{
  this->type = ::CORBA::string_dup (_tao_type);
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::MissingMandatoryProperty::MissingMandatoryProperty (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/MissingMandatoryProperty:1.0",
        "MissingMandatoryProperty"
      )
{
}

CosTrading::MissingMandatoryProperty::~MissingMandatoryProperty (void)
{
}

CosTrading::MissingMandatoryProperty::MissingMandatoryProperty (const ::CosTrading::MissingMandatoryProperty &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTrading::MissingMandatoryProperty&
CosTrading::MissingMandatoryProperty::operator= (const ::CosTrading::MissingMandatoryProperty &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTrading::MissingMandatoryProperty::_tao_any_destructor (void *_tao_void_pointer)
{
  MissingMandatoryProperty *_tao_tmp_pointer =
    static_cast<MissingMandatoryProperty *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::MissingMandatoryProperty *
CosTrading::MissingMandatoryProperty::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<MissingMandatoryProperty *> (_tao_excp);
}

const CosTrading::MissingMandatoryProperty *
CosTrading::MissingMandatoryProperty::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const MissingMandatoryProperty *> (_tao_excp);
}

::CORBA::Exception *CosTrading::MissingMandatoryProperty::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::MissingMandatoryProperty, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::MissingMandatoryProperty::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::MissingMandatoryProperty (*this),
      0
    );
  return result;
}

void CosTrading::MissingMandatoryProperty::_raise (void) const
{
  throw *this;
}

void CosTrading::MissingMandatoryProperty::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::MissingMandatoryProperty::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::MissingMandatoryProperty::_tao_type (void) const
{
  return ::CosTrading::_tc_MissingMandatoryProperty;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_MissingMandatoryProperty[] =
      {
        { "type", &CosTrading::_tc_ServiceTypeName },
        { "name", &CosTrading::_tc_PropertyName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_MissingMandatoryProperty (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/MissingMandatoryProperty:1.0",
  "MissingMandatoryProperty",
  _tao_fields_CosTrading_MissingMandatoryProperty,
  2);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_MissingMandatoryProperty =
    &_tao_tc_CosTrading_MissingMandatoryProperty;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::ReadonlyDynamicProperty::ReadonlyDynamicProperty (
    const char * _tao_type,
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/ReadonlyDynamicProperty:1.0",
        "ReadonlyDynamicProperty"
      )
{
  this->type = ::CORBA::string_dup (_tao_type);
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::ReadonlyDynamicProperty::ReadonlyDynamicProperty (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/ReadonlyDynamicProperty:1.0",
        "ReadonlyDynamicProperty"
      )
{
}

CosTrading::ReadonlyDynamicProperty::~ReadonlyDynamicProperty (void)
{
}

CosTrading::ReadonlyDynamicProperty::ReadonlyDynamicProperty (const ::CosTrading::ReadonlyDynamicProperty &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTrading::ReadonlyDynamicProperty&
CosTrading::ReadonlyDynamicProperty::operator= (const ::CosTrading::ReadonlyDynamicProperty &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTrading::ReadonlyDynamicProperty::_tao_any_destructor (void *_tao_void_pointer)
{
  ReadonlyDynamicProperty *_tao_tmp_pointer =
    static_cast<ReadonlyDynamicProperty *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::ReadonlyDynamicProperty *
CosTrading::ReadonlyDynamicProperty::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ReadonlyDynamicProperty *> (_tao_excp);
}

const CosTrading::ReadonlyDynamicProperty *
CosTrading::ReadonlyDynamicProperty::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ReadonlyDynamicProperty *> (_tao_excp);
}

::CORBA::Exception *CosTrading::ReadonlyDynamicProperty::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::ReadonlyDynamicProperty, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::ReadonlyDynamicProperty::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::ReadonlyDynamicProperty (*this),
      0
    );
  return result;
}

void CosTrading::ReadonlyDynamicProperty::_raise (void) const
{
  throw *this;
}

void CosTrading::ReadonlyDynamicProperty::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::ReadonlyDynamicProperty::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::ReadonlyDynamicProperty::_tao_type (void) const
{
  return ::CosTrading::_tc_ReadonlyDynamicProperty;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_ReadonlyDynamicProperty[] =
      {
        { "type", &CosTrading::_tc_ServiceTypeName },
        { "name", &CosTrading::_tc_PropertyName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_ReadonlyDynamicProperty (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/ReadonlyDynamicProperty:1.0",
  "ReadonlyDynamicProperty",
  _tao_fields_CosTrading_ReadonlyDynamicProperty,
  2);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_ReadonlyDynamicProperty =
    &_tao_tc_CosTrading_ReadonlyDynamicProperty;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::IllegalConstraint::IllegalConstraint (
    const char * _tao_constr)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/IllegalConstraint:1.0",
        "IllegalConstraint"
      )
{
  this->constr = ::CORBA::string_dup (_tao_constr);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::IllegalConstraint::IllegalConstraint (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/IllegalConstraint:1.0",
        "IllegalConstraint"
      )
{
}

CosTrading::IllegalConstraint::~IllegalConstraint (void)
{
}

CosTrading::IllegalConstraint::IllegalConstraint (const ::CosTrading::IllegalConstraint &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->constr = ::CORBA::string_dup (_tao_excp.constr.in ());
}

CosTrading::IllegalConstraint&
CosTrading::IllegalConstraint::operator= (const ::CosTrading::IllegalConstraint &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->constr = ::CORBA::string_dup (_tao_excp.constr.in ());
  return *this;
}

void CosTrading::IllegalConstraint::_tao_any_destructor (void *_tao_void_pointer)
{
  IllegalConstraint *_tao_tmp_pointer =
    static_cast<IllegalConstraint *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::IllegalConstraint *
CosTrading::IllegalConstraint::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<IllegalConstraint *> (_tao_excp);
}

const CosTrading::IllegalConstraint *
CosTrading::IllegalConstraint::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const IllegalConstraint *> (_tao_excp);
}

::CORBA::Exception *CosTrading::IllegalConstraint::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::IllegalConstraint, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::IllegalConstraint::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::IllegalConstraint (*this),
      0
    );
  return result;
}

void CosTrading::IllegalConstraint::_raise (void) const
{
  throw *this;
}

void CosTrading::IllegalConstraint::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::IllegalConstraint::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::IllegalConstraint::_tao_type (void) const
{
  return ::CosTrading::_tc_IllegalConstraint;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_IllegalConstraint[] =
      {
        { "constr", &CosTrading::_tc_Constraint }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_IllegalConstraint (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/IllegalConstraint:1.0",
  "IllegalConstraint",
  _tao_fields_CosTrading_IllegalConstraint,
  1);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_IllegalConstraint =
    &_tao_tc_CosTrading_IllegalConstraint;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::InvalidLookupRef::InvalidLookupRef (
    const CosTrading::Lookup_ptr _tao_target)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/InvalidLookupRef:1.0",
        "InvalidLookupRef"
      )
{
  this->target = TAO::Objref_Traits<CosTrading::Lookup>::duplicate (_tao_target);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::InvalidLookupRef::InvalidLookupRef (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/InvalidLookupRef:1.0",
        "InvalidLookupRef"
      )
{
}

CosTrading::InvalidLookupRef::~InvalidLookupRef (void)
{
}

CosTrading::InvalidLookupRef::InvalidLookupRef (const ::CosTrading::InvalidLookupRef &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->target = TAO::Objref_Traits<CosTrading::Lookup>::duplicate (_tao_excp.target.in ());
}

CosTrading::InvalidLookupRef&
CosTrading::InvalidLookupRef::operator= (const ::CosTrading::InvalidLookupRef &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->target = TAO::Objref_Traits<CosTrading::Lookup>::duplicate (_tao_excp.target.in ());
  return *this;
}

void CosTrading::InvalidLookupRef::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidLookupRef *_tao_tmp_pointer =
    static_cast<InvalidLookupRef *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::InvalidLookupRef *
CosTrading::InvalidLookupRef::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidLookupRef *> (_tao_excp);
}

const CosTrading::InvalidLookupRef *
CosTrading::InvalidLookupRef::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidLookupRef *> (_tao_excp);
}

::CORBA::Exception *CosTrading::InvalidLookupRef::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::InvalidLookupRef, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::InvalidLookupRef::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::InvalidLookupRef (*this),
      0
    );
  return result;
}

void CosTrading::InvalidLookupRef::_raise (void) const
{
  throw *this;
}

void CosTrading::InvalidLookupRef::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::InvalidLookupRef::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::InvalidLookupRef::_tao_type (void) const
{
  return ::CosTrading::_tc_InvalidLookupRef;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_InvalidLookupRef[] =
      {
        { "target", &CosTrading::_tc_Lookup }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_InvalidLookupRef (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/InvalidLookupRef:1.0",
  "InvalidLookupRef",
  _tao_fields_CosTrading_InvalidLookupRef,
  1);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_InvalidLookupRef =
    &_tao_tc_CosTrading_InvalidLookupRef;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::IllegalOfferId::IllegalOfferId (
    const char * _tao_id)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/IllegalOfferId:1.0",
        "IllegalOfferId"
      )
{
  this->id = ::CORBA::string_dup (_tao_id);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::IllegalOfferId::IllegalOfferId (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/IllegalOfferId:1.0",
        "IllegalOfferId"
      )
{
}

CosTrading::IllegalOfferId::~IllegalOfferId (void)
{
}

CosTrading::IllegalOfferId::IllegalOfferId (const ::CosTrading::IllegalOfferId &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->id = ::CORBA::string_dup (_tao_excp.id.in ());
}

CosTrading::IllegalOfferId&
CosTrading::IllegalOfferId::operator= (const ::CosTrading::IllegalOfferId &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->id = ::CORBA::string_dup (_tao_excp.id.in ());
  return *this;
}

void CosTrading::IllegalOfferId::_tao_any_destructor (void *_tao_void_pointer)
{
  IllegalOfferId *_tao_tmp_pointer =
    static_cast<IllegalOfferId *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::IllegalOfferId *
CosTrading::IllegalOfferId::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<IllegalOfferId *> (_tao_excp);
}

const CosTrading::IllegalOfferId *
CosTrading::IllegalOfferId::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const IllegalOfferId *> (_tao_excp);
}

::CORBA::Exception *CosTrading::IllegalOfferId::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::IllegalOfferId, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::IllegalOfferId::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::IllegalOfferId (*this),
      0
    );
  return result;
}

void CosTrading::IllegalOfferId::_raise (void) const
{
  throw *this;
}

void CosTrading::IllegalOfferId::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::IllegalOfferId::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::IllegalOfferId::_tao_type (void) const
{
  return ::CosTrading::_tc_IllegalOfferId;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_IllegalOfferId[] =
      {
        { "id", &CosTrading::_tc_OfferId }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_IllegalOfferId (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/IllegalOfferId:1.0",
  "IllegalOfferId",
  _tao_fields_CosTrading_IllegalOfferId,
  1);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_IllegalOfferId =
    &_tao_tc_CosTrading_IllegalOfferId;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::UnknownOfferId::UnknownOfferId (
    const char * _tao_id)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/UnknownOfferId:1.0",
        "UnknownOfferId"
      )
{
  this->id = ::CORBA::string_dup (_tao_id);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::UnknownOfferId::UnknownOfferId (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/UnknownOfferId:1.0",
        "UnknownOfferId"
      )
{
}

CosTrading::UnknownOfferId::~UnknownOfferId (void)
{
}

CosTrading::UnknownOfferId::UnknownOfferId (const ::CosTrading::UnknownOfferId &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->id = ::CORBA::string_dup (_tao_excp.id.in ());
}

CosTrading::UnknownOfferId&
CosTrading::UnknownOfferId::operator= (const ::CosTrading::UnknownOfferId &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->id = ::CORBA::string_dup (_tao_excp.id.in ());
  return *this;
}

void CosTrading::UnknownOfferId::_tao_any_destructor (void *_tao_void_pointer)
{
  UnknownOfferId *_tao_tmp_pointer =
    static_cast<UnknownOfferId *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::UnknownOfferId *
CosTrading::UnknownOfferId::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UnknownOfferId *> (_tao_excp);
}

const CosTrading::UnknownOfferId *
CosTrading::UnknownOfferId::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UnknownOfferId *> (_tao_excp);
}

::CORBA::Exception *CosTrading::UnknownOfferId::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::UnknownOfferId, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::UnknownOfferId::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::UnknownOfferId (*this),
      0
    );
  return result;
}

void CosTrading::UnknownOfferId::_raise (void) const
{
  throw *this;
}

void CosTrading::UnknownOfferId::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::UnknownOfferId::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::UnknownOfferId::_tao_type (void) const
{
  return ::CosTrading::_tc_UnknownOfferId;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_UnknownOfferId[] =
      {
        { "id", &CosTrading::_tc_OfferId }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_UnknownOfferId (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/UnknownOfferId:1.0",
  "UnknownOfferId",
  _tao_fields_CosTrading_UnknownOfferId,
  1);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_UnknownOfferId =
    &_tao_tc_CosTrading_UnknownOfferId;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::DuplicatePolicyName::DuplicatePolicyName (
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/DuplicatePolicyName:1.0",
        "DuplicatePolicyName"
      )
{
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::DuplicatePolicyName::DuplicatePolicyName (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/DuplicatePolicyName:1.0",
        "DuplicatePolicyName"
      )
{
}

CosTrading::DuplicatePolicyName::~DuplicatePolicyName (void)
{
}

CosTrading::DuplicatePolicyName::DuplicatePolicyName (const ::CosTrading::DuplicatePolicyName &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTrading::DuplicatePolicyName&
CosTrading::DuplicatePolicyName::operator= (const ::CosTrading::DuplicatePolicyName &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTrading::DuplicatePolicyName::_tao_any_destructor (void *_tao_void_pointer)
{
  DuplicatePolicyName *_tao_tmp_pointer =
    static_cast<DuplicatePolicyName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::DuplicatePolicyName *
CosTrading::DuplicatePolicyName::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<DuplicatePolicyName *> (_tao_excp);
}

const CosTrading::DuplicatePolicyName *
CosTrading::DuplicatePolicyName::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const DuplicatePolicyName *> (_tao_excp);
}

::CORBA::Exception *CosTrading::DuplicatePolicyName::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::DuplicatePolicyName, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::DuplicatePolicyName::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::DuplicatePolicyName (*this),
      0
    );
  return result;
}

void CosTrading::DuplicatePolicyName::_raise (void) const
{
  throw *this;
}

void CosTrading::DuplicatePolicyName::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::DuplicatePolicyName::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::DuplicatePolicyName::_tao_type (void) const
{
  return ::CosTrading::_tc_DuplicatePolicyName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_DuplicatePolicyName[] =
      {
        { "name", &CosTrading::_tc_PolicyName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_DuplicatePolicyName (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/DuplicatePolicyName:1.0",
  "DuplicatePolicyName",
  _tao_fields_CosTrading_DuplicatePolicyName,
  1);


namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_DuplicatePolicyName =
    &_tao_tc_CosTrading_DuplicatePolicyName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosTrading::TraderComponents.

CosTrading::TraderComponents_ptr
TAO::Objref_Traits<CosTrading::TraderComponents>::duplicate (
    CosTrading::TraderComponents_ptr p)
{
  return CosTrading::TraderComponents::_duplicate (p);
}

void
TAO::Objref_Traits<CosTrading::TraderComponents>::release (
    CosTrading::TraderComponents_ptr p)
{
  ::CORBA::release (p);
}

CosTrading::TraderComponents_ptr
TAO::Objref_Traits<CosTrading::TraderComponents>::nil (void)
{
  return CosTrading::TraderComponents::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosTrading::TraderComponents>::marshal (
    const CosTrading::TraderComponents_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosTrading__TAO_TraderComponents_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::Lookup_ptr
CosTrading::TraderComponents::lookup_if (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_TraderComponents_Proxy_Broker_ == 0)
    {
      CosTrading_TraderComponents_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::Lookup>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_lookup_if",
      14,
      this->the_TAO_TraderComponents_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::Register_ptr
CosTrading::TraderComponents::register_if (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_TraderComponents_Proxy_Broker_ == 0)
    {
      CosTrading_TraderComponents_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::Register>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_register_if",
      16,
      this->the_TAO_TraderComponents_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::Link_ptr
CosTrading::TraderComponents::link_if (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_TraderComponents_Proxy_Broker_ == 0)
    {
      CosTrading_TraderComponents_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::Link>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_link_if",
      12,
      this->the_TAO_TraderComponents_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::Proxy_ptr
CosTrading::TraderComponents::proxy_if (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_TraderComponents_Proxy_Broker_ == 0)
    {
      CosTrading_TraderComponents_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::Proxy>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_proxy_if",
      13,
      this->the_TAO_TraderComponents_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::Admin_ptr
CosTrading::TraderComponents::admin_if (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_TraderComponents_Proxy_Broker_ == 0)
    {
      CosTrading_TraderComponents_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::Admin>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_admin_if",
      13,
      this->the_TAO_TraderComponents_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

CosTrading::TraderComponents::TraderComponents (void)
 : the_TAO_TraderComponents_Proxy_Broker_ (0)
{
  this->CosTrading_TraderComponents_setup_collocation ();
}

void
CosTrading::TraderComponents::CosTrading_TraderComponents_setup_collocation ()
{
  if (::CosTrading__TAO_TraderComponents_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_TraderComponents_Proxy_Broker_ =
        ::CosTrading__TAO_TraderComponents_Proxy_Broker_Factory_function_pointer (this);
    }
}

CosTrading::TraderComponents::~TraderComponents (void)
{}

void 
CosTrading::TraderComponents::_tao_any_destructor (void *_tao_void_pointer)
{
  TraderComponents *_tao_tmp_pointer =
    static_cast<TraderComponents *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosTrading::TraderComponents_ptr
CosTrading::TraderComponents::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<TraderComponents>::narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/TraderComponents:1.0",
        CosTrading__TAO_TraderComponents_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::TraderComponents_ptr
CosTrading::TraderComponents::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<TraderComponents>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/TraderComponents:1.0",
        CosTrading__TAO_TraderComponents_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::TraderComponents_ptr
CosTrading::TraderComponents::_nil (void)
{
  return 0;
}

CosTrading::TraderComponents_ptr
CosTrading::TraderComponents::_duplicate (TraderComponents_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosTrading::TraderComponents::_tao_release (TraderComponents_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosTrading::TraderComponents::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/TraderComponents:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosTrading::TraderComponents::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosTrading/TraderComponents:1.0";
}

::CORBA::Boolean
CosTrading::TraderComponents::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_TraderComponents (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosTrading/TraderComponents:1.0",
    "TraderComponents");
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_TraderComponents =
    &_tao_tc_CosTrading_TraderComponents;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosTrading::SupportAttributes.

CosTrading::SupportAttributes_ptr
TAO::Objref_Traits<CosTrading::SupportAttributes>::duplicate (
    CosTrading::SupportAttributes_ptr p)
{
  return CosTrading::SupportAttributes::_duplicate (p);
}

void
TAO::Objref_Traits<CosTrading::SupportAttributes>::release (
    CosTrading::SupportAttributes_ptr p)
{
  ::CORBA::release (p);
}

CosTrading::SupportAttributes_ptr
TAO::Objref_Traits<CosTrading::SupportAttributes>::nil (void)
{
  return CosTrading::SupportAttributes::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosTrading::SupportAttributes>::marshal (
    const CosTrading::SupportAttributes_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosTrading__TAO_SupportAttributes_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CosTrading::SupportAttributes::supports_modifiable_properties (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_SupportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_SupportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_supports_modifiable_properties",
      35,
      this->the_TAO_SupportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CosTrading::SupportAttributes::supports_dynamic_properties (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_SupportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_SupportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_supports_dynamic_properties",
      32,
      this->the_TAO_SupportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CosTrading::SupportAttributes::supports_proxy_offers (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_SupportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_SupportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_supports_proxy_offers",
      26,
      this->the_TAO_SupportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::TypeRepository_ptr
CosTrading::SupportAttributes::type_repos (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_SupportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_SupportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_type_repos",
      15,
      this->the_TAO_SupportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

CosTrading::SupportAttributes::SupportAttributes (void)
 : the_TAO_SupportAttributes_Proxy_Broker_ (0)
{
  this->CosTrading_SupportAttributes_setup_collocation ();
}

void
CosTrading::SupportAttributes::CosTrading_SupportAttributes_setup_collocation ()
{
  if (::CosTrading__TAO_SupportAttributes_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_SupportAttributes_Proxy_Broker_ =
        ::CosTrading__TAO_SupportAttributes_Proxy_Broker_Factory_function_pointer (this);
    }
}

CosTrading::SupportAttributes::~SupportAttributes (void)
{}

void 
CosTrading::SupportAttributes::_tao_any_destructor (void *_tao_void_pointer)
{
  SupportAttributes *_tao_tmp_pointer =
    static_cast<SupportAttributes *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosTrading::SupportAttributes_ptr
CosTrading::SupportAttributes::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<SupportAttributes>::narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/SupportAttributes:1.0",
        CosTrading__TAO_SupportAttributes_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::SupportAttributes_ptr
CosTrading::SupportAttributes::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<SupportAttributes>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/SupportAttributes:1.0",
        CosTrading__TAO_SupportAttributes_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::SupportAttributes_ptr
CosTrading::SupportAttributes::_nil (void)
{
  return 0;
}

CosTrading::SupportAttributes_ptr
CosTrading::SupportAttributes::_duplicate (SupportAttributes_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosTrading::SupportAttributes::_tao_release (SupportAttributes_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosTrading::SupportAttributes::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/SupportAttributes:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosTrading::SupportAttributes::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosTrading/SupportAttributes:1.0";
}

::CORBA::Boolean
CosTrading::SupportAttributes::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_SupportAttributes (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosTrading/SupportAttributes:1.0",
    "SupportAttributes");
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_SupportAttributes =
    &_tao_tc_CosTrading_SupportAttributes;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosTrading::ImportAttributes.

CosTrading::ImportAttributes_ptr
TAO::Objref_Traits<CosTrading::ImportAttributes>::duplicate (
    CosTrading::ImportAttributes_ptr p)
{
  return CosTrading::ImportAttributes::_duplicate (p);
}

void
TAO::Objref_Traits<CosTrading::ImportAttributes>::release (
    CosTrading::ImportAttributes_ptr p)
{
  ::CORBA::release (p);
}

CosTrading::ImportAttributes_ptr
TAO::Objref_Traits<CosTrading::ImportAttributes>::nil (void)
{
  return CosTrading::ImportAttributes::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosTrading::ImportAttributes>::marshal (
    const CosTrading::ImportAttributes_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosTrading__TAO_ImportAttributes_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::ImportAttributes::def_search_card (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ImportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_ImportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_def_search_card",
      20,
      this->the_TAO_ImportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::ImportAttributes::max_search_card (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ImportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_ImportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_max_search_card",
      20,
      this->the_TAO_ImportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::ImportAttributes::def_match_card (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ImportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_ImportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_def_match_card",
      19,
      this->the_TAO_ImportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::ImportAttributes::max_match_card (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ImportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_ImportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_max_match_card",
      19,
      this->the_TAO_ImportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::ImportAttributes::def_return_card (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ImportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_ImportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_def_return_card",
      20,
      this->the_TAO_ImportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::ImportAttributes::max_return_card (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ImportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_ImportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_max_return_card",
      20,
      this->the_TAO_ImportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::ImportAttributes::max_list (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ImportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_ImportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_max_list",
      13,
      this->the_TAO_ImportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::ImportAttributes::def_hop_count (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ImportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_ImportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_def_hop_count",
      18,
      this->the_TAO_ImportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::ImportAttributes::max_hop_count (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ImportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_ImportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_max_hop_count",
      18,
      this->the_TAO_ImportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::FollowOption
CosTrading::ImportAttributes::def_follow_policy (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ImportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_ImportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::FollowOption>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_def_follow_policy",
      22,
      this->the_TAO_ImportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::FollowOption
CosTrading::ImportAttributes::max_follow_policy (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_ImportAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_ImportAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::FollowOption>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_max_follow_policy",
      22,
      this->the_TAO_ImportAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

CosTrading::ImportAttributes::ImportAttributes (void)
 : the_TAO_ImportAttributes_Proxy_Broker_ (0)
{
  this->CosTrading_ImportAttributes_setup_collocation ();
}

void
CosTrading::ImportAttributes::CosTrading_ImportAttributes_setup_collocation ()
{
  if (::CosTrading__TAO_ImportAttributes_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_ImportAttributes_Proxy_Broker_ =
        ::CosTrading__TAO_ImportAttributes_Proxy_Broker_Factory_function_pointer (this);
    }
}

CosTrading::ImportAttributes::~ImportAttributes (void)
{}

void 
CosTrading::ImportAttributes::_tao_any_destructor (void *_tao_void_pointer)
{
  ImportAttributes *_tao_tmp_pointer =
    static_cast<ImportAttributes *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosTrading::ImportAttributes_ptr
CosTrading::ImportAttributes::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ImportAttributes>::narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/ImportAttributes:1.0",
        CosTrading__TAO_ImportAttributes_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::ImportAttributes_ptr
CosTrading::ImportAttributes::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ImportAttributes>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/ImportAttributes:1.0",
        CosTrading__TAO_ImportAttributes_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::ImportAttributes_ptr
CosTrading::ImportAttributes::_nil (void)
{
  return 0;
}

CosTrading::ImportAttributes_ptr
CosTrading::ImportAttributes::_duplicate (ImportAttributes_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosTrading::ImportAttributes::_tao_release (ImportAttributes_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosTrading::ImportAttributes::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/ImportAttributes:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosTrading::ImportAttributes::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosTrading/ImportAttributes:1.0";
}

::CORBA::Boolean
CosTrading::ImportAttributes::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_ImportAttributes (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosTrading/ImportAttributes:1.0",
    "ImportAttributes");
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_ImportAttributes =
    &_tao_tc_CosTrading_ImportAttributes;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosTrading::LinkAttributes.

CosTrading::LinkAttributes_ptr
TAO::Objref_Traits<CosTrading::LinkAttributes>::duplicate (
    CosTrading::LinkAttributes_ptr p)
{
  return CosTrading::LinkAttributes::_duplicate (p);
}

void
TAO::Objref_Traits<CosTrading::LinkAttributes>::release (
    CosTrading::LinkAttributes_ptr p)
{
  ::CORBA::release (p);
}

CosTrading::LinkAttributes_ptr
TAO::Objref_Traits<CosTrading::LinkAttributes>::nil (void)
{
  return CosTrading::LinkAttributes::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosTrading::LinkAttributes>::marshal (
    const CosTrading::LinkAttributes_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosTrading__TAO_LinkAttributes_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::FollowOption
CosTrading::LinkAttributes::max_link_follow_policy (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LinkAttributes_Proxy_Broker_ == 0)
    {
      CosTrading_LinkAttributes_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::FollowOption>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_max_link_follow_policy",
      27,
      this->the_TAO_LinkAttributes_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

CosTrading::LinkAttributes::LinkAttributes (void)
 : the_TAO_LinkAttributes_Proxy_Broker_ (0)
{
  this->CosTrading_LinkAttributes_setup_collocation ();
}

void
CosTrading::LinkAttributes::CosTrading_LinkAttributes_setup_collocation ()
{
  if (::CosTrading__TAO_LinkAttributes_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_LinkAttributes_Proxy_Broker_ =
        ::CosTrading__TAO_LinkAttributes_Proxy_Broker_Factory_function_pointer (this);
    }
}

CosTrading::LinkAttributes::~LinkAttributes (void)
{}

void 
CosTrading::LinkAttributes::_tao_any_destructor (void *_tao_void_pointer)
{
  LinkAttributes *_tao_tmp_pointer =
    static_cast<LinkAttributes *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosTrading::LinkAttributes_ptr
CosTrading::LinkAttributes::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<LinkAttributes>::narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/LinkAttributes:1.0",
        CosTrading__TAO_LinkAttributes_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::LinkAttributes_ptr
CosTrading::LinkAttributes::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<LinkAttributes>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/LinkAttributes:1.0",
        CosTrading__TAO_LinkAttributes_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::LinkAttributes_ptr
CosTrading::LinkAttributes::_nil (void)
{
  return 0;
}

CosTrading::LinkAttributes_ptr
CosTrading::LinkAttributes::_duplicate (LinkAttributes_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosTrading::LinkAttributes::_tao_release (LinkAttributes_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosTrading::LinkAttributes::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/LinkAttributes:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosTrading::LinkAttributes::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosTrading/LinkAttributes:1.0";
}

::CORBA::Boolean
CosTrading::LinkAttributes::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_LinkAttributes (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosTrading/LinkAttributes:1.0",
    "LinkAttributes");
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_LinkAttributes =
    &_tao_tc_CosTrading_LinkAttributes;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosTrading::Lookup.

CosTrading::Lookup_ptr
TAO::Objref_Traits<CosTrading::Lookup>::duplicate (
    CosTrading::Lookup_ptr p)
{
  return CosTrading::Lookup::_duplicate (p);
}

void
TAO::Objref_Traits<CosTrading::Lookup>::release (
    CosTrading::Lookup_ptr p)
{
  ::CORBA::release (p);
}

CosTrading::Lookup_ptr
TAO::Objref_Traits<CosTrading::Lookup>::nil (void)
{
  return CosTrading::Lookup::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosTrading::Lookup>::marshal (
    const CosTrading::Lookup_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosTrading__TAO_Lookup_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_Lookup_Preference (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/Lookup/Preference:1.0",
    "Preference",
    &CosTrading::_tc_Istring);
  
::CORBA::TypeCode_ptr const CosTrading::Lookup::_tc_Preference =
  &_tao_tc_CosTrading_Lookup_Preference;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_CosTrading_Lookup_HowManyProps[] =
  {
    "none",
    "some",
    "all"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_Lookup_HowManyProps (
    "IDL:omg.org/CosTrading/Lookup/HowManyProps:1.0",
    "HowManyProps",
    _tao_enumerators_CosTrading_Lookup_HowManyProps,
    3);
  
::CORBA::TypeCode_ptr const CosTrading::Lookup::_tc_HowManyProps =
  &_tao_tc_CosTrading_Lookup_HowManyProps;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_union/union_cs.cpp:82

CosTrading::Lookup::SpecifiedProps::SpecifiedProps (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = CosTrading::Lookup::none;
}

CosTrading::Lookup::SpecifiedProps::SpecifiedProps (const ::CosTrading::Lookup::SpecifiedProps &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case CosTrading::Lookup::some:
    {
      if (u.u_.prop_names_ == 0)
        {
          this->u_.prop_names_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.prop_names_,
              CosTrading::PropertyNameSeq (*u.u_.prop_names_)
            );
        }
    }
    break;
    default:
    break;
  }
}

CosTrading::Lookup::SpecifiedProps::~SpecifiedProps (void)
{
  // Finalize.
  this->_reset ();
}

void CosTrading::Lookup::SpecifiedProps::_tao_any_destructor (void *_tao_void_pointer)
{
  SpecifiedProps *tmp =
    static_cast<SpecifiedProps *> (_tao_void_pointer);
  delete tmp;
}

CosTrading::Lookup::SpecifiedProps &
CosTrading::Lookup::SpecifiedProps::operator= (const ::CosTrading::Lookup::SpecifiedProps &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case CosTrading::Lookup::some:
    {
      if (u.u_.prop_names_ == 0)
        {
          this->u_.prop_names_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.prop_names_,
              CosTrading::PropertyNameSeq (*u.u_.prop_names_),
              *this
            );
        }
    }
    break;
    default:
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void CosTrading::Lookup::SpecifiedProps::_reset (void)
{
  switch (this->disc_)
  {
    
    case CosTrading::Lookup::some:
      delete this->u_.prop_names_;
      this->u_.prop_names_ = 0;
      break;
    default:
    break;
  }
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/union_typecode.cpp:66



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Case_T<CosTrading::Lookup::HowManyProps, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_CosTrading_Lookup_SpecifiedProps__0 (CosTrading::Lookup::some, "prop_names", &CosTrading::_tc_PropertyNameSeq);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_CosTrading_Lookup_SpecifiedProps[] =
  {
    &_tao_cases_CosTrading_Lookup_SpecifiedProps__0
    
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_Lookup_SpecifiedProps (
    "IDL:omg.org/CosTrading/Lookup/SpecifiedProps:1.0",
    "SpecifiedProps",
    &CosTrading::Lookup::_tc_HowManyProps,
    _tao_cases_CosTrading_Lookup_SpecifiedProps,
    1, -1);
  
::CORBA::TypeCode_ptr const CosTrading::Lookup::_tc_SpecifiedProps =
  &_tao_tc_CosTrading_Lookup_SpecifiedProps;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Lookup::IllegalPreference::IllegalPreference (
    const char * _tao_pref)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Lookup/IllegalPreference:1.0",
        "IllegalPreference"
      )
{
  this->pref = ::CORBA::string_dup (_tao_pref);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Lookup::IllegalPreference::IllegalPreference (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Lookup/IllegalPreference:1.0",
        "IllegalPreference"
      )
{
}

CosTrading::Lookup::IllegalPreference::~IllegalPreference (void)
{
}

CosTrading::Lookup::IllegalPreference::IllegalPreference (const ::CosTrading::Lookup::IllegalPreference &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->pref = ::CORBA::string_dup (_tao_excp.pref.in ());
}

CosTrading::Lookup::IllegalPreference&
CosTrading::Lookup::IllegalPreference::operator= (const ::CosTrading::Lookup::IllegalPreference &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->pref = ::CORBA::string_dup (_tao_excp.pref.in ());
  return *this;
}

void CosTrading::Lookup::IllegalPreference::_tao_any_destructor (void *_tao_void_pointer)
{
  IllegalPreference *_tao_tmp_pointer =
    static_cast<IllegalPreference *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Lookup::IllegalPreference *
CosTrading::Lookup::IllegalPreference::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<IllegalPreference *> (_tao_excp);
}

const CosTrading::Lookup::IllegalPreference *
CosTrading::Lookup::IllegalPreference::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const IllegalPreference *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Lookup::IllegalPreference::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Lookup::IllegalPreference, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Lookup::IllegalPreference::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Lookup::IllegalPreference (*this),
      0
    );
  return result;
}

void CosTrading::Lookup::IllegalPreference::_raise (void) const
{
  throw *this;
}

void CosTrading::Lookup::IllegalPreference::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Lookup::IllegalPreference::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Lookup::IllegalPreference::_tao_type (void) const
{
  return ::CosTrading::Lookup::_tc_IllegalPreference;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Lookup_IllegalPreference[] =
      {
        { "pref", &CosTrading::Lookup::_tc_Preference }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Lookup_IllegalPreference (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Lookup/IllegalPreference:1.0",
  "IllegalPreference",
  _tao_fields_CosTrading_Lookup_IllegalPreference,
  1);

::CORBA::TypeCode_ptr const CosTrading::Lookup::_tc_IllegalPreference =
  &_tao_tc_CosTrading_Lookup_IllegalPreference;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Lookup::IllegalPolicyName::IllegalPolicyName (
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Lookup/IllegalPolicyName:1.0",
        "IllegalPolicyName"
      )
{
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Lookup::IllegalPolicyName::IllegalPolicyName (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Lookup/IllegalPolicyName:1.0",
        "IllegalPolicyName"
      )
{
}

CosTrading::Lookup::IllegalPolicyName::~IllegalPolicyName (void)
{
}

CosTrading::Lookup::IllegalPolicyName::IllegalPolicyName (const ::CosTrading::Lookup::IllegalPolicyName &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTrading::Lookup::IllegalPolicyName&
CosTrading::Lookup::IllegalPolicyName::operator= (const ::CosTrading::Lookup::IllegalPolicyName &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTrading::Lookup::IllegalPolicyName::_tao_any_destructor (void *_tao_void_pointer)
{
  IllegalPolicyName *_tao_tmp_pointer =
    static_cast<IllegalPolicyName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Lookup::IllegalPolicyName *
CosTrading::Lookup::IllegalPolicyName::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<IllegalPolicyName *> (_tao_excp);
}

const CosTrading::Lookup::IllegalPolicyName *
CosTrading::Lookup::IllegalPolicyName::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const IllegalPolicyName *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Lookup::IllegalPolicyName::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Lookup::IllegalPolicyName, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Lookup::IllegalPolicyName::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Lookup::IllegalPolicyName (*this),
      0
    );
  return result;
}

void CosTrading::Lookup::IllegalPolicyName::_raise (void) const
{
  throw *this;
}

void CosTrading::Lookup::IllegalPolicyName::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Lookup::IllegalPolicyName::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Lookup::IllegalPolicyName::_tao_type (void) const
{
  return ::CosTrading::Lookup::_tc_IllegalPolicyName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Lookup_IllegalPolicyName[] =
      {
        { "name", &CosTrading::_tc_PolicyName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Lookup_IllegalPolicyName (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Lookup/IllegalPolicyName:1.0",
  "IllegalPolicyName",
  _tao_fields_CosTrading_Lookup_IllegalPolicyName,
  1);

::CORBA::TypeCode_ptr const CosTrading::Lookup::_tc_IllegalPolicyName =
  &_tao_tc_CosTrading_Lookup_IllegalPolicyName;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Lookup::PolicyTypeMismatch::PolicyTypeMismatch (
    const CosTrading::Policy & _tao_the_policy)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Lookup/PolicyTypeMismatch:1.0",
        "PolicyTypeMismatch"
      )
{
  this->the_policy = _tao_the_policy;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Lookup::PolicyTypeMismatch::PolicyTypeMismatch (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Lookup/PolicyTypeMismatch:1.0",
        "PolicyTypeMismatch"
      )
{
}

CosTrading::Lookup::PolicyTypeMismatch::~PolicyTypeMismatch (void)
{
}

CosTrading::Lookup::PolicyTypeMismatch::PolicyTypeMismatch (const ::CosTrading::Lookup::PolicyTypeMismatch &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->the_policy = _tao_excp.the_policy;
}

CosTrading::Lookup::PolicyTypeMismatch&
CosTrading::Lookup::PolicyTypeMismatch::operator= (const ::CosTrading::Lookup::PolicyTypeMismatch &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->the_policy = _tao_excp.the_policy;
  return *this;
}

void CosTrading::Lookup::PolicyTypeMismatch::_tao_any_destructor (void *_tao_void_pointer)
{
  PolicyTypeMismatch *_tao_tmp_pointer =
    static_cast<PolicyTypeMismatch *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Lookup::PolicyTypeMismatch *
CosTrading::Lookup::PolicyTypeMismatch::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<PolicyTypeMismatch *> (_tao_excp);
}

const CosTrading::Lookup::PolicyTypeMismatch *
CosTrading::Lookup::PolicyTypeMismatch::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const PolicyTypeMismatch *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Lookup::PolicyTypeMismatch::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Lookup::PolicyTypeMismatch, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Lookup::PolicyTypeMismatch::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Lookup::PolicyTypeMismatch (*this),
      0
    );
  return result;
}

void CosTrading::Lookup::PolicyTypeMismatch::_raise (void) const
{
  throw *this;
}

void CosTrading::Lookup::PolicyTypeMismatch::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Lookup::PolicyTypeMismatch::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Lookup::PolicyTypeMismatch::_tao_type (void) const
{
  return ::CosTrading::Lookup::_tc_PolicyTypeMismatch;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Lookup_PolicyTypeMismatch[] =
      {
        { "the_policy", &CosTrading::_tc_Policy }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Lookup_PolicyTypeMismatch (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Lookup/PolicyTypeMismatch:1.0",
  "PolicyTypeMismatch",
  _tao_fields_CosTrading_Lookup_PolicyTypeMismatch,
  1);

::CORBA::TypeCode_ptr const CosTrading::Lookup::_tc_PolicyTypeMismatch =
  &_tao_tc_CosTrading_Lookup_PolicyTypeMismatch;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Lookup::InvalidPolicyValue::InvalidPolicyValue (
    const CosTrading::Policy & _tao_the_policy)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Lookup/InvalidPolicyValue:1.0",
        "InvalidPolicyValue"
      )
{
  this->the_policy = _tao_the_policy;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Lookup::InvalidPolicyValue::InvalidPolicyValue (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Lookup/InvalidPolicyValue:1.0",
        "InvalidPolicyValue"
      )
{
}

CosTrading::Lookup::InvalidPolicyValue::~InvalidPolicyValue (void)
{
}

CosTrading::Lookup::InvalidPolicyValue::InvalidPolicyValue (const ::CosTrading::Lookup::InvalidPolicyValue &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->the_policy = _tao_excp.the_policy;
}

CosTrading::Lookup::InvalidPolicyValue&
CosTrading::Lookup::InvalidPolicyValue::operator= (const ::CosTrading::Lookup::InvalidPolicyValue &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->the_policy = _tao_excp.the_policy;
  return *this;
}

void CosTrading::Lookup::InvalidPolicyValue::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidPolicyValue *_tao_tmp_pointer =
    static_cast<InvalidPolicyValue *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Lookup::InvalidPolicyValue *
CosTrading::Lookup::InvalidPolicyValue::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidPolicyValue *> (_tao_excp);
}

const CosTrading::Lookup::InvalidPolicyValue *
CosTrading::Lookup::InvalidPolicyValue::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidPolicyValue *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Lookup::InvalidPolicyValue::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Lookup::InvalidPolicyValue, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Lookup::InvalidPolicyValue::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Lookup::InvalidPolicyValue (*this),
      0
    );
  return result;
}

void CosTrading::Lookup::InvalidPolicyValue::_raise (void) const
{
  throw *this;
}

void CosTrading::Lookup::InvalidPolicyValue::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Lookup::InvalidPolicyValue::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Lookup::InvalidPolicyValue::_tao_type (void) const
{
  return ::CosTrading::Lookup::_tc_InvalidPolicyValue;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Lookup_InvalidPolicyValue[] =
      {
        { "the_policy", &CosTrading::_tc_Policy }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Lookup_InvalidPolicyValue (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Lookup/InvalidPolicyValue:1.0",
  "InvalidPolicyValue",
  _tao_fields_CosTrading_Lookup_InvalidPolicyValue,
  1);

::CORBA::TypeCode_ptr const CosTrading::Lookup::_tc_InvalidPolicyValue =
  &_tao_tc_CosTrading_Lookup_InvalidPolicyValue;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTrading::Lookup::query (
  const char * type,
  const char * constr,
  const char * pref,
  const ::CosTrading::PolicySeq & policies,
  const ::CosTrading::Lookup::SpecifiedProps & desired_props,
  ::CORBA::ULong how_many,
  ::CosTrading::OfferSeq_out offers,
  ::CosTrading::OfferIterator_out offer_itr,
  ::CosTrading::PolicyNameSeq_out limits_applied)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Lookup_Proxy_Broker_ == 0)
    {
      CosTrading_Lookup_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_type (type);
  TAO::Arg_Traits< char *>::in_arg_val _tao_constr (constr);
  TAO::Arg_Traits< char *>::in_arg_val _tao_pref (pref);
  TAO::Arg_Traits< ::CosTrading::PolicySeq>::in_arg_val _tao_policies (policies);
  TAO::Arg_Traits< ::CosTrading::Lookup::SpecifiedProps>::in_arg_val _tao_desired_props (desired_props);
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_how_many (how_many);
  TAO::Arg_Traits< ::CosTrading::OfferSeq>::out_arg_val _tao_offers (offers);
  TAO::Arg_Traits< ::CosTrading::OfferIterator>::out_arg_val _tao_offer_itr (offer_itr);
  TAO::Arg_Traits< ::CosTrading::PolicyNameSeq>::out_arg_val _tao_limits_applied (limits_applied);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_type,
      &_tao_constr,
      &_tao_pref,
      &_tao_policies,
      &_tao_desired_props,
      &_tao_how_many,
      &_tao_offers,
      &_tao_offer_itr,
      &_tao_limits_applied
    };

  static TAO::Exception_Data
  _tao_CosTrading_Lookup_query_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/IllegalServiceType:1.0",
        CosTrading::IllegalServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownServiceType:1.0",
        CosTrading::UnknownServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/IllegalConstraint:1.0",
        CosTrading::IllegalConstraint::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalConstraint
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Lookup/IllegalPreference:1.0",
        CosTrading::Lookup::IllegalPreference::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Lookup::_tc_IllegalPreference
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Lookup/IllegalPolicyName:1.0",
        CosTrading::Lookup::IllegalPolicyName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Lookup::_tc_IllegalPolicyName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Lookup/PolicyTypeMismatch:1.0",
        CosTrading::Lookup::PolicyTypeMismatch::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Lookup::_tc_PolicyTypeMismatch
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Lookup/InvalidPolicyValue:1.0",
        CosTrading::Lookup::InvalidPolicyValue::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Lookup::_tc_InvalidPolicyValue
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/IllegalPropertyName:1.0",
        CosTrading::IllegalPropertyName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalPropertyName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/DuplicatePropertyName:1.0",
        CosTrading::DuplicatePropertyName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_DuplicatePropertyName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/DuplicatePolicyName:1.0",
        CosTrading::DuplicatePolicyName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_DuplicatePolicyName
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      10,
      "query",
      5,
      this->the_TAO_Lookup_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Lookup_query_exceptiondata,
      10
    );
}

CosTrading::Lookup::Lookup (void)
 : the_TAO_Lookup_Proxy_Broker_ (0)
{
  this->CosTrading_Lookup_setup_collocation ();
}

void
CosTrading::Lookup::CosTrading_Lookup_setup_collocation ()
{
  if (::CosTrading__TAO_Lookup_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Lookup_Proxy_Broker_ =
        ::CosTrading__TAO_Lookup_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CosTrading_TraderComponents_setup_collocation ();
  this->CosTrading_SupportAttributes_setup_collocation ();
  this->CosTrading_ImportAttributes_setup_collocation ();
}

CosTrading::Lookup::~Lookup (void)
{}

void 
CosTrading::Lookup::_tao_any_destructor (void *_tao_void_pointer)
{
  Lookup *_tao_tmp_pointer =
    static_cast<Lookup *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosTrading::Lookup_ptr
CosTrading::Lookup::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Lookup>::narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/Lookup:1.0",
        CosTrading__TAO_Lookup_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::Lookup_ptr
CosTrading::Lookup::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Lookup>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/Lookup:1.0",
        CosTrading__TAO_Lookup_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::Lookup_ptr
CosTrading::Lookup::_nil (void)
{
  return 0;
}

CosTrading::Lookup_ptr
CosTrading::Lookup::_duplicate (Lookup_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosTrading::Lookup::_tao_release (Lookup_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosTrading::Lookup::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/TraderComponents:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/SupportAttributes:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/ImportAttributes:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/Lookup:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosTrading::Lookup::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosTrading/Lookup:1.0";
}

::CORBA::Boolean
CosTrading::Lookup::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_Lookup (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosTrading/Lookup:1.0",
    "Lookup");
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_Lookup =
    &_tao_tc_CosTrading_Lookup;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosTrading::Register.

CosTrading::Register_ptr
TAO::Objref_Traits<CosTrading::Register>::duplicate (
    CosTrading::Register_ptr p)
{
  return CosTrading::Register::_duplicate (p);
}

void
TAO::Objref_Traits<CosTrading::Register>::release (
    CosTrading::Register_ptr p)
{
  ::CORBA::release (p);
}

CosTrading::Register_ptr
TAO::Objref_Traits<CosTrading::Register>::nil (void)
{
  return CosTrading::Register::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosTrading::Register>::marshal (
    const CosTrading::Register_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosTrading__TAO_Register_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Register_OfferInfo[] =
      {
        { "reference", &CORBA::_tc_Object },
        { "type", &CosTrading::_tc_ServiceTypeName },
        { "properties", &CosTrading::_tc_PropertySeq }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Register_OfferInfo (
  ::CORBA::tk_struct,
  "IDL:omg.org/CosTrading/Register/OfferInfo:1.0",
  "OfferInfo",
  _tao_fields_CosTrading_Register_OfferInfo,
  3);

::CORBA::TypeCode_ptr const CosTrading::Register::_tc_OfferInfo =
  &_tao_tc_CosTrading_Register_OfferInfo;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosTrading::Register::OfferInfo::_tao_any_destructor (
    void *_tao_void_pointer)
{
  OfferInfo *_tao_tmp_pointer =
    static_cast<OfferInfo *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Register::InvalidObjectRef::InvalidObjectRef (
    const ::CORBA::Object_ptr  _tao_ref)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/InvalidObjectRef:1.0",
        "InvalidObjectRef"
      )
{
  this->ref = CORBA::Object::_duplicate (_tao_ref);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Register::InvalidObjectRef::InvalidObjectRef (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/InvalidObjectRef:1.0",
        "InvalidObjectRef"
      )
{
}

CosTrading::Register::InvalidObjectRef::~InvalidObjectRef (void)
{
}

CosTrading::Register::InvalidObjectRef::InvalidObjectRef (const ::CosTrading::Register::InvalidObjectRef &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->ref = CORBA::Object::_duplicate (_tao_excp.ref.in ());
}

CosTrading::Register::InvalidObjectRef&
CosTrading::Register::InvalidObjectRef::operator= (const ::CosTrading::Register::InvalidObjectRef &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->ref = CORBA::Object::_duplicate (_tao_excp.ref.in ());
  return *this;
}

void CosTrading::Register::InvalidObjectRef::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidObjectRef *_tao_tmp_pointer =
    static_cast<InvalidObjectRef *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Register::InvalidObjectRef *
CosTrading::Register::InvalidObjectRef::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidObjectRef *> (_tao_excp);
}

const CosTrading::Register::InvalidObjectRef *
CosTrading::Register::InvalidObjectRef::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidObjectRef *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Register::InvalidObjectRef::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Register::InvalidObjectRef, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Register::InvalidObjectRef::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Register::InvalidObjectRef (*this),
      0
    );
  return result;
}

void CosTrading::Register::InvalidObjectRef::_raise (void) const
{
  throw *this;
}

void CosTrading::Register::InvalidObjectRef::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Register::InvalidObjectRef::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Register::InvalidObjectRef::_tao_type (void) const
{
  return ::CosTrading::Register::_tc_InvalidObjectRef;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Register_InvalidObjectRef[] =
      {
        { "ref", &CORBA::_tc_Object }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Register_InvalidObjectRef (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Register/InvalidObjectRef:1.0",
  "InvalidObjectRef",
  _tao_fields_CosTrading_Register_InvalidObjectRef,
  1);

::CORBA::TypeCode_ptr const CosTrading::Register::_tc_InvalidObjectRef =
  &_tao_tc_CosTrading_Register_InvalidObjectRef;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Register::UnknownPropertyName::UnknownPropertyName (
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/UnknownPropertyName:1.0",
        "UnknownPropertyName"
      )
{
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Register::UnknownPropertyName::UnknownPropertyName (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/UnknownPropertyName:1.0",
        "UnknownPropertyName"
      )
{
}

CosTrading::Register::UnknownPropertyName::~UnknownPropertyName (void)
{
}

CosTrading::Register::UnknownPropertyName::UnknownPropertyName (const ::CosTrading::Register::UnknownPropertyName &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTrading::Register::UnknownPropertyName&
CosTrading::Register::UnknownPropertyName::operator= (const ::CosTrading::Register::UnknownPropertyName &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTrading::Register::UnknownPropertyName::_tao_any_destructor (void *_tao_void_pointer)
{
  UnknownPropertyName *_tao_tmp_pointer =
    static_cast<UnknownPropertyName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Register::UnknownPropertyName *
CosTrading::Register::UnknownPropertyName::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UnknownPropertyName *> (_tao_excp);
}

const CosTrading::Register::UnknownPropertyName *
CosTrading::Register::UnknownPropertyName::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UnknownPropertyName *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Register::UnknownPropertyName::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Register::UnknownPropertyName, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Register::UnknownPropertyName::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Register::UnknownPropertyName (*this),
      0
    );
  return result;
}

void CosTrading::Register::UnknownPropertyName::_raise (void) const
{
  throw *this;
}

void CosTrading::Register::UnknownPropertyName::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Register::UnknownPropertyName::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Register::UnknownPropertyName::_tao_type (void) const
{
  return ::CosTrading::Register::_tc_UnknownPropertyName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Register_UnknownPropertyName[] =
      {
        { "name", &CosTrading::_tc_PropertyName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Register_UnknownPropertyName (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Register/UnknownPropertyName:1.0",
  "UnknownPropertyName",
  _tao_fields_CosTrading_Register_UnknownPropertyName,
  1);

::CORBA::TypeCode_ptr const CosTrading::Register::_tc_UnknownPropertyName =
  &_tao_tc_CosTrading_Register_UnknownPropertyName;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Register::InterfaceTypeMismatch::InterfaceTypeMismatch (
    const char * _tao_type,
    const ::CORBA::Object_ptr  _tao_reference)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/InterfaceTypeMismatch:1.0",
        "InterfaceTypeMismatch"
      )
{
  this->type = ::CORBA::string_dup (_tao_type);
  this->reference = CORBA::Object::_duplicate (_tao_reference);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Register::InterfaceTypeMismatch::InterfaceTypeMismatch (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/InterfaceTypeMismatch:1.0",
        "InterfaceTypeMismatch"
      )
{
}

CosTrading::Register::InterfaceTypeMismatch::~InterfaceTypeMismatch (void)
{
}

CosTrading::Register::InterfaceTypeMismatch::InterfaceTypeMismatch (const ::CosTrading::Register::InterfaceTypeMismatch &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
  this->reference = CORBA::Object::_duplicate (_tao_excp.reference.in ());
}

CosTrading::Register::InterfaceTypeMismatch&
CosTrading::Register::InterfaceTypeMismatch::operator= (const ::CosTrading::Register::InterfaceTypeMismatch &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
  this->reference = CORBA::Object::_duplicate (_tao_excp.reference.in ());
  return *this;
}

void CosTrading::Register::InterfaceTypeMismatch::_tao_any_destructor (void *_tao_void_pointer)
{
  InterfaceTypeMismatch *_tao_tmp_pointer =
    static_cast<InterfaceTypeMismatch *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Register::InterfaceTypeMismatch *
CosTrading::Register::InterfaceTypeMismatch::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InterfaceTypeMismatch *> (_tao_excp);
}

const CosTrading::Register::InterfaceTypeMismatch *
CosTrading::Register::InterfaceTypeMismatch::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InterfaceTypeMismatch *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Register::InterfaceTypeMismatch::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Register::InterfaceTypeMismatch, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Register::InterfaceTypeMismatch::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Register::InterfaceTypeMismatch (*this),
      0
    );
  return result;
}

void CosTrading::Register::InterfaceTypeMismatch::_raise (void) const
{
  throw *this;
}

void CosTrading::Register::InterfaceTypeMismatch::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Register::InterfaceTypeMismatch::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Register::InterfaceTypeMismatch::_tao_type (void) const
{
  return ::CosTrading::Register::_tc_InterfaceTypeMismatch;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Register_InterfaceTypeMismatch[] =
      {
        { "type", &CosTrading::_tc_ServiceTypeName },
        { "reference", &CORBA::_tc_Object }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Register_InterfaceTypeMismatch (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Register/InterfaceTypeMismatch:1.0",
  "InterfaceTypeMismatch",
  _tao_fields_CosTrading_Register_InterfaceTypeMismatch,
  2);

::CORBA::TypeCode_ptr const CosTrading::Register::_tc_InterfaceTypeMismatch =
  &_tao_tc_CosTrading_Register_InterfaceTypeMismatch;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Register::ProxyOfferId::ProxyOfferId (
    const char * _tao_id)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/ProxyOfferId:1.0",
        "ProxyOfferId"
      )
{
  this->id = ::CORBA::string_dup (_tao_id);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Register::ProxyOfferId::ProxyOfferId (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/ProxyOfferId:1.0",
        "ProxyOfferId"
      )
{
}

CosTrading::Register::ProxyOfferId::~ProxyOfferId (void)
{
}

CosTrading::Register::ProxyOfferId::ProxyOfferId (const ::CosTrading::Register::ProxyOfferId &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->id = ::CORBA::string_dup (_tao_excp.id.in ());
}

CosTrading::Register::ProxyOfferId&
CosTrading::Register::ProxyOfferId::operator= (const ::CosTrading::Register::ProxyOfferId &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->id = ::CORBA::string_dup (_tao_excp.id.in ());
  return *this;
}

void CosTrading::Register::ProxyOfferId::_tao_any_destructor (void *_tao_void_pointer)
{
  ProxyOfferId *_tao_tmp_pointer =
    static_cast<ProxyOfferId *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Register::ProxyOfferId *
CosTrading::Register::ProxyOfferId::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ProxyOfferId *> (_tao_excp);
}

const CosTrading::Register::ProxyOfferId *
CosTrading::Register::ProxyOfferId::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ProxyOfferId *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Register::ProxyOfferId::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Register::ProxyOfferId, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Register::ProxyOfferId::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Register::ProxyOfferId (*this),
      0
    );
  return result;
}

void CosTrading::Register::ProxyOfferId::_raise (void) const
{
  throw *this;
}

void CosTrading::Register::ProxyOfferId::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Register::ProxyOfferId::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Register::ProxyOfferId::_tao_type (void) const
{
  return ::CosTrading::Register::_tc_ProxyOfferId;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Register_ProxyOfferId[] =
      {
        { "id", &CosTrading::_tc_OfferId }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Register_ProxyOfferId (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Register/ProxyOfferId:1.0",
  "ProxyOfferId",
  _tao_fields_CosTrading_Register_ProxyOfferId,
  1);

::CORBA::TypeCode_ptr const CosTrading::Register::_tc_ProxyOfferId =
  &_tao_tc_CosTrading_Register_ProxyOfferId;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Register::MandatoryProperty::MandatoryProperty (
    const char * _tao_type,
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/MandatoryProperty:1.0",
        "MandatoryProperty"
      )
{
  this->type = ::CORBA::string_dup (_tao_type);
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Register::MandatoryProperty::MandatoryProperty (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/MandatoryProperty:1.0",
        "MandatoryProperty"
      )
{
}

CosTrading::Register::MandatoryProperty::~MandatoryProperty (void)
{
}

CosTrading::Register::MandatoryProperty::MandatoryProperty (const ::CosTrading::Register::MandatoryProperty &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTrading::Register::MandatoryProperty&
CosTrading::Register::MandatoryProperty::operator= (const ::CosTrading::Register::MandatoryProperty &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTrading::Register::MandatoryProperty::_tao_any_destructor (void *_tao_void_pointer)
{
  MandatoryProperty *_tao_tmp_pointer =
    static_cast<MandatoryProperty *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Register::MandatoryProperty *
CosTrading::Register::MandatoryProperty::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<MandatoryProperty *> (_tao_excp);
}

const CosTrading::Register::MandatoryProperty *
CosTrading::Register::MandatoryProperty::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const MandatoryProperty *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Register::MandatoryProperty::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Register::MandatoryProperty, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Register::MandatoryProperty::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Register::MandatoryProperty (*this),
      0
    );
  return result;
}

void CosTrading::Register::MandatoryProperty::_raise (void) const
{
  throw *this;
}

void CosTrading::Register::MandatoryProperty::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Register::MandatoryProperty::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Register::MandatoryProperty::_tao_type (void) const
{
  return ::CosTrading::Register::_tc_MandatoryProperty;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Register_MandatoryProperty[] =
      {
        { "type", &CosTrading::_tc_ServiceTypeName },
        { "name", &CosTrading::_tc_PropertyName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Register_MandatoryProperty (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Register/MandatoryProperty:1.0",
  "MandatoryProperty",
  _tao_fields_CosTrading_Register_MandatoryProperty,
  2);

::CORBA::TypeCode_ptr const CosTrading::Register::_tc_MandatoryProperty =
  &_tao_tc_CosTrading_Register_MandatoryProperty;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Register::ReadonlyProperty::ReadonlyProperty (
    const char * _tao_type,
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/ReadonlyProperty:1.0",
        "ReadonlyProperty"
      )
{
  this->type = ::CORBA::string_dup (_tao_type);
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Register::ReadonlyProperty::ReadonlyProperty (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/ReadonlyProperty:1.0",
        "ReadonlyProperty"
      )
{
}

CosTrading::Register::ReadonlyProperty::~ReadonlyProperty (void)
{
}

CosTrading::Register::ReadonlyProperty::ReadonlyProperty (const ::CosTrading::Register::ReadonlyProperty &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTrading::Register::ReadonlyProperty&
CosTrading::Register::ReadonlyProperty::operator= (const ::CosTrading::Register::ReadonlyProperty &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->type = ::CORBA::string_dup (_tao_excp.type.in ());
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTrading::Register::ReadonlyProperty::_tao_any_destructor (void *_tao_void_pointer)
{
  ReadonlyProperty *_tao_tmp_pointer =
    static_cast<ReadonlyProperty *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Register::ReadonlyProperty *
CosTrading::Register::ReadonlyProperty::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ReadonlyProperty *> (_tao_excp);
}

const CosTrading::Register::ReadonlyProperty *
CosTrading::Register::ReadonlyProperty::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ReadonlyProperty *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Register::ReadonlyProperty::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Register::ReadonlyProperty, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Register::ReadonlyProperty::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Register::ReadonlyProperty (*this),
      0
    );
  return result;
}

void CosTrading::Register::ReadonlyProperty::_raise (void) const
{
  throw *this;
}

void CosTrading::Register::ReadonlyProperty::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Register::ReadonlyProperty::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Register::ReadonlyProperty::_tao_type (void) const
{
  return ::CosTrading::Register::_tc_ReadonlyProperty;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Register_ReadonlyProperty[] =
      {
        { "type", &CosTrading::_tc_ServiceTypeName },
        { "name", &CosTrading::_tc_PropertyName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Register_ReadonlyProperty (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Register/ReadonlyProperty:1.0",
  "ReadonlyProperty",
  _tao_fields_CosTrading_Register_ReadonlyProperty,
  2);

::CORBA::TypeCode_ptr const CosTrading::Register::_tc_ReadonlyProperty =
  &_tao_tc_CosTrading_Register_ReadonlyProperty;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Register::NoMatchingOffers::NoMatchingOffers (
    const char * _tao_constr)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/NoMatchingOffers:1.0",
        "NoMatchingOffers"
      )
{
  this->constr = ::CORBA::string_dup (_tao_constr);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Register::NoMatchingOffers::NoMatchingOffers (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/NoMatchingOffers:1.0",
        "NoMatchingOffers"
      )
{
}

CosTrading::Register::NoMatchingOffers::~NoMatchingOffers (void)
{
}

CosTrading::Register::NoMatchingOffers::NoMatchingOffers (const ::CosTrading::Register::NoMatchingOffers &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->constr = ::CORBA::string_dup (_tao_excp.constr.in ());
}

CosTrading::Register::NoMatchingOffers&
CosTrading::Register::NoMatchingOffers::operator= (const ::CosTrading::Register::NoMatchingOffers &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->constr = ::CORBA::string_dup (_tao_excp.constr.in ());
  return *this;
}

void CosTrading::Register::NoMatchingOffers::_tao_any_destructor (void *_tao_void_pointer)
{
  NoMatchingOffers *_tao_tmp_pointer =
    static_cast<NoMatchingOffers *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Register::NoMatchingOffers *
CosTrading::Register::NoMatchingOffers::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NoMatchingOffers *> (_tao_excp);
}

const CosTrading::Register::NoMatchingOffers *
CosTrading::Register::NoMatchingOffers::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NoMatchingOffers *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Register::NoMatchingOffers::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Register::NoMatchingOffers, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Register::NoMatchingOffers::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Register::NoMatchingOffers (*this),
      0
    );
  return result;
}

void CosTrading::Register::NoMatchingOffers::_raise (void) const
{
  throw *this;
}

void CosTrading::Register::NoMatchingOffers::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Register::NoMatchingOffers::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Register::NoMatchingOffers::_tao_type (void) const
{
  return ::CosTrading::Register::_tc_NoMatchingOffers;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Register_NoMatchingOffers[] =
      {
        { "constr", &CosTrading::_tc_Constraint }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Register_NoMatchingOffers (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Register/NoMatchingOffers:1.0",
  "NoMatchingOffers",
  _tao_fields_CosTrading_Register_NoMatchingOffers,
  1);

::CORBA::TypeCode_ptr const CosTrading::Register::_tc_NoMatchingOffers =
  &_tao_tc_CosTrading_Register_NoMatchingOffers;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Register::IllegalTraderName::IllegalTraderName (
    const CosTrading::TraderName & _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/IllegalTraderName:1.0",
        "IllegalTraderName"
      )
{
  this->name = _tao_name;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Register::IllegalTraderName::IllegalTraderName (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/IllegalTraderName:1.0",
        "IllegalTraderName"
      )
{
}

CosTrading::Register::IllegalTraderName::~IllegalTraderName (void)
{
}

CosTrading::Register::IllegalTraderName::IllegalTraderName (const ::CosTrading::Register::IllegalTraderName &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = _tao_excp.name;
}

CosTrading::Register::IllegalTraderName&
CosTrading::Register::IllegalTraderName::operator= (const ::CosTrading::Register::IllegalTraderName &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = _tao_excp.name;
  return *this;
}

void CosTrading::Register::IllegalTraderName::_tao_any_destructor (void *_tao_void_pointer)
{
  IllegalTraderName *_tao_tmp_pointer =
    static_cast<IllegalTraderName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Register::IllegalTraderName *
CosTrading::Register::IllegalTraderName::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<IllegalTraderName *> (_tao_excp);
}

const CosTrading::Register::IllegalTraderName *
CosTrading::Register::IllegalTraderName::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const IllegalTraderName *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Register::IllegalTraderName::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Register::IllegalTraderName, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Register::IllegalTraderName::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Register::IllegalTraderName (*this),
      0
    );
  return result;
}

void CosTrading::Register::IllegalTraderName::_raise (void) const
{
  throw *this;
}

void CosTrading::Register::IllegalTraderName::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Register::IllegalTraderName::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Register::IllegalTraderName::_tao_type (void) const
{
  return ::CosTrading::Register::_tc_IllegalTraderName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Register_IllegalTraderName[] =
      {
        { "name", &CosTrading::_tc_TraderName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Register_IllegalTraderName (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Register/IllegalTraderName:1.0",
  "IllegalTraderName",
  _tao_fields_CosTrading_Register_IllegalTraderName,
  1);

::CORBA::TypeCode_ptr const CosTrading::Register::_tc_IllegalTraderName =
  &_tao_tc_CosTrading_Register_IllegalTraderName;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Register::UnknownTraderName::UnknownTraderName (
    const CosTrading::TraderName & _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/UnknownTraderName:1.0",
        "UnknownTraderName"
      )
{
  this->name = _tao_name;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Register::UnknownTraderName::UnknownTraderName (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/UnknownTraderName:1.0",
        "UnknownTraderName"
      )
{
}

CosTrading::Register::UnknownTraderName::~UnknownTraderName (void)
{
}

CosTrading::Register::UnknownTraderName::UnknownTraderName (const ::CosTrading::Register::UnknownTraderName &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = _tao_excp.name;
}

CosTrading::Register::UnknownTraderName&
CosTrading::Register::UnknownTraderName::operator= (const ::CosTrading::Register::UnknownTraderName &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = _tao_excp.name;
  return *this;
}

void CosTrading::Register::UnknownTraderName::_tao_any_destructor (void *_tao_void_pointer)
{
  UnknownTraderName *_tao_tmp_pointer =
    static_cast<UnknownTraderName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Register::UnknownTraderName *
CosTrading::Register::UnknownTraderName::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UnknownTraderName *> (_tao_excp);
}

const CosTrading::Register::UnknownTraderName *
CosTrading::Register::UnknownTraderName::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UnknownTraderName *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Register::UnknownTraderName::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Register::UnknownTraderName, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Register::UnknownTraderName::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Register::UnknownTraderName (*this),
      0
    );
  return result;
}

void CosTrading::Register::UnknownTraderName::_raise (void) const
{
  throw *this;
}

void CosTrading::Register::UnknownTraderName::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Register::UnknownTraderName::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Register::UnknownTraderName::_tao_type (void) const
{
  return ::CosTrading::Register::_tc_UnknownTraderName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Register_UnknownTraderName[] =
      {
        { "name", &CosTrading::_tc_TraderName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Register_UnknownTraderName (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Register/UnknownTraderName:1.0",
  "UnknownTraderName",
  _tao_fields_CosTrading_Register_UnknownTraderName,
  1);

::CORBA::TypeCode_ptr const CosTrading::Register::_tc_UnknownTraderName =
  &_tao_tc_CosTrading_Register_UnknownTraderName;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Register::RegisterNotSupported::RegisterNotSupported (
    const CosTrading::TraderName & _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/RegisterNotSupported:1.0",
        "RegisterNotSupported"
      )
{
  this->name = _tao_name;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Register::RegisterNotSupported::RegisterNotSupported (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Register/RegisterNotSupported:1.0",
        "RegisterNotSupported"
      )
{
}

CosTrading::Register::RegisterNotSupported::~RegisterNotSupported (void)
{
}

CosTrading::Register::RegisterNotSupported::RegisterNotSupported (const ::CosTrading::Register::RegisterNotSupported &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = _tao_excp.name;
}

CosTrading::Register::RegisterNotSupported&
CosTrading::Register::RegisterNotSupported::operator= (const ::CosTrading::Register::RegisterNotSupported &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = _tao_excp.name;
  return *this;
}

void CosTrading::Register::RegisterNotSupported::_tao_any_destructor (void *_tao_void_pointer)
{
  RegisterNotSupported *_tao_tmp_pointer =
    static_cast<RegisterNotSupported *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Register::RegisterNotSupported *
CosTrading::Register::RegisterNotSupported::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<RegisterNotSupported *> (_tao_excp);
}

const CosTrading::Register::RegisterNotSupported *
CosTrading::Register::RegisterNotSupported::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const RegisterNotSupported *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Register::RegisterNotSupported::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Register::RegisterNotSupported, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Register::RegisterNotSupported::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Register::RegisterNotSupported (*this),
      0
    );
  return result;
}

void CosTrading::Register::RegisterNotSupported::_raise (void) const
{
  throw *this;
}

void CosTrading::Register::RegisterNotSupported::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Register::RegisterNotSupported::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Register::RegisterNotSupported::_tao_type (void) const
{
  return ::CosTrading::Register::_tc_RegisterNotSupported;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Register_RegisterNotSupported[] =
      {
        { "name", &CosTrading::_tc_TraderName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Register_RegisterNotSupported (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Register/RegisterNotSupported:1.0",
  "RegisterNotSupported",
  _tao_fields_CosTrading_Register_RegisterNotSupported,
  1);

::CORBA::TypeCode_ptr const CosTrading::Register::_tc_RegisterNotSupported =
  &_tao_tc_CosTrading_Register_RegisterNotSupported;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CosTrading::Register::_cxx_export (
  ::CORBA::Object_ptr reference,
  const char * type,
  const ::CosTrading::PropertySeq & properties)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Register_Proxy_Broker_ == 0)
    {
      CosTrading_Register_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_reference (reference);
  TAO::Arg_Traits< char *>::in_arg_val _tao_type (type);
  TAO::Arg_Traits< ::CosTrading::PropertySeq>::in_arg_val _tao_properties (properties);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_reference,
      &_tao_type,
      &_tao_properties
    };

  static TAO::Exception_Data
  _tao_CosTrading_Register_export_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/Register/InvalidObjectRef:1.0",
        CosTrading::Register::InvalidObjectRef::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Register::_tc_InvalidObjectRef
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/IllegalServiceType:1.0",
        CosTrading::IllegalServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownServiceType:1.0",
        CosTrading::UnknownServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Register/InterfaceTypeMismatch:1.0",
        CosTrading::Register::InterfaceTypeMismatch::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Register::_tc_InterfaceTypeMismatch
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/IllegalPropertyName:1.0",
        CosTrading::IllegalPropertyName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalPropertyName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/PropertyTypeMismatch:1.0",
        CosTrading::PropertyTypeMismatch::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_PropertyTypeMismatch
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/ReadonlyDynamicProperty:1.0",
        CosTrading::ReadonlyDynamicProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_ReadonlyDynamicProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/MissingMandatoryProperty:1.0",
        CosTrading::MissingMandatoryProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_MissingMandatoryProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/DuplicatePropertyName:1.0",
        CosTrading::DuplicatePropertyName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_DuplicatePropertyName
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "export",
      6,
      this->the_TAO_Register_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Register_export_exceptiondata,
      9
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTrading::Register::withdraw (
  const char * id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Register_Proxy_Broker_ == 0)
    {
      CosTrading_Register_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_id (id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_id
    };

  static TAO::Exception_Data
  _tao_CosTrading_Register_withdraw_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/IllegalOfferId:1.0",
        CosTrading::IllegalOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownOfferId:1.0",
        CosTrading::UnknownOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Register/ProxyOfferId:1.0",
        CosTrading::Register::ProxyOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Register::_tc_ProxyOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "withdraw",
      8,
      this->the_TAO_Register_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Register_withdraw_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::Register::OfferInfo *
CosTrading::Register::describe (
  const char * id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Register_Proxy_Broker_ == 0)
    {
      CosTrading_Register_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::Register::OfferInfo>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_id (id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_id
    };

  static TAO::Exception_Data
  _tao_CosTrading_Register_describe_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/IllegalOfferId:1.0",
        CosTrading::IllegalOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownOfferId:1.0",
        CosTrading::UnknownOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Register/ProxyOfferId:1.0",
        CosTrading::Register::ProxyOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Register::_tc_ProxyOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "describe",
      8,
      this->the_TAO_Register_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Register_describe_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTrading::Register::modify (
  const char * id,
  const ::CosTrading::PropertyNameSeq & del_list,
  const ::CosTrading::PropertySeq & modify_list)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Register_Proxy_Broker_ == 0)
    {
      CosTrading_Register_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_id (id);
  TAO::Arg_Traits< ::CosTrading::PropertyNameSeq>::in_arg_val _tao_del_list (del_list);
  TAO::Arg_Traits< ::CosTrading::PropertySeq>::in_arg_val _tao_modify_list (modify_list);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_id,
      &_tao_del_list,
      &_tao_modify_list
    };

  static TAO::Exception_Data
  _tao_CosTrading_Register_modify_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/NotImplemented:1.0",
        CosTrading::NotImplemented::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_NotImplemented
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/IllegalOfferId:1.0",
        CosTrading::IllegalOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownOfferId:1.0",
        CosTrading::UnknownOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Register/ProxyOfferId:1.0",
        CosTrading::Register::ProxyOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Register::_tc_ProxyOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/IllegalPropertyName:1.0",
        CosTrading::IllegalPropertyName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalPropertyName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Register/UnknownPropertyName:1.0",
        CosTrading::Register::UnknownPropertyName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Register::_tc_UnknownPropertyName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/PropertyTypeMismatch:1.0",
        CosTrading::PropertyTypeMismatch::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_PropertyTypeMismatch
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/ReadonlyDynamicProperty:1.0",
        CosTrading::ReadonlyDynamicProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_ReadonlyDynamicProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Register/MandatoryProperty:1.0",
        CosTrading::Register::MandatoryProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Register::_tc_MandatoryProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Register/ReadonlyProperty:1.0",
        CosTrading::Register::ReadonlyProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Register::_tc_ReadonlyProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/DuplicatePropertyName:1.0",
        CosTrading::DuplicatePropertyName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_DuplicatePropertyName
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "modify",
      6,
      this->the_TAO_Register_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Register_modify_exceptiondata,
      11
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTrading::Register::withdraw_using_constraint (
  const char * type,
  const char * constr)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Register_Proxy_Broker_ == 0)
    {
      CosTrading_Register_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_type (type);
  TAO::Arg_Traits< char *>::in_arg_val _tao_constr (constr);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_type,
      &_tao_constr
    };

  static TAO::Exception_Data
  _tao_CosTrading_Register_withdraw_using_constraint_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/IllegalServiceType:1.0",
        CosTrading::IllegalServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownServiceType:1.0",
        CosTrading::UnknownServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/IllegalConstraint:1.0",
        CosTrading::IllegalConstraint::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalConstraint
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Register/NoMatchingOffers:1.0",
        CosTrading::Register::NoMatchingOffers::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Register::_tc_NoMatchingOffers
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "withdraw_using_constraint",
      25,
      this->the_TAO_Register_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Register_withdraw_using_constraint_exceptiondata,
      4
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::Register_ptr
CosTrading::Register::resolve (
  const ::CosTrading::TraderName & name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Register_Proxy_Broker_ == 0)
    {
      CosTrading_Register_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::Register>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosTrading::TraderName>::in_arg_val _tao_name (name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_name
    };

  static TAO::Exception_Data
  _tao_CosTrading_Register_resolve_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/Register/IllegalTraderName:1.0",
        CosTrading::Register::IllegalTraderName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Register::_tc_IllegalTraderName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Register/UnknownTraderName:1.0",
        CosTrading::Register::UnknownTraderName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Register::_tc_UnknownTraderName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Register/RegisterNotSupported:1.0",
        CosTrading::Register::RegisterNotSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Register::_tc_RegisterNotSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "resolve",
      7,
      this->the_TAO_Register_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Register_resolve_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

CosTrading::Register::Register (void)
 : the_TAO_Register_Proxy_Broker_ (0)
{
  this->CosTrading_Register_setup_collocation ();
}

void
CosTrading::Register::CosTrading_Register_setup_collocation ()
{
  if (::CosTrading__TAO_Register_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Register_Proxy_Broker_ =
        ::CosTrading__TAO_Register_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CosTrading_TraderComponents_setup_collocation ();
  this->CosTrading_SupportAttributes_setup_collocation ();
}

CosTrading::Register::~Register (void)
{}

void 
CosTrading::Register::_tao_any_destructor (void *_tao_void_pointer)
{
  Register *_tao_tmp_pointer =
    static_cast<Register *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosTrading::Register_ptr
CosTrading::Register::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Register>::narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/Register:1.0",
        CosTrading__TAO_Register_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::Register_ptr
CosTrading::Register::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Register>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/Register:1.0",
        CosTrading__TAO_Register_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::Register_ptr
CosTrading::Register::_nil (void)
{
  return 0;
}

CosTrading::Register_ptr
CosTrading::Register::_duplicate (Register_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosTrading::Register::_tao_release (Register_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosTrading::Register::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/TraderComponents:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/SupportAttributes:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/Register:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosTrading::Register::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosTrading/Register:1.0";
}

::CORBA::Boolean
CosTrading::Register::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_Register (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosTrading/Register:1.0",
    "Register");
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_Register =
    &_tao_tc_CosTrading_Register;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosTrading::Link.

CosTrading::Link_ptr
TAO::Objref_Traits<CosTrading::Link>::duplicate (
    CosTrading::Link_ptr p)
{
  return CosTrading::Link::_duplicate (p);
}

void
TAO::Objref_Traits<CosTrading::Link>::release (
    CosTrading::Link_ptr p)
{
  ::CORBA::release (p);
}

CosTrading::Link_ptr
TAO::Objref_Traits<CosTrading::Link>::nil (void)
{
  return CosTrading::Link::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosTrading::Link>::marshal (
    const CosTrading::Link_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosTrading__TAO_Link_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Link_LinkInfo[] =
      {
        { "target", &CosTrading::_tc_Lookup },
        { "target_reg", &CosTrading::_tc_Register },
        { "def_pass_on_follow_rule", &CosTrading::_tc_FollowOption },
        { "limiting_follow_rule", &CosTrading::_tc_FollowOption }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Link_LinkInfo (
  ::CORBA::tk_struct,
  "IDL:omg.org/CosTrading/Link/LinkInfo:1.0",
  "LinkInfo",
  _tao_fields_CosTrading_Link_LinkInfo,
  4);

::CORBA::TypeCode_ptr const CosTrading::Link::_tc_LinkInfo =
  &_tao_tc_CosTrading_Link_LinkInfo;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosTrading::Link::LinkInfo::_tao_any_destructor (
    void *_tao_void_pointer)
{
  LinkInfo *_tao_tmp_pointer =
    static_cast<LinkInfo *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Link::IllegalLinkName::IllegalLinkName (
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Link/IllegalLinkName:1.0",
        "IllegalLinkName"
      )
{
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Link::IllegalLinkName::IllegalLinkName (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Link/IllegalLinkName:1.0",
        "IllegalLinkName"
      )
{
}

CosTrading::Link::IllegalLinkName::~IllegalLinkName (void)
{
}

CosTrading::Link::IllegalLinkName::IllegalLinkName (const ::CosTrading::Link::IllegalLinkName &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTrading::Link::IllegalLinkName&
CosTrading::Link::IllegalLinkName::operator= (const ::CosTrading::Link::IllegalLinkName &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTrading::Link::IllegalLinkName::_tao_any_destructor (void *_tao_void_pointer)
{
  IllegalLinkName *_tao_tmp_pointer =
    static_cast<IllegalLinkName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Link::IllegalLinkName *
CosTrading::Link::IllegalLinkName::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<IllegalLinkName *> (_tao_excp);
}

const CosTrading::Link::IllegalLinkName *
CosTrading::Link::IllegalLinkName::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const IllegalLinkName *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Link::IllegalLinkName::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Link::IllegalLinkName, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Link::IllegalLinkName::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Link::IllegalLinkName (*this),
      0
    );
  return result;
}

void CosTrading::Link::IllegalLinkName::_raise (void) const
{
  throw *this;
}

void CosTrading::Link::IllegalLinkName::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Link::IllegalLinkName::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Link::IllegalLinkName::_tao_type (void) const
{
  return ::CosTrading::Link::_tc_IllegalLinkName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Link_IllegalLinkName[] =
      {
        { "name", &CosTrading::_tc_LinkName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Link_IllegalLinkName (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Link/IllegalLinkName:1.0",
  "IllegalLinkName",
  _tao_fields_CosTrading_Link_IllegalLinkName,
  1);

::CORBA::TypeCode_ptr const CosTrading::Link::_tc_IllegalLinkName =
  &_tao_tc_CosTrading_Link_IllegalLinkName;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Link::UnknownLinkName::UnknownLinkName (
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Link/UnknownLinkName:1.0",
        "UnknownLinkName"
      )
{
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Link::UnknownLinkName::UnknownLinkName (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Link/UnknownLinkName:1.0",
        "UnknownLinkName"
      )
{
}

CosTrading::Link::UnknownLinkName::~UnknownLinkName (void)
{
}

CosTrading::Link::UnknownLinkName::UnknownLinkName (const ::CosTrading::Link::UnknownLinkName &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTrading::Link::UnknownLinkName&
CosTrading::Link::UnknownLinkName::operator= (const ::CosTrading::Link::UnknownLinkName &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTrading::Link::UnknownLinkName::_tao_any_destructor (void *_tao_void_pointer)
{
  UnknownLinkName *_tao_tmp_pointer =
    static_cast<UnknownLinkName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Link::UnknownLinkName *
CosTrading::Link::UnknownLinkName::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UnknownLinkName *> (_tao_excp);
}

const CosTrading::Link::UnknownLinkName *
CosTrading::Link::UnknownLinkName::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UnknownLinkName *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Link::UnknownLinkName::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Link::UnknownLinkName, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Link::UnknownLinkName::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Link::UnknownLinkName (*this),
      0
    );
  return result;
}

void CosTrading::Link::UnknownLinkName::_raise (void) const
{
  throw *this;
}

void CosTrading::Link::UnknownLinkName::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Link::UnknownLinkName::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Link::UnknownLinkName::_tao_type (void) const
{
  return ::CosTrading::Link::_tc_UnknownLinkName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Link_UnknownLinkName[] =
      {
        { "name", &CosTrading::_tc_LinkName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Link_UnknownLinkName (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Link/UnknownLinkName:1.0",
  "UnknownLinkName",
  _tao_fields_CosTrading_Link_UnknownLinkName,
  1);

::CORBA::TypeCode_ptr const CosTrading::Link::_tc_UnknownLinkName =
  &_tao_tc_CosTrading_Link_UnknownLinkName;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Link::DuplicateLinkName::DuplicateLinkName (
    const char * _tao_name)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Link/DuplicateLinkName:1.0",
        "DuplicateLinkName"
      )
{
  this->name = ::CORBA::string_dup (_tao_name);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Link::DuplicateLinkName::DuplicateLinkName (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Link/DuplicateLinkName:1.0",
        "DuplicateLinkName"
      )
{
}

CosTrading::Link::DuplicateLinkName::~DuplicateLinkName (void)
{
}

CosTrading::Link::DuplicateLinkName::DuplicateLinkName (const ::CosTrading::Link::DuplicateLinkName &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
}

CosTrading::Link::DuplicateLinkName&
CosTrading::Link::DuplicateLinkName::operator= (const ::CosTrading::Link::DuplicateLinkName &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->name = ::CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void CosTrading::Link::DuplicateLinkName::_tao_any_destructor (void *_tao_void_pointer)
{
  DuplicateLinkName *_tao_tmp_pointer =
    static_cast<DuplicateLinkName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Link::DuplicateLinkName *
CosTrading::Link::DuplicateLinkName::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<DuplicateLinkName *> (_tao_excp);
}

const CosTrading::Link::DuplicateLinkName *
CosTrading::Link::DuplicateLinkName::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const DuplicateLinkName *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Link::DuplicateLinkName::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Link::DuplicateLinkName, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Link::DuplicateLinkName::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Link::DuplicateLinkName (*this),
      0
    );
  return result;
}

void CosTrading::Link::DuplicateLinkName::_raise (void) const
{
  throw *this;
}

void CosTrading::Link::DuplicateLinkName::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Link::DuplicateLinkName::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Link::DuplicateLinkName::_tao_type (void) const
{
  return ::CosTrading::Link::_tc_DuplicateLinkName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Link_DuplicateLinkName[] =
      {
        { "name", &CosTrading::_tc_LinkName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Link_DuplicateLinkName (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Link/DuplicateLinkName:1.0",
  "DuplicateLinkName",
  _tao_fields_CosTrading_Link_DuplicateLinkName,
  1);

::CORBA::TypeCode_ptr const CosTrading::Link::_tc_DuplicateLinkName =
  &_tao_tc_CosTrading_Link_DuplicateLinkName;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Link::DefaultFollowTooPermissive::DefaultFollowTooPermissive (
    CosTrading::FollowOption _tao_def_pass_on_follow_rule,
    CosTrading::FollowOption _tao_limiting_follow_rule)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Link/DefaultFollowTooPermissive:1.0",
        "DefaultFollowTooPermissive"
      )
{
  this->def_pass_on_follow_rule = _tao_def_pass_on_follow_rule;
  this->limiting_follow_rule = _tao_limiting_follow_rule;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Link::DefaultFollowTooPermissive::DefaultFollowTooPermissive (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Link/DefaultFollowTooPermissive:1.0",
        "DefaultFollowTooPermissive"
      )
{
}

CosTrading::Link::DefaultFollowTooPermissive::~DefaultFollowTooPermissive (void)
{
}

CosTrading::Link::DefaultFollowTooPermissive::DefaultFollowTooPermissive (const ::CosTrading::Link::DefaultFollowTooPermissive &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->def_pass_on_follow_rule = _tao_excp.def_pass_on_follow_rule;
  this->limiting_follow_rule = _tao_excp.limiting_follow_rule;
}

CosTrading::Link::DefaultFollowTooPermissive&
CosTrading::Link::DefaultFollowTooPermissive::operator= (const ::CosTrading::Link::DefaultFollowTooPermissive &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->def_pass_on_follow_rule = _tao_excp.def_pass_on_follow_rule;
  this->limiting_follow_rule = _tao_excp.limiting_follow_rule;
  return *this;
}

void CosTrading::Link::DefaultFollowTooPermissive::_tao_any_destructor (void *_tao_void_pointer)
{
  DefaultFollowTooPermissive *_tao_tmp_pointer =
    static_cast<DefaultFollowTooPermissive *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Link::DefaultFollowTooPermissive *
CosTrading::Link::DefaultFollowTooPermissive::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<DefaultFollowTooPermissive *> (_tao_excp);
}

const CosTrading::Link::DefaultFollowTooPermissive *
CosTrading::Link::DefaultFollowTooPermissive::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const DefaultFollowTooPermissive *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Link::DefaultFollowTooPermissive::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Link::DefaultFollowTooPermissive, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Link::DefaultFollowTooPermissive::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Link::DefaultFollowTooPermissive (*this),
      0
    );
  return result;
}

void CosTrading::Link::DefaultFollowTooPermissive::_raise (void) const
{
  throw *this;
}

void CosTrading::Link::DefaultFollowTooPermissive::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Link::DefaultFollowTooPermissive::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Link::DefaultFollowTooPermissive::_tao_type (void) const
{
  return ::CosTrading::Link::_tc_DefaultFollowTooPermissive;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Link_DefaultFollowTooPermissive[] =
      {
        { "def_pass_on_follow_rule", &CosTrading::_tc_FollowOption },
        { "limiting_follow_rule", &CosTrading::_tc_FollowOption }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Link_DefaultFollowTooPermissive (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Link/DefaultFollowTooPermissive:1.0",
  "DefaultFollowTooPermissive",
  _tao_fields_CosTrading_Link_DefaultFollowTooPermissive,
  2);

::CORBA::TypeCode_ptr const CosTrading::Link::_tc_DefaultFollowTooPermissive =
  &_tao_tc_CosTrading_Link_DefaultFollowTooPermissive;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Link::LimitingFollowTooPermissive::LimitingFollowTooPermissive (
    CosTrading::FollowOption _tao_limiting_follow_rule,
    CosTrading::FollowOption _tao_max_link_follow_policy)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Link/LimitingFollowTooPermissive:1.0",
        "LimitingFollowTooPermissive"
      )
{
  this->limiting_follow_rule = _tao_limiting_follow_rule;
  this->max_link_follow_policy = _tao_max_link_follow_policy;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Link::LimitingFollowTooPermissive::LimitingFollowTooPermissive (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Link/LimitingFollowTooPermissive:1.0",
        "LimitingFollowTooPermissive"
      )
{
}

CosTrading::Link::LimitingFollowTooPermissive::~LimitingFollowTooPermissive (void)
{
}

CosTrading::Link::LimitingFollowTooPermissive::LimitingFollowTooPermissive (const ::CosTrading::Link::LimitingFollowTooPermissive &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->limiting_follow_rule = _tao_excp.limiting_follow_rule;
  this->max_link_follow_policy = _tao_excp.max_link_follow_policy;
}

CosTrading::Link::LimitingFollowTooPermissive&
CosTrading::Link::LimitingFollowTooPermissive::operator= (const ::CosTrading::Link::LimitingFollowTooPermissive &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->limiting_follow_rule = _tao_excp.limiting_follow_rule;
  this->max_link_follow_policy = _tao_excp.max_link_follow_policy;
  return *this;
}

void CosTrading::Link::LimitingFollowTooPermissive::_tao_any_destructor (void *_tao_void_pointer)
{
  LimitingFollowTooPermissive *_tao_tmp_pointer =
    static_cast<LimitingFollowTooPermissive *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Link::LimitingFollowTooPermissive *
CosTrading::Link::LimitingFollowTooPermissive::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<LimitingFollowTooPermissive *> (_tao_excp);
}

const CosTrading::Link::LimitingFollowTooPermissive *
CosTrading::Link::LimitingFollowTooPermissive::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const LimitingFollowTooPermissive *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Link::LimitingFollowTooPermissive::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Link::LimitingFollowTooPermissive, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Link::LimitingFollowTooPermissive::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Link::LimitingFollowTooPermissive (*this),
      0
    );
  return result;
}

void CosTrading::Link::LimitingFollowTooPermissive::_raise (void) const
{
  throw *this;
}

void CosTrading::Link::LimitingFollowTooPermissive::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Link::LimitingFollowTooPermissive::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Link::LimitingFollowTooPermissive::_tao_type (void) const
{
  return ::CosTrading::Link::_tc_LimitingFollowTooPermissive;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Link_LimitingFollowTooPermissive[] =
      {
        { "limiting_follow_rule", &CosTrading::_tc_FollowOption },
        { "max_link_follow_policy", &CosTrading::_tc_FollowOption }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Link_LimitingFollowTooPermissive (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Link/LimitingFollowTooPermissive:1.0",
  "LimitingFollowTooPermissive",
  _tao_fields_CosTrading_Link_LimitingFollowTooPermissive,
  2);

::CORBA::TypeCode_ptr const CosTrading::Link::_tc_LimitingFollowTooPermissive =
  &_tao_tc_CosTrading_Link_LimitingFollowTooPermissive;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTrading::Link::add_link (
  const char * name,
  ::CosTrading::Lookup_ptr target,
  ::CosTrading::FollowOption def_pass_on_follow_rule,
  ::CosTrading::FollowOption limiting_follow_rule)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Link_Proxy_Broker_ == 0)
    {
      CosTrading_Link_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);
  TAO::Arg_Traits< ::CosTrading::Lookup>::in_arg_val _tao_target (target);
  TAO::Arg_Traits< ::CosTrading::FollowOption>::in_arg_val _tao_def_pass_on_follow_rule (def_pass_on_follow_rule);
  TAO::Arg_Traits< ::CosTrading::FollowOption>::in_arg_val _tao_limiting_follow_rule (limiting_follow_rule);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_name,
      &_tao_target,
      &_tao_def_pass_on_follow_rule,
      &_tao_limiting_follow_rule
    };

  static TAO::Exception_Data
  _tao_CosTrading_Link_add_link_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/Link/IllegalLinkName:1.0",
        CosTrading::Link::IllegalLinkName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Link::_tc_IllegalLinkName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Link/DuplicateLinkName:1.0",
        CosTrading::Link::DuplicateLinkName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Link::_tc_DuplicateLinkName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/InvalidLookupRef:1.0",
        CosTrading::InvalidLookupRef::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_InvalidLookupRef
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Link/DefaultFollowTooPermissive:1.0",
        CosTrading::Link::DefaultFollowTooPermissive::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Link::_tc_DefaultFollowTooPermissive
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Link/LimitingFollowTooPermissive:1.0",
        CosTrading::Link::LimitingFollowTooPermissive::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Link::_tc_LimitingFollowTooPermissive
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "add_link",
      8,
      this->the_TAO_Link_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Link_add_link_exceptiondata,
      5
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTrading::Link::remove_link (
  const char * name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Link_Proxy_Broker_ == 0)
    {
      CosTrading_Link_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_name
    };

  static TAO::Exception_Data
  _tao_CosTrading_Link_remove_link_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/Link/IllegalLinkName:1.0",
        CosTrading::Link::IllegalLinkName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Link::_tc_IllegalLinkName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Link/UnknownLinkName:1.0",
        CosTrading::Link::UnknownLinkName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Link::_tc_UnknownLinkName
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_link",
      11,
      this->the_TAO_Link_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Link_remove_link_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::Link::LinkInfo *
CosTrading::Link::describe_link (
  const char * name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Link_Proxy_Broker_ == 0)
    {
      CosTrading_Link_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::Link::LinkInfo>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_name
    };

  static TAO::Exception_Data
  _tao_CosTrading_Link_describe_link_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/Link/IllegalLinkName:1.0",
        CosTrading::Link::IllegalLinkName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Link::_tc_IllegalLinkName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Link/UnknownLinkName:1.0",
        CosTrading::Link::UnknownLinkName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Link::_tc_UnknownLinkName
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "describe_link",
      13,
      this->the_TAO_Link_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Link_describe_link_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::LinkNameSeq *
CosTrading::Link::list_links (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Link_Proxy_Broker_ == 0)
    {
      CosTrading_Link_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::LinkNameSeq>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "list_links",
      10,
      this->the_TAO_Link_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTrading::Link::modify_link (
  const char * name,
  ::CosTrading::FollowOption def_pass_on_follow_rule,
  ::CosTrading::FollowOption limiting_follow_rule)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Link_Proxy_Broker_ == 0)
    {
      CosTrading_Link_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_name (name);
  TAO::Arg_Traits< ::CosTrading::FollowOption>::in_arg_val _tao_def_pass_on_follow_rule (def_pass_on_follow_rule);
  TAO::Arg_Traits< ::CosTrading::FollowOption>::in_arg_val _tao_limiting_follow_rule (limiting_follow_rule);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_name,
      &_tao_def_pass_on_follow_rule,
      &_tao_limiting_follow_rule
    };

  static TAO::Exception_Data
  _tao_CosTrading_Link_modify_link_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/Link/IllegalLinkName:1.0",
        CosTrading::Link::IllegalLinkName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Link::_tc_IllegalLinkName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Link/UnknownLinkName:1.0",
        CosTrading::Link::UnknownLinkName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Link::_tc_UnknownLinkName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Link/DefaultFollowTooPermissive:1.0",
        CosTrading::Link::DefaultFollowTooPermissive::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Link::_tc_DefaultFollowTooPermissive
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Link/LimitingFollowTooPermissive:1.0",
        CosTrading::Link::LimitingFollowTooPermissive::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Link::_tc_LimitingFollowTooPermissive
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "modify_link",
      11,
      this->the_TAO_Link_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Link_modify_link_exceptiondata,
      4
    );
}

CosTrading::Link::Link (void)
 : the_TAO_Link_Proxy_Broker_ (0)
{
  this->CosTrading_Link_setup_collocation ();
}

void
CosTrading::Link::CosTrading_Link_setup_collocation ()
{
  if (::CosTrading__TAO_Link_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Link_Proxy_Broker_ =
        ::CosTrading__TAO_Link_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CosTrading_TraderComponents_setup_collocation ();
  this->CosTrading_SupportAttributes_setup_collocation ();
  this->CosTrading_LinkAttributes_setup_collocation ();
}

CosTrading::Link::~Link (void)
{}

void 
CosTrading::Link::_tao_any_destructor (void *_tao_void_pointer)
{
  Link *_tao_tmp_pointer =
    static_cast<Link *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosTrading::Link_ptr
CosTrading::Link::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Link>::narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/Link:1.0",
        CosTrading__TAO_Link_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::Link_ptr
CosTrading::Link::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Link>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/Link:1.0",
        CosTrading__TAO_Link_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::Link_ptr
CosTrading::Link::_nil (void)
{
  return 0;
}

CosTrading::Link_ptr
CosTrading::Link::_duplicate (Link_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosTrading::Link::_tao_release (Link_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosTrading::Link::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/TraderComponents:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/SupportAttributes:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/LinkAttributes:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/Link:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosTrading::Link::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosTrading/Link:1.0";
}

::CORBA::Boolean
CosTrading::Link::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_Link (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosTrading/Link:1.0",
    "Link");
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_Link =
    &_tao_tc_CosTrading_Link;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosTrading::Proxy.

CosTrading::Proxy_ptr
TAO::Objref_Traits<CosTrading::Proxy>::duplicate (
    CosTrading::Proxy_ptr p)
{
  return CosTrading::Proxy::_duplicate (p);
}

void
TAO::Objref_Traits<CosTrading::Proxy>::release (
    CosTrading::Proxy_ptr p)
{
  ::CORBA::release (p);
}

CosTrading::Proxy_ptr
TAO::Objref_Traits<CosTrading::Proxy>::nil (void)
{
  return CosTrading::Proxy::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosTrading::Proxy>::marshal (
    const CosTrading::Proxy_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosTrading__TAO_Proxy_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_Proxy_ConstraintRecipe (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/Proxy/ConstraintRecipe:1.0",
    "ConstraintRecipe",
    &CosTrading::_tc_Istring);
  
::CORBA::TypeCode_ptr const CosTrading::Proxy::_tc_ConstraintRecipe =
  &_tao_tc_CosTrading_Proxy_ConstraintRecipe;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Proxy_ProxyInfo[] =
      {
        { "type", &CosTrading::_tc_ServiceTypeName },
        { "target", &CosTrading::_tc_Lookup },
        { "properties", &CosTrading::_tc_PropertySeq },
        { "if_match_all", &CORBA::_tc_boolean },
        { "recipe", &CosTrading::Proxy::_tc_ConstraintRecipe },
        { "policies_to_pass_on", &CosTrading::_tc_PolicySeq }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Proxy_ProxyInfo (
  ::CORBA::tk_struct,
  "IDL:omg.org/CosTrading/Proxy/ProxyInfo:1.0",
  "ProxyInfo",
  _tao_fields_CosTrading_Proxy_ProxyInfo,
  6);

::CORBA::TypeCode_ptr const CosTrading::Proxy::_tc_ProxyInfo =
  &_tao_tc_CosTrading_Proxy_ProxyInfo;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosTrading::Proxy::ProxyInfo::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ProxyInfo *_tao_tmp_pointer =
    static_cast<ProxyInfo *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Proxy::IllegalRecipe::IllegalRecipe (
    const char * _tao_recipe)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Proxy/IllegalRecipe:1.0",
        "IllegalRecipe"
      )
{
  this->recipe = ::CORBA::string_dup (_tao_recipe);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Proxy::IllegalRecipe::IllegalRecipe (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Proxy/IllegalRecipe:1.0",
        "IllegalRecipe"
      )
{
}

CosTrading::Proxy::IllegalRecipe::~IllegalRecipe (void)
{
}

CosTrading::Proxy::IllegalRecipe::IllegalRecipe (const ::CosTrading::Proxy::IllegalRecipe &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->recipe = ::CORBA::string_dup (_tao_excp.recipe.in ());
}

CosTrading::Proxy::IllegalRecipe&
CosTrading::Proxy::IllegalRecipe::operator= (const ::CosTrading::Proxy::IllegalRecipe &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->recipe = ::CORBA::string_dup (_tao_excp.recipe.in ());
  return *this;
}

void CosTrading::Proxy::IllegalRecipe::_tao_any_destructor (void *_tao_void_pointer)
{
  IllegalRecipe *_tao_tmp_pointer =
    static_cast<IllegalRecipe *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Proxy::IllegalRecipe *
CosTrading::Proxy::IllegalRecipe::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<IllegalRecipe *> (_tao_excp);
}

const CosTrading::Proxy::IllegalRecipe *
CosTrading::Proxy::IllegalRecipe::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const IllegalRecipe *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Proxy::IllegalRecipe::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Proxy::IllegalRecipe, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Proxy::IllegalRecipe::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Proxy::IllegalRecipe (*this),
      0
    );
  return result;
}

void CosTrading::Proxy::IllegalRecipe::_raise (void) const
{
  throw *this;
}

void CosTrading::Proxy::IllegalRecipe::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Proxy::IllegalRecipe::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Proxy::IllegalRecipe::_tao_type (void) const
{
  return ::CosTrading::Proxy::_tc_IllegalRecipe;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Proxy_IllegalRecipe[] =
      {
        { "recipe", &CosTrading::Proxy::_tc_ConstraintRecipe }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Proxy_IllegalRecipe (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Proxy/IllegalRecipe:1.0",
  "IllegalRecipe",
  _tao_fields_CosTrading_Proxy_IllegalRecipe,
  1);

::CORBA::TypeCode_ptr const CosTrading::Proxy::_tc_IllegalRecipe =
  &_tao_tc_CosTrading_Proxy_IllegalRecipe;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosTrading::Proxy::NotProxyOfferId::NotProxyOfferId (
    const char * _tao_id)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Proxy/NotProxyOfferId:1.0",
        "NotProxyOfferId"
      )
{
  this->id = ::CORBA::string_dup (_tao_id);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosTrading::Proxy::NotProxyOfferId::NotProxyOfferId (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosTrading/Proxy/NotProxyOfferId:1.0",
        "NotProxyOfferId"
      )
{
}

CosTrading::Proxy::NotProxyOfferId::~NotProxyOfferId (void)
{
}

CosTrading::Proxy::NotProxyOfferId::NotProxyOfferId (const ::CosTrading::Proxy::NotProxyOfferId &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->id = ::CORBA::string_dup (_tao_excp.id.in ());
}

CosTrading::Proxy::NotProxyOfferId&
CosTrading::Proxy::NotProxyOfferId::operator= (const ::CosTrading::Proxy::NotProxyOfferId &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->id = ::CORBA::string_dup (_tao_excp.id.in ());
  return *this;
}

void CosTrading::Proxy::NotProxyOfferId::_tao_any_destructor (void *_tao_void_pointer)
{
  NotProxyOfferId *_tao_tmp_pointer =
    static_cast<NotProxyOfferId *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosTrading::Proxy::NotProxyOfferId *
CosTrading::Proxy::NotProxyOfferId::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NotProxyOfferId *> (_tao_excp);
}

const CosTrading::Proxy::NotProxyOfferId *
CosTrading::Proxy::NotProxyOfferId::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NotProxyOfferId *> (_tao_excp);
}

::CORBA::Exception *CosTrading::Proxy::NotProxyOfferId::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosTrading::Proxy::NotProxyOfferId, 0);
  return retval;
}

::CORBA::Exception *
CosTrading::Proxy::NotProxyOfferId::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosTrading::Proxy::NotProxyOfferId (*this),
      0
    );
  return result;
}

void CosTrading::Proxy::NotProxyOfferId::_raise (void) const
{
  throw *this;
}

void CosTrading::Proxy::NotProxyOfferId::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosTrading::Proxy::NotProxyOfferId::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosTrading::Proxy::NotProxyOfferId::_tao_type (void) const
{
  return ::CosTrading::Proxy::_tc_NotProxyOfferId;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosTrading_Proxy_NotProxyOfferId[] =
      {
        { "id", &CosTrading::_tc_OfferId }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosTrading_Proxy_NotProxyOfferId (
  ::CORBA::tk_except,
  "IDL:omg.org/CosTrading/Proxy/NotProxyOfferId:1.0",
  "NotProxyOfferId",
  _tao_fields_CosTrading_Proxy_NotProxyOfferId,
  1);

::CORBA::TypeCode_ptr const CosTrading::Proxy::_tc_NotProxyOfferId =
  &_tao_tc_CosTrading_Proxy_NotProxyOfferId;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CosTrading::Proxy::export_proxy (
  ::CosTrading::Lookup_ptr target,
  const char * type,
  const ::CosTrading::PropertySeq & properties,
  ::CORBA::Boolean if_match_all,
  const char * recipe,
  const ::CosTrading::PolicySeq & policies_to_pass_on)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Proxy_Proxy_Broker_ == 0)
    {
      CosTrading_Proxy_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosTrading::Lookup>::in_arg_val _tao_target (target);
  TAO::Arg_Traits< char *>::in_arg_val _tao_type (type);
  TAO::Arg_Traits< ::CosTrading::PropertySeq>::in_arg_val _tao_properties (properties);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_if_match_all (if_match_all);
  TAO::Arg_Traits< char *>::in_arg_val _tao_recipe (recipe);
  TAO::Arg_Traits< ::CosTrading::PolicySeq>::in_arg_val _tao_policies_to_pass_on (policies_to_pass_on);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_target,
      &_tao_type,
      &_tao_properties,
      &_tao_if_match_all,
      &_tao_recipe,
      &_tao_policies_to_pass_on
    };

  static TAO::Exception_Data
  _tao_CosTrading_Proxy_export_proxy_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/IllegalServiceType:1.0",
        CosTrading::IllegalServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownServiceType:1.0",
        CosTrading::UnknownServiceType::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownServiceType
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/InvalidLookupRef:1.0",
        CosTrading::InvalidLookupRef::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_InvalidLookupRef
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/IllegalPropertyName:1.0",
        CosTrading::IllegalPropertyName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalPropertyName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/PropertyTypeMismatch:1.0",
        CosTrading::PropertyTypeMismatch::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_PropertyTypeMismatch
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/ReadonlyDynamicProperty:1.0",
        CosTrading::ReadonlyDynamicProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_ReadonlyDynamicProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/MissingMandatoryProperty:1.0",
        CosTrading::MissingMandatoryProperty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_MissingMandatoryProperty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Proxy/IllegalRecipe:1.0",
        CosTrading::Proxy::IllegalRecipe::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Proxy::_tc_IllegalRecipe
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/DuplicatePropertyName:1.0",
        CosTrading::DuplicatePropertyName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_DuplicatePropertyName
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/DuplicatePolicyName:1.0",
        CosTrading::DuplicatePolicyName::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_DuplicatePolicyName
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      7,
      "export_proxy",
      12,
      this->the_TAO_Proxy_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Proxy_export_proxy_exceptiondata,
      10
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTrading::Proxy::withdraw_proxy (
  const char * id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Proxy_Proxy_Broker_ == 0)
    {
      CosTrading_Proxy_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_id (id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_id
    };

  static TAO::Exception_Data
  _tao_CosTrading_Proxy_withdraw_proxy_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/IllegalOfferId:1.0",
        CosTrading::IllegalOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownOfferId:1.0",
        CosTrading::UnknownOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Proxy/NotProxyOfferId:1.0",
        CosTrading::Proxy::NotProxyOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Proxy::_tc_NotProxyOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "withdraw_proxy",
      14,
      this->the_TAO_Proxy_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Proxy_withdraw_proxy_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::Proxy::ProxyInfo *
CosTrading::Proxy::describe_proxy (
  const char * id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Proxy_Proxy_Broker_ == 0)
    {
      CosTrading_Proxy_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::Proxy::ProxyInfo>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_id (id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_id
    };

  static TAO::Exception_Data
  _tao_CosTrading_Proxy_describe_proxy_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/IllegalOfferId:1.0",
        CosTrading::IllegalOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_IllegalOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/UnknownOfferId:1.0",
        CosTrading::UnknownOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosTrading/Proxy/NotProxyOfferId:1.0",
        CosTrading::Proxy::NotProxyOfferId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::Proxy::_tc_NotProxyOfferId
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "describe_proxy",
      14,
      this->the_TAO_Proxy_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Proxy_describe_proxy_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

CosTrading::Proxy::Proxy (void)
 : the_TAO_Proxy_Proxy_Broker_ (0)
{
  this->CosTrading_Proxy_setup_collocation ();
}

void
CosTrading::Proxy::CosTrading_Proxy_setup_collocation ()
{
  if (::CosTrading__TAO_Proxy_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Proxy_Proxy_Broker_ =
        ::CosTrading__TAO_Proxy_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CosTrading_TraderComponents_setup_collocation ();
  this->CosTrading_SupportAttributes_setup_collocation ();
}

CosTrading::Proxy::~Proxy (void)
{}

void 
CosTrading::Proxy::_tao_any_destructor (void *_tao_void_pointer)
{
  Proxy *_tao_tmp_pointer =
    static_cast<Proxy *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosTrading::Proxy_ptr
CosTrading::Proxy::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Proxy>::narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/Proxy:1.0",
        CosTrading__TAO_Proxy_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::Proxy_ptr
CosTrading::Proxy::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Proxy>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/Proxy:1.0",
        CosTrading__TAO_Proxy_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::Proxy_ptr
CosTrading::Proxy::_nil (void)
{
  return 0;
}

CosTrading::Proxy_ptr
CosTrading::Proxy::_duplicate (Proxy_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosTrading::Proxy::_tao_release (Proxy_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosTrading::Proxy::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/TraderComponents:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/SupportAttributes:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/Proxy:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosTrading::Proxy::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosTrading/Proxy:1.0";
}

::CORBA::Boolean
CosTrading::Proxy::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_Proxy (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosTrading/Proxy:1.0",
    "Proxy");
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_Proxy =
    &_tao_tc_CosTrading_Proxy;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosTrading::Admin.

CosTrading::Admin_ptr
TAO::Objref_Traits<CosTrading::Admin>::duplicate (
    CosTrading::Admin_ptr p)
{
  return CosTrading::Admin::_duplicate (p);
}

void
TAO::Objref_Traits<CosTrading::Admin>::release (
    CosTrading::Admin_ptr p)
{
  ::CORBA::release (p);
}

CosTrading::Admin_ptr
TAO::Objref_Traits<CosTrading::Admin>::nil (void)
{
  return CosTrading::Admin::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosTrading::Admin>::marshal (
    const CosTrading::Admin_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosTrading__TAO_Admin_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSTRADING_ADMIN_OCTETSEQ_CS_)
#define _COSTRADING_ADMIN_OCTETSEQ_CS_

CosTrading::Admin::OctetSeq::OctetSeq (void)
{}

CosTrading::Admin::OctetSeq::OctetSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

CosTrading::Admin::OctetSeq::OctetSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

CosTrading::Admin::OctetSeq::OctetSeq (
    const OctetSeq &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

CosTrading::Admin::OctetSeq::~OctetSeq (void)
{}

void CosTrading::Admin::OctetSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  OctetSeq * _tao_tmp_pointer =
    static_cast<OctetSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosTrading_Admin_OctetSeq_GUARD
#define _TAO_TYPECODE_CosTrading_Admin_OctetSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosTrading_Admin_OctetSeq_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosTrading_Admin_OctetSeq_0 =
        &CosTrading_Admin_OctetSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosTrading_Admin_OctetSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_Admin_OctetSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosTrading/Admin/OctetSeq:1.0",
    "OctetSeq",
    &TAO::TypeCode::tc_CosTrading_Admin_OctetSeq_0);
  
::CORBA::TypeCode_ptr const CosTrading::Admin::_tc_OctetSeq =
  &_tao_tc_CosTrading_Admin_OctetSeq;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::Admin::OctetSeq *
CosTrading::Admin::request_id_stem (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::Admin::OctetSeq>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_request_id_stem",
      20,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::Admin::set_def_search_card (
  ::CORBA::ULong value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_value (value);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_value
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_def_search_card",
      19,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::Admin::set_max_search_card (
  ::CORBA::ULong value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_value (value);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_value
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_max_search_card",
      19,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::Admin::set_def_match_card (
  ::CORBA::ULong value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_value (value);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_value
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_def_match_card",
      18,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::Admin::set_max_match_card (
  ::CORBA::ULong value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_value (value);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_value
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_max_match_card",
      18,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::Admin::set_def_return_card (
  ::CORBA::ULong value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_value (value);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_value
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_def_return_card",
      19,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::Admin::set_max_return_card (
  ::CORBA::ULong value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_value (value);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_value
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_max_return_card",
      19,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::Admin::set_max_list (
  ::CORBA::ULong value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_value (value);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_value
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_max_list",
      12,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CosTrading::Admin::set_supports_modifiable_properties (
  ::CORBA::Boolean value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_value (value);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_value
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_supports_modifiable_properties",
      34,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CosTrading::Admin::set_supports_dynamic_properties (
  ::CORBA::Boolean value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_value (value);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_value
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_supports_dynamic_properties",
      31,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CosTrading::Admin::set_supports_proxy_offers (
  ::CORBA::Boolean value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_value (value);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_value
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_supports_proxy_offers",
      25,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::Admin::set_def_hop_count (
  ::CORBA::ULong value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_value (value);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_value
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_def_hop_count",
      17,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::Admin::set_max_hop_count (
  ::CORBA::ULong value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_value (value);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_value
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_max_hop_count",
      17,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::FollowOption
CosTrading::Admin::set_def_follow_policy (
  ::CosTrading::FollowOption policy)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::FollowOption>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosTrading::FollowOption>::in_arg_val _tao_policy (policy);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_policy
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_def_follow_policy",
      21,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::FollowOption
CosTrading::Admin::set_max_follow_policy (
  ::CosTrading::FollowOption policy)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::FollowOption>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosTrading::FollowOption>::in_arg_val _tao_policy (policy);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_policy
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_max_follow_policy",
      21,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::FollowOption
CosTrading::Admin::set_max_link_follow_policy (
  ::CosTrading::FollowOption policy)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::FollowOption>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosTrading::FollowOption>::in_arg_val _tao_policy (policy);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_policy
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_max_link_follow_policy",
      26,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::TypeRepository_ptr
CosTrading::Admin::set_type_repos (
  ::CosTrading::TypeRepository_ptr repository)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_repository (repository);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_repository
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_type_repos",
      14,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosTrading::Admin::OctetSeq *
CosTrading::Admin::set_request_id_stem (
  const ::CosTrading::Admin::OctetSeq & stem)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosTrading::Admin::OctetSeq>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosTrading::Admin::OctetSeq>::in_arg_val _tao_stem (stem);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_stem
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_request_id_stem",
      19,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTrading::Admin::list_offers (
  ::CORBA::ULong how_many,
  ::CosTrading::OfferIdSeq_out ids,
  ::CosTrading::OfferIdIterator_out id_itr)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_how_many (how_many);
  TAO::Arg_Traits< ::CosTrading::OfferIdSeq>::out_arg_val _tao_ids (ids);
  TAO::Arg_Traits< ::CosTrading::OfferIdIterator>::out_arg_val _tao_id_itr (id_itr);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_how_many,
      &_tao_ids,
      &_tao_id_itr
    };

  static TAO::Exception_Data
  _tao_CosTrading_Admin_list_offers_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/NotImplemented:1.0",
        CosTrading::NotImplemented::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_NotImplemented
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "list_offers",
      11,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Admin_list_offers_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTrading::Admin::list_proxies (
  ::CORBA::ULong how_many,
  ::CosTrading::OfferIdSeq_out ids,
  ::CosTrading::OfferIdIterator_out id_itr)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Admin_Proxy_Broker_ == 0)
    {
      CosTrading_Admin_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_how_many (how_many);
  TAO::Arg_Traits< ::CosTrading::OfferIdSeq>::out_arg_val _tao_ids (ids);
  TAO::Arg_Traits< ::CosTrading::OfferIdIterator>::out_arg_val _tao_id_itr (id_itr);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_how_many,
      &_tao_ids,
      &_tao_id_itr
    };

  static TAO::Exception_Data
  _tao_CosTrading_Admin_list_proxies_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/NotImplemented:1.0",
        CosTrading::NotImplemented::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_NotImplemented
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "list_proxies",
      12,
      this->the_TAO_Admin_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_Admin_list_proxies_exceptiondata,
      1
    );
}

CosTrading::Admin::Admin (void)
 : the_TAO_Admin_Proxy_Broker_ (0)
{
  this->CosTrading_Admin_setup_collocation ();
}

void
CosTrading::Admin::CosTrading_Admin_setup_collocation ()
{
  if (::CosTrading__TAO_Admin_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Admin_Proxy_Broker_ =
        ::CosTrading__TAO_Admin_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CosTrading_TraderComponents_setup_collocation ();
  this->CosTrading_SupportAttributes_setup_collocation ();
  this->CosTrading_ImportAttributes_setup_collocation ();
  this->CosTrading_LinkAttributes_setup_collocation ();
}

CosTrading::Admin::~Admin (void)
{}

void 
CosTrading::Admin::_tao_any_destructor (void *_tao_void_pointer)
{
  Admin *_tao_tmp_pointer =
    static_cast<Admin *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosTrading::Admin_ptr
CosTrading::Admin::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Admin>::narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/Admin:1.0",
        CosTrading__TAO_Admin_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::Admin_ptr
CosTrading::Admin::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Admin>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/Admin:1.0",
        CosTrading__TAO_Admin_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::Admin_ptr
CosTrading::Admin::_nil (void)
{
  return 0;
}

CosTrading::Admin_ptr
CosTrading::Admin::_duplicate (Admin_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosTrading::Admin::_tao_release (Admin_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosTrading::Admin::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/TraderComponents:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/SupportAttributes:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/ImportAttributes:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/LinkAttributes:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/Admin:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosTrading::Admin::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosTrading/Admin:1.0";
}

::CORBA::Boolean
CosTrading::Admin::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_Admin (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosTrading/Admin:1.0",
    "Admin");
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_Admin =
    &_tao_tc_CosTrading_Admin;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosTrading::OfferIterator.

CosTrading::OfferIterator_ptr
TAO::Objref_Traits<CosTrading::OfferIterator>::duplicate (
    CosTrading::OfferIterator_ptr p)
{
  return CosTrading::OfferIterator::_duplicate (p);
}

void
TAO::Objref_Traits<CosTrading::OfferIterator>::release (
    CosTrading::OfferIterator_ptr p)
{
  ::CORBA::release (p);
}

CosTrading::OfferIterator_ptr
TAO::Objref_Traits<CosTrading::OfferIterator>::nil (void)
{
  return CosTrading::OfferIterator::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosTrading::OfferIterator>::marshal (
    const CosTrading::OfferIterator_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosTrading__TAO_OfferIterator_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::OfferIterator::max_left (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_OfferIterator_Proxy_Broker_ == 0)
    {
      CosTrading_OfferIterator_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CosTrading_OfferIterator_max_left_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/UnknownMaxLeft:1.0",
        CosTrading::UnknownMaxLeft::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownMaxLeft
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "max_left",
      8,
      this->the_TAO_OfferIterator_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_OfferIterator_max_left_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CosTrading::OfferIterator::next_n (
  ::CORBA::ULong n,
  ::CosTrading::OfferSeq_out offers)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_OfferIterator_Proxy_Broker_ == 0)
    {
      CosTrading_OfferIterator_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_n (n);
  TAO::Arg_Traits< ::CosTrading::OfferSeq>::out_arg_val _tao_offers (offers);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_n,
      &_tao_offers
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "next_n",
      6,
      this->the_TAO_OfferIterator_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTrading::OfferIterator::destroy (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_OfferIterator_Proxy_Broker_ == 0)
    {
      CosTrading_OfferIterator_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "destroy",
      7,
      this->the_TAO_OfferIterator_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

CosTrading::OfferIterator::OfferIterator (void)
 : the_TAO_OfferIterator_Proxy_Broker_ (0)
{
  this->CosTrading_OfferIterator_setup_collocation ();
}

void
CosTrading::OfferIterator::CosTrading_OfferIterator_setup_collocation ()
{
  if (::CosTrading__TAO_OfferIterator_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_OfferIterator_Proxy_Broker_ =
        ::CosTrading__TAO_OfferIterator_Proxy_Broker_Factory_function_pointer (this);
    }
}

CosTrading::OfferIterator::~OfferIterator (void)
{}

void 
CosTrading::OfferIterator::_tao_any_destructor (void *_tao_void_pointer)
{
  OfferIterator *_tao_tmp_pointer =
    static_cast<OfferIterator *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosTrading::OfferIterator_ptr
CosTrading::OfferIterator::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<OfferIterator>::narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/OfferIterator:1.0",
        CosTrading__TAO_OfferIterator_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::OfferIterator_ptr
CosTrading::OfferIterator::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<OfferIterator>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/OfferIterator:1.0",
        CosTrading__TAO_OfferIterator_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::OfferIterator_ptr
CosTrading::OfferIterator::_nil (void)
{
  return 0;
}

CosTrading::OfferIterator_ptr
CosTrading::OfferIterator::_duplicate (OfferIterator_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosTrading::OfferIterator::_tao_release (OfferIterator_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosTrading::OfferIterator::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/OfferIterator:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosTrading::OfferIterator::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosTrading/OfferIterator:1.0";
}

::CORBA::Boolean
CosTrading::OfferIterator::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_OfferIterator (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosTrading/OfferIterator:1.0",
    "OfferIterator");
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_OfferIterator =
    &_tao_tc_CosTrading_OfferIterator;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosTrading::OfferIdIterator.

CosTrading::OfferIdIterator_ptr
TAO::Objref_Traits<CosTrading::OfferIdIterator>::duplicate (
    CosTrading::OfferIdIterator_ptr p)
{
  return CosTrading::OfferIdIterator::_duplicate (p);
}

void
TAO::Objref_Traits<CosTrading::OfferIdIterator>::release (
    CosTrading::OfferIdIterator_ptr p)
{
  ::CORBA::release (p);
}

CosTrading::OfferIdIterator_ptr
TAO::Objref_Traits<CosTrading::OfferIdIterator>::nil (void)
{
  return CosTrading::OfferIdIterator::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosTrading::OfferIdIterator>::marshal (
    const CosTrading::OfferIdIterator_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosTrading__TAO_OfferIdIterator_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
CosTrading::OfferIdIterator::max_left (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_OfferIdIterator_Proxy_Broker_ == 0)
    {
      CosTrading_OfferIdIterator_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CosTrading_OfferIdIterator_max_left_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosTrading/UnknownMaxLeft:1.0",
        CosTrading::UnknownMaxLeft::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosTrading::_tc_UnknownMaxLeft
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "max_left",
      8,
      this->the_TAO_OfferIdIterator_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosTrading_OfferIdIterator_max_left_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CosTrading::OfferIdIterator::next_n (
  ::CORBA::ULong n,
  ::CosTrading::OfferIdSeq_out ids)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_OfferIdIterator_Proxy_Broker_ == 0)
    {
      CosTrading_OfferIdIterator_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_n (n);
  TAO::Arg_Traits< ::CosTrading::OfferIdSeq>::out_arg_val _tao_ids (ids);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_n,
      &_tao_ids
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "next_n",
      6,
      this->the_TAO_OfferIdIterator_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosTrading::OfferIdIterator::destroy (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_OfferIdIterator_Proxy_Broker_ == 0)
    {
      CosTrading_OfferIdIterator_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "destroy",
      7,
      this->the_TAO_OfferIdIterator_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

CosTrading::OfferIdIterator::OfferIdIterator (void)
 : the_TAO_OfferIdIterator_Proxy_Broker_ (0)
{
  this->CosTrading_OfferIdIterator_setup_collocation ();
}

void
CosTrading::OfferIdIterator::CosTrading_OfferIdIterator_setup_collocation ()
{
  if (::CosTrading__TAO_OfferIdIterator_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_OfferIdIterator_Proxy_Broker_ =
        ::CosTrading__TAO_OfferIdIterator_Proxy_Broker_Factory_function_pointer (this);
    }
}

CosTrading::OfferIdIterator::~OfferIdIterator (void)
{}

void 
CosTrading::OfferIdIterator::_tao_any_destructor (void *_tao_void_pointer)
{
  OfferIdIterator *_tao_tmp_pointer =
    static_cast<OfferIdIterator *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosTrading::OfferIdIterator_ptr
CosTrading::OfferIdIterator::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<OfferIdIterator>::narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/OfferIdIterator:1.0",
        CosTrading__TAO_OfferIdIterator_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::OfferIdIterator_ptr
CosTrading::OfferIdIterator::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<OfferIdIterator>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosTrading/OfferIdIterator:1.0",
        CosTrading__TAO_OfferIdIterator_Proxy_Broker_Factory_function_pointer
      );
}

CosTrading::OfferIdIterator_ptr
CosTrading::OfferIdIterator::_nil (void)
{
  return 0;
}

CosTrading::OfferIdIterator_ptr
CosTrading::OfferIdIterator::_duplicate (OfferIdIterator_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosTrading::OfferIdIterator::_tao_release (OfferIdIterator_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosTrading::OfferIdIterator::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosTrading/OfferIdIterator:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosTrading::OfferIdIterator::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosTrading/OfferIdIterator:1.0";
}

::CORBA::Boolean
CosTrading::OfferIdIterator::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosTrading_OfferIdIterator (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosTrading/OfferIdIterator:1.0",
    "OfferIdIterator");
  

namespace CosTrading
{
  ::CORBA::TypeCode_ptr const _tc_OfferIdIterator =
    &_tao_tc_CosTrading_OfferIdIterator;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::PropertyNameSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::PropertyNameSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::PropertyNameSeq>::insert_copy (
          _tao_any,
          ::CosTrading::PropertyNameSeq::_tao_any_destructor,
          ::CosTrading::_tc_PropertyNameSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::PropertyNameSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::PropertyNameSeq>::insert (
        _tao_any,
        ::CosTrading::PropertyNameSeq::_tao_any_destructor,
        ::CosTrading::_tc_PropertyNameSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::PropertyNameSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::PropertyNameSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::PropertyNameSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::PropertyNameSeq>::extract (
          _tao_any,
          ::CosTrading::PropertyNameSeq::_tao_any_destructor,
          ::CosTrading::_tc_PropertyNameSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::PropertyNameSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::PropertyNameSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::PropertyNameSeq>::insert_copy (
        _tao_any,
        CosTrading::PropertyNameSeq::_tao_any_destructor,
        CosTrading::_tc_PropertyNameSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::PropertyNameSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::PropertyNameSeq>::insert (
      _tao_any,
      CosTrading::PropertyNameSeq::_tao_any_destructor,
      CosTrading::_tc_PropertyNameSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::PropertyNameSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::PropertyNameSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::PropertyNameSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::PropertyNameSeq>::extract (
        _tao_any,
        CosTrading::PropertyNameSeq::_tao_any_destructor,
        CosTrading::_tc_PropertyNameSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Property &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::Property *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::Property>::insert_copy (
          _tao_any,
          ::CosTrading::Property::_tao_any_destructor,
          ::CosTrading::_tc_Property,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosTrading::Property *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Property>::insert (
        _tao_any,
        ::CosTrading::Property::_tao_any_destructor,
        ::CosTrading::_tc_Property,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Property *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Property *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Property *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Property>::extract (
          _tao_any,
          ::CosTrading::Property::_tao_any_destructor,
          ::CosTrading::_tc_Property,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Property &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::Property *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::Property>::insert_copy (
        _tao_any,
        CosTrading::Property::_tao_any_destructor,
        CosTrading::_tc_Property,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Property *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Property>::insert (
      _tao_any,
      CosTrading::Property::_tao_any_destructor,
      CosTrading::_tc_Property,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Property *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Property *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Property *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Property>::extract (
        _tao_any,
        CosTrading::Property::_tao_any_destructor,
        CosTrading::_tc_Property,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::PropertySeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::PropertySeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::PropertySeq>::insert_copy (
          _tao_any,
          ::CosTrading::PropertySeq::_tao_any_destructor,
          ::CosTrading::_tc_PropertySeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::PropertySeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::PropertySeq>::insert (
        _tao_any,
        ::CosTrading::PropertySeq::_tao_any_destructor,
        ::CosTrading::_tc_PropertySeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::PropertySeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::PropertySeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::PropertySeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::PropertySeq>::extract (
          _tao_any,
          ::CosTrading::PropertySeq::_tao_any_destructor,
          ::CosTrading::_tc_PropertySeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::PropertySeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::PropertySeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::PropertySeq>::insert_copy (
        _tao_any,
        CosTrading::PropertySeq::_tao_any_destructor,
        CosTrading::_tc_PropertySeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::PropertySeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::PropertySeq>::insert (
      _tao_any,
      CosTrading::PropertySeq::_tao_any_destructor,
      CosTrading::_tc_PropertySeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::PropertySeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::PropertySeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::PropertySeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::PropertySeq>::extract (
        _tao_any,
        CosTrading::PropertySeq::_tao_any_destructor,
        CosTrading::_tc_PropertySeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Offer &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::Offer *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::Offer>::insert_copy (
          _tao_any,
          ::CosTrading::Offer::_tao_any_destructor,
          ::CosTrading::_tc_Offer,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosTrading::Offer *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Offer>::insert (
        _tao_any,
        ::CosTrading::Offer::_tao_any_destructor,
        ::CosTrading::_tc_Offer,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Offer *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Offer *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Offer *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Offer>::extract (
          _tao_any,
          ::CosTrading::Offer::_tao_any_destructor,
          ::CosTrading::_tc_Offer,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Offer &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::Offer *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::Offer>::insert_copy (
        _tao_any,
        CosTrading::Offer::_tao_any_destructor,
        CosTrading::_tc_Offer,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Offer *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Offer>::insert (
      _tao_any,
      CosTrading::Offer::_tao_any_destructor,
      CosTrading::_tc_Offer,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Offer *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Offer *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Offer *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Offer>::extract (
        _tao_any,
        CosTrading::Offer::_tao_any_destructor,
        CosTrading::_tc_Offer,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::OfferSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::OfferSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::OfferSeq>::insert_copy (
          _tao_any,
          ::CosTrading::OfferSeq::_tao_any_destructor,
          ::CosTrading::_tc_OfferSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::OfferSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::OfferSeq>::insert (
        _tao_any,
        ::CosTrading::OfferSeq::_tao_any_destructor,
        ::CosTrading::_tc_OfferSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::OfferSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::OfferSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::OfferSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::OfferSeq>::extract (
          _tao_any,
          ::CosTrading::OfferSeq::_tao_any_destructor,
          ::CosTrading::_tc_OfferSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::OfferSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::OfferSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::OfferSeq>::insert_copy (
        _tao_any,
        CosTrading::OfferSeq::_tao_any_destructor,
        CosTrading::_tc_OfferSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::OfferSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::OfferSeq>::insert (
      _tao_any,
      CosTrading::OfferSeq::_tao_any_destructor,
      CosTrading::_tc_OfferSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::OfferSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::OfferSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::OfferSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::OfferSeq>::extract (
        _tao_any,
        CosTrading::OfferSeq::_tao_any_destructor,
        CosTrading::_tc_OfferSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::OfferIdSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::OfferIdSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::OfferIdSeq>::insert_copy (
          _tao_any,
          ::CosTrading::OfferIdSeq::_tao_any_destructor,
          ::CosTrading::_tc_OfferIdSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::OfferIdSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::OfferIdSeq>::insert (
        _tao_any,
        ::CosTrading::OfferIdSeq::_tao_any_destructor,
        ::CosTrading::_tc_OfferIdSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::OfferIdSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::OfferIdSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::OfferIdSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::OfferIdSeq>::extract (
          _tao_any,
          ::CosTrading::OfferIdSeq::_tao_any_destructor,
          ::CosTrading::_tc_OfferIdSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::OfferIdSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::OfferIdSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::OfferIdSeq>::insert_copy (
        _tao_any,
        CosTrading::OfferIdSeq::_tao_any_destructor,
        CosTrading::_tc_OfferIdSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::OfferIdSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::OfferIdSeq>::insert (
      _tao_any,
      CosTrading::OfferIdSeq::_tao_any_destructor,
      CosTrading::_tc_OfferIdSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::OfferIdSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::OfferIdSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::OfferIdSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::OfferIdSeq>::extract (
        _tao_any,
        CosTrading::OfferIdSeq::_tao_any_destructor,
        CosTrading::_tc_OfferIdSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::FollowOption _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::CosTrading::FollowOption>::insert (
        _tao_any,
        ::CosTrading::_tc_FollowOption,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::FollowOption &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::CosTrading::FollowOption>::extract (
          _tao_any,
          ::CosTrading::_tc_FollowOption,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::FollowOption _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<CosTrading::FollowOption>::insert (
      _tao_any,
      CosTrading::_tc_FollowOption,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::FollowOption &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<CosTrading::FollowOption>::extract (
        _tao_any,
        CosTrading::_tc_FollowOption,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::LinkNameSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::LinkNameSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::LinkNameSeq>::insert_copy (
          _tao_any,
          ::CosTrading::LinkNameSeq::_tao_any_destructor,
          ::CosTrading::_tc_LinkNameSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::LinkNameSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::LinkNameSeq>::insert (
        _tao_any,
        ::CosTrading::LinkNameSeq::_tao_any_destructor,
        ::CosTrading::_tc_LinkNameSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::LinkNameSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::LinkNameSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::LinkNameSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::LinkNameSeq>::extract (
          _tao_any,
          ::CosTrading::LinkNameSeq::_tao_any_destructor,
          ::CosTrading::_tc_LinkNameSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::LinkNameSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::LinkNameSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::LinkNameSeq>::insert_copy (
        _tao_any,
        CosTrading::LinkNameSeq::_tao_any_destructor,
        CosTrading::_tc_LinkNameSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::LinkNameSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::LinkNameSeq>::insert (
      _tao_any,
      CosTrading::LinkNameSeq::_tao_any_destructor,
      CosTrading::_tc_LinkNameSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::LinkNameSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::LinkNameSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::LinkNameSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::LinkNameSeq>::extract (
        _tao_any,
        CosTrading::LinkNameSeq::_tao_any_destructor,
        CosTrading::_tc_LinkNameSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::PolicyNameSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::PolicyNameSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::PolicyNameSeq>::insert_copy (
          _tao_any,
          ::CosTrading::PolicyNameSeq::_tao_any_destructor,
          ::CosTrading::_tc_PolicyNameSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::PolicyNameSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::PolicyNameSeq>::insert (
        _tao_any,
        ::CosTrading::PolicyNameSeq::_tao_any_destructor,
        ::CosTrading::_tc_PolicyNameSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::PolicyNameSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::PolicyNameSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::PolicyNameSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::PolicyNameSeq>::extract (
          _tao_any,
          ::CosTrading::PolicyNameSeq::_tao_any_destructor,
          ::CosTrading::_tc_PolicyNameSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::PolicyNameSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::PolicyNameSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::PolicyNameSeq>::insert_copy (
        _tao_any,
        CosTrading::PolicyNameSeq::_tao_any_destructor,
        CosTrading::_tc_PolicyNameSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::PolicyNameSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::PolicyNameSeq>::insert (
      _tao_any,
      CosTrading::PolicyNameSeq::_tao_any_destructor,
      CosTrading::_tc_PolicyNameSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::PolicyNameSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::PolicyNameSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::PolicyNameSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::PolicyNameSeq>::extract (
        _tao_any,
        CosTrading::PolicyNameSeq::_tao_any_destructor,
        CosTrading::_tc_PolicyNameSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Policy &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::Policy *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::Policy>::insert_copy (
          _tao_any,
          ::CosTrading::Policy::_tao_any_destructor,
          ::CosTrading::_tc_Policy,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosTrading::Policy *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Policy>::insert (
        _tao_any,
        ::CosTrading::Policy::_tao_any_destructor,
        ::CosTrading::_tc_Policy,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Policy *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Policy *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Policy *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Policy>::extract (
          _tao_any,
          ::CosTrading::Policy::_tao_any_destructor,
          ::CosTrading::_tc_Policy,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Policy &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::Policy *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::Policy>::insert_copy (
        _tao_any,
        CosTrading::Policy::_tao_any_destructor,
        CosTrading::_tc_Policy,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Policy *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Policy>::insert (
      _tao_any,
      CosTrading::Policy::_tao_any_destructor,
      CosTrading::_tc_Policy,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Policy *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Policy *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Policy *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Policy>::extract (
        _tao_any,
        CosTrading::Policy::_tao_any_destructor,
        CosTrading::_tc_Policy,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::PolicySeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::PolicySeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::PolicySeq>::insert_copy (
          _tao_any,
          ::CosTrading::PolicySeq::_tao_any_destructor,
          ::CosTrading::_tc_PolicySeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::PolicySeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::PolicySeq>::insert (
        _tao_any,
        ::CosTrading::PolicySeq::_tao_any_destructor,
        ::CosTrading::_tc_PolicySeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::PolicySeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::PolicySeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::PolicySeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::PolicySeq>::extract (
          _tao_any,
          ::CosTrading::PolicySeq::_tao_any_destructor,
          ::CosTrading::_tc_PolicySeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::PolicySeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::PolicySeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::PolicySeq>::insert_copy (
        _tao_any,
        CosTrading::PolicySeq::_tao_any_destructor,
        CosTrading::_tc_PolicySeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::PolicySeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::PolicySeq>::insert (
      _tao_any,
      CosTrading::PolicySeq::_tao_any_destructor,
      CosTrading::_tc_PolicySeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::PolicySeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::PolicySeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::PolicySeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::PolicySeq>::extract (
        _tao_any,
        CosTrading::PolicySeq::_tao_any_destructor,
        CosTrading::_tc_PolicySeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::UnknownMaxLeft>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::UnknownMaxLeft &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::UnknownMaxLeft>::insert_copy (
        _tao_any,
        ::CosTrading::UnknownMaxLeft::_tao_any_destructor,
        ::CosTrading::_tc_UnknownMaxLeft,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::UnknownMaxLeft *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::UnknownMaxLeft>::insert (
        _tao_any,
        ::CosTrading::UnknownMaxLeft::_tao_any_destructor,
        ::CosTrading::_tc_UnknownMaxLeft,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::UnknownMaxLeft *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::UnknownMaxLeft *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::UnknownMaxLeft *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::UnknownMaxLeft>::extract (
          _tao_any,
          ::CosTrading::UnknownMaxLeft::_tao_any_destructor,
          ::CosTrading::_tc_UnknownMaxLeft,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::UnknownMaxLeft &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::UnknownMaxLeft>::insert_copy (
      _tao_any,
      CosTrading::UnknownMaxLeft::_tao_any_destructor,
      CosTrading::_tc_UnknownMaxLeft,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::UnknownMaxLeft *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::UnknownMaxLeft>::insert (
      _tao_any,
      CosTrading::UnknownMaxLeft::_tao_any_destructor,
      CosTrading::_tc_UnknownMaxLeft,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::UnknownMaxLeft *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::UnknownMaxLeft *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::UnknownMaxLeft *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::UnknownMaxLeft>::extract (
        _tao_any,
        CosTrading::UnknownMaxLeft::_tao_any_destructor,
        CosTrading::_tc_UnknownMaxLeft,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::NotImplemented>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::NotImplemented &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::NotImplemented>::insert_copy (
        _tao_any,
        ::CosTrading::NotImplemented::_tao_any_destructor,
        ::CosTrading::_tc_NotImplemented,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::NotImplemented *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::NotImplemented>::insert (
        _tao_any,
        ::CosTrading::NotImplemented::_tao_any_destructor,
        ::CosTrading::_tc_NotImplemented,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::NotImplemented *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::NotImplemented *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::NotImplemented *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::NotImplemented>::extract (
          _tao_any,
          ::CosTrading::NotImplemented::_tao_any_destructor,
          ::CosTrading::_tc_NotImplemented,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::NotImplemented &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::NotImplemented>::insert_copy (
      _tao_any,
      CosTrading::NotImplemented::_tao_any_destructor,
      CosTrading::_tc_NotImplemented,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::NotImplemented *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::NotImplemented>::insert (
      _tao_any,
      CosTrading::NotImplemented::_tao_any_destructor,
      CosTrading::_tc_NotImplemented,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::NotImplemented *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::NotImplemented *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::NotImplemented *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::NotImplemented>::extract (
        _tao_any,
        CosTrading::NotImplemented::_tao_any_destructor,
        CosTrading::_tc_NotImplemented,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::IllegalServiceType>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::IllegalServiceType &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::IllegalServiceType>::insert_copy (
        _tao_any,
        ::CosTrading::IllegalServiceType::_tao_any_destructor,
        ::CosTrading::_tc_IllegalServiceType,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::IllegalServiceType *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::IllegalServiceType>::insert (
        _tao_any,
        ::CosTrading::IllegalServiceType::_tao_any_destructor,
        ::CosTrading::_tc_IllegalServiceType,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::IllegalServiceType *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::IllegalServiceType *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::IllegalServiceType *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::IllegalServiceType>::extract (
          _tao_any,
          ::CosTrading::IllegalServiceType::_tao_any_destructor,
          ::CosTrading::_tc_IllegalServiceType,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::IllegalServiceType &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::IllegalServiceType>::insert_copy (
      _tao_any,
      CosTrading::IllegalServiceType::_tao_any_destructor,
      CosTrading::_tc_IllegalServiceType,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::IllegalServiceType *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::IllegalServiceType>::insert (
      _tao_any,
      CosTrading::IllegalServiceType::_tao_any_destructor,
      CosTrading::_tc_IllegalServiceType,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::IllegalServiceType *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::IllegalServiceType *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::IllegalServiceType *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::IllegalServiceType>::extract (
        _tao_any,
        CosTrading::IllegalServiceType::_tao_any_destructor,
        CosTrading::_tc_IllegalServiceType,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::UnknownServiceType>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::UnknownServiceType &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::UnknownServiceType>::insert_copy (
        _tao_any,
        ::CosTrading::UnknownServiceType::_tao_any_destructor,
        ::CosTrading::_tc_UnknownServiceType,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::UnknownServiceType *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::UnknownServiceType>::insert (
        _tao_any,
        ::CosTrading::UnknownServiceType::_tao_any_destructor,
        ::CosTrading::_tc_UnknownServiceType,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::UnknownServiceType *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::UnknownServiceType *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::UnknownServiceType *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::UnknownServiceType>::extract (
          _tao_any,
          ::CosTrading::UnknownServiceType::_tao_any_destructor,
          ::CosTrading::_tc_UnknownServiceType,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::UnknownServiceType &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::UnknownServiceType>::insert_copy (
      _tao_any,
      CosTrading::UnknownServiceType::_tao_any_destructor,
      CosTrading::_tc_UnknownServiceType,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::UnknownServiceType *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::UnknownServiceType>::insert (
      _tao_any,
      CosTrading::UnknownServiceType::_tao_any_destructor,
      CosTrading::_tc_UnknownServiceType,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::UnknownServiceType *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::UnknownServiceType *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::UnknownServiceType *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::UnknownServiceType>::extract (
        _tao_any,
        CosTrading::UnknownServiceType::_tao_any_destructor,
        CosTrading::_tc_UnknownServiceType,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::IllegalPropertyName>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::IllegalPropertyName &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::IllegalPropertyName>::insert_copy (
        _tao_any,
        ::CosTrading::IllegalPropertyName::_tao_any_destructor,
        ::CosTrading::_tc_IllegalPropertyName,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::IllegalPropertyName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::IllegalPropertyName>::insert (
        _tao_any,
        ::CosTrading::IllegalPropertyName::_tao_any_destructor,
        ::CosTrading::_tc_IllegalPropertyName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::IllegalPropertyName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::IllegalPropertyName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::IllegalPropertyName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::IllegalPropertyName>::extract (
          _tao_any,
          ::CosTrading::IllegalPropertyName::_tao_any_destructor,
          ::CosTrading::_tc_IllegalPropertyName,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::IllegalPropertyName &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::IllegalPropertyName>::insert_copy (
      _tao_any,
      CosTrading::IllegalPropertyName::_tao_any_destructor,
      CosTrading::_tc_IllegalPropertyName,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::IllegalPropertyName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::IllegalPropertyName>::insert (
      _tao_any,
      CosTrading::IllegalPropertyName::_tao_any_destructor,
      CosTrading::_tc_IllegalPropertyName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::IllegalPropertyName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::IllegalPropertyName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::IllegalPropertyName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::IllegalPropertyName>::extract (
        _tao_any,
        CosTrading::IllegalPropertyName::_tao_any_destructor,
        CosTrading::_tc_IllegalPropertyName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::DuplicatePropertyName>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::DuplicatePropertyName &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::DuplicatePropertyName>::insert_copy (
        _tao_any,
        ::CosTrading::DuplicatePropertyName::_tao_any_destructor,
        ::CosTrading::_tc_DuplicatePropertyName,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::DuplicatePropertyName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::DuplicatePropertyName>::insert (
        _tao_any,
        ::CosTrading::DuplicatePropertyName::_tao_any_destructor,
        ::CosTrading::_tc_DuplicatePropertyName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::DuplicatePropertyName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::DuplicatePropertyName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::DuplicatePropertyName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::DuplicatePropertyName>::extract (
          _tao_any,
          ::CosTrading::DuplicatePropertyName::_tao_any_destructor,
          ::CosTrading::_tc_DuplicatePropertyName,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::DuplicatePropertyName &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::DuplicatePropertyName>::insert_copy (
      _tao_any,
      CosTrading::DuplicatePropertyName::_tao_any_destructor,
      CosTrading::_tc_DuplicatePropertyName,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::DuplicatePropertyName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::DuplicatePropertyName>::insert (
      _tao_any,
      CosTrading::DuplicatePropertyName::_tao_any_destructor,
      CosTrading::_tc_DuplicatePropertyName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::DuplicatePropertyName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::DuplicatePropertyName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::DuplicatePropertyName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::DuplicatePropertyName>::extract (
        _tao_any,
        CosTrading::DuplicatePropertyName::_tao_any_destructor,
        CosTrading::_tc_DuplicatePropertyName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::PropertyTypeMismatch>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::PropertyTypeMismatch &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::PropertyTypeMismatch>::insert_copy (
        _tao_any,
        ::CosTrading::PropertyTypeMismatch::_tao_any_destructor,
        ::CosTrading::_tc_PropertyTypeMismatch,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::PropertyTypeMismatch *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::PropertyTypeMismatch>::insert (
        _tao_any,
        ::CosTrading::PropertyTypeMismatch::_tao_any_destructor,
        ::CosTrading::_tc_PropertyTypeMismatch,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::PropertyTypeMismatch *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::PropertyTypeMismatch *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::PropertyTypeMismatch *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::PropertyTypeMismatch>::extract (
          _tao_any,
          ::CosTrading::PropertyTypeMismatch::_tao_any_destructor,
          ::CosTrading::_tc_PropertyTypeMismatch,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::PropertyTypeMismatch &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::PropertyTypeMismatch>::insert_copy (
      _tao_any,
      CosTrading::PropertyTypeMismatch::_tao_any_destructor,
      CosTrading::_tc_PropertyTypeMismatch,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::PropertyTypeMismatch *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::PropertyTypeMismatch>::insert (
      _tao_any,
      CosTrading::PropertyTypeMismatch::_tao_any_destructor,
      CosTrading::_tc_PropertyTypeMismatch,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::PropertyTypeMismatch *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::PropertyTypeMismatch *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::PropertyTypeMismatch *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::PropertyTypeMismatch>::extract (
        _tao_any,
        CosTrading::PropertyTypeMismatch::_tao_any_destructor,
        CosTrading::_tc_PropertyTypeMismatch,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::MissingMandatoryProperty>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::MissingMandatoryProperty &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::MissingMandatoryProperty>::insert_copy (
        _tao_any,
        ::CosTrading::MissingMandatoryProperty::_tao_any_destructor,
        ::CosTrading::_tc_MissingMandatoryProperty,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::MissingMandatoryProperty *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::MissingMandatoryProperty>::insert (
        _tao_any,
        ::CosTrading::MissingMandatoryProperty::_tao_any_destructor,
        ::CosTrading::_tc_MissingMandatoryProperty,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::MissingMandatoryProperty *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::MissingMandatoryProperty *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::MissingMandatoryProperty *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::MissingMandatoryProperty>::extract (
          _tao_any,
          ::CosTrading::MissingMandatoryProperty::_tao_any_destructor,
          ::CosTrading::_tc_MissingMandatoryProperty,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::MissingMandatoryProperty &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::MissingMandatoryProperty>::insert_copy (
      _tao_any,
      CosTrading::MissingMandatoryProperty::_tao_any_destructor,
      CosTrading::_tc_MissingMandatoryProperty,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::MissingMandatoryProperty *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::MissingMandatoryProperty>::insert (
      _tao_any,
      CosTrading::MissingMandatoryProperty::_tao_any_destructor,
      CosTrading::_tc_MissingMandatoryProperty,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::MissingMandatoryProperty *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::MissingMandatoryProperty *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::MissingMandatoryProperty *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::MissingMandatoryProperty>::extract (
        _tao_any,
        CosTrading::MissingMandatoryProperty::_tao_any_destructor,
        CosTrading::_tc_MissingMandatoryProperty,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::ReadonlyDynamicProperty>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::ReadonlyDynamicProperty &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::ReadonlyDynamicProperty>::insert_copy (
        _tao_any,
        ::CosTrading::ReadonlyDynamicProperty::_tao_any_destructor,
        ::CosTrading::_tc_ReadonlyDynamicProperty,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::ReadonlyDynamicProperty *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::ReadonlyDynamicProperty>::insert (
        _tao_any,
        ::CosTrading::ReadonlyDynamicProperty::_tao_any_destructor,
        ::CosTrading::_tc_ReadonlyDynamicProperty,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::ReadonlyDynamicProperty *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::ReadonlyDynamicProperty *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::ReadonlyDynamicProperty *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::ReadonlyDynamicProperty>::extract (
          _tao_any,
          ::CosTrading::ReadonlyDynamicProperty::_tao_any_destructor,
          ::CosTrading::_tc_ReadonlyDynamicProperty,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::ReadonlyDynamicProperty &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::ReadonlyDynamicProperty>::insert_copy (
      _tao_any,
      CosTrading::ReadonlyDynamicProperty::_tao_any_destructor,
      CosTrading::_tc_ReadonlyDynamicProperty,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::ReadonlyDynamicProperty *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::ReadonlyDynamicProperty>::insert (
      _tao_any,
      CosTrading::ReadonlyDynamicProperty::_tao_any_destructor,
      CosTrading::_tc_ReadonlyDynamicProperty,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::ReadonlyDynamicProperty *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::ReadonlyDynamicProperty *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::ReadonlyDynamicProperty *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::ReadonlyDynamicProperty>::extract (
        _tao_any,
        CosTrading::ReadonlyDynamicProperty::_tao_any_destructor,
        CosTrading::_tc_ReadonlyDynamicProperty,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::IllegalConstraint>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::IllegalConstraint &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::IllegalConstraint>::insert_copy (
        _tao_any,
        ::CosTrading::IllegalConstraint::_tao_any_destructor,
        ::CosTrading::_tc_IllegalConstraint,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::IllegalConstraint *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::IllegalConstraint>::insert (
        _tao_any,
        ::CosTrading::IllegalConstraint::_tao_any_destructor,
        ::CosTrading::_tc_IllegalConstraint,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::IllegalConstraint *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::IllegalConstraint *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::IllegalConstraint *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::IllegalConstraint>::extract (
          _tao_any,
          ::CosTrading::IllegalConstraint::_tao_any_destructor,
          ::CosTrading::_tc_IllegalConstraint,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::IllegalConstraint &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::IllegalConstraint>::insert_copy (
      _tao_any,
      CosTrading::IllegalConstraint::_tao_any_destructor,
      CosTrading::_tc_IllegalConstraint,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::IllegalConstraint *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::IllegalConstraint>::insert (
      _tao_any,
      CosTrading::IllegalConstraint::_tao_any_destructor,
      CosTrading::_tc_IllegalConstraint,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::IllegalConstraint *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::IllegalConstraint *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::IllegalConstraint *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::IllegalConstraint>::extract (
        _tao_any,
        CosTrading::IllegalConstraint::_tao_any_destructor,
        CosTrading::_tc_IllegalConstraint,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::InvalidLookupRef>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::InvalidLookupRef &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::InvalidLookupRef>::insert_copy (
        _tao_any,
        ::CosTrading::InvalidLookupRef::_tao_any_destructor,
        ::CosTrading::_tc_InvalidLookupRef,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::InvalidLookupRef *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::InvalidLookupRef>::insert (
        _tao_any,
        ::CosTrading::InvalidLookupRef::_tao_any_destructor,
        ::CosTrading::_tc_InvalidLookupRef,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::InvalidLookupRef *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::InvalidLookupRef *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::InvalidLookupRef *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::InvalidLookupRef>::extract (
          _tao_any,
          ::CosTrading::InvalidLookupRef::_tao_any_destructor,
          ::CosTrading::_tc_InvalidLookupRef,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::InvalidLookupRef &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::InvalidLookupRef>::insert_copy (
      _tao_any,
      CosTrading::InvalidLookupRef::_tao_any_destructor,
      CosTrading::_tc_InvalidLookupRef,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::InvalidLookupRef *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::InvalidLookupRef>::insert (
      _tao_any,
      CosTrading::InvalidLookupRef::_tao_any_destructor,
      CosTrading::_tc_InvalidLookupRef,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::InvalidLookupRef *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::InvalidLookupRef *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::InvalidLookupRef *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::InvalidLookupRef>::extract (
        _tao_any,
        CosTrading::InvalidLookupRef::_tao_any_destructor,
        CosTrading::_tc_InvalidLookupRef,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::IllegalOfferId>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::IllegalOfferId &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::IllegalOfferId>::insert_copy (
        _tao_any,
        ::CosTrading::IllegalOfferId::_tao_any_destructor,
        ::CosTrading::_tc_IllegalOfferId,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::IllegalOfferId *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::IllegalOfferId>::insert (
        _tao_any,
        ::CosTrading::IllegalOfferId::_tao_any_destructor,
        ::CosTrading::_tc_IllegalOfferId,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::IllegalOfferId *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::IllegalOfferId *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::IllegalOfferId *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::IllegalOfferId>::extract (
          _tao_any,
          ::CosTrading::IllegalOfferId::_tao_any_destructor,
          ::CosTrading::_tc_IllegalOfferId,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::IllegalOfferId &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::IllegalOfferId>::insert_copy (
      _tao_any,
      CosTrading::IllegalOfferId::_tao_any_destructor,
      CosTrading::_tc_IllegalOfferId,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::IllegalOfferId *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::IllegalOfferId>::insert (
      _tao_any,
      CosTrading::IllegalOfferId::_tao_any_destructor,
      CosTrading::_tc_IllegalOfferId,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::IllegalOfferId *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::IllegalOfferId *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::IllegalOfferId *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::IllegalOfferId>::extract (
        _tao_any,
        CosTrading::IllegalOfferId::_tao_any_destructor,
        CosTrading::_tc_IllegalOfferId,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::UnknownOfferId>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::UnknownOfferId &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::UnknownOfferId>::insert_copy (
        _tao_any,
        ::CosTrading::UnknownOfferId::_tao_any_destructor,
        ::CosTrading::_tc_UnknownOfferId,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::UnknownOfferId *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::UnknownOfferId>::insert (
        _tao_any,
        ::CosTrading::UnknownOfferId::_tao_any_destructor,
        ::CosTrading::_tc_UnknownOfferId,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::UnknownOfferId *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::UnknownOfferId *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::UnknownOfferId *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::UnknownOfferId>::extract (
          _tao_any,
          ::CosTrading::UnknownOfferId::_tao_any_destructor,
          ::CosTrading::_tc_UnknownOfferId,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::UnknownOfferId &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::UnknownOfferId>::insert_copy (
      _tao_any,
      CosTrading::UnknownOfferId::_tao_any_destructor,
      CosTrading::_tc_UnknownOfferId,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::UnknownOfferId *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::UnknownOfferId>::insert (
      _tao_any,
      CosTrading::UnknownOfferId::_tao_any_destructor,
      CosTrading::_tc_UnknownOfferId,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::UnknownOfferId *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::UnknownOfferId *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::UnknownOfferId *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::UnknownOfferId>::extract (
        _tao_any,
        CosTrading::UnknownOfferId::_tao_any_destructor,
        CosTrading::_tc_UnknownOfferId,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::DuplicatePolicyName>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::DuplicatePolicyName &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::DuplicatePolicyName>::insert_copy (
        _tao_any,
        ::CosTrading::DuplicatePolicyName::_tao_any_destructor,
        ::CosTrading::_tc_DuplicatePolicyName,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::DuplicatePolicyName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::DuplicatePolicyName>::insert (
        _tao_any,
        ::CosTrading::DuplicatePolicyName::_tao_any_destructor,
        ::CosTrading::_tc_DuplicatePolicyName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::DuplicatePolicyName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::DuplicatePolicyName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::DuplicatePolicyName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::DuplicatePolicyName>::extract (
          _tao_any,
          ::CosTrading::DuplicatePolicyName::_tao_any_destructor,
          ::CosTrading::_tc_DuplicatePolicyName,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::DuplicatePolicyName &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::DuplicatePolicyName>::insert_copy (
      _tao_any,
      CosTrading::DuplicatePolicyName::_tao_any_destructor,
      CosTrading::_tc_DuplicatePolicyName,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::DuplicatePolicyName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::DuplicatePolicyName>::insert (
      _tao_any,
      CosTrading::DuplicatePolicyName::_tao_any_destructor,
      CosTrading::_tc_DuplicatePolicyName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::DuplicatePolicyName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::DuplicatePolicyName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::DuplicatePolicyName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::DuplicatePolicyName>::extract (
        _tao_any,
        CosTrading::DuplicatePolicyName::_tao_any_destructor,
        CosTrading::_tc_DuplicatePolicyName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosTrading::TraderComponents>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      TraderComponents_ptr _tao_elem)
  {
    TraderComponents_ptr _tao_objptr =
      TraderComponents::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      TraderComponents_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<TraderComponents>::insert (
        _tao_any,
        TraderComponents::_tao_any_destructor,
        _tc_TraderComponents,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      TraderComponents_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<TraderComponents>::extract (
          _tao_any,
          TraderComponents::_tao_any_destructor,
          _tc_TraderComponents,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::TraderComponents_ptr _tao_elem)
{
  CosTrading::TraderComponents_ptr _tao_objptr =
    CosTrading::TraderComponents::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::TraderComponents_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosTrading::TraderComponents>::insert (
      _tao_any,
      CosTrading::TraderComponents::_tao_any_destructor,
      CosTrading::_tc_TraderComponents,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::TraderComponents_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosTrading::TraderComponents>::extract (
        _tao_any,
        CosTrading::TraderComponents::_tao_any_destructor,
        CosTrading::_tc_TraderComponents,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosTrading::SupportAttributes>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      SupportAttributes_ptr _tao_elem)
  {
    SupportAttributes_ptr _tao_objptr =
      SupportAttributes::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      SupportAttributes_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<SupportAttributes>::insert (
        _tao_any,
        SupportAttributes::_tao_any_destructor,
        _tc_SupportAttributes,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      SupportAttributes_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<SupportAttributes>::extract (
          _tao_any,
          SupportAttributes::_tao_any_destructor,
          _tc_SupportAttributes,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::SupportAttributes_ptr _tao_elem)
{
  CosTrading::SupportAttributes_ptr _tao_objptr =
    CosTrading::SupportAttributes::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::SupportAttributes_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosTrading::SupportAttributes>::insert (
      _tao_any,
      CosTrading::SupportAttributes::_tao_any_destructor,
      CosTrading::_tc_SupportAttributes,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::SupportAttributes_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosTrading::SupportAttributes>::extract (
        _tao_any,
        CosTrading::SupportAttributes::_tao_any_destructor,
        CosTrading::_tc_SupportAttributes,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosTrading::ImportAttributes>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ImportAttributes_ptr _tao_elem)
  {
    ImportAttributes_ptr _tao_objptr =
      ImportAttributes::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ImportAttributes_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<ImportAttributes>::insert (
        _tao_any,
        ImportAttributes::_tao_any_destructor,
        _tc_ImportAttributes,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      ImportAttributes_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<ImportAttributes>::extract (
          _tao_any,
          ImportAttributes::_tao_any_destructor,
          _tc_ImportAttributes,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::ImportAttributes_ptr _tao_elem)
{
  CosTrading::ImportAttributes_ptr _tao_objptr =
    CosTrading::ImportAttributes::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::ImportAttributes_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosTrading::ImportAttributes>::insert (
      _tao_any,
      CosTrading::ImportAttributes::_tao_any_destructor,
      CosTrading::_tc_ImportAttributes,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::ImportAttributes_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosTrading::ImportAttributes>::extract (
        _tao_any,
        CosTrading::ImportAttributes::_tao_any_destructor,
        CosTrading::_tc_ImportAttributes,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosTrading::LinkAttributes>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      LinkAttributes_ptr _tao_elem)
  {
    LinkAttributes_ptr _tao_objptr =
      LinkAttributes::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      LinkAttributes_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<LinkAttributes>::insert (
        _tao_any,
        LinkAttributes::_tao_any_destructor,
        _tc_LinkAttributes,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      LinkAttributes_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<LinkAttributes>::extract (
          _tao_any,
          LinkAttributes::_tao_any_destructor,
          _tc_LinkAttributes,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::LinkAttributes_ptr _tao_elem)
{
  CosTrading::LinkAttributes_ptr _tao_objptr =
    CosTrading::LinkAttributes::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::LinkAttributes_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosTrading::LinkAttributes>::insert (
      _tao_any,
      CosTrading::LinkAttributes::_tao_any_destructor,
      CosTrading::_tc_LinkAttributes,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::LinkAttributes_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosTrading::LinkAttributes>::extract (
        _tao_any,
        CosTrading::LinkAttributes::_tao_any_destructor,
        CosTrading::_tc_LinkAttributes,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosTrading::Lookup>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Lookup_ptr _tao_elem)
  {
    Lookup_ptr _tao_objptr =
      Lookup::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Lookup_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Lookup>::insert (
        _tao_any,
        Lookup::_tao_any_destructor,
        _tc_Lookup,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Lookup_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Lookup>::extract (
          _tao_any,
          Lookup::_tao_any_destructor,
          _tc_Lookup,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Lookup_ptr _tao_elem)
{
  CosTrading::Lookup_ptr _tao_objptr =
    CosTrading::Lookup::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Lookup_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosTrading::Lookup>::insert (
      _tao_any,
      CosTrading::Lookup::_tao_any_destructor,
      CosTrading::_tc_Lookup,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Lookup_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosTrading::Lookup>::extract (
        _tao_any,
        CosTrading::Lookup::_tao_any_destructor,
        CosTrading::_tc_Lookup,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Lookup::HowManyProps _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::CosTrading::Lookup::HowManyProps>::insert (
        _tao_any,
        ::CosTrading::Lookup::_tc_HowManyProps,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Lookup::HowManyProps &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::CosTrading::Lookup::HowManyProps>::extract (
          _tao_any,
          ::CosTrading::Lookup::_tc_HowManyProps,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Lookup::HowManyProps _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<CosTrading::Lookup::HowManyProps>::insert (
      _tao_any,
      CosTrading::Lookup::_tc_HowManyProps,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Lookup::HowManyProps &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<CosTrading::Lookup::HowManyProps>::extract (
        _tao_any,
        CosTrading::Lookup::_tc_HowManyProps,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_union/any_op_cs.cpp:45



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Lookup::SpecifiedProps &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::Lookup::SpecifiedProps *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::SpecifiedProps>::insert_copy (
          _tao_any,
          ::CosTrading::Lookup::SpecifiedProps::_tao_any_destructor,
          ::CosTrading::Lookup::_tc_SpecifiedProps,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Lookup::SpecifiedProps *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::SpecifiedProps>::insert (
        _tao_any,
        ::CosTrading::Lookup::SpecifiedProps::_tao_any_destructor,
        ::CosTrading::Lookup::_tc_SpecifiedProps,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Lookup::SpecifiedProps *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Lookup::SpecifiedProps *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Lookup::SpecifiedProps *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::SpecifiedProps>::extract (
          _tao_any,
          ::CosTrading::Lookup::SpecifiedProps::_tao_any_destructor,
          ::CosTrading::Lookup::_tc_SpecifiedProps,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Lookup::SpecifiedProps &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::Lookup::SpecifiedProps *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::Lookup::SpecifiedProps>::insert_copy (
        _tao_any,
        CosTrading::Lookup::SpecifiedProps::_tao_any_destructor,
        CosTrading::Lookup::_tc_SpecifiedProps,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Lookup::SpecifiedProps *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Lookup::SpecifiedProps>::insert (
      _tao_any,
      CosTrading::Lookup::SpecifiedProps::_tao_any_destructor,
      CosTrading::Lookup::_tc_SpecifiedProps,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Lookup::SpecifiedProps *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Lookup::SpecifiedProps *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Lookup::SpecifiedProps *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Lookup::SpecifiedProps>::extract (
        _tao_any,
        CosTrading::Lookup::SpecifiedProps::_tao_any_destructor,
        CosTrading::Lookup::_tc_SpecifiedProps,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Lookup::IllegalPreference>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Lookup::IllegalPreference &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::IllegalPreference>::insert_copy (
        _tao_any,
        ::CosTrading::Lookup::IllegalPreference::_tao_any_destructor,
        ::CosTrading::Lookup::_tc_IllegalPreference,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Lookup::IllegalPreference *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::IllegalPreference>::insert (
        _tao_any,
        ::CosTrading::Lookup::IllegalPreference::_tao_any_destructor,
        ::CosTrading::Lookup::_tc_IllegalPreference,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Lookup::IllegalPreference *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Lookup::IllegalPreference *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Lookup::IllegalPreference *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::IllegalPreference>::extract (
          _tao_any,
          ::CosTrading::Lookup::IllegalPreference::_tao_any_destructor,
          ::CosTrading::Lookup::_tc_IllegalPreference,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Lookup::IllegalPreference &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Lookup::IllegalPreference>::insert_copy (
      _tao_any,
      CosTrading::Lookup::IllegalPreference::_tao_any_destructor,
      CosTrading::Lookup::_tc_IllegalPreference,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Lookup::IllegalPreference *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Lookup::IllegalPreference>::insert (
      _tao_any,
      CosTrading::Lookup::IllegalPreference::_tao_any_destructor,
      CosTrading::Lookup::_tc_IllegalPreference,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Lookup::IllegalPreference *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Lookup::IllegalPreference *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Lookup::IllegalPreference *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Lookup::IllegalPreference>::extract (
        _tao_any,
        CosTrading::Lookup::IllegalPreference::_tao_any_destructor,
        CosTrading::Lookup::_tc_IllegalPreference,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Lookup::IllegalPolicyName>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Lookup::IllegalPolicyName &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::IllegalPolicyName>::insert_copy (
        _tao_any,
        ::CosTrading::Lookup::IllegalPolicyName::_tao_any_destructor,
        ::CosTrading::Lookup::_tc_IllegalPolicyName,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Lookup::IllegalPolicyName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::IllegalPolicyName>::insert (
        _tao_any,
        ::CosTrading::Lookup::IllegalPolicyName::_tao_any_destructor,
        ::CosTrading::Lookup::_tc_IllegalPolicyName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Lookup::IllegalPolicyName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Lookup::IllegalPolicyName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Lookup::IllegalPolicyName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::IllegalPolicyName>::extract (
          _tao_any,
          ::CosTrading::Lookup::IllegalPolicyName::_tao_any_destructor,
          ::CosTrading::Lookup::_tc_IllegalPolicyName,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Lookup::IllegalPolicyName &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Lookup::IllegalPolicyName>::insert_copy (
      _tao_any,
      CosTrading::Lookup::IllegalPolicyName::_tao_any_destructor,
      CosTrading::Lookup::_tc_IllegalPolicyName,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Lookup::IllegalPolicyName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Lookup::IllegalPolicyName>::insert (
      _tao_any,
      CosTrading::Lookup::IllegalPolicyName::_tao_any_destructor,
      CosTrading::Lookup::_tc_IllegalPolicyName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Lookup::IllegalPolicyName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Lookup::IllegalPolicyName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Lookup::IllegalPolicyName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Lookup::IllegalPolicyName>::extract (
        _tao_any,
        CosTrading::Lookup::IllegalPolicyName::_tao_any_destructor,
        CosTrading::Lookup::_tc_IllegalPolicyName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Lookup::PolicyTypeMismatch>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Lookup::PolicyTypeMismatch &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::PolicyTypeMismatch>::insert_copy (
        _tao_any,
        ::CosTrading::Lookup::PolicyTypeMismatch::_tao_any_destructor,
        ::CosTrading::Lookup::_tc_PolicyTypeMismatch,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Lookup::PolicyTypeMismatch *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::PolicyTypeMismatch>::insert (
        _tao_any,
        ::CosTrading::Lookup::PolicyTypeMismatch::_tao_any_destructor,
        ::CosTrading::Lookup::_tc_PolicyTypeMismatch,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Lookup::PolicyTypeMismatch *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Lookup::PolicyTypeMismatch *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Lookup::PolicyTypeMismatch *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::PolicyTypeMismatch>::extract (
          _tao_any,
          ::CosTrading::Lookup::PolicyTypeMismatch::_tao_any_destructor,
          ::CosTrading::Lookup::_tc_PolicyTypeMismatch,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Lookup::PolicyTypeMismatch &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Lookup::PolicyTypeMismatch>::insert_copy (
      _tao_any,
      CosTrading::Lookup::PolicyTypeMismatch::_tao_any_destructor,
      CosTrading::Lookup::_tc_PolicyTypeMismatch,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Lookup::PolicyTypeMismatch *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Lookup::PolicyTypeMismatch>::insert (
      _tao_any,
      CosTrading::Lookup::PolicyTypeMismatch::_tao_any_destructor,
      CosTrading::Lookup::_tc_PolicyTypeMismatch,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Lookup::PolicyTypeMismatch *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Lookup::PolicyTypeMismatch *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Lookup::PolicyTypeMismatch *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Lookup::PolicyTypeMismatch>::extract (
        _tao_any,
        CosTrading::Lookup::PolicyTypeMismatch::_tao_any_destructor,
        CosTrading::Lookup::_tc_PolicyTypeMismatch,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Lookup::InvalidPolicyValue>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Lookup::InvalidPolicyValue &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::InvalidPolicyValue>::insert_copy (
        _tao_any,
        ::CosTrading::Lookup::InvalidPolicyValue::_tao_any_destructor,
        ::CosTrading::Lookup::_tc_InvalidPolicyValue,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Lookup::InvalidPolicyValue *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::InvalidPolicyValue>::insert (
        _tao_any,
        ::CosTrading::Lookup::InvalidPolicyValue::_tao_any_destructor,
        ::CosTrading::Lookup::_tc_InvalidPolicyValue,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Lookup::InvalidPolicyValue *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Lookup::InvalidPolicyValue *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Lookup::InvalidPolicyValue *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Lookup::InvalidPolicyValue>::extract (
          _tao_any,
          ::CosTrading::Lookup::InvalidPolicyValue::_tao_any_destructor,
          ::CosTrading::Lookup::_tc_InvalidPolicyValue,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Lookup::InvalidPolicyValue &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Lookup::InvalidPolicyValue>::insert_copy (
      _tao_any,
      CosTrading::Lookup::InvalidPolicyValue::_tao_any_destructor,
      CosTrading::Lookup::_tc_InvalidPolicyValue,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Lookup::InvalidPolicyValue *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Lookup::InvalidPolicyValue>::insert (
      _tao_any,
      CosTrading::Lookup::InvalidPolicyValue::_tao_any_destructor,
      CosTrading::Lookup::_tc_InvalidPolicyValue,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Lookup::InvalidPolicyValue *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Lookup::InvalidPolicyValue *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Lookup::InvalidPolicyValue *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Lookup::InvalidPolicyValue>::extract (
        _tao_any,
        CosTrading::Lookup::InvalidPolicyValue::_tao_any_destructor,
        CosTrading::Lookup::_tc_InvalidPolicyValue,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosTrading::Register>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Register_ptr _tao_elem)
  {
    Register_ptr _tao_objptr =
      Register::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Register_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Register>::insert (
        _tao_any,
        Register::_tao_any_destructor,
        _tc_Register,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Register_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Register>::extract (
          _tao_any,
          Register::_tao_any_destructor,
          _tc_Register,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Register_ptr _tao_elem)
{
  CosTrading::Register_ptr _tao_objptr =
    CosTrading::Register::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Register_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosTrading::Register>::insert (
      _tao_any,
      CosTrading::Register::_tao_any_destructor,
      CosTrading::_tc_Register,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Register_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosTrading::Register>::extract (
        _tao_any,
        CosTrading::Register::_tao_any_destructor,
        CosTrading::_tc_Register,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::OfferInfo &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::Register::OfferInfo *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::Register::OfferInfo>::insert_copy (
          _tao_any,
          ::CosTrading::Register::OfferInfo::_tao_any_destructor,
          ::CosTrading::Register::_tc_OfferInfo,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosTrading::Register::OfferInfo *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::OfferInfo>::insert (
        _tao_any,
        ::CosTrading::Register::OfferInfo::_tao_any_destructor,
        ::CosTrading::Register::_tc_OfferInfo,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Register::OfferInfo *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Register::OfferInfo *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::OfferInfo *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Register::OfferInfo>::extract (
          _tao_any,
          ::CosTrading::Register::OfferInfo::_tao_any_destructor,
          ::CosTrading::Register::_tc_OfferInfo,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Register::OfferInfo &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::Register::OfferInfo *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::Register::OfferInfo>::insert_copy (
        _tao_any,
        CosTrading::Register::OfferInfo::_tao_any_destructor,
        CosTrading::Register::_tc_OfferInfo,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Register::OfferInfo *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::OfferInfo>::insert (
      _tao_any,
      CosTrading::Register::OfferInfo::_tao_any_destructor,
      CosTrading::Register::_tc_OfferInfo,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Register::OfferInfo *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Register::OfferInfo *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Register::OfferInfo *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Register::OfferInfo>::extract (
        _tao_any,
        CosTrading::Register::OfferInfo::_tao_any_destructor,
        CosTrading::Register::_tc_OfferInfo,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Register::InvalidObjectRef>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::InvalidObjectRef &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::InvalidObjectRef>::insert_copy (
        _tao_any,
        ::CosTrading::Register::InvalidObjectRef::_tao_any_destructor,
        ::CosTrading::Register::_tc_InvalidObjectRef,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Register::InvalidObjectRef *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::InvalidObjectRef>::insert (
        _tao_any,
        ::CosTrading::Register::InvalidObjectRef::_tao_any_destructor,
        ::CosTrading::Register::_tc_InvalidObjectRef,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Register::InvalidObjectRef *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Register::InvalidObjectRef *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::InvalidObjectRef *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Register::InvalidObjectRef>::extract (
          _tao_any,
          ::CosTrading::Register::InvalidObjectRef::_tao_any_destructor,
          ::CosTrading::Register::_tc_InvalidObjectRef,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Register::InvalidObjectRef &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::InvalidObjectRef>::insert_copy (
      _tao_any,
      CosTrading::Register::InvalidObjectRef::_tao_any_destructor,
      CosTrading::Register::_tc_InvalidObjectRef,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Register::InvalidObjectRef *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::InvalidObjectRef>::insert (
      _tao_any,
      CosTrading::Register::InvalidObjectRef::_tao_any_destructor,
      CosTrading::Register::_tc_InvalidObjectRef,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Register::InvalidObjectRef *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Register::InvalidObjectRef *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Register::InvalidObjectRef *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Register::InvalidObjectRef>::extract (
        _tao_any,
        CosTrading::Register::InvalidObjectRef::_tao_any_destructor,
        CosTrading::Register::_tc_InvalidObjectRef,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Register::UnknownPropertyName>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::UnknownPropertyName &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::UnknownPropertyName>::insert_copy (
        _tao_any,
        ::CosTrading::Register::UnknownPropertyName::_tao_any_destructor,
        ::CosTrading::Register::_tc_UnknownPropertyName,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Register::UnknownPropertyName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::UnknownPropertyName>::insert (
        _tao_any,
        ::CosTrading::Register::UnknownPropertyName::_tao_any_destructor,
        ::CosTrading::Register::_tc_UnknownPropertyName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Register::UnknownPropertyName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Register::UnknownPropertyName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::UnknownPropertyName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Register::UnknownPropertyName>::extract (
          _tao_any,
          ::CosTrading::Register::UnknownPropertyName::_tao_any_destructor,
          ::CosTrading::Register::_tc_UnknownPropertyName,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Register::UnknownPropertyName &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::UnknownPropertyName>::insert_copy (
      _tao_any,
      CosTrading::Register::UnknownPropertyName::_tao_any_destructor,
      CosTrading::Register::_tc_UnknownPropertyName,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Register::UnknownPropertyName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::UnknownPropertyName>::insert (
      _tao_any,
      CosTrading::Register::UnknownPropertyName::_tao_any_destructor,
      CosTrading::Register::_tc_UnknownPropertyName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Register::UnknownPropertyName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Register::UnknownPropertyName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Register::UnknownPropertyName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Register::UnknownPropertyName>::extract (
        _tao_any,
        CosTrading::Register::UnknownPropertyName::_tao_any_destructor,
        CosTrading::Register::_tc_UnknownPropertyName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Register::InterfaceTypeMismatch>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::InterfaceTypeMismatch &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::InterfaceTypeMismatch>::insert_copy (
        _tao_any,
        ::CosTrading::Register::InterfaceTypeMismatch::_tao_any_destructor,
        ::CosTrading::Register::_tc_InterfaceTypeMismatch,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Register::InterfaceTypeMismatch *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::InterfaceTypeMismatch>::insert (
        _tao_any,
        ::CosTrading::Register::InterfaceTypeMismatch::_tao_any_destructor,
        ::CosTrading::Register::_tc_InterfaceTypeMismatch,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Register::InterfaceTypeMismatch *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Register::InterfaceTypeMismatch *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::InterfaceTypeMismatch *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Register::InterfaceTypeMismatch>::extract (
          _tao_any,
          ::CosTrading::Register::InterfaceTypeMismatch::_tao_any_destructor,
          ::CosTrading::Register::_tc_InterfaceTypeMismatch,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Register::InterfaceTypeMismatch &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::InterfaceTypeMismatch>::insert_copy (
      _tao_any,
      CosTrading::Register::InterfaceTypeMismatch::_tao_any_destructor,
      CosTrading::Register::_tc_InterfaceTypeMismatch,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Register::InterfaceTypeMismatch *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::InterfaceTypeMismatch>::insert (
      _tao_any,
      CosTrading::Register::InterfaceTypeMismatch::_tao_any_destructor,
      CosTrading::Register::_tc_InterfaceTypeMismatch,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Register::InterfaceTypeMismatch *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Register::InterfaceTypeMismatch *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Register::InterfaceTypeMismatch *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Register::InterfaceTypeMismatch>::extract (
        _tao_any,
        CosTrading::Register::InterfaceTypeMismatch::_tao_any_destructor,
        CosTrading::Register::_tc_InterfaceTypeMismatch,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Register::ProxyOfferId>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::ProxyOfferId &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::ProxyOfferId>::insert_copy (
        _tao_any,
        ::CosTrading::Register::ProxyOfferId::_tao_any_destructor,
        ::CosTrading::Register::_tc_ProxyOfferId,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Register::ProxyOfferId *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::ProxyOfferId>::insert (
        _tao_any,
        ::CosTrading::Register::ProxyOfferId::_tao_any_destructor,
        ::CosTrading::Register::_tc_ProxyOfferId,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Register::ProxyOfferId *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Register::ProxyOfferId *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::ProxyOfferId *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Register::ProxyOfferId>::extract (
          _tao_any,
          ::CosTrading::Register::ProxyOfferId::_tao_any_destructor,
          ::CosTrading::Register::_tc_ProxyOfferId,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Register::ProxyOfferId &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::ProxyOfferId>::insert_copy (
      _tao_any,
      CosTrading::Register::ProxyOfferId::_tao_any_destructor,
      CosTrading::Register::_tc_ProxyOfferId,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Register::ProxyOfferId *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::ProxyOfferId>::insert (
      _tao_any,
      CosTrading::Register::ProxyOfferId::_tao_any_destructor,
      CosTrading::Register::_tc_ProxyOfferId,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Register::ProxyOfferId *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Register::ProxyOfferId *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Register::ProxyOfferId *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Register::ProxyOfferId>::extract (
        _tao_any,
        CosTrading::Register::ProxyOfferId::_tao_any_destructor,
        CosTrading::Register::_tc_ProxyOfferId,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Register::MandatoryProperty>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::MandatoryProperty &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::MandatoryProperty>::insert_copy (
        _tao_any,
        ::CosTrading::Register::MandatoryProperty::_tao_any_destructor,
        ::CosTrading::Register::_tc_MandatoryProperty,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Register::MandatoryProperty *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::MandatoryProperty>::insert (
        _tao_any,
        ::CosTrading::Register::MandatoryProperty::_tao_any_destructor,
        ::CosTrading::Register::_tc_MandatoryProperty,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Register::MandatoryProperty *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Register::MandatoryProperty *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::MandatoryProperty *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Register::MandatoryProperty>::extract (
          _tao_any,
          ::CosTrading::Register::MandatoryProperty::_tao_any_destructor,
          ::CosTrading::Register::_tc_MandatoryProperty,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Register::MandatoryProperty &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::MandatoryProperty>::insert_copy (
      _tao_any,
      CosTrading::Register::MandatoryProperty::_tao_any_destructor,
      CosTrading::Register::_tc_MandatoryProperty,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Register::MandatoryProperty *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::MandatoryProperty>::insert (
      _tao_any,
      CosTrading::Register::MandatoryProperty::_tao_any_destructor,
      CosTrading::Register::_tc_MandatoryProperty,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Register::MandatoryProperty *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Register::MandatoryProperty *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Register::MandatoryProperty *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Register::MandatoryProperty>::extract (
        _tao_any,
        CosTrading::Register::MandatoryProperty::_tao_any_destructor,
        CosTrading::Register::_tc_MandatoryProperty,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Register::ReadonlyProperty>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::ReadonlyProperty &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::ReadonlyProperty>::insert_copy (
        _tao_any,
        ::CosTrading::Register::ReadonlyProperty::_tao_any_destructor,
        ::CosTrading::Register::_tc_ReadonlyProperty,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Register::ReadonlyProperty *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::ReadonlyProperty>::insert (
        _tao_any,
        ::CosTrading::Register::ReadonlyProperty::_tao_any_destructor,
        ::CosTrading::Register::_tc_ReadonlyProperty,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Register::ReadonlyProperty *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Register::ReadonlyProperty *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::ReadonlyProperty *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Register::ReadonlyProperty>::extract (
          _tao_any,
          ::CosTrading::Register::ReadonlyProperty::_tao_any_destructor,
          ::CosTrading::Register::_tc_ReadonlyProperty,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Register::ReadonlyProperty &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::ReadonlyProperty>::insert_copy (
      _tao_any,
      CosTrading::Register::ReadonlyProperty::_tao_any_destructor,
      CosTrading::Register::_tc_ReadonlyProperty,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Register::ReadonlyProperty *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::ReadonlyProperty>::insert (
      _tao_any,
      CosTrading::Register::ReadonlyProperty::_tao_any_destructor,
      CosTrading::Register::_tc_ReadonlyProperty,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Register::ReadonlyProperty *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Register::ReadonlyProperty *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Register::ReadonlyProperty *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Register::ReadonlyProperty>::extract (
        _tao_any,
        CosTrading::Register::ReadonlyProperty::_tao_any_destructor,
        CosTrading::Register::_tc_ReadonlyProperty,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Register::NoMatchingOffers>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::NoMatchingOffers &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::NoMatchingOffers>::insert_copy (
        _tao_any,
        ::CosTrading::Register::NoMatchingOffers::_tao_any_destructor,
        ::CosTrading::Register::_tc_NoMatchingOffers,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Register::NoMatchingOffers *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::NoMatchingOffers>::insert (
        _tao_any,
        ::CosTrading::Register::NoMatchingOffers::_tao_any_destructor,
        ::CosTrading::Register::_tc_NoMatchingOffers,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Register::NoMatchingOffers *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Register::NoMatchingOffers *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::NoMatchingOffers *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Register::NoMatchingOffers>::extract (
          _tao_any,
          ::CosTrading::Register::NoMatchingOffers::_tao_any_destructor,
          ::CosTrading::Register::_tc_NoMatchingOffers,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Register::NoMatchingOffers &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::NoMatchingOffers>::insert_copy (
      _tao_any,
      CosTrading::Register::NoMatchingOffers::_tao_any_destructor,
      CosTrading::Register::_tc_NoMatchingOffers,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Register::NoMatchingOffers *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::NoMatchingOffers>::insert (
      _tao_any,
      CosTrading::Register::NoMatchingOffers::_tao_any_destructor,
      CosTrading::Register::_tc_NoMatchingOffers,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Register::NoMatchingOffers *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Register::NoMatchingOffers *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Register::NoMatchingOffers *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Register::NoMatchingOffers>::extract (
        _tao_any,
        CosTrading::Register::NoMatchingOffers::_tao_any_destructor,
        CosTrading::Register::_tc_NoMatchingOffers,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Register::IllegalTraderName>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::IllegalTraderName &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::IllegalTraderName>::insert_copy (
        _tao_any,
        ::CosTrading::Register::IllegalTraderName::_tao_any_destructor,
        ::CosTrading::Register::_tc_IllegalTraderName,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Register::IllegalTraderName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::IllegalTraderName>::insert (
        _tao_any,
        ::CosTrading::Register::IllegalTraderName::_tao_any_destructor,
        ::CosTrading::Register::_tc_IllegalTraderName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Register::IllegalTraderName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Register::IllegalTraderName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::IllegalTraderName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Register::IllegalTraderName>::extract (
          _tao_any,
          ::CosTrading::Register::IllegalTraderName::_tao_any_destructor,
          ::CosTrading::Register::_tc_IllegalTraderName,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Register::IllegalTraderName &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::IllegalTraderName>::insert_copy (
      _tao_any,
      CosTrading::Register::IllegalTraderName::_tao_any_destructor,
      CosTrading::Register::_tc_IllegalTraderName,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Register::IllegalTraderName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::IllegalTraderName>::insert (
      _tao_any,
      CosTrading::Register::IllegalTraderName::_tao_any_destructor,
      CosTrading::Register::_tc_IllegalTraderName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Register::IllegalTraderName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Register::IllegalTraderName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Register::IllegalTraderName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Register::IllegalTraderName>::extract (
        _tao_any,
        CosTrading::Register::IllegalTraderName::_tao_any_destructor,
        CosTrading::Register::_tc_IllegalTraderName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Register::UnknownTraderName>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::UnknownTraderName &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::UnknownTraderName>::insert_copy (
        _tao_any,
        ::CosTrading::Register::UnknownTraderName::_tao_any_destructor,
        ::CosTrading::Register::_tc_UnknownTraderName,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Register::UnknownTraderName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::UnknownTraderName>::insert (
        _tao_any,
        ::CosTrading::Register::UnknownTraderName::_tao_any_destructor,
        ::CosTrading::Register::_tc_UnknownTraderName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Register::UnknownTraderName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Register::UnknownTraderName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::UnknownTraderName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Register::UnknownTraderName>::extract (
          _tao_any,
          ::CosTrading::Register::UnknownTraderName::_tao_any_destructor,
          ::CosTrading::Register::_tc_UnknownTraderName,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Register::UnknownTraderName &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::UnknownTraderName>::insert_copy (
      _tao_any,
      CosTrading::Register::UnknownTraderName::_tao_any_destructor,
      CosTrading::Register::_tc_UnknownTraderName,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Register::UnknownTraderName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::UnknownTraderName>::insert (
      _tao_any,
      CosTrading::Register::UnknownTraderName::_tao_any_destructor,
      CosTrading::Register::_tc_UnknownTraderName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Register::UnknownTraderName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Register::UnknownTraderName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Register::UnknownTraderName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Register::UnknownTraderName>::extract (
        _tao_any,
        CosTrading::Register::UnknownTraderName::_tao_any_destructor,
        CosTrading::Register::_tc_UnknownTraderName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Register::RegisterNotSupported>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::RegisterNotSupported &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::RegisterNotSupported>::insert_copy (
        _tao_any,
        ::CosTrading::Register::RegisterNotSupported::_tao_any_destructor,
        ::CosTrading::Register::_tc_RegisterNotSupported,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Register::RegisterNotSupported *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Register::RegisterNotSupported>::insert (
        _tao_any,
        ::CosTrading::Register::RegisterNotSupported::_tao_any_destructor,
        ::CosTrading::Register::_tc_RegisterNotSupported,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Register::RegisterNotSupported *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Register::RegisterNotSupported *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Register::RegisterNotSupported *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Register::RegisterNotSupported>::extract (
          _tao_any,
          ::CosTrading::Register::RegisterNotSupported::_tao_any_destructor,
          ::CosTrading::Register::_tc_RegisterNotSupported,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Register::RegisterNotSupported &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::RegisterNotSupported>::insert_copy (
      _tao_any,
      CosTrading::Register::RegisterNotSupported::_tao_any_destructor,
      CosTrading::Register::_tc_RegisterNotSupported,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Register::RegisterNotSupported *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Register::RegisterNotSupported>::insert (
      _tao_any,
      CosTrading::Register::RegisterNotSupported::_tao_any_destructor,
      CosTrading::Register::_tc_RegisterNotSupported,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Register::RegisterNotSupported *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Register::RegisterNotSupported *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Register::RegisterNotSupported *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Register::RegisterNotSupported>::extract (
        _tao_any,
        CosTrading::Register::RegisterNotSupported::_tao_any_destructor,
        CosTrading::Register::_tc_RegisterNotSupported,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosTrading::Link>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Link_ptr _tao_elem)
  {
    Link_ptr _tao_objptr =
      Link::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Link_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Link>::insert (
        _tao_any,
        Link::_tao_any_destructor,
        _tc_Link,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Link_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Link>::extract (
          _tao_any,
          Link::_tao_any_destructor,
          _tc_Link,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Link_ptr _tao_elem)
{
  CosTrading::Link_ptr _tao_objptr =
    CosTrading::Link::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Link_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosTrading::Link>::insert (
      _tao_any,
      CosTrading::Link::_tao_any_destructor,
      CosTrading::_tc_Link,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Link_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosTrading::Link>::extract (
        _tao_any,
        CosTrading::Link::_tao_any_destructor,
        CosTrading::_tc_Link,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Link::LinkInfo &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::Link::LinkInfo *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::Link::LinkInfo>::insert_copy (
          _tao_any,
          ::CosTrading::Link::LinkInfo::_tao_any_destructor,
          ::CosTrading::Link::_tc_LinkInfo,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosTrading::Link::LinkInfo *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Link::LinkInfo>::insert (
        _tao_any,
        ::CosTrading::Link::LinkInfo::_tao_any_destructor,
        ::CosTrading::Link::_tc_LinkInfo,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Link::LinkInfo *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Link::LinkInfo *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Link::LinkInfo *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Link::LinkInfo>::extract (
          _tao_any,
          ::CosTrading::Link::LinkInfo::_tao_any_destructor,
          ::CosTrading::Link::_tc_LinkInfo,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Link::LinkInfo &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::Link::LinkInfo *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::Link::LinkInfo>::insert_copy (
        _tao_any,
        CosTrading::Link::LinkInfo::_tao_any_destructor,
        CosTrading::Link::_tc_LinkInfo,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Link::LinkInfo *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Link::LinkInfo>::insert (
      _tao_any,
      CosTrading::Link::LinkInfo::_tao_any_destructor,
      CosTrading::Link::_tc_LinkInfo,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Link::LinkInfo *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Link::LinkInfo *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Link::LinkInfo *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Link::LinkInfo>::extract (
        _tao_any,
        CosTrading::Link::LinkInfo::_tao_any_destructor,
        CosTrading::Link::_tc_LinkInfo,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Link::IllegalLinkName>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Link::IllegalLinkName &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Link::IllegalLinkName>::insert_copy (
        _tao_any,
        ::CosTrading::Link::IllegalLinkName::_tao_any_destructor,
        ::CosTrading::Link::_tc_IllegalLinkName,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Link::IllegalLinkName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Link::IllegalLinkName>::insert (
        _tao_any,
        ::CosTrading::Link::IllegalLinkName::_tao_any_destructor,
        ::CosTrading::Link::_tc_IllegalLinkName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Link::IllegalLinkName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Link::IllegalLinkName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Link::IllegalLinkName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Link::IllegalLinkName>::extract (
          _tao_any,
          ::CosTrading::Link::IllegalLinkName::_tao_any_destructor,
          ::CosTrading::Link::_tc_IllegalLinkName,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Link::IllegalLinkName &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Link::IllegalLinkName>::insert_copy (
      _tao_any,
      CosTrading::Link::IllegalLinkName::_tao_any_destructor,
      CosTrading::Link::_tc_IllegalLinkName,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Link::IllegalLinkName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Link::IllegalLinkName>::insert (
      _tao_any,
      CosTrading::Link::IllegalLinkName::_tao_any_destructor,
      CosTrading::Link::_tc_IllegalLinkName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Link::IllegalLinkName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Link::IllegalLinkName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Link::IllegalLinkName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Link::IllegalLinkName>::extract (
        _tao_any,
        CosTrading::Link::IllegalLinkName::_tao_any_destructor,
        CosTrading::Link::_tc_IllegalLinkName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Link::UnknownLinkName>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Link::UnknownLinkName &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Link::UnknownLinkName>::insert_copy (
        _tao_any,
        ::CosTrading::Link::UnknownLinkName::_tao_any_destructor,
        ::CosTrading::Link::_tc_UnknownLinkName,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Link::UnknownLinkName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Link::UnknownLinkName>::insert (
        _tao_any,
        ::CosTrading::Link::UnknownLinkName::_tao_any_destructor,
        ::CosTrading::Link::_tc_UnknownLinkName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Link::UnknownLinkName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Link::UnknownLinkName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Link::UnknownLinkName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Link::UnknownLinkName>::extract (
          _tao_any,
          ::CosTrading::Link::UnknownLinkName::_tao_any_destructor,
          ::CosTrading::Link::_tc_UnknownLinkName,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Link::UnknownLinkName &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Link::UnknownLinkName>::insert_copy (
      _tao_any,
      CosTrading::Link::UnknownLinkName::_tao_any_destructor,
      CosTrading::Link::_tc_UnknownLinkName,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Link::UnknownLinkName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Link::UnknownLinkName>::insert (
      _tao_any,
      CosTrading::Link::UnknownLinkName::_tao_any_destructor,
      CosTrading::Link::_tc_UnknownLinkName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Link::UnknownLinkName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Link::UnknownLinkName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Link::UnknownLinkName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Link::UnknownLinkName>::extract (
        _tao_any,
        CosTrading::Link::UnknownLinkName::_tao_any_destructor,
        CosTrading::Link::_tc_UnknownLinkName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Link::DuplicateLinkName>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Link::DuplicateLinkName &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Link::DuplicateLinkName>::insert_copy (
        _tao_any,
        ::CosTrading::Link::DuplicateLinkName::_tao_any_destructor,
        ::CosTrading::Link::_tc_DuplicateLinkName,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Link::DuplicateLinkName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Link::DuplicateLinkName>::insert (
        _tao_any,
        ::CosTrading::Link::DuplicateLinkName::_tao_any_destructor,
        ::CosTrading::Link::_tc_DuplicateLinkName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Link::DuplicateLinkName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Link::DuplicateLinkName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Link::DuplicateLinkName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Link::DuplicateLinkName>::extract (
          _tao_any,
          ::CosTrading::Link::DuplicateLinkName::_tao_any_destructor,
          ::CosTrading::Link::_tc_DuplicateLinkName,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Link::DuplicateLinkName &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Link::DuplicateLinkName>::insert_copy (
      _tao_any,
      CosTrading::Link::DuplicateLinkName::_tao_any_destructor,
      CosTrading::Link::_tc_DuplicateLinkName,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Link::DuplicateLinkName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Link::DuplicateLinkName>::insert (
      _tao_any,
      CosTrading::Link::DuplicateLinkName::_tao_any_destructor,
      CosTrading::Link::_tc_DuplicateLinkName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Link::DuplicateLinkName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Link::DuplicateLinkName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Link::DuplicateLinkName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Link::DuplicateLinkName>::extract (
        _tao_any,
        CosTrading::Link::DuplicateLinkName::_tao_any_destructor,
        CosTrading::Link::_tc_DuplicateLinkName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Link::DefaultFollowTooPermissive>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Link::DefaultFollowTooPermissive &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Link::DefaultFollowTooPermissive>::insert_copy (
        _tao_any,
        ::CosTrading::Link::DefaultFollowTooPermissive::_tao_any_destructor,
        ::CosTrading::Link::_tc_DefaultFollowTooPermissive,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Link::DefaultFollowTooPermissive *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Link::DefaultFollowTooPermissive>::insert (
        _tao_any,
        ::CosTrading::Link::DefaultFollowTooPermissive::_tao_any_destructor,
        ::CosTrading::Link::_tc_DefaultFollowTooPermissive,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Link::DefaultFollowTooPermissive *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Link::DefaultFollowTooPermissive *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Link::DefaultFollowTooPermissive *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Link::DefaultFollowTooPermissive>::extract (
          _tao_any,
          ::CosTrading::Link::DefaultFollowTooPermissive::_tao_any_destructor,
          ::CosTrading::Link::_tc_DefaultFollowTooPermissive,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Link::DefaultFollowTooPermissive &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Link::DefaultFollowTooPermissive>::insert_copy (
      _tao_any,
      CosTrading::Link::DefaultFollowTooPermissive::_tao_any_destructor,
      CosTrading::Link::_tc_DefaultFollowTooPermissive,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Link::DefaultFollowTooPermissive *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Link::DefaultFollowTooPermissive>::insert (
      _tao_any,
      CosTrading::Link::DefaultFollowTooPermissive::_tao_any_destructor,
      CosTrading::Link::_tc_DefaultFollowTooPermissive,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Link::DefaultFollowTooPermissive *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Link::DefaultFollowTooPermissive *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Link::DefaultFollowTooPermissive *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Link::DefaultFollowTooPermissive>::extract (
        _tao_any,
        CosTrading::Link::DefaultFollowTooPermissive::_tao_any_destructor,
        CosTrading::Link::_tc_DefaultFollowTooPermissive,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Link::LimitingFollowTooPermissive>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Link::LimitingFollowTooPermissive &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Link::LimitingFollowTooPermissive>::insert_copy (
        _tao_any,
        ::CosTrading::Link::LimitingFollowTooPermissive::_tao_any_destructor,
        ::CosTrading::Link::_tc_LimitingFollowTooPermissive,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Link::LimitingFollowTooPermissive *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Link::LimitingFollowTooPermissive>::insert (
        _tao_any,
        ::CosTrading::Link::LimitingFollowTooPermissive::_tao_any_destructor,
        ::CosTrading::Link::_tc_LimitingFollowTooPermissive,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Link::LimitingFollowTooPermissive *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Link::LimitingFollowTooPermissive *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Link::LimitingFollowTooPermissive *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Link::LimitingFollowTooPermissive>::extract (
          _tao_any,
          ::CosTrading::Link::LimitingFollowTooPermissive::_tao_any_destructor,
          ::CosTrading::Link::_tc_LimitingFollowTooPermissive,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Link::LimitingFollowTooPermissive &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Link::LimitingFollowTooPermissive>::insert_copy (
      _tao_any,
      CosTrading::Link::LimitingFollowTooPermissive::_tao_any_destructor,
      CosTrading::Link::_tc_LimitingFollowTooPermissive,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Link::LimitingFollowTooPermissive *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Link::LimitingFollowTooPermissive>::insert (
      _tao_any,
      CosTrading::Link::LimitingFollowTooPermissive::_tao_any_destructor,
      CosTrading::Link::_tc_LimitingFollowTooPermissive,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Link::LimitingFollowTooPermissive *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Link::LimitingFollowTooPermissive *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Link::LimitingFollowTooPermissive *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Link::LimitingFollowTooPermissive>::extract (
        _tao_any,
        CosTrading::Link::LimitingFollowTooPermissive::_tao_any_destructor,
        CosTrading::Link::_tc_LimitingFollowTooPermissive,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosTrading::Proxy>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Proxy_ptr _tao_elem)
  {
    Proxy_ptr _tao_objptr =
      Proxy::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Proxy_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Proxy>::insert (
        _tao_any,
        Proxy::_tao_any_destructor,
        _tc_Proxy,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Proxy_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Proxy>::extract (
          _tao_any,
          Proxy::_tao_any_destructor,
          _tc_Proxy,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Proxy_ptr _tao_elem)
{
  CosTrading::Proxy_ptr _tao_objptr =
    CosTrading::Proxy::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Proxy_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosTrading::Proxy>::insert (
      _tao_any,
      CosTrading::Proxy::_tao_any_destructor,
      CosTrading::_tc_Proxy,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Proxy_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosTrading::Proxy>::extract (
        _tao_any,
        CosTrading::Proxy::_tao_any_destructor,
        CosTrading::_tc_Proxy,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Proxy::ProxyInfo &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::Proxy::ProxyInfo *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::Proxy::ProxyInfo>::insert_copy (
          _tao_any,
          ::CosTrading::Proxy::ProxyInfo::_tao_any_destructor,
          ::CosTrading::Proxy::_tc_ProxyInfo,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosTrading::Proxy::ProxyInfo *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Proxy::ProxyInfo>::insert (
        _tao_any,
        ::CosTrading::Proxy::ProxyInfo::_tao_any_destructor,
        ::CosTrading::Proxy::_tc_ProxyInfo,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Proxy::ProxyInfo *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Proxy::ProxyInfo *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Proxy::ProxyInfo *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Proxy::ProxyInfo>::extract (
          _tao_any,
          ::CosTrading::Proxy::ProxyInfo::_tao_any_destructor,
          ::CosTrading::Proxy::_tc_ProxyInfo,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Proxy::ProxyInfo &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::Proxy::ProxyInfo *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::Proxy::ProxyInfo>::insert_copy (
        _tao_any,
        CosTrading::Proxy::ProxyInfo::_tao_any_destructor,
        CosTrading::Proxy::_tc_ProxyInfo,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Proxy::ProxyInfo *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Proxy::ProxyInfo>::insert (
      _tao_any,
      CosTrading::Proxy::ProxyInfo::_tao_any_destructor,
      CosTrading::Proxy::_tc_ProxyInfo,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Proxy::ProxyInfo *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Proxy::ProxyInfo *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Proxy::ProxyInfo *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Proxy::ProxyInfo>::extract (
        _tao_any,
        CosTrading::Proxy::ProxyInfo::_tao_any_destructor,
        CosTrading::Proxy::_tc_ProxyInfo,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Proxy::IllegalRecipe>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Proxy::IllegalRecipe &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Proxy::IllegalRecipe>::insert_copy (
        _tao_any,
        ::CosTrading::Proxy::IllegalRecipe::_tao_any_destructor,
        ::CosTrading::Proxy::_tc_IllegalRecipe,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Proxy::IllegalRecipe *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Proxy::IllegalRecipe>::insert (
        _tao_any,
        ::CosTrading::Proxy::IllegalRecipe::_tao_any_destructor,
        ::CosTrading::Proxy::_tc_IllegalRecipe,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Proxy::IllegalRecipe *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Proxy::IllegalRecipe *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Proxy::IllegalRecipe *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Proxy::IllegalRecipe>::extract (
          _tao_any,
          ::CosTrading::Proxy::IllegalRecipe::_tao_any_destructor,
          ::CosTrading::Proxy::_tc_IllegalRecipe,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Proxy::IllegalRecipe &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Proxy::IllegalRecipe>::insert_copy (
      _tao_any,
      CosTrading::Proxy::IllegalRecipe::_tao_any_destructor,
      CosTrading::Proxy::_tc_IllegalRecipe,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Proxy::IllegalRecipe *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Proxy::IllegalRecipe>::insert (
      _tao_any,
      CosTrading::Proxy::IllegalRecipe::_tao_any_destructor,
      CosTrading::Proxy::_tc_IllegalRecipe,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Proxy::IllegalRecipe *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Proxy::IllegalRecipe *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Proxy::IllegalRecipe *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Proxy::IllegalRecipe>::extract (
        _tao_any,
        CosTrading::Proxy::IllegalRecipe::_tao_any_destructor,
        CosTrading::Proxy::_tc_IllegalRecipe,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosTrading::Proxy::NotProxyOfferId>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Proxy::NotProxyOfferId &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Proxy::NotProxyOfferId>::insert_copy (
        _tao_any,
        ::CosTrading::Proxy::NotProxyOfferId::_tao_any_destructor,
        ::CosTrading::Proxy::_tc_NotProxyOfferId,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Proxy::NotProxyOfferId *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Proxy::NotProxyOfferId>::insert (
        _tao_any,
        ::CosTrading::Proxy::NotProxyOfferId::_tao_any_destructor,
        ::CosTrading::Proxy::_tc_NotProxyOfferId,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Proxy::NotProxyOfferId *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Proxy::NotProxyOfferId *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Proxy::NotProxyOfferId *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Proxy::NotProxyOfferId>::extract (
          _tao_any,
          ::CosTrading::Proxy::NotProxyOfferId::_tao_any_destructor,
          ::CosTrading::Proxy::_tc_NotProxyOfferId,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Proxy::NotProxyOfferId &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Proxy::NotProxyOfferId>::insert_copy (
      _tao_any,
      CosTrading::Proxy::NotProxyOfferId::_tao_any_destructor,
      CosTrading::Proxy::_tc_NotProxyOfferId,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Proxy::NotProxyOfferId *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Proxy::NotProxyOfferId>::insert (
      _tao_any,
      CosTrading::Proxy::NotProxyOfferId::_tao_any_destructor,
      CosTrading::Proxy::_tc_NotProxyOfferId,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Proxy::NotProxyOfferId *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Proxy::NotProxyOfferId *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Proxy::NotProxyOfferId *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Proxy::NotProxyOfferId>::extract (
        _tao_any,
        CosTrading::Proxy::NotProxyOfferId::_tao_any_destructor,
        CosTrading::Proxy::_tc_NotProxyOfferId,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosTrading::Admin>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Admin_ptr _tao_elem)
  {
    Admin_ptr _tao_objptr =
      Admin::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Admin_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Admin>::insert (
        _tao_any,
        Admin::_tao_any_destructor,
        _tc_Admin,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Admin_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Admin>::extract (
          _tao_any,
          Admin::_tao_any_destructor,
          _tc_Admin,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Admin_ptr _tao_elem)
{
  CosTrading::Admin_ptr _tao_objptr =
    CosTrading::Admin::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Admin_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosTrading::Admin>::insert (
      _tao_any,
      CosTrading::Admin::_tao_any_destructor,
      CosTrading::_tc_Admin,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Admin_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosTrading::Admin>::extract (
        _tao_any,
        CosTrading::Admin::_tao_any_destructor,
        CosTrading::_tc_Admin,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosTrading::Admin::OctetSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosTrading::Admin::OctetSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosTrading::Admin::OctetSeq>::insert_copy (
          _tao_any,
          ::CosTrading::Admin::OctetSeq::_tao_any_destructor,
          ::CosTrading::Admin::_tc_OctetSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosTrading::Admin::OctetSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosTrading::Admin::OctetSeq>::insert (
        _tao_any,
        ::CosTrading::Admin::OctetSeq::_tao_any_destructor,
        ::CosTrading::Admin::_tc_OctetSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosTrading::Admin::OctetSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosTrading::Admin::OctetSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosTrading::Admin::OctetSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosTrading::Admin::OctetSeq>::extract (
          _tao_any,
          ::CosTrading::Admin::OctetSeq::_tao_any_destructor,
          ::CosTrading::Admin::_tc_OctetSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosTrading::Admin::OctetSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosTrading::Admin::OctetSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosTrading::Admin::OctetSeq>::insert_copy (
        _tao_any,
        CosTrading::Admin::OctetSeq::_tao_any_destructor,
        CosTrading::Admin::_tc_OctetSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::Admin::OctetSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosTrading::Admin::OctetSeq>::insert (
      _tao_any,
      CosTrading::Admin::OctetSeq::_tao_any_destructor,
      CosTrading::Admin::_tc_OctetSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::Admin::OctetSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosTrading::Admin::OctetSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosTrading::Admin::OctetSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosTrading::Admin::OctetSeq>::extract (
        _tao_any,
        CosTrading::Admin::OctetSeq::_tao_any_destructor,
        CosTrading::Admin::_tc_OctetSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosTrading::OfferIterator>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      OfferIterator_ptr _tao_elem)
  {
    OfferIterator_ptr _tao_objptr =
      OfferIterator::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      OfferIterator_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<OfferIterator>::insert (
        _tao_any,
        OfferIterator::_tao_any_destructor,
        _tc_OfferIterator,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      OfferIterator_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<OfferIterator>::extract (
          _tao_any,
          OfferIterator::_tao_any_destructor,
          _tc_OfferIterator,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::OfferIterator_ptr _tao_elem)
{
  CosTrading::OfferIterator_ptr _tao_objptr =
    CosTrading::OfferIterator::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::OfferIterator_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosTrading::OfferIterator>::insert (
      _tao_any,
      CosTrading::OfferIterator::_tao_any_destructor,
      CosTrading::_tc_OfferIterator,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::OfferIterator_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosTrading::OfferIterator>::extract (
        _tao_any,
        CosTrading::OfferIterator::_tao_any_destructor,
        CosTrading::_tc_OfferIterator,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosTrading::OfferIdIterator>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosTrading
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      OfferIdIterator_ptr _tao_elem)
  {
    OfferIdIterator_ptr _tao_objptr =
      OfferIdIterator::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      OfferIdIterator_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<OfferIdIterator>::insert (
        _tao_any,
        OfferIdIterator::_tao_any_destructor,
        _tc_OfferIdIterator,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      OfferIdIterator_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<OfferIdIterator>::extract (
          _tao_any,
          OfferIdIterator::_tao_any_destructor,
          _tc_OfferIdIterator,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::OfferIdIterator_ptr _tao_elem)
{
  CosTrading::OfferIdIterator_ptr _tao_objptr =
    CosTrading::OfferIdIterator::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosTrading::OfferIdIterator_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosTrading::OfferIdIterator>::insert (
      _tao_any,
      CosTrading::OfferIdIterator::_tao_any_destructor,
      CosTrading::_tc_OfferIdIterator,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosTrading::OfferIdIterator_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosTrading::OfferIdIterator>::extract (
        _tao_any,
        CosTrading::OfferIdIterator::_tao_any_destructor,
        CosTrading::_tc_OfferIdIterator,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTrading_PropertyNameSeq_CPP_
#define _TAO_CDR_OP_CosTrading_PropertyNameSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::PropertyNameSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::PropertyNameSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTrading_PropertyNameSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Property &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Property &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTrading_PropertySeq_CPP_
#define _TAO_CDR_OP_CosTrading_PropertySeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::PropertySeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::PropertySeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTrading_PropertySeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Offer &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.reference.in ()) &&
    (strm << _tao_aggregate.properties);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Offer &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.reference.out ()) &&
    (strm >> _tao_aggregate.properties);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTrading_OfferSeq_CPP_
#define _TAO_CDR_OP_CosTrading_OfferSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::OfferSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::OfferSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTrading_OfferSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTrading_OfferIdSeq_CPP_
#define _TAO_CDR_OP_CosTrading_OfferIdSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::OfferIdSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::OfferIdSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTrading_OfferIdSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CosTrading::FollowOption _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, CosTrading::FollowOption & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<CosTrading::FollowOption> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTrading_LinkNameSeq_CPP_
#define _TAO_CDR_OP_CosTrading_LinkNameSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::LinkNameSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::LinkNameSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTrading_LinkNameSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTrading_PolicyNameSeq_CPP_
#define _TAO_CDR_OP_CosTrading_PolicyNameSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::PolicyNameSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::PolicyNameSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTrading_PolicyNameSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Policy &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Policy &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTrading_PolicySeq_CPP_
#define _TAO_CDR_OP_CosTrading_PolicySeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::PolicySeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::PolicySeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTrading_PolicySeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::UnknownMaxLeft &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CosTrading::UnknownMaxLeft&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::NotImplemented &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CosTrading::NotImplemented&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::IllegalServiceType &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.type.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::IllegalServiceType &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.type.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::UnknownServiceType &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.type.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::UnknownServiceType &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.type.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::IllegalPropertyName &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::IllegalPropertyName &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::DuplicatePropertyName &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::DuplicatePropertyName &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::PropertyTypeMismatch &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.type.in ()) &&
        (strm << _tao_aggregate.prop)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::PropertyTypeMismatch &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> _tao_aggregate.prop)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::MissingMandatoryProperty &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.type.in ()) &&
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::MissingMandatoryProperty &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::ReadonlyDynamicProperty &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.type.in ()) &&
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::ReadonlyDynamicProperty &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::IllegalConstraint &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.constr.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::IllegalConstraint &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.constr.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::InvalidLookupRef &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        ::CORBA::Object::marshal (
            _tao_aggregate.target.in (),
            strm
          )
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::InvalidLookupRef &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.target.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::IllegalOfferId &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.id.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::IllegalOfferId &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.id.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::UnknownOfferId &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.id.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::UnknownOfferId &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.id.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::DuplicatePolicyName &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::DuplicatePolicyName &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::TraderComponents_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::TraderComponents_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosTrading::TraderComponents RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosTrading__TAO_TraderComponents_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::SupportAttributes_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::SupportAttributes_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosTrading::SupportAttributes RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosTrading__TAO_SupportAttributes_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::ImportAttributes_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::ImportAttributes_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosTrading::ImportAttributes RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosTrading__TAO_ImportAttributes_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::LinkAttributes_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::LinkAttributes_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosTrading::LinkAttributes RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosTrading__TAO_LinkAttributes_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, CosTrading::Lookup::HowManyProps _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, CosTrading::Lookup::HowManyProps & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<CosTrading::Lookup::HowManyProps> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_union/cdr_op_cs.cpp:82



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Lookup::SpecifiedProps &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case CosTrading::Lookup::some:
      {
        result = strm << _tao_union.prop_names ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Lookup::SpecifiedProps &_tao_union
  )
{
  CosTrading::Lookup::HowManyProps _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case CosTrading::Lookup::some:
      {
        CosTrading::PropertyNameSeq _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.prop_names (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatability, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Lookup::IllegalPreference &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.pref.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Lookup::IllegalPreference &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.pref.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Lookup::IllegalPolicyName &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Lookup::IllegalPolicyName &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Lookup::PolicyTypeMismatch &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.the_policy)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Lookup::PolicyTypeMismatch &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.the_policy)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Lookup::InvalidPolicyValue &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.the_policy)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Lookup::InvalidPolicyValue &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.the_policy)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Lookup_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Lookup_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosTrading::Lookup RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosTrading__TAO_Lookup_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Register::OfferInfo &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.reference.in ()) &&
    (strm << _tao_aggregate.type.in ()) &&
    (strm << _tao_aggregate.properties);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Register::OfferInfo &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.reference.out ()) &&
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> _tao_aggregate.properties);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Register::InvalidObjectRef &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.ref.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Register::InvalidObjectRef &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.ref.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Register::UnknownPropertyName &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Register::UnknownPropertyName &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Register::InterfaceTypeMismatch &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.type.in ()) &&
        (strm << _tao_aggregate.reference.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Register::InterfaceTypeMismatch &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> _tao_aggregate.reference.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Register::ProxyOfferId &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.id.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Register::ProxyOfferId &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.id.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Register::MandatoryProperty &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.type.in ()) &&
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Register::MandatoryProperty &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Register::ReadonlyProperty &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.type.in ()) &&
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Register::ReadonlyProperty &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Register::NoMatchingOffers &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.constr.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Register::NoMatchingOffers &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.constr.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Register::IllegalTraderName &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Register::IllegalTraderName &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Register::UnknownTraderName &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Register::UnknownTraderName &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Register::RegisterNotSupported &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Register::RegisterNotSupported &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Register_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Register_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosTrading::Register RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosTrading__TAO_Register_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Link::LinkInfo &_tao_aggregate)
{
  return
    ::CORBA::Object::marshal (
        _tao_aggregate.target.in (),
        strm
      ) &&
    ::CORBA::Object::marshal (
        _tao_aggregate.target_reg.in (),
        strm
      ) &&
    (strm << _tao_aggregate.def_pass_on_follow_rule) &&
    (strm << _tao_aggregate.limiting_follow_rule);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Link::LinkInfo &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.target.out ()) &&
    (strm >> _tao_aggregate.target_reg.out ()) &&
    (strm >> _tao_aggregate.def_pass_on_follow_rule) &&
    (strm >> _tao_aggregate.limiting_follow_rule);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Link::IllegalLinkName &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Link::IllegalLinkName &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Link::UnknownLinkName &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Link::UnknownLinkName &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Link::DuplicateLinkName &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Link::DuplicateLinkName &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Link::DefaultFollowTooPermissive &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.def_pass_on_follow_rule) &&
        (strm << _tao_aggregate.limiting_follow_rule)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Link::DefaultFollowTooPermissive &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.def_pass_on_follow_rule) &&
    (strm >> _tao_aggregate.limiting_follow_rule)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Link::LimitingFollowTooPermissive &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.limiting_follow_rule) &&
        (strm << _tao_aggregate.max_link_follow_policy)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Link::LimitingFollowTooPermissive &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.limiting_follow_rule) &&
    (strm >> _tao_aggregate.max_link_follow_policy)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Link_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Link_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosTrading::Link RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosTrading__TAO_Link_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Proxy::ProxyInfo &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.type.in ()) &&
    ::CORBA::Object::marshal (
        _tao_aggregate.target.in (),
        strm
      ) &&
    (strm << _tao_aggregate.properties) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.if_match_all)) &&
    (strm << _tao_aggregate.recipe.in ()) &&
    (strm << _tao_aggregate.policies_to_pass_on);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Proxy::ProxyInfo &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> _tao_aggregate.target.out ()) &&
    (strm >> _tao_aggregate.properties) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.if_match_all)) &&
    (strm >> _tao_aggregate.recipe.out ()) &&
    (strm >> _tao_aggregate.policies_to_pass_on);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Proxy::IllegalRecipe &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.recipe.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Proxy::IllegalRecipe &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.recipe.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Proxy::NotProxyOfferId &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.id.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Proxy::NotProxyOfferId &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.id.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Proxy_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Proxy_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosTrading::Proxy RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosTrading__TAO_Proxy_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosTrading_Admin_OctetSeq_CPP_
#define _TAO_CDR_OP_CosTrading_Admin_OctetSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Admin::OctetSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Admin::OctetSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosTrading_Admin_OctetSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::Admin_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::Admin_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosTrading::Admin RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosTrading__TAO_Admin_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::OfferIterator_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::OfferIterator_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosTrading::OfferIterator RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosTrading__TAO_OfferIterator_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosTrading::OfferIdIterator_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosTrading::OfferIdIterator_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosTrading::OfferIdIterator RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosTrading__TAO_OfferIdIterator_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL





TAO_END_VERSIONED_NAMESPACE_DECL


