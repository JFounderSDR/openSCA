// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "DsLogAdminC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "DsLogAdminC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

DsLogAdmin::InvalidParam::InvalidParam (
    const char * _tao_details)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/InvalidParam:1.0",
        "InvalidParam"
      )
{
  this->details = ::CORBA::string_dup (_tao_details);
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::InvalidParam::InvalidParam (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/InvalidParam:1.0",
        "InvalidParam"
      )
{
}

DsLogAdmin::InvalidParam::~InvalidParam (void)
{
}

DsLogAdmin::InvalidParam::InvalidParam (const ::DsLogAdmin::InvalidParam &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->details = ::CORBA::string_dup (_tao_excp.details.in ());
}

DsLogAdmin::InvalidParam&
DsLogAdmin::InvalidParam::operator= (const ::DsLogAdmin::InvalidParam &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->details = ::CORBA::string_dup (_tao_excp.details.in ());
  return *this;
}

void DsLogAdmin::InvalidParam::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidParam *_tao_tmp_pointer =
    static_cast<InvalidParam *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::InvalidParam *
DsLogAdmin::InvalidParam::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidParam *> (_tao_excp);
}

const DsLogAdmin::InvalidParam *
DsLogAdmin::InvalidParam::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidParam *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::InvalidParam::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::InvalidParam, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::InvalidParam::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::InvalidParam (*this),
      0
    );
  return result;
}

void DsLogAdmin::InvalidParam::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::InvalidParam::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::InvalidParam::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::InvalidParam::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_InvalidParam;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_DsLogAdmin_InvalidParam[] =
      {
        { "details", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_InvalidParam (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/InvalidParam:1.0",
  "InvalidParam",
  _tao_fields_DsLogAdmin_InvalidParam,
  1);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_InvalidParam =
    &_tao_tc_DsLogAdmin_InvalidParam;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::InvalidThreshold::InvalidThreshold (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/InvalidThreshold:1.0",
        "InvalidThreshold"
      )
{
}

DsLogAdmin::InvalidThreshold::~InvalidThreshold (void)
{
}

DsLogAdmin::InvalidThreshold::InvalidThreshold (const ::DsLogAdmin::InvalidThreshold &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DsLogAdmin::InvalidThreshold&
DsLogAdmin::InvalidThreshold::operator= (const ::DsLogAdmin::InvalidThreshold &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DsLogAdmin::InvalidThreshold::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidThreshold *_tao_tmp_pointer =
    static_cast<InvalidThreshold *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::InvalidThreshold *
DsLogAdmin::InvalidThreshold::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidThreshold *> (_tao_excp);
}

const DsLogAdmin::InvalidThreshold *
DsLogAdmin::InvalidThreshold::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidThreshold *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::InvalidThreshold::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::InvalidThreshold, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::InvalidThreshold::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::InvalidThreshold (*this),
      0
    );
  return result;
}

void DsLogAdmin::InvalidThreshold::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::InvalidThreshold::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::InvalidThreshold::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::InvalidThreshold::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_InvalidThreshold;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DsLogAdmin_InvalidThreshold = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_InvalidThreshold (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/InvalidThreshold:1.0",
  "InvalidThreshold",
  _tao_fields_DsLogAdmin_InvalidThreshold,
  0);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_InvalidThreshold =
    &_tao_tc_DsLogAdmin_InvalidThreshold;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::InvalidTime::InvalidTime (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/InvalidTime:1.0",
        "InvalidTime"
      )
{
}

DsLogAdmin::InvalidTime::~InvalidTime (void)
{
}

DsLogAdmin::InvalidTime::InvalidTime (const ::DsLogAdmin::InvalidTime &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DsLogAdmin::InvalidTime&
DsLogAdmin::InvalidTime::operator= (const ::DsLogAdmin::InvalidTime &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DsLogAdmin::InvalidTime::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidTime *_tao_tmp_pointer =
    static_cast<InvalidTime *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::InvalidTime *
DsLogAdmin::InvalidTime::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidTime *> (_tao_excp);
}

const DsLogAdmin::InvalidTime *
DsLogAdmin::InvalidTime::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidTime *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::InvalidTime::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::InvalidTime, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::InvalidTime::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::InvalidTime (*this),
      0
    );
  return result;
}

void DsLogAdmin::InvalidTime::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::InvalidTime::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::InvalidTime::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::InvalidTime::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_InvalidTime;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DsLogAdmin_InvalidTime = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_InvalidTime (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/InvalidTime:1.0",
  "InvalidTime",
  _tao_fields_DsLogAdmin_InvalidTime,
  0);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_InvalidTime =
    &_tao_tc_DsLogAdmin_InvalidTime;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::InvalidTimeInterval::InvalidTimeInterval (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/InvalidTimeInterval:1.0",
        "InvalidTimeInterval"
      )
{
}

DsLogAdmin::InvalidTimeInterval::~InvalidTimeInterval (void)
{
}

DsLogAdmin::InvalidTimeInterval::InvalidTimeInterval (const ::DsLogAdmin::InvalidTimeInterval &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DsLogAdmin::InvalidTimeInterval&
DsLogAdmin::InvalidTimeInterval::operator= (const ::DsLogAdmin::InvalidTimeInterval &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DsLogAdmin::InvalidTimeInterval::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidTimeInterval *_tao_tmp_pointer =
    static_cast<InvalidTimeInterval *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::InvalidTimeInterval *
DsLogAdmin::InvalidTimeInterval::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidTimeInterval *> (_tao_excp);
}

const DsLogAdmin::InvalidTimeInterval *
DsLogAdmin::InvalidTimeInterval::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidTimeInterval *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::InvalidTimeInterval::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::InvalidTimeInterval, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::InvalidTimeInterval::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::InvalidTimeInterval (*this),
      0
    );
  return result;
}

void DsLogAdmin::InvalidTimeInterval::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::InvalidTimeInterval::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::InvalidTimeInterval::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::InvalidTimeInterval::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_InvalidTimeInterval;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DsLogAdmin_InvalidTimeInterval = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_InvalidTimeInterval (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/InvalidTimeInterval:1.0",
  "InvalidTimeInterval",
  _tao_fields_DsLogAdmin_InvalidTimeInterval,
  0);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_InvalidTimeInterval =
    &_tao_tc_DsLogAdmin_InvalidTimeInterval;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::InvalidMask::InvalidMask (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/InvalidMask:1.0",
        "InvalidMask"
      )
{
}

DsLogAdmin::InvalidMask::~InvalidMask (void)
{
}

DsLogAdmin::InvalidMask::InvalidMask (const ::DsLogAdmin::InvalidMask &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DsLogAdmin::InvalidMask&
DsLogAdmin::InvalidMask::operator= (const ::DsLogAdmin::InvalidMask &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DsLogAdmin::InvalidMask::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidMask *_tao_tmp_pointer =
    static_cast<InvalidMask *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::InvalidMask *
DsLogAdmin::InvalidMask::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidMask *> (_tao_excp);
}

const DsLogAdmin::InvalidMask *
DsLogAdmin::InvalidMask::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidMask *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::InvalidMask::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::InvalidMask, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::InvalidMask::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::InvalidMask (*this),
      0
    );
  return result;
}

void DsLogAdmin::InvalidMask::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::InvalidMask::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::InvalidMask::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::InvalidMask::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_InvalidMask;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DsLogAdmin_InvalidMask = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_InvalidMask (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/InvalidMask:1.0",
  "InvalidMask",
  _tao_fields_DsLogAdmin_InvalidMask,
  0);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_InvalidMask =
    &_tao_tc_DsLogAdmin_InvalidMask;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::LogIdAlreadyExists::LogIdAlreadyExists (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/LogIdAlreadyExists:1.0",
        "LogIdAlreadyExists"
      )
{
}

DsLogAdmin::LogIdAlreadyExists::~LogIdAlreadyExists (void)
{
}

DsLogAdmin::LogIdAlreadyExists::LogIdAlreadyExists (const ::DsLogAdmin::LogIdAlreadyExists &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DsLogAdmin::LogIdAlreadyExists&
DsLogAdmin::LogIdAlreadyExists::operator= (const ::DsLogAdmin::LogIdAlreadyExists &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DsLogAdmin::LogIdAlreadyExists::_tao_any_destructor (void *_tao_void_pointer)
{
  LogIdAlreadyExists *_tao_tmp_pointer =
    static_cast<LogIdAlreadyExists *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::LogIdAlreadyExists *
DsLogAdmin::LogIdAlreadyExists::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<LogIdAlreadyExists *> (_tao_excp);
}

const DsLogAdmin::LogIdAlreadyExists *
DsLogAdmin::LogIdAlreadyExists::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const LogIdAlreadyExists *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::LogIdAlreadyExists::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::LogIdAlreadyExists, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::LogIdAlreadyExists::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::LogIdAlreadyExists (*this),
      0
    );
  return result;
}

void DsLogAdmin::LogIdAlreadyExists::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::LogIdAlreadyExists::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::LogIdAlreadyExists::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::LogIdAlreadyExists::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_LogIdAlreadyExists;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DsLogAdmin_LogIdAlreadyExists = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_LogIdAlreadyExists (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/LogIdAlreadyExists:1.0",
  "LogIdAlreadyExists",
  _tao_fields_DsLogAdmin_LogIdAlreadyExists,
  0);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_LogIdAlreadyExists =
    &_tao_tc_DsLogAdmin_LogIdAlreadyExists;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::InvalidGrammar::InvalidGrammar (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/InvalidGrammar:1.0",
        "InvalidGrammar"
      )
{
}

DsLogAdmin::InvalidGrammar::~InvalidGrammar (void)
{
}

DsLogAdmin::InvalidGrammar::InvalidGrammar (const ::DsLogAdmin::InvalidGrammar &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DsLogAdmin::InvalidGrammar&
DsLogAdmin::InvalidGrammar::operator= (const ::DsLogAdmin::InvalidGrammar &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DsLogAdmin::InvalidGrammar::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidGrammar *_tao_tmp_pointer =
    static_cast<InvalidGrammar *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::InvalidGrammar *
DsLogAdmin::InvalidGrammar::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidGrammar *> (_tao_excp);
}

const DsLogAdmin::InvalidGrammar *
DsLogAdmin::InvalidGrammar::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidGrammar *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::InvalidGrammar::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::InvalidGrammar, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::InvalidGrammar::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::InvalidGrammar (*this),
      0
    );
  return result;
}

void DsLogAdmin::InvalidGrammar::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::InvalidGrammar::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::InvalidGrammar::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::InvalidGrammar::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_InvalidGrammar;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DsLogAdmin_InvalidGrammar = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_InvalidGrammar (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/InvalidGrammar:1.0",
  "InvalidGrammar",
  _tao_fields_DsLogAdmin_InvalidGrammar,
  0);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_InvalidGrammar =
    &_tao_tc_DsLogAdmin_InvalidGrammar;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::InvalidConstraint::InvalidConstraint (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/InvalidConstraint:1.0",
        "InvalidConstraint"
      )
{
}

DsLogAdmin::InvalidConstraint::~InvalidConstraint (void)
{
}

DsLogAdmin::InvalidConstraint::InvalidConstraint (const ::DsLogAdmin::InvalidConstraint &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DsLogAdmin::InvalidConstraint&
DsLogAdmin::InvalidConstraint::operator= (const ::DsLogAdmin::InvalidConstraint &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DsLogAdmin::InvalidConstraint::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidConstraint *_tao_tmp_pointer =
    static_cast<InvalidConstraint *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::InvalidConstraint *
DsLogAdmin::InvalidConstraint::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidConstraint *> (_tao_excp);
}

const DsLogAdmin::InvalidConstraint *
DsLogAdmin::InvalidConstraint::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidConstraint *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::InvalidConstraint::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::InvalidConstraint, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::InvalidConstraint::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::InvalidConstraint (*this),
      0
    );
  return result;
}

void DsLogAdmin::InvalidConstraint::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::InvalidConstraint::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::InvalidConstraint::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::InvalidConstraint::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_InvalidConstraint;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DsLogAdmin_InvalidConstraint = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_InvalidConstraint (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/InvalidConstraint:1.0",
  "InvalidConstraint",
  _tao_fields_DsLogAdmin_InvalidConstraint,
  0);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_InvalidConstraint =
    &_tao_tc_DsLogAdmin_InvalidConstraint;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

DsLogAdmin::LogFull::LogFull (
    ::CORBA::Short _tao_n_records_written)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/LogFull:1.0",
        "LogFull"
      )
{
  this->n_records_written = _tao_n_records_written;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::LogFull::LogFull (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/LogFull:1.0",
        "LogFull"
      )
{
}

DsLogAdmin::LogFull::~LogFull (void)
{
}

DsLogAdmin::LogFull::LogFull (const ::DsLogAdmin::LogFull &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->n_records_written = _tao_excp.n_records_written;
}

DsLogAdmin::LogFull&
DsLogAdmin::LogFull::operator= (const ::DsLogAdmin::LogFull &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->n_records_written = _tao_excp.n_records_written;
  return *this;
}

void DsLogAdmin::LogFull::_tao_any_destructor (void *_tao_void_pointer)
{
  LogFull *_tao_tmp_pointer =
    static_cast<LogFull *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::LogFull *
DsLogAdmin::LogFull::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<LogFull *> (_tao_excp);
}

const DsLogAdmin::LogFull *
DsLogAdmin::LogFull::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const LogFull *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::LogFull::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::LogFull, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::LogFull::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::LogFull (*this),
      0
    );
  return result;
}

void DsLogAdmin::LogFull::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::LogFull::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::LogFull::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::LogFull::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_LogFull;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_DsLogAdmin_LogFull[] =
      {
        { "n_records_written", &CORBA::_tc_short }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_LogFull (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/LogFull:1.0",
  "LogFull",
  _tao_fields_DsLogAdmin_LogFull,
  1);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_LogFull =
    &_tao_tc_DsLogAdmin_LogFull;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::LogOffDuty::LogOffDuty (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/LogOffDuty:1.0",
        "LogOffDuty"
      )
{
}

DsLogAdmin::LogOffDuty::~LogOffDuty (void)
{
}

DsLogAdmin::LogOffDuty::LogOffDuty (const ::DsLogAdmin::LogOffDuty &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DsLogAdmin::LogOffDuty&
DsLogAdmin::LogOffDuty::operator= (const ::DsLogAdmin::LogOffDuty &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DsLogAdmin::LogOffDuty::_tao_any_destructor (void *_tao_void_pointer)
{
  LogOffDuty *_tao_tmp_pointer =
    static_cast<LogOffDuty *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::LogOffDuty *
DsLogAdmin::LogOffDuty::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<LogOffDuty *> (_tao_excp);
}

const DsLogAdmin::LogOffDuty *
DsLogAdmin::LogOffDuty::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const LogOffDuty *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::LogOffDuty::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::LogOffDuty, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::LogOffDuty::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::LogOffDuty (*this),
      0
    );
  return result;
}

void DsLogAdmin::LogOffDuty::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::LogOffDuty::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::LogOffDuty::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::LogOffDuty::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_LogOffDuty;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DsLogAdmin_LogOffDuty = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_LogOffDuty (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/LogOffDuty:1.0",
  "LogOffDuty",
  _tao_fields_DsLogAdmin_LogOffDuty,
  0);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_LogOffDuty =
    &_tao_tc_DsLogAdmin_LogOffDuty;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::LogLocked::LogLocked (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/LogLocked:1.0",
        "LogLocked"
      )
{
}

DsLogAdmin::LogLocked::~LogLocked (void)
{
}

DsLogAdmin::LogLocked::LogLocked (const ::DsLogAdmin::LogLocked &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DsLogAdmin::LogLocked&
DsLogAdmin::LogLocked::operator= (const ::DsLogAdmin::LogLocked &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DsLogAdmin::LogLocked::_tao_any_destructor (void *_tao_void_pointer)
{
  LogLocked *_tao_tmp_pointer =
    static_cast<LogLocked *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::LogLocked *
DsLogAdmin::LogLocked::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<LogLocked *> (_tao_excp);
}

const DsLogAdmin::LogLocked *
DsLogAdmin::LogLocked::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const LogLocked *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::LogLocked::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::LogLocked, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::LogLocked::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::LogLocked (*this),
      0
    );
  return result;
}

void DsLogAdmin::LogLocked::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::LogLocked::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::LogLocked::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::LogLocked::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_LogLocked;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DsLogAdmin_LogLocked = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_LogLocked (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/LogLocked:1.0",
  "LogLocked",
  _tao_fields_DsLogAdmin_LogLocked,
  0);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_LogLocked =
    &_tao_tc_DsLogAdmin_LogLocked;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::LogDisabled::LogDisabled (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/LogDisabled:1.0",
        "LogDisabled"
      )
{
}

DsLogAdmin::LogDisabled::~LogDisabled (void)
{
}

DsLogAdmin::LogDisabled::LogDisabled (const ::DsLogAdmin::LogDisabled &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DsLogAdmin::LogDisabled&
DsLogAdmin::LogDisabled::operator= (const ::DsLogAdmin::LogDisabled &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DsLogAdmin::LogDisabled::_tao_any_destructor (void *_tao_void_pointer)
{
  LogDisabled *_tao_tmp_pointer =
    static_cast<LogDisabled *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::LogDisabled *
DsLogAdmin::LogDisabled::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<LogDisabled *> (_tao_excp);
}

const DsLogAdmin::LogDisabled *
DsLogAdmin::LogDisabled::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const LogDisabled *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::LogDisabled::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::LogDisabled, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::LogDisabled::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::LogDisabled (*this),
      0
    );
  return result;
}

void DsLogAdmin::LogDisabled::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::LogDisabled::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::LogDisabled::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::LogDisabled::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_LogDisabled;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DsLogAdmin_LogDisabled = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_LogDisabled (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/LogDisabled:1.0",
  "LogDisabled",
  _tao_fields_DsLogAdmin_LogDisabled,
  0);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_LogDisabled =
    &_tao_tc_DsLogAdmin_LogDisabled;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::InvalidRecordId::InvalidRecordId (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/InvalidRecordId:1.0",
        "InvalidRecordId"
      )
{
}

DsLogAdmin::InvalidRecordId::~InvalidRecordId (void)
{
}

DsLogAdmin::InvalidRecordId::InvalidRecordId (const ::DsLogAdmin::InvalidRecordId &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DsLogAdmin::InvalidRecordId&
DsLogAdmin::InvalidRecordId::operator= (const ::DsLogAdmin::InvalidRecordId &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DsLogAdmin::InvalidRecordId::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidRecordId *_tao_tmp_pointer =
    static_cast<InvalidRecordId *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::InvalidRecordId *
DsLogAdmin::InvalidRecordId::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidRecordId *> (_tao_excp);
}

const DsLogAdmin::InvalidRecordId *
DsLogAdmin::InvalidRecordId::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidRecordId *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::InvalidRecordId::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::InvalidRecordId, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::InvalidRecordId::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::InvalidRecordId (*this),
      0
    );
  return result;
}

void DsLogAdmin::InvalidRecordId::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::InvalidRecordId::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::InvalidRecordId::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::InvalidRecordId::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_InvalidRecordId;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DsLogAdmin_InvalidRecordId = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_InvalidRecordId (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/InvalidRecordId:1.0",
  "InvalidRecordId",
  _tao_fields_DsLogAdmin_InvalidRecordId,
  0);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_InvalidRecordId =
    &_tao_tc_DsLogAdmin_InvalidRecordId;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

DsLogAdmin::InvalidAttribute::InvalidAttribute (
    const char * _tao_attr_name,
    const ::CORBA::Any & _tao_value)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/InvalidAttribute:1.0",
        "InvalidAttribute"
      )
{
  this->attr_name = ::CORBA::string_dup (_tao_attr_name);
  this->value = _tao_value;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::InvalidAttribute::InvalidAttribute (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/InvalidAttribute:1.0",
        "InvalidAttribute"
      )
{
}

DsLogAdmin::InvalidAttribute::~InvalidAttribute (void)
{
}

DsLogAdmin::InvalidAttribute::InvalidAttribute (const ::DsLogAdmin::InvalidAttribute &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->attr_name = ::CORBA::string_dup (_tao_excp.attr_name.in ());
  this->value = _tao_excp.value;
}

DsLogAdmin::InvalidAttribute&
DsLogAdmin::InvalidAttribute::operator= (const ::DsLogAdmin::InvalidAttribute &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->attr_name = ::CORBA::string_dup (_tao_excp.attr_name.in ());
  this->value = _tao_excp.value;
  return *this;
}

void DsLogAdmin::InvalidAttribute::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidAttribute *_tao_tmp_pointer =
    static_cast<InvalidAttribute *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::InvalidAttribute *
DsLogAdmin::InvalidAttribute::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidAttribute *> (_tao_excp);
}

const DsLogAdmin::InvalidAttribute *
DsLogAdmin::InvalidAttribute::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidAttribute *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::InvalidAttribute::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::InvalidAttribute, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::InvalidAttribute::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::InvalidAttribute (*this),
      0
    );
  return result;
}

void DsLogAdmin::InvalidAttribute::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::InvalidAttribute::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::InvalidAttribute::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::InvalidAttribute::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_InvalidAttribute;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_DsLogAdmin_InvalidAttribute[] =
      {
        { "attr_name", &CORBA::_tc_string },
        { "value", &CORBA::_tc_any }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_InvalidAttribute (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/InvalidAttribute:1.0",
  "InvalidAttribute",
  _tao_fields_DsLogAdmin_InvalidAttribute,
  2);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_InvalidAttribute =
    &_tao_tc_DsLogAdmin_InvalidAttribute;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::InvalidLogFullAction::InvalidLogFullAction (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/InvalidLogFullAction:1.0",
        "InvalidLogFullAction"
      )
{
}

DsLogAdmin::InvalidLogFullAction::~InvalidLogFullAction (void)
{
}

DsLogAdmin::InvalidLogFullAction::InvalidLogFullAction (const ::DsLogAdmin::InvalidLogFullAction &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DsLogAdmin::InvalidLogFullAction&
DsLogAdmin::InvalidLogFullAction::operator= (const ::DsLogAdmin::InvalidLogFullAction &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DsLogAdmin::InvalidLogFullAction::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidLogFullAction *_tao_tmp_pointer =
    static_cast<InvalidLogFullAction *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::InvalidLogFullAction *
DsLogAdmin::InvalidLogFullAction::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidLogFullAction *> (_tao_excp);
}

const DsLogAdmin::InvalidLogFullAction *
DsLogAdmin::InvalidLogFullAction::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidLogFullAction *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::InvalidLogFullAction::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::InvalidLogFullAction, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::InvalidLogFullAction::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::InvalidLogFullAction (*this),
      0
    );
  return result;
}

void DsLogAdmin::InvalidLogFullAction::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::InvalidLogFullAction::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::InvalidLogFullAction::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::InvalidLogFullAction::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_InvalidLogFullAction;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DsLogAdmin_InvalidLogFullAction = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_InvalidLogFullAction (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/InvalidLogFullAction:1.0",
  "InvalidLogFullAction",
  _tao_fields_DsLogAdmin_InvalidLogFullAction,
  0);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_InvalidLogFullAction =
    &_tao_tc_DsLogAdmin_InvalidLogFullAction;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_LogId (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/LogId:1.0",
    "LogId",
    &CORBA::_tc_ulong);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_LogId =
    &_tao_tc_DsLogAdmin_LogId;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_RecordId (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/RecordId:1.0",
    "RecordId",
    &CORBA::_tc_ulonglong);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_RecordId =
    &_tao_tc_DsLogAdmin_RecordId;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DSLOGADMIN_RECORDIDLIST_CS_)
#define _DSLOGADMIN_RECORDIDLIST_CS_

DsLogAdmin::RecordIdList::RecordIdList (void)
{}

DsLogAdmin::RecordIdList::RecordIdList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        RecordId
      > (max)
{}

DsLogAdmin::RecordIdList::RecordIdList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::ULongLong * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        RecordId
      >
    (max, length, buffer, release)
{}

DsLogAdmin::RecordIdList::RecordIdList (
    const RecordIdList &seq)
  : ::TAO::unbounded_value_sequence<
        RecordId
      > (seq)
{}

DsLogAdmin::RecordIdList::~RecordIdList (void)
{}

void DsLogAdmin::RecordIdList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  RecordIdList * _tao_tmp_pointer =
    static_cast<RecordIdList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DsLogAdmin_RecordIdList_GUARD
#define _TAO_TYPECODE_DsLogAdmin_RecordIdList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DsLogAdmin_RecordIdList_0 (
          ::CORBA::tk_sequence,
          &DsLogAdmin::_tc_RecordId,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DsLogAdmin_RecordIdList_0 =
        &DsLogAdmin_RecordIdList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DsLogAdmin_RecordIdList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_RecordIdList (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/RecordIdList:1.0",
    "RecordIdList",
    &TAO::TypeCode::tc_DsLogAdmin_RecordIdList_0);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_RecordIdList =
    &_tao_tc_DsLogAdmin_RecordIdList;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_Constraint (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/Constraint:1.0",
    "Constraint",
    &CORBA::_tc_string);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_Constraint =
    &_tao_tc_DsLogAdmin_Constraint;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_TimeT (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/TimeT:1.0",
    "TimeT",
    &TimeBase::_tc_TimeT);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_TimeT =
    &_tao_tc_DsLogAdmin_TimeT;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_DsLogAdmin_NVPair[] =
      {
        { "name", &CORBA::_tc_string },
        { "value", &CORBA::_tc_any }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_NVPair (
  ::CORBA::tk_struct,
  "IDL:omg.org/DsLogAdmin/NVPair:1.0",
  "NVPair",
  _tao_fields_DsLogAdmin_NVPair,
  2);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_NVPair =
    &_tao_tc_DsLogAdmin_NVPair;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
DsLogAdmin::NVPair::_tao_any_destructor (
    void *_tao_void_pointer)
{
  NVPair *_tao_tmp_pointer =
    static_cast<NVPair *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DSLOGADMIN_NVLIST_CS_)
#define _DSLOGADMIN_NVLIST_CS_

DsLogAdmin::NVList::NVList (void)
{}

DsLogAdmin::NVList::NVList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        NVPair
      > (max)
{}

DsLogAdmin::NVList::NVList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    DsLogAdmin::NVPair * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        NVPair
      >
    (max, length, buffer, release)
{}

DsLogAdmin::NVList::NVList (
    const NVList &seq)
  : ::TAO::unbounded_value_sequence<
        NVPair
      > (seq)
{}

DsLogAdmin::NVList::~NVList (void)
{}

void DsLogAdmin::NVList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  NVList * _tao_tmp_pointer =
    static_cast<NVList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DsLogAdmin_NVList_GUARD
#define _TAO_TYPECODE_DsLogAdmin_NVList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DsLogAdmin_NVList_0 (
          ::CORBA::tk_sequence,
          &DsLogAdmin::_tc_NVPair,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DsLogAdmin_NVList_0 =
        &DsLogAdmin_NVList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DsLogAdmin_NVList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_NVList (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/NVList:1.0",
    "NVList",
    &TAO::TypeCode::tc_DsLogAdmin_NVList_0);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_NVList =
    &_tao_tc_DsLogAdmin_NVList;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_DsLogAdmin_TimeInterval[] =
      {
        { "start", &DsLogAdmin::_tc_TimeT },
        { "stop", &DsLogAdmin::_tc_TimeT }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_TimeInterval (
  ::CORBA::tk_struct,
  "IDL:omg.org/DsLogAdmin/TimeInterval:1.0",
  "TimeInterval",
  _tao_fields_DsLogAdmin_TimeInterval,
  2);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_TimeInterval =
    &_tao_tc_DsLogAdmin_TimeInterval;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
DsLogAdmin::TimeInterval::_tao_any_destructor (
    void *_tao_void_pointer)
{
  TimeInterval *_tao_tmp_pointer =
    static_cast<TimeInterval *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DSLOGADMIN_TIMEINTERVALSEQ_CS_)
#define _DSLOGADMIN_TIMEINTERVALSEQ_CS_

DsLogAdmin::TimeIntervalSeq::TimeIntervalSeq (void)
{}

DsLogAdmin::TimeIntervalSeq::TimeIntervalSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        TimeInterval
      > (max)
{}

DsLogAdmin::TimeIntervalSeq::TimeIntervalSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    DsLogAdmin::TimeInterval * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        TimeInterval
      >
    (max, length, buffer, release)
{}

DsLogAdmin::TimeIntervalSeq::TimeIntervalSeq (
    const TimeIntervalSeq &seq)
  : ::TAO::unbounded_value_sequence<
        TimeInterval
      > (seq)
{}

DsLogAdmin::TimeIntervalSeq::~TimeIntervalSeq (void)
{}

void DsLogAdmin::TimeIntervalSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  TimeIntervalSeq * _tao_tmp_pointer =
    static_cast<TimeIntervalSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DsLogAdmin_TimeIntervalSeq_GUARD
#define _TAO_TYPECODE_DsLogAdmin_TimeIntervalSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DsLogAdmin_TimeIntervalSeq_0 (
          ::CORBA::tk_sequence,
          &DsLogAdmin::_tc_TimeInterval,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DsLogAdmin_TimeIntervalSeq_0 =
        &DsLogAdmin_TimeIntervalSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DsLogAdmin_TimeIntervalSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_TimeIntervalSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/TimeIntervalSeq:1.0",
    "TimeIntervalSeq",
    &TAO::TypeCode::tc_DsLogAdmin_TimeIntervalSeq_0);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_TimeIntervalSeq =
    &_tao_tc_DsLogAdmin_TimeIntervalSeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_DsLogAdmin_LogRecord[] =
      {
        { "id", &DsLogAdmin::_tc_RecordId },
        { "time", &DsLogAdmin::_tc_TimeT },
        { "attr_list", &DsLogAdmin::_tc_NVList },
        { "info", &CORBA::_tc_any }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_LogRecord (
  ::CORBA::tk_struct,
  "IDL:omg.org/DsLogAdmin/LogRecord:1.0",
  "LogRecord",
  _tao_fields_DsLogAdmin_LogRecord,
  4);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_LogRecord =
    &_tao_tc_DsLogAdmin_LogRecord;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
DsLogAdmin::LogRecord::_tao_any_destructor (
    void *_tao_void_pointer)
{
  LogRecord *_tao_tmp_pointer =
    static_cast<LogRecord *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DSLOGADMIN_RECORDLIST_CS_)
#define _DSLOGADMIN_RECORDLIST_CS_

DsLogAdmin::RecordList::RecordList (void)
{}

DsLogAdmin::RecordList::RecordList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        LogRecord
      > (max)
{}

DsLogAdmin::RecordList::RecordList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    DsLogAdmin::LogRecord * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        LogRecord
      >
    (max, length, buffer, release)
{}

DsLogAdmin::RecordList::RecordList (
    const RecordList &seq)
  : ::TAO::unbounded_value_sequence<
        LogRecord
      > (seq)
{}

DsLogAdmin::RecordList::~RecordList (void)
{}

void DsLogAdmin::RecordList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  RecordList * _tao_tmp_pointer =
    static_cast<RecordList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DsLogAdmin_RecordList_GUARD
#define _TAO_TYPECODE_DsLogAdmin_RecordList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DsLogAdmin_RecordList_0 (
          ::CORBA::tk_sequence,
          &DsLogAdmin::_tc_LogRecord,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DsLogAdmin_RecordList_0 =
        &DsLogAdmin_RecordList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DsLogAdmin_RecordList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_RecordList (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/RecordList:1.0",
    "RecordList",
    &TAO::TypeCode::tc_DsLogAdmin_RecordList_0);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_RecordList =
    &_tao_tc_DsLogAdmin_RecordList;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DSLOGADMIN_ANYS_CS_)
#define _DSLOGADMIN_ANYS_CS_

DsLogAdmin::Anys::Anys (void)
{}

DsLogAdmin::Anys::Anys (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Any
      > (max)
{}

DsLogAdmin::Anys::Anys (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Any * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Any
      >
    (max, length, buffer, release)
{}

DsLogAdmin::Anys::Anys (
    const Anys &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Any
      > (seq)
{}

DsLogAdmin::Anys::~Anys (void)
{}

void DsLogAdmin::Anys::_tao_any_destructor (
    void * _tao_void_pointer)
{
  Anys * _tao_tmp_pointer =
    static_cast<Anys *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DsLogAdmin_Anys_GUARD
#define _TAO_TYPECODE_DsLogAdmin_Anys_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DsLogAdmin_Anys_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_any,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DsLogAdmin_Anys_0 =
        &DsLogAdmin_Anys_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DsLogAdmin_Anys_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_Anys (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/Anys:1.0",
    "Anys",
    &TAO::TypeCode::tc_DsLogAdmin_Anys_0);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_Anys =
    &_tao_tc_DsLogAdmin_Anys;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DsLogAdmin::Iterator.

DsLogAdmin::Iterator_ptr
TAO::Objref_Traits<DsLogAdmin::Iterator>::duplicate (
    DsLogAdmin::Iterator_ptr p)
{
  return DsLogAdmin::Iterator::_duplicate (p);
}

void
TAO::Objref_Traits<DsLogAdmin::Iterator>::release (
    DsLogAdmin::Iterator_ptr p)
{
  ::CORBA::release (p);
}

DsLogAdmin::Iterator_ptr
TAO::Objref_Traits<DsLogAdmin::Iterator>::nil (void)
{
  return DsLogAdmin::Iterator::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DsLogAdmin::Iterator>::marshal (
    const DsLogAdmin::Iterator_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*DsLogAdmin__TAO_Iterator_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::RecordList *
DsLogAdmin::Iterator::get (
  ::CORBA::ULong position,
  ::CORBA::ULong how_many)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Iterator_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Iterator_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::RecordList>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_position (position);
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_how_many (how_many);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_position,
      &_tao_how_many
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Iterator_get_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/InvalidParam:1.0",
        DsLogAdmin::InvalidParam::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidParam
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "get",
      3,
      this->the_TAO_Iterator_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Iterator_get_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::Iterator::destroy (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Iterator_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Iterator_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "destroy",
      7,
      this->the_TAO_Iterator_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

DsLogAdmin::Iterator::Iterator (void)
 : the_TAO_Iterator_Proxy_Broker_ (0)
{
  this->DsLogAdmin_Iterator_setup_collocation ();
}

void
DsLogAdmin::Iterator::DsLogAdmin_Iterator_setup_collocation ()
{
  if (::DsLogAdmin__TAO_Iterator_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Iterator_Proxy_Broker_ =
        ::DsLogAdmin__TAO_Iterator_Proxy_Broker_Factory_function_pointer (this);
    }
}

DsLogAdmin::Iterator::~Iterator (void)
{}

void 
DsLogAdmin::Iterator::_tao_any_destructor (void *_tao_void_pointer)
{
  Iterator *_tao_tmp_pointer =
    static_cast<Iterator *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DsLogAdmin::Iterator_ptr
DsLogAdmin::Iterator::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Iterator>::narrow (
        _tao_objref,
        "IDL:omg.org/DsLogAdmin/Iterator:1.0",
        DsLogAdmin__TAO_Iterator_Proxy_Broker_Factory_function_pointer
      );
}

DsLogAdmin::Iterator_ptr
DsLogAdmin::Iterator::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Iterator>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/DsLogAdmin/Iterator:1.0",
        DsLogAdmin__TAO_Iterator_Proxy_Broker_Factory_function_pointer
      );
}

DsLogAdmin::Iterator_ptr
DsLogAdmin::Iterator::_nil (void)
{
  return 0;
}

DsLogAdmin::Iterator_ptr
DsLogAdmin::Iterator::_duplicate (Iterator_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DsLogAdmin::Iterator::_tao_release (Iterator_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DsLogAdmin::Iterator::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DsLogAdmin/Iterator:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* DsLogAdmin::Iterator::_interface_repository_id (void) const
{
  return "IDL:omg.org/DsLogAdmin/Iterator:1.0";
}

::CORBA::Boolean
DsLogAdmin::Iterator::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_Iterator (
    ::CORBA::tk_objref,
    "IDL:omg.org/DsLogAdmin/Iterator:1.0",
    "Iterator");
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_Iterator =
    &_tao_tc_DsLogAdmin_Iterator;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_DsLogAdmin_AvailabilityStatus[] =
      {
        { "off_duty", &CORBA::_tc_boolean },
        { "log_full", &CORBA::_tc_boolean }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_AvailabilityStatus (
  ::CORBA::tk_struct,
  "IDL:omg.org/DsLogAdmin/AvailabilityStatus:1.0",
  "AvailabilityStatus",
  _tao_fields_DsLogAdmin_AvailabilityStatus,
  2);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_AvailabilityStatus =
    &_tao_tc_DsLogAdmin_AvailabilityStatus;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
DsLogAdmin::AvailabilityStatus::_tao_any_destructor (
    void *_tao_void_pointer)
{
  AvailabilityStatus *_tao_tmp_pointer =
    static_cast<AvailabilityStatus *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_LogFullActionType (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/LogFullActionType:1.0",
    "LogFullActionType",
    &CORBA::_tc_ushort);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_LogFullActionType =
    &_tao_tc_DsLogAdmin_LogFullActionType;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_DsLogAdmin_Time24[] =
      {
        { "hour", &CORBA::_tc_ushort },
        { "minute", &CORBA::_tc_ushort }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_Time24 (
  ::CORBA::tk_struct,
  "IDL:omg.org/DsLogAdmin/Time24:1.0",
  "Time24",
  _tao_fields_DsLogAdmin_Time24,
  2);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_Time24 =
    &_tao_tc_DsLogAdmin_Time24;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
DsLogAdmin::Time24::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Time24 *_tao_tmp_pointer =
    static_cast<Time24 *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_DsLogAdmin_Time24Interval[] =
      {
        { "start", &DsLogAdmin::_tc_Time24 },
        { "stop", &DsLogAdmin::_tc_Time24 }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_Time24Interval (
  ::CORBA::tk_struct,
  "IDL:omg.org/DsLogAdmin/Time24Interval:1.0",
  "Time24Interval",
  _tao_fields_DsLogAdmin_Time24Interval,
  2);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_Time24Interval =
    &_tao_tc_DsLogAdmin_Time24Interval;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
DsLogAdmin::Time24Interval::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Time24Interval *_tao_tmp_pointer =
    static_cast<Time24Interval *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DSLOGADMIN_INTERVALSOFDAY_CS_)
#define _DSLOGADMIN_INTERVALSOFDAY_CS_

DsLogAdmin::IntervalsOfDay::IntervalsOfDay (void)
{}

DsLogAdmin::IntervalsOfDay::IntervalsOfDay (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Time24Interval
      > (max)
{}

DsLogAdmin::IntervalsOfDay::IntervalsOfDay (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    DsLogAdmin::Time24Interval * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Time24Interval
      >
    (max, length, buffer, release)
{}

DsLogAdmin::IntervalsOfDay::IntervalsOfDay (
    const IntervalsOfDay &seq)
  : ::TAO::unbounded_value_sequence<
        Time24Interval
      > (seq)
{}

DsLogAdmin::IntervalsOfDay::~IntervalsOfDay (void)
{}

void DsLogAdmin::IntervalsOfDay::_tao_any_destructor (
    void * _tao_void_pointer)
{
  IntervalsOfDay * _tao_tmp_pointer =
    static_cast<IntervalsOfDay *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DsLogAdmin_IntervalsOfDay_GUARD
#define _TAO_TYPECODE_DsLogAdmin_IntervalsOfDay_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DsLogAdmin_IntervalsOfDay_0 (
          ::CORBA::tk_sequence,
          &DsLogAdmin::_tc_Time24Interval,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DsLogAdmin_IntervalsOfDay_0 =
        &DsLogAdmin_IntervalsOfDay_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DsLogAdmin_IntervalsOfDay_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_IntervalsOfDay (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/IntervalsOfDay:1.0",
    "IntervalsOfDay",
    &TAO::TypeCode::tc_DsLogAdmin_IntervalsOfDay_0);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_IntervalsOfDay =
    &_tao_tc_DsLogAdmin_IntervalsOfDay;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_DaysOfWeek (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/DaysOfWeek:1.0",
    "DaysOfWeek",
    &CORBA::_tc_ushort);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_DaysOfWeek =
    &_tao_tc_DsLogAdmin_DaysOfWeek;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_DsLogAdmin_WeekMaskItem[] =
      {
        { "days", &DsLogAdmin::_tc_DaysOfWeek },
        { "intervals", &DsLogAdmin::_tc_IntervalsOfDay }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_WeekMaskItem (
  ::CORBA::tk_struct,
  "IDL:omg.org/DsLogAdmin/WeekMaskItem:1.0",
  "WeekMaskItem",
  _tao_fields_DsLogAdmin_WeekMaskItem,
  2);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_WeekMaskItem =
    &_tao_tc_DsLogAdmin_WeekMaskItem;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
DsLogAdmin::WeekMaskItem::_tao_any_destructor (
    void *_tao_void_pointer)
{
  WeekMaskItem *_tao_tmp_pointer =
    static_cast<WeekMaskItem *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DSLOGADMIN_WEEKMASK_CS_)
#define _DSLOGADMIN_WEEKMASK_CS_

DsLogAdmin::WeekMask::WeekMask (void)
{}

DsLogAdmin::WeekMask::WeekMask (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        WeekMaskItem
      > (max)
{}

DsLogAdmin::WeekMask::WeekMask (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    DsLogAdmin::WeekMaskItem * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        WeekMaskItem
      >
    (max, length, buffer, release)
{}

DsLogAdmin::WeekMask::WeekMask (
    const WeekMask &seq)
  : ::TAO::unbounded_value_sequence<
        WeekMaskItem
      > (seq)
{}

DsLogAdmin::WeekMask::~WeekMask (void)
{}

void DsLogAdmin::WeekMask::_tao_any_destructor (
    void * _tao_void_pointer)
{
  WeekMask * _tao_tmp_pointer =
    static_cast<WeekMask *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DsLogAdmin_WeekMask_GUARD
#define _TAO_TYPECODE_DsLogAdmin_WeekMask_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DsLogAdmin_WeekMask_0 (
          ::CORBA::tk_sequence,
          &DsLogAdmin::_tc_WeekMaskItem,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DsLogAdmin_WeekMask_0 =
        &DsLogAdmin_WeekMask_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DsLogAdmin_WeekMask_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_WeekMask (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/WeekMask:1.0",
    "WeekMask",
    &TAO::TypeCode::tc_DsLogAdmin_WeekMask_0);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_WeekMask =
    &_tao_tc_DsLogAdmin_WeekMask;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_Threshold (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/Threshold:1.0",
    "Threshold",
    &CORBA::_tc_ushort);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_Threshold =
    &_tao_tc_DsLogAdmin_Threshold;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DSLOGADMIN_CAPACITYALARMTHRESHOLDLIST_CS_)
#define _DSLOGADMIN_CAPACITYALARMTHRESHOLDLIST_CS_

DsLogAdmin::CapacityAlarmThresholdList::CapacityAlarmThresholdList (void)
{}

DsLogAdmin::CapacityAlarmThresholdList::CapacityAlarmThresholdList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Threshold
      > (max)
{}

DsLogAdmin::CapacityAlarmThresholdList::CapacityAlarmThresholdList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::UShort * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Threshold
      >
    (max, length, buffer, release)
{}

DsLogAdmin::CapacityAlarmThresholdList::CapacityAlarmThresholdList (
    const CapacityAlarmThresholdList &seq)
  : ::TAO::unbounded_value_sequence<
        Threshold
      > (seq)
{}

DsLogAdmin::CapacityAlarmThresholdList::~CapacityAlarmThresholdList (void)
{}

void DsLogAdmin::CapacityAlarmThresholdList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  CapacityAlarmThresholdList * _tao_tmp_pointer =
    static_cast<CapacityAlarmThresholdList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DsLogAdmin_CapacityAlarmThresholdList_GUARD
#define _TAO_TYPECODE_DsLogAdmin_CapacityAlarmThresholdList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DsLogAdmin_CapacityAlarmThresholdList_0 (
          ::CORBA::tk_sequence,
          &DsLogAdmin::_tc_Threshold,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DsLogAdmin_CapacityAlarmThresholdList_0 =
        &DsLogAdmin_CapacityAlarmThresholdList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DsLogAdmin_CapacityAlarmThresholdList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_CapacityAlarmThresholdList (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/CapacityAlarmThresholdList:1.0",
    "CapacityAlarmThresholdList",
    &TAO::TypeCode::tc_DsLogAdmin_CapacityAlarmThresholdList_0);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_CapacityAlarmThresholdList =
    &_tao_tc_DsLogAdmin_CapacityAlarmThresholdList;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_DsLogAdmin_OperationalState[] =
  {
    "disabled",
    "enabled"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_OperationalState (
    "IDL:omg.org/DsLogAdmin/OperationalState:1.0",
    "OperationalState",
    _tao_enumerators_DsLogAdmin_OperationalState,
    2);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_OperationalState =
    &_tao_tc_DsLogAdmin_OperationalState;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_DsLogAdmin_AdministrativeState[] =
  {
    "locked",
    "unlocked"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_AdministrativeState (
    "IDL:omg.org/DsLogAdmin/AdministrativeState:1.0",
    "AdministrativeState",
    _tao_enumerators_DsLogAdmin_AdministrativeState,
    2);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_AdministrativeState =
    &_tao_tc_DsLogAdmin_AdministrativeState;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_DsLogAdmin_ForwardingState[] =
  {
    "on",
    "off"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_ForwardingState (
    "IDL:omg.org/DsLogAdmin/ForwardingState:1.0",
    "ForwardingState",
    _tao_enumerators_DsLogAdmin_ForwardingState,
    2);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_ForwardingState =
    &_tao_tc_DsLogAdmin_ForwardingState;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_QoSType (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/QoSType:1.0",
    "QoSType",
    &CORBA::_tc_ushort);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_QoSType =
    &_tao_tc_DsLogAdmin_QoSType;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DSLOGADMIN_QOSLIST_CS_)
#define _DSLOGADMIN_QOSLIST_CS_

DsLogAdmin::QoSList::QoSList (void)
{}

DsLogAdmin::QoSList::QoSList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        QoSType
      > (max)
{}

DsLogAdmin::QoSList::QoSList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::UShort * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        QoSType
      >
    (max, length, buffer, release)
{}

DsLogAdmin::QoSList::QoSList (
    const QoSList &seq)
  : ::TAO::unbounded_value_sequence<
        QoSType
      > (seq)
{}

DsLogAdmin::QoSList::~QoSList (void)
{}

void DsLogAdmin::QoSList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  QoSList * _tao_tmp_pointer =
    static_cast<QoSList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DsLogAdmin_QoSList_GUARD
#define _TAO_TYPECODE_DsLogAdmin_QoSList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DsLogAdmin_QoSList_0 (
          ::CORBA::tk_sequence,
          &DsLogAdmin::_tc_QoSType,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DsLogAdmin_QoSList_0 =
        &DsLogAdmin_QoSList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DsLogAdmin_QoSList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_QoSList (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/QoSList:1.0",
    "QoSList",
    &TAO::TypeCode::tc_DsLogAdmin_QoSList_0);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_QoSList =
    &_tao_tc_DsLogAdmin_QoSList;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

DsLogAdmin::UnsupportedQoS::UnsupportedQoS (
    const DsLogAdmin::QoSList & _tao_denied)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/UnsupportedQoS:1.0",
        "UnsupportedQoS"
      )
{
  this->denied = _tao_denied;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DsLogAdmin::UnsupportedQoS::UnsupportedQoS (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DsLogAdmin/UnsupportedQoS:1.0",
        "UnsupportedQoS"
      )
{
}

DsLogAdmin::UnsupportedQoS::~UnsupportedQoS (void)
{
}

DsLogAdmin::UnsupportedQoS::UnsupportedQoS (const ::DsLogAdmin::UnsupportedQoS &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->denied = _tao_excp.denied;
}

DsLogAdmin::UnsupportedQoS&
DsLogAdmin::UnsupportedQoS::operator= (const ::DsLogAdmin::UnsupportedQoS &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->denied = _tao_excp.denied;
  return *this;
}

void DsLogAdmin::UnsupportedQoS::_tao_any_destructor (void *_tao_void_pointer)
{
  UnsupportedQoS *_tao_tmp_pointer =
    static_cast<UnsupportedQoS *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DsLogAdmin::UnsupportedQoS *
DsLogAdmin::UnsupportedQoS::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UnsupportedQoS *> (_tao_excp);
}

const DsLogAdmin::UnsupportedQoS *
DsLogAdmin::UnsupportedQoS::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UnsupportedQoS *> (_tao_excp);
}

::CORBA::Exception *DsLogAdmin::UnsupportedQoS::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DsLogAdmin::UnsupportedQoS, 0);
  return retval;
}

::CORBA::Exception *
DsLogAdmin::UnsupportedQoS::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DsLogAdmin::UnsupportedQoS (*this),
      0
    );
  return result;
}

void DsLogAdmin::UnsupportedQoS::_raise (void) const
{
  throw *this;
}

void DsLogAdmin::UnsupportedQoS::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DsLogAdmin::UnsupportedQoS::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DsLogAdmin::UnsupportedQoS::_tao_type (void) const
{
  return ::DsLogAdmin::_tc_UnsupportedQoS;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_DsLogAdmin_UnsupportedQoS[] =
      {
        { "denied", &DsLogAdmin::_tc_QoSList }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DsLogAdmin_UnsupportedQoS (
  ::CORBA::tk_except,
  "IDL:omg.org/DsLogAdmin/UnsupportedQoS:1.0",
  "UnsupportedQoS",
  _tao_fields_DsLogAdmin_UnsupportedQoS,
  1);


namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_UnsupportedQoS =
    &_tao_tc_DsLogAdmin_UnsupportedQoS;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DsLogAdmin::Log.

DsLogAdmin::Log_ptr
TAO::Objref_Traits<DsLogAdmin::Log>::duplicate (
    DsLogAdmin::Log_ptr p)
{
  return DsLogAdmin::Log::_duplicate (p);
}

void
TAO::Objref_Traits<DsLogAdmin::Log>::release (
    DsLogAdmin::Log_ptr p)
{
  ::CORBA::release (p);
}

DsLogAdmin::Log_ptr
TAO::Objref_Traits<DsLogAdmin::Log>::nil (void)
{
  return DsLogAdmin::Log::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DsLogAdmin::Log>::marshal (
    const DsLogAdmin::Log_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*DsLogAdmin__TAO_Log_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::LogMgr_ptr
DsLogAdmin::Log::my_factory (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::LogMgr>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "my_factory",
      10,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::LogId
DsLogAdmin::Log::id (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "id",
      2,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::QoSList *
DsLogAdmin::Log::get_log_qos (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::QoSList>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_log_qos",
      11,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::Log::set_log_qos (
  const ::DsLogAdmin::QoSList & qos)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::DsLogAdmin::QoSList>::in_arg_val _tao_qos (qos);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_qos
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_set_log_qos_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/UnsupportedQoS:1.0",
        DsLogAdmin::UnsupportedQoS::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_UnsupportedQoS
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_log_qos",
      11,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_set_log_qos_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
DsLogAdmin::Log::get_max_record_life (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_max_record_life",
      19,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::Log::set_max_record_life (
  ::CORBA::ULong life)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_life (life);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_life
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_max_record_life",
      19,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULongLong
DsLogAdmin::Log::get_max_size (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULongLong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_max_size",
      12,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::Log::set_max_size (
  ::CORBA::ULongLong size)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_size (size);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_size
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_set_max_size_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/InvalidParam:1.0",
        DsLogAdmin::InvalidParam::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidParam
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_max_size",
      12,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_set_max_size_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULongLong
DsLogAdmin::Log::get_current_size (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULongLong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_current_size",
      16,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULongLong
DsLogAdmin::Log::get_n_records (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULongLong>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_n_records",
      13,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::LogFullActionType
DsLogAdmin::Log::get_log_full_action (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::UShort>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_log_full_action",
      19,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::Log::set_log_full_action (
  ::DsLogAdmin::LogFullActionType action)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::UShort>::in_arg_val _tao_action (action);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_action
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_set_log_full_action_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/InvalidLogFullAction:1.0",
        DsLogAdmin::InvalidLogFullAction::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidLogFullAction
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_log_full_action",
      19,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_set_log_full_action_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::AdministrativeState
DsLogAdmin::Log::get_administrative_state (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::AdministrativeState>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_administrative_state",
      24,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::Log::set_administrative_state (
  ::DsLogAdmin::AdministrativeState state)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::DsLogAdmin::AdministrativeState>::in_arg_val _tao_state (state);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_state
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_administrative_state",
      24,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::ForwardingState
DsLogAdmin::Log::get_forwarding_state (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::ForwardingState>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_forwarding_state",
      20,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::Log::set_forwarding_state (
  ::DsLogAdmin::ForwardingState state)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::DsLogAdmin::ForwardingState>::in_arg_val _tao_state (state);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_state
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_forwarding_state",
      20,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::OperationalState
DsLogAdmin::Log::get_operational_state (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::OperationalState>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_operational_state",
      21,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::TimeInterval
DsLogAdmin::Log::get_interval (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::TimeInterval>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_interval",
      12,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::Log::set_interval (
  const ::DsLogAdmin::TimeInterval & interval)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::DsLogAdmin::TimeInterval>::in_arg_val _tao_interval (interval);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_interval
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_set_interval_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/InvalidTime:1.0",
        DsLogAdmin::InvalidTime::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidTime
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/InvalidTimeInterval:1.0",
        DsLogAdmin::InvalidTimeInterval::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidTimeInterval
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_interval",
      12,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_set_interval_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::AvailabilityStatus
DsLogAdmin::Log::get_availability_status (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::AvailabilityStatus>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_availability_status",
      23,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::CapacityAlarmThresholdList *
DsLogAdmin::Log::get_capacity_alarm_thresholds (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::CapacityAlarmThresholdList>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_capacity_alarm_thresholds",
      29,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::Log::set_capacity_alarm_thresholds (
  const ::DsLogAdmin::CapacityAlarmThresholdList & threshs)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::DsLogAdmin::CapacityAlarmThresholdList>::in_arg_val _tao_threshs (threshs);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_threshs
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_set_capacity_alarm_thresholds_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/InvalidThreshold:1.0",
        DsLogAdmin::InvalidThreshold::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidThreshold
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_capacity_alarm_thresholds",
      29,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_set_capacity_alarm_thresholds_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::WeekMask *
DsLogAdmin::Log::get_week_mask (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::WeekMask>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_week_mask",
      13,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::Log::set_week_mask (
  const ::DsLogAdmin::WeekMask & masks)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::DsLogAdmin::WeekMask>::in_arg_val _tao_masks (masks);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_masks
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_set_week_mask_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/InvalidTime:1.0",
        DsLogAdmin::InvalidTime::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidTime
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/InvalidTimeInterval:1.0",
        DsLogAdmin::InvalidTimeInterval::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidTimeInterval
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/InvalidMask:1.0",
        DsLogAdmin::InvalidMask::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidMask
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_week_mask",
      13,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_set_week_mask_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::RecordList *
DsLogAdmin::Log::query (
  const char * grammar,
  const char * c,
  ::DsLogAdmin::Iterator_out i)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::RecordList>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_grammar (grammar);
  TAO::Arg_Traits< char *>::in_arg_val _tao_c (c);
  TAO::Arg_Traits< ::DsLogAdmin::Iterator>::out_arg_val _tao_i (i);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_grammar,
      &_tao_c,
      &_tao_i
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_query_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/InvalidGrammar:1.0",
        DsLogAdmin::InvalidGrammar::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidGrammar
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/InvalidConstraint:1.0",
        DsLogAdmin::InvalidConstraint::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidConstraint
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "query",
      5,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_query_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::RecordList *
DsLogAdmin::Log::retrieve (
  ::DsLogAdmin::TimeT from_time,
  ::CORBA::Long how_many,
  ::DsLogAdmin::Iterator_out i)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::RecordList>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_from_time (from_time);
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_how_many (how_many);
  TAO::Arg_Traits< ::DsLogAdmin::Iterator>::out_arg_val _tao_i (i);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_from_time,
      &_tao_how_many,
      &_tao_i
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "retrieve",
      8,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
DsLogAdmin::Log::match (
  const char * grammar,
  const char * c)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_grammar (grammar);
  TAO::Arg_Traits< char *>::in_arg_val _tao_c (c);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_grammar,
      &_tao_c
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_match_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/InvalidGrammar:1.0",
        DsLogAdmin::InvalidGrammar::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidGrammar
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/InvalidConstraint:1.0",
        DsLogAdmin::InvalidConstraint::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidConstraint
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "match",
      5,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_match_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
DsLogAdmin::Log::delete_records (
  const char * grammar,
  const char * c)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_grammar (grammar);
  TAO::Arg_Traits< char *>::in_arg_val _tao_c (c);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_grammar,
      &_tao_c
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_delete_records_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/InvalidGrammar:1.0",
        DsLogAdmin::InvalidGrammar::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidGrammar
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/InvalidConstraint:1.0",
        DsLogAdmin::InvalidConstraint::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidConstraint
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "delete_records",
      14,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_delete_records_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
DsLogAdmin::Log::delete_records_by_id (
  const ::DsLogAdmin::RecordIdList & ids)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< ::DsLogAdmin::RecordIdList>::in_arg_val _tao_ids (ids);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ids
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "delete_records_by_id",
      20,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::Log::write_records (
  const ::DsLogAdmin::Anys & records)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::DsLogAdmin::Anys>::in_arg_val _tao_records (records);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_records
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_write_records_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/LogFull:1.0",
        DsLogAdmin::LogFull::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_LogFull
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/LogOffDuty:1.0",
        DsLogAdmin::LogOffDuty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_LogOffDuty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/LogLocked:1.0",
        DsLogAdmin::LogLocked::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_LogLocked
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/LogDisabled:1.0",
        DsLogAdmin::LogDisabled::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_LogDisabled
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "write_records",
      13,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_write_records_exceptiondata,
      4
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::Log::write_recordlist (
  const ::DsLogAdmin::RecordList & list)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::DsLogAdmin::RecordList>::in_arg_val _tao_list (list);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_list
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_write_recordlist_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/LogFull:1.0",
        DsLogAdmin::LogFull::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_LogFull
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/LogOffDuty:1.0",
        DsLogAdmin::LogOffDuty::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_LogOffDuty
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/LogLocked:1.0",
        DsLogAdmin::LogLocked::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_LogLocked
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/LogDisabled:1.0",
        DsLogAdmin::LogDisabled::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_LogDisabled
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "write_recordlist",
      16,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_write_recordlist_exceptiondata,
      4
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::Log::set_record_attribute (
  ::DsLogAdmin::RecordId id,
  const ::DsLogAdmin::NVList & attr_list)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_id (id);
  TAO::Arg_Traits< ::DsLogAdmin::NVList>::in_arg_val _tao_attr_list (attr_list);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_id,
      &_tao_attr_list
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_set_record_attribute_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/InvalidRecordId:1.0",
        DsLogAdmin::InvalidRecordId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidRecordId
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/InvalidAttribute:1.0",
        DsLogAdmin::InvalidAttribute::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidAttribute
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "set_record_attribute",
      20,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_set_record_attribute_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ULong
DsLogAdmin::Log::set_records_attribute (
  const char * grammar,
  const char * c,
  const ::DsLogAdmin::NVList & attr_list)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_grammar (grammar);
  TAO::Arg_Traits< char *>::in_arg_val _tao_c (c);
  TAO::Arg_Traits< ::DsLogAdmin::NVList>::in_arg_val _tao_attr_list (attr_list);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_grammar,
      &_tao_c,
      &_tao_attr_list
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_set_records_attribute_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/InvalidGrammar:1.0",
        DsLogAdmin::InvalidGrammar::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidGrammar
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/InvalidConstraint:1.0",
        DsLogAdmin::InvalidConstraint::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidConstraint
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/InvalidAttribute:1.0",
        DsLogAdmin::InvalidAttribute::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidAttribute
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "set_records_attribute",
      21,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_set_records_attribute_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::NVList *
DsLogAdmin::Log::get_record_attribute (
  ::DsLogAdmin::RecordId id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::NVList>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_id (id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_id
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_get_record_attribute_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/InvalidRecordId:1.0",
        DsLogAdmin::InvalidRecordId::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidRecordId
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_record_attribute",
      20,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_get_record_attribute_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::Log_ptr
DsLogAdmin::Log::copy (
  ::DsLogAdmin::LogId_out id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::Log>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::out_arg_val _tao_id (id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_id
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "copy",
      4,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::Log_ptr
DsLogAdmin::Log::copy_with_id (
  ::DsLogAdmin::LogId id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::Log>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_id (id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_id
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_copy_with_id_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/LogIdAlreadyExists:1.0",
        DsLogAdmin::LogIdAlreadyExists::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_LogIdAlreadyExists
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "copy_with_id",
      12,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_copy_with_id_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::Log::flush (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Log_Proxy_Broker_ == 0)
    {
      DsLogAdmin_Log_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_Log_flush_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/UnsupportedQoS:1.0",
        DsLogAdmin::UnsupportedQoS::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_UnsupportedQoS
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "flush",
      5,
      this->the_TAO_Log_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_Log_flush_exceptiondata,
      1
    );
}

DsLogAdmin::Log::Log (void)
 : the_TAO_Log_Proxy_Broker_ (0)
{
  this->DsLogAdmin_Log_setup_collocation ();
}

void
DsLogAdmin::Log::DsLogAdmin_Log_setup_collocation ()
{
  if (::DsLogAdmin__TAO_Log_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Log_Proxy_Broker_ =
        ::DsLogAdmin__TAO_Log_Proxy_Broker_Factory_function_pointer (this);
    }
}

DsLogAdmin::Log::~Log (void)
{}

void 
DsLogAdmin::Log::_tao_any_destructor (void *_tao_void_pointer)
{
  Log *_tao_tmp_pointer =
    static_cast<Log *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DsLogAdmin::Log_ptr
DsLogAdmin::Log::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Log>::narrow (
        _tao_objref,
        "IDL:omg.org/DsLogAdmin/Log:1.0",
        DsLogAdmin__TAO_Log_Proxy_Broker_Factory_function_pointer
      );
}

DsLogAdmin::Log_ptr
DsLogAdmin::Log::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Log>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/DsLogAdmin/Log:1.0",
        DsLogAdmin__TAO_Log_Proxy_Broker_Factory_function_pointer
      );
}

DsLogAdmin::Log_ptr
DsLogAdmin::Log::_nil (void)
{
  return 0;
}

DsLogAdmin::Log_ptr
DsLogAdmin::Log::_duplicate (Log_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DsLogAdmin::Log::_tao_release (Log_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DsLogAdmin::Log::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DsLogAdmin/Log:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* DsLogAdmin::Log::_interface_repository_id (void) const
{
  return "IDL:omg.org/DsLogAdmin/Log:1.0";
}

::CORBA::Boolean
DsLogAdmin::Log::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_Log (
    ::CORBA::tk_objref,
    "IDL:omg.org/DsLogAdmin/Log:1.0",
    "Log");
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_Log =
    &_tao_tc_DsLogAdmin_Log;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DsLogAdmin::BasicLog.

DsLogAdmin::BasicLog_ptr
TAO::Objref_Traits<DsLogAdmin::BasicLog>::duplicate (
    DsLogAdmin::BasicLog_ptr p)
{
  return DsLogAdmin::BasicLog::_duplicate (p);
}

void
TAO::Objref_Traits<DsLogAdmin::BasicLog>::release (
    DsLogAdmin::BasicLog_ptr p)
{
  ::CORBA::release (p);
}

DsLogAdmin::BasicLog_ptr
TAO::Objref_Traits<DsLogAdmin::BasicLog>::nil (void)
{
  return DsLogAdmin::BasicLog::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DsLogAdmin::BasicLog>::marshal (
    const DsLogAdmin::BasicLog_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*DsLogAdmin__TAO_BasicLog_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
DsLogAdmin::BasicLog::destroy (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_BasicLog_Proxy_Broker_ == 0)
    {
      DsLogAdmin_BasicLog_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "destroy",
      7,
      this->the_TAO_BasicLog_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

DsLogAdmin::BasicLog::BasicLog (void)
 : the_TAO_BasicLog_Proxy_Broker_ (0)
{
  this->DsLogAdmin_BasicLog_setup_collocation ();
}

void
DsLogAdmin::BasicLog::DsLogAdmin_BasicLog_setup_collocation ()
{
  if (::DsLogAdmin__TAO_BasicLog_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_BasicLog_Proxy_Broker_ =
        ::DsLogAdmin__TAO_BasicLog_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->DsLogAdmin_Log_setup_collocation ();
}

DsLogAdmin::BasicLog::~BasicLog (void)
{}

void 
DsLogAdmin::BasicLog::_tao_any_destructor (void *_tao_void_pointer)
{
  BasicLog *_tao_tmp_pointer =
    static_cast<BasicLog *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DsLogAdmin::BasicLog_ptr
DsLogAdmin::BasicLog::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<BasicLog>::narrow (
        _tao_objref,
        "IDL:omg.org/DsLogAdmin/BasicLog:1.0",
        DsLogAdmin__TAO_BasicLog_Proxy_Broker_Factory_function_pointer
      );
}

DsLogAdmin::BasicLog_ptr
DsLogAdmin::BasicLog::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<BasicLog>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/DsLogAdmin/BasicLog:1.0",
        DsLogAdmin__TAO_BasicLog_Proxy_Broker_Factory_function_pointer
      );
}

DsLogAdmin::BasicLog_ptr
DsLogAdmin::BasicLog::_nil (void)
{
  return 0;
}

DsLogAdmin::BasicLog_ptr
DsLogAdmin::BasicLog::_duplicate (BasicLog_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DsLogAdmin::BasicLog::_tao_release (BasicLog_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DsLogAdmin::BasicLog::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DsLogAdmin/Log:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DsLogAdmin/BasicLog:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* DsLogAdmin::BasicLog::_interface_repository_id (void) const
{
  return "IDL:omg.org/DsLogAdmin/BasicLog:1.0";
}

::CORBA::Boolean
DsLogAdmin::BasicLog::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_BasicLog (
    ::CORBA::tk_objref,
    "IDL:omg.org/DsLogAdmin/BasicLog:1.0",
    "BasicLog");
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_BasicLog =
    &_tao_tc_DsLogAdmin_BasicLog;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DSLOGADMIN_LOGLIST_CS_)
#define _DSLOGADMIN_LOGLIST_CS_

DsLogAdmin::LogList::LogList (void)
{}

DsLogAdmin::LogList::LogList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        Log,
        Log_var
      > (max)
{}

DsLogAdmin::LogList::LogList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    DsLogAdmin::Log_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        Log,
        Log_var
      >
    (max, length, buffer, release)
{}

DsLogAdmin::LogList::LogList (
    const LogList &seq)
  : ::TAO::unbounded_object_reference_sequence<
        Log,
        Log_var
      > (seq)
{}

DsLogAdmin::LogList::~LogList (void)
{}

void DsLogAdmin::LogList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  LogList * _tao_tmp_pointer =
    static_cast<LogList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DsLogAdmin_LogList_GUARD
#define _TAO_TYPECODE_DsLogAdmin_LogList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DsLogAdmin_LogList_0 (
          ::CORBA::tk_sequence,
          &DsLogAdmin::_tc_Log,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DsLogAdmin_LogList_0 =
        &DsLogAdmin_LogList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DsLogAdmin_LogList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_LogList (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/LogList:1.0",
    "LogList",
    &TAO::TypeCode::tc_DsLogAdmin_LogList_0);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_LogList =
    &_tao_tc_DsLogAdmin_LogList;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DSLOGADMIN_LOGIDLIST_CS_)
#define _DSLOGADMIN_LOGIDLIST_CS_

DsLogAdmin::LogIdList::LogIdList (void)
{}

DsLogAdmin::LogIdList::LogIdList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        LogId
      > (max)
{}

DsLogAdmin::LogIdList::LogIdList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::ULong * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        LogId
      >
    (max, length, buffer, release)
{}

DsLogAdmin::LogIdList::LogIdList (
    const LogIdList &seq)
  : ::TAO::unbounded_value_sequence<
        LogId
      > (seq)
{}

DsLogAdmin::LogIdList::~LogIdList (void)
{}

void DsLogAdmin::LogIdList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  LogIdList * _tao_tmp_pointer =
    static_cast<LogIdList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DsLogAdmin_LogIdList_GUARD
#define _TAO_TYPECODE_DsLogAdmin_LogIdList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DsLogAdmin_LogIdList_0 (
          ::CORBA::tk_sequence,
          &DsLogAdmin::_tc_LogId,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DsLogAdmin_LogIdList_0 =
        &DsLogAdmin_LogIdList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DsLogAdmin_LogIdList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_LogIdList (
    ::CORBA::tk_alias,
    "IDL:omg.org/DsLogAdmin/LogIdList:1.0",
    "LogIdList",
    &TAO::TypeCode::tc_DsLogAdmin_LogIdList_0);
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_LogIdList =
    &_tao_tc_DsLogAdmin_LogIdList;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DsLogAdmin::LogMgr.

DsLogAdmin::LogMgr_ptr
TAO::Objref_Traits<DsLogAdmin::LogMgr>::duplicate (
    DsLogAdmin::LogMgr_ptr p)
{
  return DsLogAdmin::LogMgr::_duplicate (p);
}

void
TAO::Objref_Traits<DsLogAdmin::LogMgr>::release (
    DsLogAdmin::LogMgr_ptr p)
{
  ::CORBA::release (p);
}

DsLogAdmin::LogMgr_ptr
TAO::Objref_Traits<DsLogAdmin::LogMgr>::nil (void)
{
  return DsLogAdmin::LogMgr::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DsLogAdmin::LogMgr>::marshal (
    const DsLogAdmin::LogMgr_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*DsLogAdmin__TAO_LogMgr_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::LogList *
DsLogAdmin::LogMgr::list_logs (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LogMgr_Proxy_Broker_ == 0)
    {
      DsLogAdmin_LogMgr_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::LogList>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "list_logs",
      9,
      this->the_TAO_LogMgr_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::Log_ptr
DsLogAdmin::LogMgr::find_log (
  ::DsLogAdmin::LogId id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LogMgr_Proxy_Broker_ == 0)
    {
      DsLogAdmin_LogMgr_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::Log>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_id (id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_id
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "find_log",
      8,
      this->the_TAO_LogMgr_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::LogIdList *
DsLogAdmin::LogMgr::list_logs_by_id (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LogMgr_Proxy_Broker_ == 0)
    {
      DsLogAdmin_LogMgr_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::LogIdList>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "list_logs_by_id",
      15,
      this->the_TAO_LogMgr_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

DsLogAdmin::LogMgr::LogMgr (void)
 : the_TAO_LogMgr_Proxy_Broker_ (0)
{
  this->DsLogAdmin_LogMgr_setup_collocation ();
}

void
DsLogAdmin::LogMgr::DsLogAdmin_LogMgr_setup_collocation ()
{
  if (::DsLogAdmin__TAO_LogMgr_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_LogMgr_Proxy_Broker_ =
        ::DsLogAdmin__TAO_LogMgr_Proxy_Broker_Factory_function_pointer (this);
    }
}

DsLogAdmin::LogMgr::~LogMgr (void)
{}

void 
DsLogAdmin::LogMgr::_tao_any_destructor (void *_tao_void_pointer)
{
  LogMgr *_tao_tmp_pointer =
    static_cast<LogMgr *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DsLogAdmin::LogMgr_ptr
DsLogAdmin::LogMgr::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<LogMgr>::narrow (
        _tao_objref,
        "IDL:omg.org/DsLogAdmin/LogMgr:1.0",
        DsLogAdmin__TAO_LogMgr_Proxy_Broker_Factory_function_pointer
      );
}

DsLogAdmin::LogMgr_ptr
DsLogAdmin::LogMgr::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<LogMgr>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/DsLogAdmin/LogMgr:1.0",
        DsLogAdmin__TAO_LogMgr_Proxy_Broker_Factory_function_pointer
      );
}

DsLogAdmin::LogMgr_ptr
DsLogAdmin::LogMgr::_nil (void)
{
  return 0;
}

DsLogAdmin::LogMgr_ptr
DsLogAdmin::LogMgr::_duplicate (LogMgr_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DsLogAdmin::LogMgr::_tao_release (LogMgr_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DsLogAdmin::LogMgr::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DsLogAdmin/LogMgr:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* DsLogAdmin::LogMgr::_interface_repository_id (void) const
{
  return "IDL:omg.org/DsLogAdmin/LogMgr:1.0";
}

::CORBA::Boolean
DsLogAdmin::LogMgr::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_LogMgr (
    ::CORBA::tk_objref,
    "IDL:omg.org/DsLogAdmin/LogMgr:1.0",
    "LogMgr");
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_LogMgr =
    &_tao_tc_DsLogAdmin_LogMgr;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DsLogAdmin::BasicLogFactory.

DsLogAdmin::BasicLogFactory_ptr
TAO::Objref_Traits<DsLogAdmin::BasicLogFactory>::duplicate (
    DsLogAdmin::BasicLogFactory_ptr p)
{
  return DsLogAdmin::BasicLogFactory::_duplicate (p);
}

void
TAO::Objref_Traits<DsLogAdmin::BasicLogFactory>::release (
    DsLogAdmin::BasicLogFactory_ptr p)
{
  ::CORBA::release (p);
}

DsLogAdmin::BasicLogFactory_ptr
TAO::Objref_Traits<DsLogAdmin::BasicLogFactory>::nil (void)
{
  return DsLogAdmin::BasicLogFactory::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DsLogAdmin::BasicLogFactory>::marshal (
    const DsLogAdmin::BasicLogFactory_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*DsLogAdmin__TAO_BasicLogFactory_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::BasicLog_ptr
DsLogAdmin::BasicLogFactory::create (
  ::DsLogAdmin::LogFullActionType full_action,
  ::CORBA::ULongLong max_size,
  ::DsLogAdmin::LogId_out id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_BasicLogFactory_Proxy_Broker_ == 0)
    {
      DsLogAdmin_BasicLogFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::BasicLog>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::UShort>::in_arg_val _tao_full_action (full_action);
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_max_size (max_size);
  TAO::Arg_Traits< ::CORBA::ULong>::out_arg_val _tao_id (id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_full_action,
      &_tao_max_size,
      &_tao_id
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_BasicLogFactory_create_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/InvalidLogFullAction:1.0",
        DsLogAdmin::InvalidLogFullAction::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidLogFullAction
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "create",
      6,
      this->the_TAO_BasicLogFactory_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_BasicLogFactory_create_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::DsLogAdmin::BasicLog_ptr
DsLogAdmin::BasicLogFactory::create_with_id (
  ::DsLogAdmin::LogId id,
  ::DsLogAdmin::LogFullActionType full_action,
  ::CORBA::ULongLong max_size)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_BasicLogFactory_Proxy_Broker_ == 0)
    {
      DsLogAdmin_BasicLogFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::DsLogAdmin::BasicLog>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_id (id);
  TAO::Arg_Traits< ::CORBA::UShort>::in_arg_val _tao_full_action (full_action);
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_max_size (max_size);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_id,
      &_tao_full_action,
      &_tao_max_size
    };

  static TAO::Exception_Data
  _tao_DsLogAdmin_BasicLogFactory_create_with_id_exceptiondata [] = 
    {
      {
        "IDL:omg.org/DsLogAdmin/LogIdAlreadyExists:1.0",
        DsLogAdmin::LogIdAlreadyExists::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_LogIdAlreadyExists
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/DsLogAdmin/InvalidLogFullAction:1.0",
        DsLogAdmin::InvalidLogFullAction::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , DsLogAdmin::_tc_InvalidLogFullAction
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "create_with_id",
      14,
      this->the_TAO_BasicLogFactory_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_DsLogAdmin_BasicLogFactory_create_with_id_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

DsLogAdmin::BasicLogFactory::BasicLogFactory (void)
 : the_TAO_BasicLogFactory_Proxy_Broker_ (0)
{
  this->DsLogAdmin_BasicLogFactory_setup_collocation ();
}

void
DsLogAdmin::BasicLogFactory::DsLogAdmin_BasicLogFactory_setup_collocation ()
{
  if (::DsLogAdmin__TAO_BasicLogFactory_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_BasicLogFactory_Proxy_Broker_ =
        ::DsLogAdmin__TAO_BasicLogFactory_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->DsLogAdmin_LogMgr_setup_collocation ();
}

DsLogAdmin::BasicLogFactory::~BasicLogFactory (void)
{}

void 
DsLogAdmin::BasicLogFactory::_tao_any_destructor (void *_tao_void_pointer)
{
  BasicLogFactory *_tao_tmp_pointer =
    static_cast<BasicLogFactory *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DsLogAdmin::BasicLogFactory_ptr
DsLogAdmin::BasicLogFactory::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<BasicLogFactory>::narrow (
        _tao_objref,
        "IDL:omg.org/DsLogAdmin/BasicLogFactory:1.0",
        DsLogAdmin__TAO_BasicLogFactory_Proxy_Broker_Factory_function_pointer
      );
}

DsLogAdmin::BasicLogFactory_ptr
DsLogAdmin::BasicLogFactory::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<BasicLogFactory>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/DsLogAdmin/BasicLogFactory:1.0",
        DsLogAdmin__TAO_BasicLogFactory_Proxy_Broker_Factory_function_pointer
      );
}

DsLogAdmin::BasicLogFactory_ptr
DsLogAdmin::BasicLogFactory::_nil (void)
{
  return 0;
}

DsLogAdmin::BasicLogFactory_ptr
DsLogAdmin::BasicLogFactory::_duplicate (BasicLogFactory_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DsLogAdmin::BasicLogFactory::_tao_release (BasicLogFactory_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DsLogAdmin::BasicLogFactory::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DsLogAdmin/LogMgr:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DsLogAdmin/BasicLogFactory:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* DsLogAdmin::BasicLogFactory::_interface_repository_id (void) const
{
  return "IDL:omg.org/DsLogAdmin/BasicLogFactory:1.0";
}

::CORBA::Boolean
DsLogAdmin::BasicLogFactory::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DsLogAdmin_BasicLogFactory (
    ::CORBA::tk_objref,
    "IDL:omg.org/DsLogAdmin/BasicLogFactory:1.0",
    "BasicLogFactory");
  

namespace DsLogAdmin
{
  ::CORBA::TypeCode_ptr const _tc_BasicLogFactory =
    &_tao_tc_DsLogAdmin_BasicLogFactory;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::InvalidParam>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidParam &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidParam>::insert_copy (
        _tao_any,
        ::DsLogAdmin::InvalidParam::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidParam,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidParam *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidParam>::insert (
        _tao_any,
        ::DsLogAdmin::InvalidParam::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidParam,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidParam *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::InvalidParam *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidParam *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidParam>::extract (
          _tao_any,
          ::DsLogAdmin::InvalidParam::_tao_any_destructor,
          ::DsLogAdmin::_tc_InvalidParam,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidParam &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidParam>::insert_copy (
      _tao_any,
      DsLogAdmin::InvalidParam::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidParam,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidParam *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidParam>::insert (
      _tao_any,
      DsLogAdmin::InvalidParam::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidParam,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidParam *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::InvalidParam *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidParam *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidParam>::extract (
        _tao_any,
        DsLogAdmin::InvalidParam::_tao_any_destructor,
        DsLogAdmin::_tc_InvalidParam,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::InvalidThreshold>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidThreshold &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidThreshold>::insert_copy (
        _tao_any,
        ::DsLogAdmin::InvalidThreshold::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidThreshold,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidThreshold *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidThreshold>::insert (
        _tao_any,
        ::DsLogAdmin::InvalidThreshold::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidThreshold,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidThreshold *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::InvalidThreshold *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidThreshold *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidThreshold>::extract (
          _tao_any,
          ::DsLogAdmin::InvalidThreshold::_tao_any_destructor,
          ::DsLogAdmin::_tc_InvalidThreshold,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidThreshold &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidThreshold>::insert_copy (
      _tao_any,
      DsLogAdmin::InvalidThreshold::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidThreshold,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidThreshold *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidThreshold>::insert (
      _tao_any,
      DsLogAdmin::InvalidThreshold::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidThreshold,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidThreshold *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::InvalidThreshold *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidThreshold *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidThreshold>::extract (
        _tao_any,
        DsLogAdmin::InvalidThreshold::_tao_any_destructor,
        DsLogAdmin::_tc_InvalidThreshold,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::InvalidTime>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidTime &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidTime>::insert_copy (
        _tao_any,
        ::DsLogAdmin::InvalidTime::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidTime,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidTime *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidTime>::insert (
        _tao_any,
        ::DsLogAdmin::InvalidTime::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidTime,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidTime *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::InvalidTime *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidTime *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidTime>::extract (
          _tao_any,
          ::DsLogAdmin::InvalidTime::_tao_any_destructor,
          ::DsLogAdmin::_tc_InvalidTime,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidTime &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidTime>::insert_copy (
      _tao_any,
      DsLogAdmin::InvalidTime::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidTime,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidTime *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidTime>::insert (
      _tao_any,
      DsLogAdmin::InvalidTime::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidTime,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidTime *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::InvalidTime *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidTime *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidTime>::extract (
        _tao_any,
        DsLogAdmin::InvalidTime::_tao_any_destructor,
        DsLogAdmin::_tc_InvalidTime,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::InvalidTimeInterval>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidTimeInterval &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidTimeInterval>::insert_copy (
        _tao_any,
        ::DsLogAdmin::InvalidTimeInterval::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidTimeInterval,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidTimeInterval *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidTimeInterval>::insert (
        _tao_any,
        ::DsLogAdmin::InvalidTimeInterval::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidTimeInterval,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidTimeInterval *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::InvalidTimeInterval *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidTimeInterval *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidTimeInterval>::extract (
          _tao_any,
          ::DsLogAdmin::InvalidTimeInterval::_tao_any_destructor,
          ::DsLogAdmin::_tc_InvalidTimeInterval,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidTimeInterval &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidTimeInterval>::insert_copy (
      _tao_any,
      DsLogAdmin::InvalidTimeInterval::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidTimeInterval,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidTimeInterval *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidTimeInterval>::insert (
      _tao_any,
      DsLogAdmin::InvalidTimeInterval::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidTimeInterval,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidTimeInterval *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::InvalidTimeInterval *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidTimeInterval *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidTimeInterval>::extract (
        _tao_any,
        DsLogAdmin::InvalidTimeInterval::_tao_any_destructor,
        DsLogAdmin::_tc_InvalidTimeInterval,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::InvalidMask>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidMask &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidMask>::insert_copy (
        _tao_any,
        ::DsLogAdmin::InvalidMask::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidMask,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidMask *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidMask>::insert (
        _tao_any,
        ::DsLogAdmin::InvalidMask::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidMask,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidMask *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::InvalidMask *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidMask *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidMask>::extract (
          _tao_any,
          ::DsLogAdmin::InvalidMask::_tao_any_destructor,
          ::DsLogAdmin::_tc_InvalidMask,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidMask &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidMask>::insert_copy (
      _tao_any,
      DsLogAdmin::InvalidMask::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidMask,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidMask *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidMask>::insert (
      _tao_any,
      DsLogAdmin::InvalidMask::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidMask,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidMask *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::InvalidMask *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidMask *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidMask>::extract (
        _tao_any,
        DsLogAdmin::InvalidMask::_tao_any_destructor,
        DsLogAdmin::_tc_InvalidMask,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::LogIdAlreadyExists>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogIdAlreadyExists &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogIdAlreadyExists>::insert_copy (
        _tao_any,
        ::DsLogAdmin::LogIdAlreadyExists::_tao_any_destructor,
        ::DsLogAdmin::_tc_LogIdAlreadyExists,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogIdAlreadyExists *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogIdAlreadyExists>::insert (
        _tao_any,
        ::DsLogAdmin::LogIdAlreadyExists::_tao_any_destructor,
        ::DsLogAdmin::_tc_LogIdAlreadyExists,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogIdAlreadyExists *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::LogIdAlreadyExists *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogIdAlreadyExists *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogIdAlreadyExists>::extract (
          _tao_any,
          ::DsLogAdmin::LogIdAlreadyExists::_tao_any_destructor,
          ::DsLogAdmin::_tc_LogIdAlreadyExists,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogIdAlreadyExists &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::LogIdAlreadyExists>::insert_copy (
      _tao_any,
      DsLogAdmin::LogIdAlreadyExists::_tao_any_destructor,
      DsLogAdmin::_tc_LogIdAlreadyExists,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::LogIdAlreadyExists *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::LogIdAlreadyExists>::insert (
      _tao_any,
      DsLogAdmin::LogIdAlreadyExists::_tao_any_destructor,
      DsLogAdmin::_tc_LogIdAlreadyExists,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::LogIdAlreadyExists *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::LogIdAlreadyExists *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogIdAlreadyExists *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::LogIdAlreadyExists>::extract (
        _tao_any,
        DsLogAdmin::LogIdAlreadyExists::_tao_any_destructor,
        DsLogAdmin::_tc_LogIdAlreadyExists,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::InvalidGrammar>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidGrammar &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidGrammar>::insert_copy (
        _tao_any,
        ::DsLogAdmin::InvalidGrammar::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidGrammar,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidGrammar *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidGrammar>::insert (
        _tao_any,
        ::DsLogAdmin::InvalidGrammar::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidGrammar,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidGrammar *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::InvalidGrammar *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidGrammar *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidGrammar>::extract (
          _tao_any,
          ::DsLogAdmin::InvalidGrammar::_tao_any_destructor,
          ::DsLogAdmin::_tc_InvalidGrammar,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidGrammar &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidGrammar>::insert_copy (
      _tao_any,
      DsLogAdmin::InvalidGrammar::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidGrammar,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidGrammar *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidGrammar>::insert (
      _tao_any,
      DsLogAdmin::InvalidGrammar::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidGrammar,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidGrammar *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::InvalidGrammar *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidGrammar *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidGrammar>::extract (
        _tao_any,
        DsLogAdmin::InvalidGrammar::_tao_any_destructor,
        DsLogAdmin::_tc_InvalidGrammar,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::InvalidConstraint>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidConstraint &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidConstraint>::insert_copy (
        _tao_any,
        ::DsLogAdmin::InvalidConstraint::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidConstraint,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidConstraint *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidConstraint>::insert (
        _tao_any,
        ::DsLogAdmin::InvalidConstraint::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidConstraint,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidConstraint *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::InvalidConstraint *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidConstraint *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidConstraint>::extract (
          _tao_any,
          ::DsLogAdmin::InvalidConstraint::_tao_any_destructor,
          ::DsLogAdmin::_tc_InvalidConstraint,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidConstraint &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidConstraint>::insert_copy (
      _tao_any,
      DsLogAdmin::InvalidConstraint::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidConstraint,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidConstraint *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidConstraint>::insert (
      _tao_any,
      DsLogAdmin::InvalidConstraint::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidConstraint,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidConstraint *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::InvalidConstraint *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidConstraint *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidConstraint>::extract (
        _tao_any,
        DsLogAdmin::InvalidConstraint::_tao_any_destructor,
        DsLogAdmin::_tc_InvalidConstraint,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::LogFull>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogFull &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogFull>::insert_copy (
        _tao_any,
        ::DsLogAdmin::LogFull::_tao_any_destructor,
        ::DsLogAdmin::_tc_LogFull,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogFull *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogFull>::insert (
        _tao_any,
        ::DsLogAdmin::LogFull::_tao_any_destructor,
        ::DsLogAdmin::_tc_LogFull,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogFull *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::LogFull *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogFull *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogFull>::extract (
          _tao_any,
          ::DsLogAdmin::LogFull::_tao_any_destructor,
          ::DsLogAdmin::_tc_LogFull,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogFull &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::LogFull>::insert_copy (
      _tao_any,
      DsLogAdmin::LogFull::_tao_any_destructor,
      DsLogAdmin::_tc_LogFull,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::LogFull *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::LogFull>::insert (
      _tao_any,
      DsLogAdmin::LogFull::_tao_any_destructor,
      DsLogAdmin::_tc_LogFull,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::LogFull *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::LogFull *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogFull *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::LogFull>::extract (
        _tao_any,
        DsLogAdmin::LogFull::_tao_any_destructor,
        DsLogAdmin::_tc_LogFull,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::LogOffDuty>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogOffDuty &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogOffDuty>::insert_copy (
        _tao_any,
        ::DsLogAdmin::LogOffDuty::_tao_any_destructor,
        ::DsLogAdmin::_tc_LogOffDuty,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogOffDuty *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogOffDuty>::insert (
        _tao_any,
        ::DsLogAdmin::LogOffDuty::_tao_any_destructor,
        ::DsLogAdmin::_tc_LogOffDuty,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogOffDuty *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::LogOffDuty *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogOffDuty *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogOffDuty>::extract (
          _tao_any,
          ::DsLogAdmin::LogOffDuty::_tao_any_destructor,
          ::DsLogAdmin::_tc_LogOffDuty,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogOffDuty &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::LogOffDuty>::insert_copy (
      _tao_any,
      DsLogAdmin::LogOffDuty::_tao_any_destructor,
      DsLogAdmin::_tc_LogOffDuty,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::LogOffDuty *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::LogOffDuty>::insert (
      _tao_any,
      DsLogAdmin::LogOffDuty::_tao_any_destructor,
      DsLogAdmin::_tc_LogOffDuty,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::LogOffDuty *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::LogOffDuty *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogOffDuty *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::LogOffDuty>::extract (
        _tao_any,
        DsLogAdmin::LogOffDuty::_tao_any_destructor,
        DsLogAdmin::_tc_LogOffDuty,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::LogLocked>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogLocked &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogLocked>::insert_copy (
        _tao_any,
        ::DsLogAdmin::LogLocked::_tao_any_destructor,
        ::DsLogAdmin::_tc_LogLocked,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogLocked *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogLocked>::insert (
        _tao_any,
        ::DsLogAdmin::LogLocked::_tao_any_destructor,
        ::DsLogAdmin::_tc_LogLocked,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogLocked *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::LogLocked *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogLocked *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogLocked>::extract (
          _tao_any,
          ::DsLogAdmin::LogLocked::_tao_any_destructor,
          ::DsLogAdmin::_tc_LogLocked,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogLocked &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::LogLocked>::insert_copy (
      _tao_any,
      DsLogAdmin::LogLocked::_tao_any_destructor,
      DsLogAdmin::_tc_LogLocked,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::LogLocked *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::LogLocked>::insert (
      _tao_any,
      DsLogAdmin::LogLocked::_tao_any_destructor,
      DsLogAdmin::_tc_LogLocked,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::LogLocked *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::LogLocked *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogLocked *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::LogLocked>::extract (
        _tao_any,
        DsLogAdmin::LogLocked::_tao_any_destructor,
        DsLogAdmin::_tc_LogLocked,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::LogDisabled>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogDisabled &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogDisabled>::insert_copy (
        _tao_any,
        ::DsLogAdmin::LogDisabled::_tao_any_destructor,
        ::DsLogAdmin::_tc_LogDisabled,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogDisabled *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogDisabled>::insert (
        _tao_any,
        ::DsLogAdmin::LogDisabled::_tao_any_destructor,
        ::DsLogAdmin::_tc_LogDisabled,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogDisabled *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::LogDisabled *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogDisabled *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogDisabled>::extract (
          _tao_any,
          ::DsLogAdmin::LogDisabled::_tao_any_destructor,
          ::DsLogAdmin::_tc_LogDisabled,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogDisabled &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::LogDisabled>::insert_copy (
      _tao_any,
      DsLogAdmin::LogDisabled::_tao_any_destructor,
      DsLogAdmin::_tc_LogDisabled,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::LogDisabled *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::LogDisabled>::insert (
      _tao_any,
      DsLogAdmin::LogDisabled::_tao_any_destructor,
      DsLogAdmin::_tc_LogDisabled,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::LogDisabled *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::LogDisabled *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogDisabled *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::LogDisabled>::extract (
        _tao_any,
        DsLogAdmin::LogDisabled::_tao_any_destructor,
        DsLogAdmin::_tc_LogDisabled,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::InvalidRecordId>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidRecordId &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidRecordId>::insert_copy (
        _tao_any,
        ::DsLogAdmin::InvalidRecordId::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidRecordId,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidRecordId *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidRecordId>::insert (
        _tao_any,
        ::DsLogAdmin::InvalidRecordId::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidRecordId,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidRecordId *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::InvalidRecordId *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidRecordId *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidRecordId>::extract (
          _tao_any,
          ::DsLogAdmin::InvalidRecordId::_tao_any_destructor,
          ::DsLogAdmin::_tc_InvalidRecordId,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidRecordId &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidRecordId>::insert_copy (
      _tao_any,
      DsLogAdmin::InvalidRecordId::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidRecordId,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidRecordId *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidRecordId>::insert (
      _tao_any,
      DsLogAdmin::InvalidRecordId::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidRecordId,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidRecordId *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::InvalidRecordId *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidRecordId *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidRecordId>::extract (
        _tao_any,
        DsLogAdmin::InvalidRecordId::_tao_any_destructor,
        DsLogAdmin::_tc_InvalidRecordId,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::InvalidAttribute>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidAttribute &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidAttribute>::insert_copy (
        _tao_any,
        ::DsLogAdmin::InvalidAttribute::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidAttribute,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidAttribute *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidAttribute>::insert (
        _tao_any,
        ::DsLogAdmin::InvalidAttribute::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidAttribute,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidAttribute *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::InvalidAttribute *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidAttribute *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidAttribute>::extract (
          _tao_any,
          ::DsLogAdmin::InvalidAttribute::_tao_any_destructor,
          ::DsLogAdmin::_tc_InvalidAttribute,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidAttribute &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidAttribute>::insert_copy (
      _tao_any,
      DsLogAdmin::InvalidAttribute::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidAttribute,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidAttribute *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidAttribute>::insert (
      _tao_any,
      DsLogAdmin::InvalidAttribute::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidAttribute,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidAttribute *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::InvalidAttribute *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidAttribute *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidAttribute>::extract (
        _tao_any,
        DsLogAdmin::InvalidAttribute::_tao_any_destructor,
        DsLogAdmin::_tc_InvalidAttribute,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::InvalidLogFullAction>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidLogFullAction &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidLogFullAction>::insert_copy (
        _tao_any,
        ::DsLogAdmin::InvalidLogFullAction::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidLogFullAction,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidLogFullAction *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidLogFullAction>::insert (
        _tao_any,
        ::DsLogAdmin::InvalidLogFullAction::_tao_any_destructor,
        ::DsLogAdmin::_tc_InvalidLogFullAction,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::InvalidLogFullAction *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::InvalidLogFullAction *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::InvalidLogFullAction *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::InvalidLogFullAction>::extract (
          _tao_any,
          ::DsLogAdmin::InvalidLogFullAction::_tao_any_destructor,
          ::DsLogAdmin::_tc_InvalidLogFullAction,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidLogFullAction &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidLogFullAction>::insert_copy (
      _tao_any,
      DsLogAdmin::InvalidLogFullAction::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidLogFullAction,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidLogFullAction *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidLogFullAction>::insert (
      _tao_any,
      DsLogAdmin::InvalidLogFullAction::_tao_any_destructor,
      DsLogAdmin::_tc_InvalidLogFullAction,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::InvalidLogFullAction *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::InvalidLogFullAction *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::InvalidLogFullAction *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::InvalidLogFullAction>::extract (
        _tao_any,
        DsLogAdmin::InvalidLogFullAction::_tao_any_destructor,
        DsLogAdmin::_tc_InvalidLogFullAction,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::RecordIdList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::RecordIdList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::RecordIdList>::insert_copy (
          _tao_any,
          ::DsLogAdmin::RecordIdList::_tao_any_destructor,
          ::DsLogAdmin::_tc_RecordIdList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::RecordIdList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::RecordIdList>::insert (
        _tao_any,
        ::DsLogAdmin::RecordIdList::_tao_any_destructor,
        ::DsLogAdmin::_tc_RecordIdList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::RecordIdList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::RecordIdList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::RecordIdList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::RecordIdList>::extract (
          _tao_any,
          ::DsLogAdmin::RecordIdList::_tao_any_destructor,
          ::DsLogAdmin::_tc_RecordIdList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::RecordIdList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::RecordIdList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::RecordIdList>::insert_copy (
        _tao_any,
        DsLogAdmin::RecordIdList::_tao_any_destructor,
        DsLogAdmin::_tc_RecordIdList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::RecordIdList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::RecordIdList>::insert (
      _tao_any,
      DsLogAdmin::RecordIdList::_tao_any_destructor,
      DsLogAdmin::_tc_RecordIdList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::RecordIdList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::RecordIdList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::RecordIdList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::RecordIdList>::extract (
        _tao_any,
        DsLogAdmin::RecordIdList::_tao_any_destructor,
        DsLogAdmin::_tc_RecordIdList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::NVPair &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::NVPair *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::NVPair>::insert_copy (
          _tao_any,
          ::DsLogAdmin::NVPair::_tao_any_destructor,
          ::DsLogAdmin::_tc_NVPair,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      DsLogAdmin::NVPair *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::NVPair>::insert (
        _tao_any,
        ::DsLogAdmin::NVPair::_tao_any_destructor,
        ::DsLogAdmin::_tc_NVPair,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::NVPair *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::NVPair *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::NVPair *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::NVPair>::extract (
          _tao_any,
          ::DsLogAdmin::NVPair::_tao_any_destructor,
          ::DsLogAdmin::_tc_NVPair,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::NVPair &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::NVPair *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::NVPair>::insert_copy (
        _tao_any,
        DsLogAdmin::NVPair::_tao_any_destructor,
        DsLogAdmin::_tc_NVPair,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::NVPair *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::NVPair>::insert (
      _tao_any,
      DsLogAdmin::NVPair::_tao_any_destructor,
      DsLogAdmin::_tc_NVPair,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::NVPair *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::NVPair *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::NVPair *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::NVPair>::extract (
        _tao_any,
        DsLogAdmin::NVPair::_tao_any_destructor,
        DsLogAdmin::_tc_NVPair,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::NVList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::NVList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::NVList>::insert_copy (
          _tao_any,
          ::DsLogAdmin::NVList::_tao_any_destructor,
          ::DsLogAdmin::_tc_NVList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::NVList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::NVList>::insert (
        _tao_any,
        ::DsLogAdmin::NVList::_tao_any_destructor,
        ::DsLogAdmin::_tc_NVList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::NVList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::NVList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::NVList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::NVList>::extract (
          _tao_any,
          ::DsLogAdmin::NVList::_tao_any_destructor,
          ::DsLogAdmin::_tc_NVList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::NVList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::NVList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::NVList>::insert_copy (
        _tao_any,
        DsLogAdmin::NVList::_tao_any_destructor,
        DsLogAdmin::_tc_NVList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::NVList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::NVList>::insert (
      _tao_any,
      DsLogAdmin::NVList::_tao_any_destructor,
      DsLogAdmin::_tc_NVList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::NVList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::NVList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::NVList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::NVList>::extract (
        _tao_any,
        DsLogAdmin::NVList::_tao_any_destructor,
        DsLogAdmin::_tc_NVList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::TimeInterval &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::TimeInterval *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::TimeInterval>::insert_copy (
          _tao_any,
          ::DsLogAdmin::TimeInterval::_tao_any_destructor,
          ::DsLogAdmin::_tc_TimeInterval,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      DsLogAdmin::TimeInterval *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::TimeInterval>::insert (
        _tao_any,
        ::DsLogAdmin::TimeInterval::_tao_any_destructor,
        ::DsLogAdmin::_tc_TimeInterval,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::TimeInterval *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::TimeInterval *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::TimeInterval *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::TimeInterval>::extract (
          _tao_any,
          ::DsLogAdmin::TimeInterval::_tao_any_destructor,
          ::DsLogAdmin::_tc_TimeInterval,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::TimeInterval &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::TimeInterval *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::TimeInterval>::insert_copy (
        _tao_any,
        DsLogAdmin::TimeInterval::_tao_any_destructor,
        DsLogAdmin::_tc_TimeInterval,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::TimeInterval *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::TimeInterval>::insert (
      _tao_any,
      DsLogAdmin::TimeInterval::_tao_any_destructor,
      DsLogAdmin::_tc_TimeInterval,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::TimeInterval *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::TimeInterval *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::TimeInterval *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::TimeInterval>::extract (
        _tao_any,
        DsLogAdmin::TimeInterval::_tao_any_destructor,
        DsLogAdmin::_tc_TimeInterval,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::TimeIntervalSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::TimeIntervalSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::TimeIntervalSeq>::insert_copy (
          _tao_any,
          ::DsLogAdmin::TimeIntervalSeq::_tao_any_destructor,
          ::DsLogAdmin::_tc_TimeIntervalSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::TimeIntervalSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::TimeIntervalSeq>::insert (
        _tao_any,
        ::DsLogAdmin::TimeIntervalSeq::_tao_any_destructor,
        ::DsLogAdmin::_tc_TimeIntervalSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::TimeIntervalSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::TimeIntervalSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::TimeIntervalSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::TimeIntervalSeq>::extract (
          _tao_any,
          ::DsLogAdmin::TimeIntervalSeq::_tao_any_destructor,
          ::DsLogAdmin::_tc_TimeIntervalSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::TimeIntervalSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::TimeIntervalSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::TimeIntervalSeq>::insert_copy (
        _tao_any,
        DsLogAdmin::TimeIntervalSeq::_tao_any_destructor,
        DsLogAdmin::_tc_TimeIntervalSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::TimeIntervalSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::TimeIntervalSeq>::insert (
      _tao_any,
      DsLogAdmin::TimeIntervalSeq::_tao_any_destructor,
      DsLogAdmin::_tc_TimeIntervalSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::TimeIntervalSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::TimeIntervalSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::TimeIntervalSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::TimeIntervalSeq>::extract (
        _tao_any,
        DsLogAdmin::TimeIntervalSeq::_tao_any_destructor,
        DsLogAdmin::_tc_TimeIntervalSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogRecord &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::LogRecord *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogRecord>::insert_copy (
          _tao_any,
          ::DsLogAdmin::LogRecord::_tao_any_destructor,
          ::DsLogAdmin::_tc_LogRecord,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      DsLogAdmin::LogRecord *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogRecord>::insert (
        _tao_any,
        ::DsLogAdmin::LogRecord::_tao_any_destructor,
        ::DsLogAdmin::_tc_LogRecord,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogRecord *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::LogRecord *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogRecord *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogRecord>::extract (
          _tao_any,
          ::DsLogAdmin::LogRecord::_tao_any_destructor,
          ::DsLogAdmin::_tc_LogRecord,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogRecord &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::LogRecord *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::LogRecord>::insert_copy (
        _tao_any,
        DsLogAdmin::LogRecord::_tao_any_destructor,
        DsLogAdmin::_tc_LogRecord,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::LogRecord *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::LogRecord>::insert (
      _tao_any,
      DsLogAdmin::LogRecord::_tao_any_destructor,
      DsLogAdmin::_tc_LogRecord,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::LogRecord *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::LogRecord *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogRecord *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::LogRecord>::extract (
        _tao_any,
        DsLogAdmin::LogRecord::_tao_any_destructor,
        DsLogAdmin::_tc_LogRecord,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::RecordList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::RecordList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::RecordList>::insert_copy (
          _tao_any,
          ::DsLogAdmin::RecordList::_tao_any_destructor,
          ::DsLogAdmin::_tc_RecordList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::RecordList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::RecordList>::insert (
        _tao_any,
        ::DsLogAdmin::RecordList::_tao_any_destructor,
        ::DsLogAdmin::_tc_RecordList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::RecordList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::RecordList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::RecordList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::RecordList>::extract (
          _tao_any,
          ::DsLogAdmin::RecordList::_tao_any_destructor,
          ::DsLogAdmin::_tc_RecordList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::RecordList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::RecordList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::RecordList>::insert_copy (
        _tao_any,
        DsLogAdmin::RecordList::_tao_any_destructor,
        DsLogAdmin::_tc_RecordList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::RecordList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::RecordList>::insert (
      _tao_any,
      DsLogAdmin::RecordList::_tao_any_destructor,
      DsLogAdmin::_tc_RecordList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::RecordList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::RecordList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::RecordList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::RecordList>::extract (
        _tao_any,
        DsLogAdmin::RecordList::_tao_any_destructor,
        DsLogAdmin::_tc_RecordList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::Anys &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::Anys *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::Anys>::insert_copy (
          _tao_any,
          ::DsLogAdmin::Anys::_tao_any_destructor,
          ::DsLogAdmin::_tc_Anys,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::Anys *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::Anys>::insert (
        _tao_any,
        ::DsLogAdmin::Anys::_tao_any_destructor,
        ::DsLogAdmin::_tc_Anys,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::Anys *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::Anys *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::Anys *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::Anys>::extract (
          _tao_any,
          ::DsLogAdmin::Anys::_tao_any_destructor,
          ::DsLogAdmin::_tc_Anys,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::Anys &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::Anys *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::Anys>::insert_copy (
        _tao_any,
        DsLogAdmin::Anys::_tao_any_destructor,
        DsLogAdmin::_tc_Anys,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::Anys *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::Anys>::insert (
      _tao_any,
      DsLogAdmin::Anys::_tao_any_destructor,
      DsLogAdmin::_tc_Anys,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::Anys *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::Anys *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::Anys *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::Anys>::extract (
        _tao_any,
        DsLogAdmin::Anys::_tao_any_destructor,
        DsLogAdmin::_tc_Anys,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DsLogAdmin::Iterator>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Iterator_ptr _tao_elem)
  {
    Iterator_ptr _tao_objptr =
      Iterator::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Iterator_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Iterator>::insert (
        _tao_any,
        Iterator::_tao_any_destructor,
        _tc_Iterator,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Iterator_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Iterator>::extract (
          _tao_any,
          Iterator::_tao_any_destructor,
          _tc_Iterator,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::Iterator_ptr _tao_elem)
{
  DsLogAdmin::Iterator_ptr _tao_objptr =
    DsLogAdmin::Iterator::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::Iterator_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DsLogAdmin::Iterator>::insert (
      _tao_any,
      DsLogAdmin::Iterator::_tao_any_destructor,
      DsLogAdmin::_tc_Iterator,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::Iterator_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DsLogAdmin::Iterator>::extract (
        _tao_any,
        DsLogAdmin::Iterator::_tao_any_destructor,
        DsLogAdmin::_tc_Iterator,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::AvailabilityStatus &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::AvailabilityStatus *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::AvailabilityStatus>::insert_copy (
          _tao_any,
          ::DsLogAdmin::AvailabilityStatus::_tao_any_destructor,
          ::DsLogAdmin::_tc_AvailabilityStatus,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      DsLogAdmin::AvailabilityStatus *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::AvailabilityStatus>::insert (
        _tao_any,
        ::DsLogAdmin::AvailabilityStatus::_tao_any_destructor,
        ::DsLogAdmin::_tc_AvailabilityStatus,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::AvailabilityStatus *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::AvailabilityStatus *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::AvailabilityStatus *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::AvailabilityStatus>::extract (
          _tao_any,
          ::DsLogAdmin::AvailabilityStatus::_tao_any_destructor,
          ::DsLogAdmin::_tc_AvailabilityStatus,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::AvailabilityStatus &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::AvailabilityStatus *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::AvailabilityStatus>::insert_copy (
        _tao_any,
        DsLogAdmin::AvailabilityStatus::_tao_any_destructor,
        DsLogAdmin::_tc_AvailabilityStatus,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::AvailabilityStatus *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::AvailabilityStatus>::insert (
      _tao_any,
      DsLogAdmin::AvailabilityStatus::_tao_any_destructor,
      DsLogAdmin::_tc_AvailabilityStatus,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::AvailabilityStatus *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::AvailabilityStatus *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::AvailabilityStatus *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::AvailabilityStatus>::extract (
        _tao_any,
        DsLogAdmin::AvailabilityStatus::_tao_any_destructor,
        DsLogAdmin::_tc_AvailabilityStatus,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::Time24 &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::Time24 *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::Time24>::insert_copy (
          _tao_any,
          ::DsLogAdmin::Time24::_tao_any_destructor,
          ::DsLogAdmin::_tc_Time24,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      DsLogAdmin::Time24 *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::Time24>::insert (
        _tao_any,
        ::DsLogAdmin::Time24::_tao_any_destructor,
        ::DsLogAdmin::_tc_Time24,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::Time24 *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::Time24 *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::Time24 *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::Time24>::extract (
          _tao_any,
          ::DsLogAdmin::Time24::_tao_any_destructor,
          ::DsLogAdmin::_tc_Time24,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::Time24 &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::Time24 *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::Time24>::insert_copy (
        _tao_any,
        DsLogAdmin::Time24::_tao_any_destructor,
        DsLogAdmin::_tc_Time24,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::Time24 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::Time24>::insert (
      _tao_any,
      DsLogAdmin::Time24::_tao_any_destructor,
      DsLogAdmin::_tc_Time24,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::Time24 *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::Time24 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::Time24 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::Time24>::extract (
        _tao_any,
        DsLogAdmin::Time24::_tao_any_destructor,
        DsLogAdmin::_tc_Time24,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::Time24Interval &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::Time24Interval *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::Time24Interval>::insert_copy (
          _tao_any,
          ::DsLogAdmin::Time24Interval::_tao_any_destructor,
          ::DsLogAdmin::_tc_Time24Interval,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      DsLogAdmin::Time24Interval *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::Time24Interval>::insert (
        _tao_any,
        ::DsLogAdmin::Time24Interval::_tao_any_destructor,
        ::DsLogAdmin::_tc_Time24Interval,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::Time24Interval *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::Time24Interval *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::Time24Interval *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::Time24Interval>::extract (
          _tao_any,
          ::DsLogAdmin::Time24Interval::_tao_any_destructor,
          ::DsLogAdmin::_tc_Time24Interval,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::Time24Interval &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::Time24Interval *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::Time24Interval>::insert_copy (
        _tao_any,
        DsLogAdmin::Time24Interval::_tao_any_destructor,
        DsLogAdmin::_tc_Time24Interval,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::Time24Interval *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::Time24Interval>::insert (
      _tao_any,
      DsLogAdmin::Time24Interval::_tao_any_destructor,
      DsLogAdmin::_tc_Time24Interval,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::Time24Interval *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::Time24Interval *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::Time24Interval *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::Time24Interval>::extract (
        _tao_any,
        DsLogAdmin::Time24Interval::_tao_any_destructor,
        DsLogAdmin::_tc_Time24Interval,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::IntervalsOfDay &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::IntervalsOfDay *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::IntervalsOfDay>::insert_copy (
          _tao_any,
          ::DsLogAdmin::IntervalsOfDay::_tao_any_destructor,
          ::DsLogAdmin::_tc_IntervalsOfDay,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::IntervalsOfDay *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::IntervalsOfDay>::insert (
        _tao_any,
        ::DsLogAdmin::IntervalsOfDay::_tao_any_destructor,
        ::DsLogAdmin::_tc_IntervalsOfDay,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::IntervalsOfDay *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::IntervalsOfDay *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::IntervalsOfDay *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::IntervalsOfDay>::extract (
          _tao_any,
          ::DsLogAdmin::IntervalsOfDay::_tao_any_destructor,
          ::DsLogAdmin::_tc_IntervalsOfDay,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::IntervalsOfDay &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::IntervalsOfDay *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::IntervalsOfDay>::insert_copy (
        _tao_any,
        DsLogAdmin::IntervalsOfDay::_tao_any_destructor,
        DsLogAdmin::_tc_IntervalsOfDay,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::IntervalsOfDay *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::IntervalsOfDay>::insert (
      _tao_any,
      DsLogAdmin::IntervalsOfDay::_tao_any_destructor,
      DsLogAdmin::_tc_IntervalsOfDay,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::IntervalsOfDay *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::IntervalsOfDay *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::IntervalsOfDay *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::IntervalsOfDay>::extract (
        _tao_any,
        DsLogAdmin::IntervalsOfDay::_tao_any_destructor,
        DsLogAdmin::_tc_IntervalsOfDay,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::WeekMaskItem &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::WeekMaskItem *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::WeekMaskItem>::insert_copy (
          _tao_any,
          ::DsLogAdmin::WeekMaskItem::_tao_any_destructor,
          ::DsLogAdmin::_tc_WeekMaskItem,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      DsLogAdmin::WeekMaskItem *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::WeekMaskItem>::insert (
        _tao_any,
        ::DsLogAdmin::WeekMaskItem::_tao_any_destructor,
        ::DsLogAdmin::_tc_WeekMaskItem,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::WeekMaskItem *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::WeekMaskItem *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::WeekMaskItem *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::WeekMaskItem>::extract (
          _tao_any,
          ::DsLogAdmin::WeekMaskItem::_tao_any_destructor,
          ::DsLogAdmin::_tc_WeekMaskItem,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::WeekMaskItem &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::WeekMaskItem *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::WeekMaskItem>::insert_copy (
        _tao_any,
        DsLogAdmin::WeekMaskItem::_tao_any_destructor,
        DsLogAdmin::_tc_WeekMaskItem,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::WeekMaskItem *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::WeekMaskItem>::insert (
      _tao_any,
      DsLogAdmin::WeekMaskItem::_tao_any_destructor,
      DsLogAdmin::_tc_WeekMaskItem,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::WeekMaskItem *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::WeekMaskItem *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::WeekMaskItem *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::WeekMaskItem>::extract (
        _tao_any,
        DsLogAdmin::WeekMaskItem::_tao_any_destructor,
        DsLogAdmin::_tc_WeekMaskItem,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::WeekMask &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::WeekMask *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::WeekMask>::insert_copy (
          _tao_any,
          ::DsLogAdmin::WeekMask::_tao_any_destructor,
          ::DsLogAdmin::_tc_WeekMask,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::WeekMask *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::WeekMask>::insert (
        _tao_any,
        ::DsLogAdmin::WeekMask::_tao_any_destructor,
        ::DsLogAdmin::_tc_WeekMask,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::WeekMask *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::WeekMask *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::WeekMask *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::WeekMask>::extract (
          _tao_any,
          ::DsLogAdmin::WeekMask::_tao_any_destructor,
          ::DsLogAdmin::_tc_WeekMask,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::WeekMask &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::WeekMask *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::WeekMask>::insert_copy (
        _tao_any,
        DsLogAdmin::WeekMask::_tao_any_destructor,
        DsLogAdmin::_tc_WeekMask,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::WeekMask *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::WeekMask>::insert (
      _tao_any,
      DsLogAdmin::WeekMask::_tao_any_destructor,
      DsLogAdmin::_tc_WeekMask,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::WeekMask *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::WeekMask *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::WeekMask *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::WeekMask>::extract (
        _tao_any,
        DsLogAdmin::WeekMask::_tao_any_destructor,
        DsLogAdmin::_tc_WeekMask,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::CapacityAlarmThresholdList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::CapacityAlarmThresholdList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::CapacityAlarmThresholdList>::insert_copy (
          _tao_any,
          ::DsLogAdmin::CapacityAlarmThresholdList::_tao_any_destructor,
          ::DsLogAdmin::_tc_CapacityAlarmThresholdList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::CapacityAlarmThresholdList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::CapacityAlarmThresholdList>::insert (
        _tao_any,
        ::DsLogAdmin::CapacityAlarmThresholdList::_tao_any_destructor,
        ::DsLogAdmin::_tc_CapacityAlarmThresholdList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::CapacityAlarmThresholdList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::CapacityAlarmThresholdList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::CapacityAlarmThresholdList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::CapacityAlarmThresholdList>::extract (
          _tao_any,
          ::DsLogAdmin::CapacityAlarmThresholdList::_tao_any_destructor,
          ::DsLogAdmin::_tc_CapacityAlarmThresholdList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::CapacityAlarmThresholdList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::CapacityAlarmThresholdList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::CapacityAlarmThresholdList>::insert_copy (
        _tao_any,
        DsLogAdmin::CapacityAlarmThresholdList::_tao_any_destructor,
        DsLogAdmin::_tc_CapacityAlarmThresholdList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::CapacityAlarmThresholdList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::CapacityAlarmThresholdList>::insert (
      _tao_any,
      DsLogAdmin::CapacityAlarmThresholdList::_tao_any_destructor,
      DsLogAdmin::_tc_CapacityAlarmThresholdList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::CapacityAlarmThresholdList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::CapacityAlarmThresholdList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::CapacityAlarmThresholdList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::CapacityAlarmThresholdList>::extract (
        _tao_any,
        DsLogAdmin::CapacityAlarmThresholdList::_tao_any_destructor,
        DsLogAdmin::_tc_CapacityAlarmThresholdList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::OperationalState _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::DsLogAdmin::OperationalState>::insert (
        _tao_any,
        ::DsLogAdmin::_tc_OperationalState,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::OperationalState &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::DsLogAdmin::OperationalState>::extract (
          _tao_any,
          ::DsLogAdmin::_tc_OperationalState,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::OperationalState _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<DsLogAdmin::OperationalState>::insert (
      _tao_any,
      DsLogAdmin::_tc_OperationalState,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::OperationalState &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<DsLogAdmin::OperationalState>::extract (
        _tao_any,
        DsLogAdmin::_tc_OperationalState,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::AdministrativeState _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::DsLogAdmin::AdministrativeState>::insert (
        _tao_any,
        ::DsLogAdmin::_tc_AdministrativeState,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::AdministrativeState &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::DsLogAdmin::AdministrativeState>::extract (
          _tao_any,
          ::DsLogAdmin::_tc_AdministrativeState,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::AdministrativeState _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<DsLogAdmin::AdministrativeState>::insert (
      _tao_any,
      DsLogAdmin::_tc_AdministrativeState,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::AdministrativeState &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<DsLogAdmin::AdministrativeState>::extract (
        _tao_any,
        DsLogAdmin::_tc_AdministrativeState,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::ForwardingState _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::DsLogAdmin::ForwardingState>::insert (
        _tao_any,
        ::DsLogAdmin::_tc_ForwardingState,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::ForwardingState &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::DsLogAdmin::ForwardingState>::extract (
          _tao_any,
          ::DsLogAdmin::_tc_ForwardingState,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::ForwardingState _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<DsLogAdmin::ForwardingState>::insert (
      _tao_any,
      DsLogAdmin::_tc_ForwardingState,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::ForwardingState &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<DsLogAdmin::ForwardingState>::extract (
        _tao_any,
        DsLogAdmin::_tc_ForwardingState,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::QoSList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::QoSList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::QoSList>::insert_copy (
          _tao_any,
          ::DsLogAdmin::QoSList::_tao_any_destructor,
          ::DsLogAdmin::_tc_QoSList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::QoSList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::QoSList>::insert (
        _tao_any,
        ::DsLogAdmin::QoSList::_tao_any_destructor,
        ::DsLogAdmin::_tc_QoSList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::QoSList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::QoSList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::QoSList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::QoSList>::extract (
          _tao_any,
          ::DsLogAdmin::QoSList::_tao_any_destructor,
          ::DsLogAdmin::_tc_QoSList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::QoSList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::QoSList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::QoSList>::insert_copy (
        _tao_any,
        DsLogAdmin::QoSList::_tao_any_destructor,
        DsLogAdmin::_tc_QoSList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::QoSList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::QoSList>::insert (
      _tao_any,
      DsLogAdmin::QoSList::_tao_any_destructor,
      DsLogAdmin::_tc_QoSList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::QoSList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::QoSList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::QoSList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::QoSList>::extract (
        _tao_any,
        DsLogAdmin::QoSList::_tao_any_destructor,
        DsLogAdmin::_tc_QoSList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DsLogAdmin::UnsupportedQoS>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::UnsupportedQoS &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::UnsupportedQoS>::insert_copy (
        _tao_any,
        ::DsLogAdmin::UnsupportedQoS::_tao_any_destructor,
        ::DsLogAdmin::_tc_UnsupportedQoS,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::UnsupportedQoS *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::UnsupportedQoS>::insert (
        _tao_any,
        ::DsLogAdmin::UnsupportedQoS::_tao_any_destructor,
        ::DsLogAdmin::_tc_UnsupportedQoS,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::UnsupportedQoS *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::UnsupportedQoS *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::UnsupportedQoS *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::UnsupportedQoS>::extract (
          _tao_any,
          ::DsLogAdmin::UnsupportedQoS::_tao_any_destructor,
          ::DsLogAdmin::_tc_UnsupportedQoS,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::UnsupportedQoS &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::UnsupportedQoS>::insert_copy (
      _tao_any,
      DsLogAdmin::UnsupportedQoS::_tao_any_destructor,
      DsLogAdmin::_tc_UnsupportedQoS,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::UnsupportedQoS *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::UnsupportedQoS>::insert (
      _tao_any,
      DsLogAdmin::UnsupportedQoS::_tao_any_destructor,
      DsLogAdmin::_tc_UnsupportedQoS,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::UnsupportedQoS *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::UnsupportedQoS *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::UnsupportedQoS *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::UnsupportedQoS>::extract (
        _tao_any,
        DsLogAdmin::UnsupportedQoS::_tao_any_destructor,
        DsLogAdmin::_tc_UnsupportedQoS,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DsLogAdmin::Log>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Log_ptr _tao_elem)
  {
    Log_ptr _tao_objptr =
      Log::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Log_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Log>::insert (
        _tao_any,
        Log::_tao_any_destructor,
        _tc_Log,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Log_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Log>::extract (
          _tao_any,
          Log::_tao_any_destructor,
          _tc_Log,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::Log_ptr _tao_elem)
{
  DsLogAdmin::Log_ptr _tao_objptr =
    DsLogAdmin::Log::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::Log_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DsLogAdmin::Log>::insert (
      _tao_any,
      DsLogAdmin::Log::_tao_any_destructor,
      DsLogAdmin::_tc_Log,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::Log_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DsLogAdmin::Log>::extract (
        _tao_any,
        DsLogAdmin::Log::_tao_any_destructor,
        DsLogAdmin::_tc_Log,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DsLogAdmin::BasicLog>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      BasicLog_ptr _tao_elem)
  {
    BasicLog_ptr _tao_objptr =
      BasicLog::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      BasicLog_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<BasicLog>::insert (
        _tao_any,
        BasicLog::_tao_any_destructor,
        _tc_BasicLog,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      BasicLog_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<BasicLog>::extract (
          _tao_any,
          BasicLog::_tao_any_destructor,
          _tc_BasicLog,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::BasicLog_ptr _tao_elem)
{
  DsLogAdmin::BasicLog_ptr _tao_objptr =
    DsLogAdmin::BasicLog::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::BasicLog_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DsLogAdmin::BasicLog>::insert (
      _tao_any,
      DsLogAdmin::BasicLog::_tao_any_destructor,
      DsLogAdmin::_tc_BasicLog,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::BasicLog_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DsLogAdmin::BasicLog>::extract (
        _tao_any,
        DsLogAdmin::BasicLog::_tao_any_destructor,
        DsLogAdmin::_tc_BasicLog,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::LogList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogList>::insert_copy (
          _tao_any,
          ::DsLogAdmin::LogList::_tao_any_destructor,
          ::DsLogAdmin::_tc_LogList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogList>::insert (
        _tao_any,
        ::DsLogAdmin::LogList::_tao_any_destructor,
        ::DsLogAdmin::_tc_LogList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::LogList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogList>::extract (
          _tao_any,
          ::DsLogAdmin::LogList::_tao_any_destructor,
          ::DsLogAdmin::_tc_LogList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::LogList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::LogList>::insert_copy (
        _tao_any,
        DsLogAdmin::LogList::_tao_any_destructor,
        DsLogAdmin::_tc_LogList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::LogList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::LogList>::insert (
      _tao_any,
      DsLogAdmin::LogList::_tao_any_destructor,
      DsLogAdmin::_tc_LogList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::LogList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::LogList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::LogList>::extract (
        _tao_any,
        DsLogAdmin::LogList::_tao_any_destructor,
        DsLogAdmin::_tc_LogList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogIdList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DsLogAdmin::LogIdList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogIdList>::insert_copy (
          _tao_any,
          ::DsLogAdmin::LogIdList::_tao_any_destructor,
          ::DsLogAdmin::_tc_LogIdList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogIdList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogIdList>::insert (
        _tao_any,
        ::DsLogAdmin::LogIdList::_tao_any_destructor,
        ::DsLogAdmin::_tc_LogIdList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DsLogAdmin::LogIdList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DsLogAdmin::LogIdList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DsLogAdmin::LogIdList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DsLogAdmin::LogIdList>::extract (
          _tao_any,
          ::DsLogAdmin::LogIdList::_tao_any_destructor,
          ::DsLogAdmin::_tc_LogIdList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogIdList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DsLogAdmin::LogIdList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DsLogAdmin::LogIdList>::insert_copy (
        _tao_any,
        DsLogAdmin::LogIdList::_tao_any_destructor,
        DsLogAdmin::_tc_LogIdList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::LogIdList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DsLogAdmin::LogIdList>::insert (
      _tao_any,
      DsLogAdmin::LogIdList::_tao_any_destructor,
      DsLogAdmin::_tc_LogIdList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::LogIdList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DsLogAdmin::LogIdList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DsLogAdmin::LogIdList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DsLogAdmin::LogIdList>::extract (
        _tao_any,
        DsLogAdmin::LogIdList::_tao_any_destructor,
        DsLogAdmin::_tc_LogIdList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DsLogAdmin::LogMgr>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      LogMgr_ptr _tao_elem)
  {
    LogMgr_ptr _tao_objptr =
      LogMgr::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      LogMgr_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<LogMgr>::insert (
        _tao_any,
        LogMgr::_tao_any_destructor,
        _tc_LogMgr,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      LogMgr_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<LogMgr>::extract (
          _tao_any,
          LogMgr::_tao_any_destructor,
          _tc_LogMgr,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::LogMgr_ptr _tao_elem)
{
  DsLogAdmin::LogMgr_ptr _tao_objptr =
    DsLogAdmin::LogMgr::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::LogMgr_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DsLogAdmin::LogMgr>::insert (
      _tao_any,
      DsLogAdmin::LogMgr::_tao_any_destructor,
      DsLogAdmin::_tc_LogMgr,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::LogMgr_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DsLogAdmin::LogMgr>::extract (
        _tao_any,
        DsLogAdmin::LogMgr::_tao_any_destructor,
        DsLogAdmin::_tc_LogMgr,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DsLogAdmin::BasicLogFactory>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DsLogAdmin
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      BasicLogFactory_ptr _tao_elem)
  {
    BasicLogFactory_ptr _tao_objptr =
      BasicLogFactory::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      BasicLogFactory_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<BasicLogFactory>::insert (
        _tao_any,
        BasicLogFactory::_tao_any_destructor,
        _tc_BasicLogFactory,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      BasicLogFactory_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<BasicLogFactory>::extract (
          _tao_any,
          BasicLogFactory::_tao_any_destructor,
          _tc_BasicLogFactory,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::BasicLogFactory_ptr _tao_elem)
{
  DsLogAdmin::BasicLogFactory_ptr _tao_objptr =
    DsLogAdmin::BasicLogFactory::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DsLogAdmin::BasicLogFactory_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DsLogAdmin::BasicLogFactory>::insert (
      _tao_any,
      DsLogAdmin::BasicLogFactory::_tao_any_destructor,
      DsLogAdmin::_tc_BasicLogFactory,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DsLogAdmin::BasicLogFactory_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DsLogAdmin::BasicLogFactory>::extract (
        _tao_any,
        DsLogAdmin::BasicLogFactory::_tao_any_destructor,
        DsLogAdmin::_tc_BasicLogFactory,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::InvalidParam &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.details.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::InvalidParam &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.details.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::InvalidThreshold &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    DsLogAdmin::InvalidThreshold&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::InvalidTime &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    DsLogAdmin::InvalidTime&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::InvalidTimeInterval &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    DsLogAdmin::InvalidTimeInterval&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::InvalidMask &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    DsLogAdmin::InvalidMask&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::LogIdAlreadyExists &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    DsLogAdmin::LogIdAlreadyExists&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::InvalidGrammar &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    DsLogAdmin::InvalidGrammar&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::InvalidConstraint &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    DsLogAdmin::InvalidConstraint&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::LogFull &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.n_records_written)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::LogFull &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.n_records_written)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::LogOffDuty &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    DsLogAdmin::LogOffDuty&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::LogLocked &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    DsLogAdmin::LogLocked&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::LogDisabled &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    DsLogAdmin::LogDisabled&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::InvalidRecordId &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    DsLogAdmin::InvalidRecordId&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::InvalidAttribute &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.attr_name.in ()) &&
        (strm << _tao_aggregate.value)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::InvalidAttribute &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.attr_name.out ()) &&
    (strm >> _tao_aggregate.value)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::InvalidLogFullAction &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    DsLogAdmin::InvalidLogFullAction&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_DsLogAdmin_RecordIdList_CPP_
#define _TAO_CDR_OP_DsLogAdmin_RecordIdList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::RecordIdList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::RecordIdList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_DsLogAdmin_RecordIdList_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::NVPair &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::NVPair &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_DsLogAdmin_NVList_CPP_
#define _TAO_CDR_OP_DsLogAdmin_NVList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::NVList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::NVList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_DsLogAdmin_NVList_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::TimeInterval &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.start) &&
    (strm << _tao_aggregate.stop);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::TimeInterval &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.start) &&
    (strm >> _tao_aggregate.stop);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_DsLogAdmin_TimeIntervalSeq_CPP_
#define _TAO_CDR_OP_DsLogAdmin_TimeIntervalSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::TimeIntervalSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::TimeIntervalSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_DsLogAdmin_TimeIntervalSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::LogRecord &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.id) &&
    (strm << _tao_aggregate.time) &&
    (strm << _tao_aggregate.attr_list) &&
    (strm << _tao_aggregate.info);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::LogRecord &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.id) &&
    (strm >> _tao_aggregate.time) &&
    (strm >> _tao_aggregate.attr_list) &&
    (strm >> _tao_aggregate.info);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_DsLogAdmin_RecordList_CPP_
#define _TAO_CDR_OP_DsLogAdmin_RecordList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::RecordList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::RecordList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_DsLogAdmin_RecordList_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_DsLogAdmin_Anys_CPP_
#define _TAO_CDR_OP_DsLogAdmin_Anys_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::Anys &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::Anys &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_DsLogAdmin_Anys_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::Iterator_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::Iterator_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::DsLogAdmin::Iterator RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        DsLogAdmin__TAO_Iterator_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::AvailabilityStatus &_tao_aggregate)
{
  return
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.off_duty)) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.log_full));
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::AvailabilityStatus &_tao_aggregate)
{
  return
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.off_duty)) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.log_full));
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::Time24 &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.hour) &&
    (strm << _tao_aggregate.minute);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::Time24 &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.hour) &&
    (strm >> _tao_aggregate.minute);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::Time24Interval &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.start) &&
    (strm << _tao_aggregate.stop);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::Time24Interval &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.start) &&
    (strm >> _tao_aggregate.stop);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_DsLogAdmin_IntervalsOfDay_CPP_
#define _TAO_CDR_OP_DsLogAdmin_IntervalsOfDay_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::IntervalsOfDay &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::IntervalsOfDay &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_DsLogAdmin_IntervalsOfDay_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::WeekMaskItem &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.days) &&
    (strm << _tao_aggregate.intervals);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::WeekMaskItem &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.days) &&
    (strm >> _tao_aggregate.intervals);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_DsLogAdmin_WeekMask_CPP_
#define _TAO_CDR_OP_DsLogAdmin_WeekMask_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::WeekMask &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::WeekMask &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_DsLogAdmin_WeekMask_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_DsLogAdmin_CapacityAlarmThresholdList_CPP_
#define _TAO_CDR_OP_DsLogAdmin_CapacityAlarmThresholdList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::CapacityAlarmThresholdList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::CapacityAlarmThresholdList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_DsLogAdmin_CapacityAlarmThresholdList_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, DsLogAdmin::OperationalState _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, DsLogAdmin::OperationalState & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<DsLogAdmin::OperationalState> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, DsLogAdmin::AdministrativeState _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, DsLogAdmin::AdministrativeState & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<DsLogAdmin::AdministrativeState> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, DsLogAdmin::ForwardingState _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, DsLogAdmin::ForwardingState & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<DsLogAdmin::ForwardingState> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_DsLogAdmin_QoSList_CPP_
#define _TAO_CDR_OP_DsLogAdmin_QoSList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::QoSList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::QoSList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_DsLogAdmin_QoSList_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::UnsupportedQoS &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.denied)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::UnsupportedQoS &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.denied)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::Log_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::Log_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::DsLogAdmin::Log RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        DsLogAdmin__TAO_Log_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::BasicLog_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::BasicLog_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::DsLogAdmin::BasicLog RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        DsLogAdmin__TAO_BasicLog_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_DsLogAdmin_LogList_CPP_
#define _TAO_CDR_OP_DsLogAdmin_LogList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::LogList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::LogList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_DsLogAdmin_LogList_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_DsLogAdmin_LogIdList_CPP_
#define _TAO_CDR_OP_DsLogAdmin_LogIdList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::LogIdList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::LogIdList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_DsLogAdmin_LogIdList_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::LogMgr_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::LogMgr_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::DsLogAdmin::LogMgr RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        DsLogAdmin__TAO_LogMgr_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DsLogAdmin::BasicLogFactory_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DsLogAdmin::BasicLogFactory_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::DsLogAdmin::BasicLogFactory RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        DsLogAdmin__TAO_BasicLogFactory_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL





TAO_END_VERSIONED_NAMESPACE_DECL


