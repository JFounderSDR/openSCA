// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/


// TAO_IDL - Generated from 
// .\be\be_codegen.cpp:651

#ifndef _TAO_IDL_COSLOADBALANCINGS_SBLBK3_CPP_
#define _TAO_IDL_COSLOADBALANCINGS_SBLBK3_CPP_


#include "CosLoadBalancingS.h"
#include "tao/PortableServer/Operation_Table_Perfect_Hash.h"
#include "tao/Exception_Data.h"
#include "tao/Messaging/ExceptionHolder_i.h"
#include "tao/PortableServer/Upcall_Command.h"
#include "tao/PortableServer/Upcall_Wrapper.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Profile.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/Object_T.h"
#include "tao/AnyTypeCode/TypeCode.h"
#include "tao/AnyTypeCode/DynamicC.h"
#include "tao/CDR.h"
#include "tao/operation_details.h"
#include "tao/PortableInterceptor.h"
#include "ace/Dynamic_Service.h"
#include "ace/Malloc_Allocator.h"

#if !defined (__ACE_INLINE__)
#include "CosLoadBalancingS.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_CosLoadBalancing_Strategy_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CosLoadBalancing_Strategy_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CosLoadBalancing_Strategy_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26,  0, 26, 10, 26, 26,
      5, 15, 26,  0, 26, 26, 26, 26, 26, 26,
      0, 26, 10, 26,  0,  0,  0, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CosLoadBalancing_Strategy_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 11,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 9,
      MAX_HASH_VALUE = 25,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 0,
      WORDLIST_SIZE = 20
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
            {"get_loads", &POA_CosLoadBalancing::Strategy::get_loads_skel, 0},
      {"_component", &POA_CosLoadBalancing::Strategy::_component_skel, 0},
      {"next_member", &POA_CosLoadBalancing::Strategy::next_member_skel, 0},
      {"",0,0},
      {"_non_existent", &POA_CosLoadBalancing::Strategy::_non_existent_skel, 0},
      {"get_properties", &POA_CosLoadBalancing::Strategy::get_properties_skel, 0},
      {"_is_a", &POA_CosLoadBalancing::Strategy::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_repository_id", &POA_CosLoadBalancing::Strategy::_repository_id_skel, 0},
      {"push_loads", &POA_CosLoadBalancing::Strategy::push_loads_skel, 0},
      {"",0,0},{"",0,0},
      {"analyze_loads", &POA_CosLoadBalancing::Strategy::analyze_loads_skel, 0},
      {"_get_name", &POA_CosLoadBalancing::Strategy::_get_name_skel, 0},
      {"_interface", &POA_CosLoadBalancing::Strategy::_interface_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CosLoadBalancing_Strategy_Perfect_Hash_OpTable tao_CosLoadBalancing_Strategy_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
CosLoadBalancing__TAO_Strategy_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CosLoadBalancing__TAO_Strategy_Proxy_Broker_Factory_Initializer (size_t)
{
  CosLoadBalancing__TAO_Strategy_Proxy_Broker_Factory_function_pointer = 
    CosLoadBalancing__TAO_Strategy_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CosLoadBalancing__TAO_Strategy_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CosLoadBalancing__TAO_Strategy_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CosLoadBalancing__TAO_Strategy_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_CosLoadBalancing::Strategy::Strategy (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CosLoadBalancing_Strategy_optable;
}

POA_CosLoadBalancing::Strategy::Strategy (const Strategy& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_CosLoadBalancing::Strategy::~Strategy (void)
{
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_name_Strategy
    : public TAO::Upcall_Command
  {
  public:
    inline _get_name_Strategy (
      POA_CosLoadBalancing::Strategy * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->name ();
    }
  
  private:
    POA_CosLoadBalancing::Strategy * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::Strategy::_get_name_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::Strategy * const impl =
    static_cast<POA_CosLoadBalancing::Strategy *> (servant);

  _get_name_Strategy command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_properties_Strategy
    : public TAO::Upcall_Command
  {
  public:
    inline get_properties_Strategy (
      POA_CosLoadBalancing::Strategy * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosLoadBalancing::Properties>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CosLoadBalancing::Properties> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->get_properties ();
    }
  
  private:
    POA_CosLoadBalancing::Strategy * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::Strategy::get_properties_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CosLoadBalancing::Properties>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::Strategy * const impl =
    static_cast<POA_CosLoadBalancing::Strategy *> (servant);

  get_properties_Strategy command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class push_loads_Strategy
    : public TAO::Upcall_Command
  {
  public:
    inline push_loads_Strategy (
      POA_CosLoadBalancing::Strategy * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::PortableGroup::Location> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CosLoadBalancing::LoadList> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->push_loads (
        arg_1
        , arg_2);
    }
  
  private:
    POA_CosLoadBalancing::Strategy * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::Strategy::push_loads_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_StrategyNotAdaptive
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location;
  TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::in_arg_val _tao_loads;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_location,
      &_tao_loads
    };
  
  static size_t const nargs = 3;

  POA_CosLoadBalancing::Strategy * const impl =
    static_cast<POA_CosLoadBalancing::Strategy *> (servant);

  push_loads_Strategy command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_loads_Strategy
    : public TAO::Upcall_Command
  {
  public:
    inline get_loads_Strategy (
      POA_CosLoadBalancing::Strategy * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CosLoadBalancing::LoadList> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CosLoadBalancing::LoadManager>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CosLoadBalancing::LoadManager> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::PortableGroup::Location> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->get_loads (
          arg_1
          , arg_2);
    }
  
  private:
    POA_CosLoadBalancing::Strategy * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::Strategy::get_loads_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LocationNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::ret_val retval;
  TAO::SArg_Traits< ::CosLoadBalancing::LoadManager>::in_arg_val _tao_load_manager;
  TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_load_manager,
      &_tao_the_location
    };
  
  static size_t const nargs = 3;

  POA_CosLoadBalancing::Strategy * const impl =
    static_cast<POA_CosLoadBalancing::Strategy *> (servant);

  get_loads_Strategy command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class next_member_Strategy
    : public TAO::Upcall_Command
  {
  public:
    inline next_member_Strategy (
      POA_CosLoadBalancing::Strategy * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Object>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CosLoadBalancing::LoadManager>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CosLoadBalancing::LoadManager> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->next_member (
          arg_1
          , arg_2);
    }
  
  private:
    POA_CosLoadBalancing::Strategy * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::Strategy::next_member_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      PortableGroup::_tc_ObjectGroupNotFound,
      PortableGroup::_tc_MemberNotFound
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group;
  TAO::SArg_Traits< ::CosLoadBalancing::LoadManager>::in_arg_val _tao_load_manager;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_object_group,
      &_tao_load_manager
    };
  
  static size_t const nargs = 3;

  POA_CosLoadBalancing::Strategy * const impl =
    static_cast<POA_CosLoadBalancing::Strategy *> (servant);

  next_member_Strategy command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class analyze_loads_Strategy
    : public TAO::Upcall_Command
  {
  public:
    inline analyze_loads_Strategy (
      POA_CosLoadBalancing::Strategy * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CosLoadBalancing::LoadManager>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CosLoadBalancing::LoadManager> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->analyze_loads (
        arg_1
        , arg_2);
    }
  
  private:
    POA_CosLoadBalancing::Strategy * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::Strategy::analyze_loads_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group;
  TAO::SArg_Traits< ::CosLoadBalancing::LoadManager>::in_arg_val _tao_load_manager;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_object_group,
      &_tao_load_manager
    };
  
  static size_t const nargs = 3;

  POA_CosLoadBalancing::Strategy * const impl =
    static_cast<POA_CosLoadBalancing::Strategy *> (servant);

  analyze_loads_Strategy command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_Strategy_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_Strategy_Upcall_Command (
      POA_CosLoadBalancing::Strategy * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_CosLoadBalancing::Strategy * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::Strategy::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::Strategy * const impl =
    static_cast<POA_CosLoadBalancing::Strategy *> (servant);
  
  _is_a_Strategy_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_Strategy_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_Strategy_Upcall_Command (
      POA_CosLoadBalancing::Strategy * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_CosLoadBalancing::Strategy * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::Strategy::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::Strategy * const impl =
    static_cast<POA_CosLoadBalancing::Strategy *> (servant);
  
  _non_existent_Strategy_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_Strategy_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_Strategy_Upcall_Command (
      POA_CosLoadBalancing::Strategy * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_CosLoadBalancing::Strategy * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::Strategy::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::Strategy * const impl =
    static_cast<POA_CosLoadBalancing::Strategy *> (servant);
  
  _repository_id_Strategy_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_CosLoadBalancing::Strategy::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_CosLoadBalancing::Strategy * const impl =
    static_cast<POA_CosLoadBalancing::Strategy *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_Strategy_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_Strategy_Upcall_Command (
      POA_CosLoadBalancing::Strategy * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_CosLoadBalancing::Strategy * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::Strategy::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::Strategy * const impl =
    static_cast<POA_CosLoadBalancing::Strategy *> (servant);
  
  _get_component_Strategy_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CosLoadBalancing::Strategy::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/Strategy:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CosLoadBalancing::Strategy::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/Strategy:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_CosLoadBalancing::Strategy::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

CosLoadBalancing::Strategy *
POA_CosLoadBalancing::Strategy::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CosLoadBalancing::Strategy STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_Strategy_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_CosLoadBalancing_AMI_StrategyHandler_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CosLoadBalancing_AMI_StrategyHandler_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CosLoadBalancing_AMI_StrategyHandler_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30,  0, 30,  0, 30, 30,
      5, 13, 30,  0, 30, 30, 30, 30, 30, 30,
      0, 30,  0, 30,  0, 15,  0, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CosLoadBalancing_AMI_StrategyHandler_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 15,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 20,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 29,
      HASH_VALUE_RANGE = 25,
      DUPLICATES = 0,
      WORDLIST_SIZE = 20
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CosLoadBalancing::AMI_StrategyHandler::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_component", &POA_CosLoadBalancing::AMI_StrategyHandler::_component_skel, 0},
      {"next_member", &POA_CosLoadBalancing::AMI_StrategyHandler::next_member_skel, 0},
      {"",0,0},
      {"_non_existent", &POA_CosLoadBalancing::AMI_StrategyHandler::_non_existent_skel, 0},
      {"get_name_excep", &POA_CosLoadBalancing::AMI_StrategyHandler::get_name_excep_skel, 0},
      {"get_loads_excep", &POA_CosLoadBalancing::AMI_StrategyHandler::get_loads_excep_skel, 0},
      {"push_loads_excep", &POA_CosLoadBalancing::AMI_StrategyHandler::push_loads_excep_skel, 0},
      {"next_member_excep", &POA_CosLoadBalancing::AMI_StrategyHandler::next_member_excep_skel, 0},
      {"",0,0},
      {"_repository_id", &POA_CosLoadBalancing::AMI_StrategyHandler::_repository_id_skel, 0},
      {"get_properties_excep", &POA_CosLoadBalancing::AMI_StrategyHandler::get_properties_excep_skel, 0},
      {"get_name", &POA_CosLoadBalancing::AMI_StrategyHandler::get_name_skel, 0},
      {"",0,0},
      {"_interface", &POA_CosLoadBalancing::AMI_StrategyHandler::_interface_skel, 0},
      {"get_loads", &POA_CosLoadBalancing::AMI_StrategyHandler::get_loads_skel, 0},
      {"push_loads", &POA_CosLoadBalancing::AMI_StrategyHandler::push_loads_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"get_properties", &POA_CosLoadBalancing::AMI_StrategyHandler::get_properties_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CosLoadBalancing_AMI_StrategyHandler_Perfect_Hash_OpTable tao_CosLoadBalancing_AMI_StrategyHandler_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
CosLoadBalancing__TAO_AMI_StrategyHandler_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CosLoadBalancing__TAO_AMI_StrategyHandler_Proxy_Broker_Factory_Initializer (size_t)
{
  CosLoadBalancing__TAO_AMI_StrategyHandler_Proxy_Broker_Factory_function_pointer = 
    CosLoadBalancing__TAO_AMI_StrategyHandler_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CosLoadBalancing__TAO_AMI_StrategyHandler_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CosLoadBalancing__TAO_AMI_StrategyHandler_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CosLoadBalancing__TAO_AMI_StrategyHandler_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_CosLoadBalancing::AMI_StrategyHandler::AMI_StrategyHandler (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CosLoadBalancing_AMI_StrategyHandler_optable;
}

POA_CosLoadBalancing::AMI_StrategyHandler::AMI_StrategyHandler (const AMI_StrategyHandler& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ::POA_Messaging::ReplyHandler (rhs)
{
}

POA_CosLoadBalancing::AMI_StrategyHandler::~AMI_StrategyHandler (void)
{
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_name_AMI_StrategyHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_name_AMI_StrategyHandler (
      POA_CosLoadBalancing::AMI_StrategyHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->get_name (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_StrategyHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_StrategyHandler::get_name_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_ami_return_val;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_ami_return_val
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);

  get_name_AMI_StrategyHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_name_excep_AMI_StrategyHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_name_excep_AMI_StrategyHandler (
      POA_CosLoadBalancing::AMI_StrategyHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->get_name_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_StrategyHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_StrategyHandler::get_name_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);

  get_name_excep_AMI_StrategyHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_properties_AMI_StrategyHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_properties_AMI_StrategyHandler (
      POA_CosLoadBalancing::AMI_StrategyHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosLoadBalancing::Properties>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CosLoadBalancing::Properties> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->get_properties (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_StrategyHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_StrategyHandler::get_properties_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CosLoadBalancing::Properties>::in_arg_val _tao_ami_return_val;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_ami_return_val
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);

  get_properties_AMI_StrategyHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_properties_excep_AMI_StrategyHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_properties_excep_AMI_StrategyHandler (
      POA_CosLoadBalancing::AMI_StrategyHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->get_properties_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_StrategyHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_StrategyHandler::get_properties_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);

  get_properties_excep_AMI_StrategyHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class push_loads_AMI_StrategyHandler
    : public TAO::Upcall_Command
  {
  public:
    inline push_loads_AMI_StrategyHandler (
      POA_CosLoadBalancing::AMI_StrategyHandler * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->push_loads ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_StrategyHandler * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_StrategyHandler::push_loads_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_StrategyNotAdaptive
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);

  push_loads_AMI_StrategyHandler command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class push_loads_excep_AMI_StrategyHandler
    : public TAO::Upcall_Command
  {
  public:
    inline push_loads_excep_AMI_StrategyHandler (
      POA_CosLoadBalancing::AMI_StrategyHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      

      static TAO::Exception_Data
      _tao_CosLoadBalancing_AMI_StrategyHandler_push_loads_excep_exceptiondata [] = 
        {
          {
            "IDL:tao.lb/CosLoadBalancing/StrategyNotAdaptive:1.0",
            CosLoadBalancing::StrategyNotAdaptive::_alloc
#if TAO_HAS_INTERCEPTORS == 1
            , CosLoadBalancing::_tc_StrategyNotAdaptive
#endif /* TAO_HAS_INTERCEPTORS */
          }
        };
      TAO::ExceptionHolder *tao_excepholder = 
        dynamic_cast<TAO::ExceptionHolder *> (arg_1);
      if (tao_excepholder != 0)
        {
          tao_excepholder->set_exception_data (_tao_CosLoadBalancing_AMI_StrategyHandler_push_loads_excep_exceptiondata, 1);
        }
      
      this->servant_->push_loads_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_StrategyHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_StrategyHandler::push_loads_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_StrategyNotAdaptive
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);

  push_loads_excep_AMI_StrategyHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_loads_AMI_StrategyHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_loads_AMI_StrategyHandler (
      POA_CosLoadBalancing::AMI_StrategyHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CosLoadBalancing::LoadList> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->get_loads (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_StrategyHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_StrategyHandler::get_loads_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LocationNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::in_arg_val _tao_ami_return_val;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_ami_return_val
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);

  get_loads_AMI_StrategyHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_loads_excep_AMI_StrategyHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_loads_excep_AMI_StrategyHandler (
      POA_CosLoadBalancing::AMI_StrategyHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      

      static TAO::Exception_Data
      _tao_CosLoadBalancing_AMI_StrategyHandler_get_loads_excep_exceptiondata [] = 
        {
          {
            "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
            CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
            , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
          }
        };
      TAO::ExceptionHolder *tao_excepholder = 
        dynamic_cast<TAO::ExceptionHolder *> (arg_1);
      if (tao_excepholder != 0)
        {
          tao_excepholder->set_exception_data (_tao_CosLoadBalancing_AMI_StrategyHandler_get_loads_excep_exceptiondata, 1);
        }
      
      this->servant_->get_loads_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_StrategyHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_StrategyHandler::get_loads_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LocationNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);

  get_loads_excep_AMI_StrategyHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class next_member_AMI_StrategyHandler
    : public TAO::Upcall_Command
  {
  public:
    inline next_member_AMI_StrategyHandler (
      POA_CosLoadBalancing::AMI_StrategyHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->next_member (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_StrategyHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_StrategyHandler::next_member_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      PortableGroup::_tc_ObjectGroupNotFound,
      PortableGroup::_tc_MemberNotFound
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Object>::in_arg_val _tao_ami_return_val;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_ami_return_val
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);

  next_member_AMI_StrategyHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class next_member_excep_AMI_StrategyHandler
    : public TAO::Upcall_Command
  {
  public:
    inline next_member_excep_AMI_StrategyHandler (
      POA_CosLoadBalancing::AMI_StrategyHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      

      static TAO::Exception_Data
      _tao_CosLoadBalancing_AMI_StrategyHandler_next_member_excep_exceptiondata [] = 
        {
          {
            "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
            PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
            , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
          },

          {
            "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
            PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
            , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
          }
        };
      TAO::ExceptionHolder *tao_excepholder = 
        dynamic_cast<TAO::ExceptionHolder *> (arg_1);
      if (tao_excepholder != 0)
        {
          tao_excepholder->set_exception_data (_tao_CosLoadBalancing_AMI_StrategyHandler_next_member_excep_exceptiondata, 2);
        }
      
      this->servant_->next_member_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_StrategyHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_StrategyHandler::next_member_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      PortableGroup::_tc_ObjectGroupNotFound,
      PortableGroup::_tc_MemberNotFound
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);

  next_member_excep_AMI_StrategyHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_AMI_StrategyHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_AMI_StrategyHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_StrategyHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_StrategyHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_StrategyHandler::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);
  
  _is_a_AMI_StrategyHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_AMI_StrategyHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_AMI_StrategyHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_StrategyHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_StrategyHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_StrategyHandler::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);
  
  _non_existent_AMI_StrategyHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_AMI_StrategyHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_AMI_StrategyHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_StrategyHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_StrategyHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_StrategyHandler::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);
  
  _repository_id_AMI_StrategyHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_CosLoadBalancing::AMI_StrategyHandler::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_AMI_StrategyHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_AMI_StrategyHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_StrategyHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_StrategyHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_StrategyHandler::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_StrategyHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_StrategyHandler *> (servant);
  
  _get_component_AMI_StrategyHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CosLoadBalancing::AMI_StrategyHandler::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/AMI_StrategyHandler:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CosLoadBalancing::AMI_StrategyHandler::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/AMI_StrategyHandler:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_CosLoadBalancing::AMI_StrategyHandler::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

CosLoadBalancing::AMI_StrategyHandler *
POA_CosLoadBalancing::AMI_StrategyHandler::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CosLoadBalancing::AMI_StrategyHandler STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_AMI_StrategyHandler_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_CosLoadBalancing_LoadAlert_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CosLoadBalancing_LoadAlert_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CosLoadBalancing_LoadAlert_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20,  0, 20,  0, 20, 20,
      5,  5, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20,  0, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CosLoadBalancing_LoadAlert_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 19,
      HASH_VALUE_RANGE = 15,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CosLoadBalancing::LoadAlert::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_component", &POA_CosLoadBalancing::LoadAlert::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_CosLoadBalancing::LoadAlert::_non_existent_skel, 0},
      {"",0,0},
      {"_interface", &POA_CosLoadBalancing::LoadAlert::_interface_skel, 0},
      {"",0,0},
      {"enable_alert", &POA_CosLoadBalancing::LoadAlert::enable_alert_skel, 0},
      {"disable_alert", &POA_CosLoadBalancing::LoadAlert::disable_alert_skel, 0},
      {"_repository_id", &POA_CosLoadBalancing::LoadAlert::_repository_id_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CosLoadBalancing_LoadAlert_Perfect_Hash_OpTable tao_CosLoadBalancing_LoadAlert_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
CosLoadBalancing__TAO_LoadAlert_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CosLoadBalancing__TAO_LoadAlert_Proxy_Broker_Factory_Initializer (size_t)
{
  CosLoadBalancing__TAO_LoadAlert_Proxy_Broker_Factory_function_pointer = 
    CosLoadBalancing__TAO_LoadAlert_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CosLoadBalancing__TAO_LoadAlert_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CosLoadBalancing__TAO_LoadAlert_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CosLoadBalancing__TAO_LoadAlert_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_CosLoadBalancing::LoadAlert::LoadAlert (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CosLoadBalancing_LoadAlert_optable;
}

POA_CosLoadBalancing::LoadAlert::LoadAlert (const LoadAlert& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_CosLoadBalancing::LoadAlert::~LoadAlert (void)
{
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class enable_alert_LoadAlert
    : public TAO::Upcall_Command
  {
  public:
    inline enable_alert_LoadAlert (
      POA_CosLoadBalancing::LoadAlert * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->enable_alert ();
    }
  
  private:
    POA_CosLoadBalancing::LoadAlert * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::LoadAlert::enable_alert_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::LoadAlert * const impl =
    static_cast<POA_CosLoadBalancing::LoadAlert *> (servant);

  enable_alert_LoadAlert command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class disable_alert_LoadAlert
    : public TAO::Upcall_Command
  {
  public:
    inline disable_alert_LoadAlert (
      POA_CosLoadBalancing::LoadAlert * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->disable_alert ();
    }
  
  private:
    POA_CosLoadBalancing::LoadAlert * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::LoadAlert::disable_alert_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::LoadAlert * const impl =
    static_cast<POA_CosLoadBalancing::LoadAlert *> (servant);

  disable_alert_LoadAlert command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_LoadAlert_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_LoadAlert_Upcall_Command (
      POA_CosLoadBalancing::LoadAlert * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_CosLoadBalancing::LoadAlert * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::LoadAlert::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::LoadAlert * const impl =
    static_cast<POA_CosLoadBalancing::LoadAlert *> (servant);
  
  _is_a_LoadAlert_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_LoadAlert_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_LoadAlert_Upcall_Command (
      POA_CosLoadBalancing::LoadAlert * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_CosLoadBalancing::LoadAlert * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::LoadAlert::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::LoadAlert * const impl =
    static_cast<POA_CosLoadBalancing::LoadAlert *> (servant);
  
  _non_existent_LoadAlert_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_LoadAlert_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_LoadAlert_Upcall_Command (
      POA_CosLoadBalancing::LoadAlert * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_CosLoadBalancing::LoadAlert * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::LoadAlert::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::LoadAlert * const impl =
    static_cast<POA_CosLoadBalancing::LoadAlert *> (servant);
  
  _repository_id_LoadAlert_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_CosLoadBalancing::LoadAlert::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_CosLoadBalancing::LoadAlert * const impl =
    static_cast<POA_CosLoadBalancing::LoadAlert *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_LoadAlert_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_LoadAlert_Upcall_Command (
      POA_CosLoadBalancing::LoadAlert * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_CosLoadBalancing::LoadAlert * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::LoadAlert::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::LoadAlert * const impl =
    static_cast<POA_CosLoadBalancing::LoadAlert *> (servant);
  
  _get_component_LoadAlert_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CosLoadBalancing::LoadAlert::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/LoadAlert:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CosLoadBalancing::LoadAlert::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/LoadAlert:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_CosLoadBalancing::LoadAlert::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

CosLoadBalancing::LoadAlert *
POA_CosLoadBalancing::LoadAlert::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CosLoadBalancing::LoadAlert STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_LoadAlert_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_CosLoadBalancing_AMI_LoadAlertHandler_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CosLoadBalancing_AMI_LoadAlertHandler_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CosLoadBalancing_AMI_LoadAlertHandler_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25,  0, 25,  0, 25, 25,
      5,  5, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25,  0, 25, 25, 25,  0, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CosLoadBalancing_AMI_LoadAlertHandler_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 19,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 24,
      HASH_VALUE_RANGE = 20,
      DUPLICATES = 0,
      WORDLIST_SIZE = 14
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CosLoadBalancing::AMI_LoadAlertHandler::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_component", &POA_CosLoadBalancing::AMI_LoadAlertHandler::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_CosLoadBalancing::AMI_LoadAlertHandler::_non_existent_skel, 0},
      {"",0,0},
      {"_interface", &POA_CosLoadBalancing::AMI_LoadAlertHandler::_interface_skel, 0},
      {"",0,0},
      {"enable_alert", &POA_CosLoadBalancing::AMI_LoadAlertHandler::enable_alert_skel, 0},
      {"disable_alert", &POA_CosLoadBalancing::AMI_LoadAlertHandler::disable_alert_skel, 0},
      {"_repository_id", &POA_CosLoadBalancing::AMI_LoadAlertHandler::_repository_id_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"enable_alert_excep", &POA_CosLoadBalancing::AMI_LoadAlertHandler::enable_alert_excep_skel, 0},
      {"disable_alert_excep", &POA_CosLoadBalancing::AMI_LoadAlertHandler::disable_alert_excep_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CosLoadBalancing_AMI_LoadAlertHandler_Perfect_Hash_OpTable tao_CosLoadBalancing_AMI_LoadAlertHandler_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
CosLoadBalancing__TAO_AMI_LoadAlertHandler_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CosLoadBalancing__TAO_AMI_LoadAlertHandler_Proxy_Broker_Factory_Initializer (size_t)
{
  CosLoadBalancing__TAO_AMI_LoadAlertHandler_Proxy_Broker_Factory_function_pointer = 
    CosLoadBalancing__TAO_AMI_LoadAlertHandler_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CosLoadBalancing__TAO_AMI_LoadAlertHandler_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CosLoadBalancing__TAO_AMI_LoadAlertHandler_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CosLoadBalancing__TAO_AMI_LoadAlertHandler_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_CosLoadBalancing::AMI_LoadAlertHandler::AMI_LoadAlertHandler (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CosLoadBalancing_AMI_LoadAlertHandler_optable;
}

POA_CosLoadBalancing::AMI_LoadAlertHandler::AMI_LoadAlertHandler (const AMI_LoadAlertHandler& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ::POA_Messaging::ReplyHandler (rhs)
{
}

POA_CosLoadBalancing::AMI_LoadAlertHandler::~AMI_LoadAlertHandler (void)
{
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class enable_alert_AMI_LoadAlertHandler
    : public TAO::Upcall_Command
  {
  public:
    inline enable_alert_AMI_LoadAlertHandler (
      POA_CosLoadBalancing::AMI_LoadAlertHandler * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->enable_alert ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadAlertHandler * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadAlertHandler::enable_alert_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadAlertHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadAlertHandler *> (servant);

  enable_alert_AMI_LoadAlertHandler command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class enable_alert_excep_AMI_LoadAlertHandler
    : public TAO::Upcall_Command
  {
  public:
    inline enable_alert_excep_AMI_LoadAlertHandler (
      POA_CosLoadBalancing::AMI_LoadAlertHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->enable_alert_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadAlertHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadAlertHandler::enable_alert_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadAlertHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadAlertHandler *> (servant);

  enable_alert_excep_AMI_LoadAlertHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class disable_alert_AMI_LoadAlertHandler
    : public TAO::Upcall_Command
  {
  public:
    inline disable_alert_AMI_LoadAlertHandler (
      POA_CosLoadBalancing::AMI_LoadAlertHandler * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->disable_alert ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadAlertHandler * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadAlertHandler::disable_alert_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadAlertHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadAlertHandler *> (servant);

  disable_alert_AMI_LoadAlertHandler command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class disable_alert_excep_AMI_LoadAlertHandler
    : public TAO::Upcall_Command
  {
  public:
    inline disable_alert_excep_AMI_LoadAlertHandler (
      POA_CosLoadBalancing::AMI_LoadAlertHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->disable_alert_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadAlertHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadAlertHandler::disable_alert_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadAlertHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadAlertHandler *> (servant);

  disable_alert_excep_AMI_LoadAlertHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_AMI_LoadAlertHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_AMI_LoadAlertHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_LoadAlertHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadAlertHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_LoadAlertHandler::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadAlertHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadAlertHandler *> (servant);
  
  _is_a_AMI_LoadAlertHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_AMI_LoadAlertHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_AMI_LoadAlertHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_LoadAlertHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadAlertHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_LoadAlertHandler::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadAlertHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadAlertHandler *> (servant);
  
  _non_existent_AMI_LoadAlertHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_AMI_LoadAlertHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_AMI_LoadAlertHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_LoadAlertHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadAlertHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_LoadAlertHandler::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadAlertHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadAlertHandler *> (servant);
  
  _repository_id_AMI_LoadAlertHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_CosLoadBalancing::AMI_LoadAlertHandler::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_CosLoadBalancing::AMI_LoadAlertHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadAlertHandler *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_AMI_LoadAlertHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_AMI_LoadAlertHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_LoadAlertHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadAlertHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_LoadAlertHandler::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadAlertHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadAlertHandler *> (servant);
  
  _get_component_AMI_LoadAlertHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CosLoadBalancing::AMI_LoadAlertHandler::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/AMI_LoadAlertHandler:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CosLoadBalancing::AMI_LoadAlertHandler::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/AMI_LoadAlertHandler:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_CosLoadBalancing::AMI_LoadAlertHandler::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

CosLoadBalancing::AMI_LoadAlertHandler *
POA_CosLoadBalancing::AMI_LoadAlertHandler::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CosLoadBalancing::AMI_LoadAlertHandler STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_AMI_LoadAlertHandler_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_CosLoadBalancing_LoadMonitor_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CosLoadBalancing_LoadMonitor_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CosLoadBalancing_LoadMonitor_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18,  0, 18,  0, 18, 18,
      0,  5, 18, 18, 18, 18, 18, 18, 18, 18,
      0, 18, 18, 18, 18,  2,  0, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CosLoadBalancing_LoadMonitor_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 17,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 17,
      HASH_VALUE_RANGE = 13,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CosLoadBalancing::LoadMonitor::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_component", &POA_CosLoadBalancing::LoadMonitor::_component_skel, 0},
      {"",0,0},
      {"_get_loads", &POA_CosLoadBalancing::LoadMonitor::_get_loads_skel, 0},
      {"_non_existent", &POA_CosLoadBalancing::LoadMonitor::_non_existent_skel, 0},
      {"_repository_id", &POA_CosLoadBalancing::LoadMonitor::_repository_id_skel, 0},
      {"_interface", &POA_CosLoadBalancing::LoadMonitor::_interface_skel, 0},
      {"",0,0},
      {"_get_the_location", &POA_CosLoadBalancing::LoadMonitor::_get_the_location_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CosLoadBalancing_LoadMonitor_Perfect_Hash_OpTable tao_CosLoadBalancing_LoadMonitor_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
CosLoadBalancing__TAO_LoadMonitor_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CosLoadBalancing__TAO_LoadMonitor_Proxy_Broker_Factory_Initializer (size_t)
{
  CosLoadBalancing__TAO_LoadMonitor_Proxy_Broker_Factory_function_pointer = 
    CosLoadBalancing__TAO_LoadMonitor_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CosLoadBalancing__TAO_LoadMonitor_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CosLoadBalancing__TAO_LoadMonitor_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CosLoadBalancing__TAO_LoadMonitor_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_CosLoadBalancing::LoadMonitor::LoadMonitor (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CosLoadBalancing_LoadMonitor_optable;
}

POA_CosLoadBalancing::LoadMonitor::LoadMonitor (const LoadMonitor& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_CosLoadBalancing::LoadMonitor::~LoadMonitor (void)
{
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_the_location_LoadMonitor
    : public TAO::Upcall_Command
  {
  public:
    inline _get_the_location_LoadMonitor (
      POA_CosLoadBalancing::LoadMonitor * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosLoadBalancing::Location>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CosLoadBalancing::Location> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->the_location ();
    }
  
  private:
    POA_CosLoadBalancing::LoadMonitor * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::LoadMonitor::_get_the_location_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CosLoadBalancing::Location>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::LoadMonitor * const impl =
    static_cast<POA_CosLoadBalancing::LoadMonitor *> (servant);

  _get_the_location_LoadMonitor command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_loads_LoadMonitor
    : public TAO::Upcall_Command
  {
  public:
    inline _get_loads_LoadMonitor (
      POA_CosLoadBalancing::LoadMonitor * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CosLoadBalancing::LoadList> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->loads ();
    }
  
  private:
    POA_CosLoadBalancing::LoadMonitor * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::LoadMonitor::_get_loads_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::LoadMonitor * const impl =
    static_cast<POA_CosLoadBalancing::LoadMonitor *> (servant);

  _get_loads_LoadMonitor command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_LoadMonitor_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_LoadMonitor_Upcall_Command (
      POA_CosLoadBalancing::LoadMonitor * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_CosLoadBalancing::LoadMonitor * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::LoadMonitor::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::LoadMonitor * const impl =
    static_cast<POA_CosLoadBalancing::LoadMonitor *> (servant);
  
  _is_a_LoadMonitor_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_LoadMonitor_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_LoadMonitor_Upcall_Command (
      POA_CosLoadBalancing::LoadMonitor * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_CosLoadBalancing::LoadMonitor * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::LoadMonitor::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::LoadMonitor * const impl =
    static_cast<POA_CosLoadBalancing::LoadMonitor *> (servant);
  
  _non_existent_LoadMonitor_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_LoadMonitor_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_LoadMonitor_Upcall_Command (
      POA_CosLoadBalancing::LoadMonitor * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_CosLoadBalancing::LoadMonitor * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::LoadMonitor::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::LoadMonitor * const impl =
    static_cast<POA_CosLoadBalancing::LoadMonitor *> (servant);
  
  _repository_id_LoadMonitor_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_CosLoadBalancing::LoadMonitor::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_CosLoadBalancing::LoadMonitor * const impl =
    static_cast<POA_CosLoadBalancing::LoadMonitor *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_LoadMonitor_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_LoadMonitor_Upcall_Command (
      POA_CosLoadBalancing::LoadMonitor * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_CosLoadBalancing::LoadMonitor * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::LoadMonitor::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::LoadMonitor * const impl =
    static_cast<POA_CosLoadBalancing::LoadMonitor *> (servant);
  
  _get_component_LoadMonitor_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CosLoadBalancing::LoadMonitor::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/LoadMonitor:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CosLoadBalancing::LoadMonitor::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/LoadMonitor:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_CosLoadBalancing::LoadMonitor::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

CosLoadBalancing::LoadMonitor *
POA_CosLoadBalancing::LoadMonitor::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CosLoadBalancing::LoadMonitor STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_LoadMonitor_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_CosLoadBalancing_AMI_LoadMonitorHandler_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CosLoadBalancing_AMI_LoadMonitorHandler_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CosLoadBalancing_AMI_LoadMonitorHandler_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23,  0, 23,  0, 23, 23,
      0, 10, 23,  0, 23, 23, 23, 23, 23, 23,
      0, 23,  0, 23, 23,  0,  0, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CosLoadBalancing_AMI_LoadMonitorHandler_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 22,
      HASH_VALUE_RANGE = 18,
      DUPLICATES = 0,
      WORDLIST_SIZE = 14
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CosLoadBalancing::AMI_LoadMonitorHandler::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"get_loads", &POA_CosLoadBalancing::AMI_LoadMonitorHandler::get_loads_skel, 0},
      {"_component", &POA_CosLoadBalancing::AMI_LoadMonitorHandler::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_CosLoadBalancing::AMI_LoadMonitorHandler::_non_existent_skel, 0},
      {"_repository_id", &POA_CosLoadBalancing::AMI_LoadMonitorHandler::_repository_id_skel, 0},
      {"get_loads_excep", &POA_CosLoadBalancing::AMI_LoadMonitorHandler::get_loads_excep_skel, 0},
      {"get_the_location", &POA_CosLoadBalancing::AMI_LoadMonitorHandler::get_the_location_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_interface", &POA_CosLoadBalancing::AMI_LoadMonitorHandler::_interface_skel, 0},
      {"",0,0},
      {"get_the_location_excep", &POA_CosLoadBalancing::AMI_LoadMonitorHandler::get_the_location_excep_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CosLoadBalancing_AMI_LoadMonitorHandler_Perfect_Hash_OpTable tao_CosLoadBalancing_AMI_LoadMonitorHandler_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
CosLoadBalancing__TAO_AMI_LoadMonitorHandler_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CosLoadBalancing__TAO_AMI_LoadMonitorHandler_Proxy_Broker_Factory_Initializer (size_t)
{
  CosLoadBalancing__TAO_AMI_LoadMonitorHandler_Proxy_Broker_Factory_function_pointer = 
    CosLoadBalancing__TAO_AMI_LoadMonitorHandler_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CosLoadBalancing__TAO_AMI_LoadMonitorHandler_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CosLoadBalancing__TAO_AMI_LoadMonitorHandler_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CosLoadBalancing__TAO_AMI_LoadMonitorHandler_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_CosLoadBalancing::AMI_LoadMonitorHandler::AMI_LoadMonitorHandler (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CosLoadBalancing_AMI_LoadMonitorHandler_optable;
}

POA_CosLoadBalancing::AMI_LoadMonitorHandler::AMI_LoadMonitorHandler (const AMI_LoadMonitorHandler& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ::POA_Messaging::ReplyHandler (rhs)
{
}

POA_CosLoadBalancing::AMI_LoadMonitorHandler::~AMI_LoadMonitorHandler (void)
{
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_the_location_AMI_LoadMonitorHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_the_location_AMI_LoadMonitorHandler (
      POA_CosLoadBalancing::AMI_LoadMonitorHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosLoadBalancing::Location>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CosLoadBalancing::Location> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->get_the_location (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadMonitorHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadMonitorHandler::get_the_location_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CosLoadBalancing::Location>::in_arg_val _tao_ami_return_val;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_ami_return_val
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadMonitorHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadMonitorHandler *> (servant);

  get_the_location_AMI_LoadMonitorHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_the_location_excep_AMI_LoadMonitorHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_the_location_excep_AMI_LoadMonitorHandler (
      POA_CosLoadBalancing::AMI_LoadMonitorHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->get_the_location_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadMonitorHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadMonitorHandler::get_the_location_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadMonitorHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadMonitorHandler *> (servant);

  get_the_location_excep_AMI_LoadMonitorHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_loads_AMI_LoadMonitorHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_loads_AMI_LoadMonitorHandler (
      POA_CosLoadBalancing::AMI_LoadMonitorHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CosLoadBalancing::LoadList> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->get_loads (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadMonitorHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadMonitorHandler::get_loads_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::in_arg_val _tao_ami_return_val;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_ami_return_val
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadMonitorHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadMonitorHandler *> (servant);

  get_loads_AMI_LoadMonitorHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_loads_excep_AMI_LoadMonitorHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_loads_excep_AMI_LoadMonitorHandler (
      POA_CosLoadBalancing::AMI_LoadMonitorHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->get_loads_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadMonitorHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadMonitorHandler::get_loads_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadMonitorHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadMonitorHandler *> (servant);

  get_loads_excep_AMI_LoadMonitorHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_AMI_LoadMonitorHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_AMI_LoadMonitorHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_LoadMonitorHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadMonitorHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_LoadMonitorHandler::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadMonitorHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadMonitorHandler *> (servant);
  
  _is_a_AMI_LoadMonitorHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_AMI_LoadMonitorHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_AMI_LoadMonitorHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_LoadMonitorHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadMonitorHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_LoadMonitorHandler::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadMonitorHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadMonitorHandler *> (servant);
  
  _non_existent_AMI_LoadMonitorHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_AMI_LoadMonitorHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_AMI_LoadMonitorHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_LoadMonitorHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadMonitorHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_LoadMonitorHandler::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadMonitorHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadMonitorHandler *> (servant);
  
  _repository_id_AMI_LoadMonitorHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_CosLoadBalancing::AMI_LoadMonitorHandler::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_CosLoadBalancing::AMI_LoadMonitorHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadMonitorHandler *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_AMI_LoadMonitorHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_AMI_LoadMonitorHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_LoadMonitorHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadMonitorHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_LoadMonitorHandler::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadMonitorHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadMonitorHandler *> (servant);
  
  _get_component_AMI_LoadMonitorHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CosLoadBalancing::AMI_LoadMonitorHandler::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/AMI_LoadMonitorHandler:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CosLoadBalancing::AMI_LoadMonitorHandler::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/AMI_LoadMonitorHandler:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_CosLoadBalancing::AMI_LoadMonitorHandler::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

CosLoadBalancing::AMI_LoadMonitorHandler *
POA_CosLoadBalancing::AMI_LoadMonitorHandler::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CosLoadBalancing::AMI_LoadMonitorHandler STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_AMI_LoadMonitorHandler_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_CosLoadBalancing_LoadManager_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CosLoadBalancing_LoadManager_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CosLoadBalancing_LoadManager_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     84, 84, 84, 84, 84, 84, 84, 84, 84, 84,
     84, 84, 84, 84, 84, 84, 84, 84, 84, 84,
     84, 84, 84, 84, 84, 84, 84, 84, 84, 84,
     84, 84, 84, 84, 84, 84, 84, 84, 84, 84,
     84, 84, 84, 84, 84, 84, 84, 84, 84, 84,
     84, 84, 84, 84, 84, 84, 84, 84, 84, 84,
     84, 84, 84, 84, 84, 84, 84, 84, 84, 84,
     84, 84, 84, 84, 84, 84, 84, 84, 84, 84,
     84, 84, 84, 84, 84, 84, 84, 84, 84, 84,
     84, 84, 84, 84, 84, 40, 84,  0, 84, 10,
      5,  0, 25, 25, 84, 84, 84, 84,  0, 84,
      0, 84,  0, 84,  5,  0, 30, 84, 84, 84,
     84,  0, 84, 84, 84, 84, 84, 84,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CosLoadBalancing_LoadManager_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 34,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 28,
      MIN_HASH_VALUE = 10,
      MAX_HASH_VALUE = 83,
      HASH_VALUE_RANGE = 74,
      DUPLICATES = 2,
      WORDLIST_SIZE = 44
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"",0,0},
      {"push_loads", &POA_CosLoadBalancing::LoadManager::push_loads_skel, 0},
      {"add_member", &POA_CosLoadBalancing::LoadManager::add_member_skel, 0},
      {"set_type_properties", &POA_CosLoadBalancing::LoadManager::set_type_properties_skel, 0},
      {"locations_of_members", &POA_CosLoadBalancing::LoadManager::locations_of_members_skel, 0},
      {"set_default_properties", &POA_CosLoadBalancing::LoadManager::set_default_properties_skel, 0},
      {"remove_member", &POA_CosLoadBalancing::LoadManager::remove_member_skel, 0},
      {"set_properties_dynamically", &POA_CosLoadBalancing::LoadManager::set_properties_dynamically_skel, 0},
      {"remove_type_properties", &POA_CosLoadBalancing::LoadManager::remove_type_properties_skel, 0},
      {"create_member", &POA_CosLoadBalancing::LoadManager::create_member_skel, 0},
      {"remove_load_monitor", &POA_CosLoadBalancing::LoadManager::remove_load_monitor_skel, 0},
      {"remove_default_properties", &POA_CosLoadBalancing::LoadManager::remove_default_properties_skel, 0},
      {"register_load_monitor", &POA_CosLoadBalancing::LoadManager::register_load_monitor_skel, 0},
      {"get_loads", &POA_CosLoadBalancing::LoadManager::get_loads_skel, 0},
      {"get_properties", &POA_CosLoadBalancing::LoadManager::get_properties_skel, 0},
      {"enable_alert", &POA_CosLoadBalancing::LoadManager::enable_alert_skel, 0},
      {"groups_at_location", &POA_CosLoadBalancing::LoadManager::groups_at_location_skel, 0},
      {"get_type_properties", &POA_CosLoadBalancing::LoadManager::get_type_properties_skel, 0},
      {"_is_a", &POA_CosLoadBalancing::LoadManager::_is_a_skel, 0},
      {"get_load_monitor", &POA_CosLoadBalancing::LoadManager::get_load_monitor_skel, 0},
      {"get_default_properties", &POA_CosLoadBalancing::LoadManager::get_default_properties_skel, 0},
      {"delete_object", &POA_CosLoadBalancing::LoadManager::delete_object_skel, 0},
      {"disable_alert", &POA_CosLoadBalancing::LoadManager::disable_alert_skel, 0},
      {"get_object_group_id", &POA_CosLoadBalancing::LoadManager::get_object_group_id_skel, 0},
      {"_interface", &POA_CosLoadBalancing::LoadManager::_interface_skel, 0},
      {"remove_load_alert", &POA_CosLoadBalancing::LoadManager::remove_load_alert_skel, 0},
      {"create_object", &POA_CosLoadBalancing::LoadManager::create_object_skel, 0},
      {"register_load_alert", &POA_CosLoadBalancing::LoadManager::register_load_alert_skel, 0},
      {"get_object_group_ref_from_id", &POA_CosLoadBalancing::LoadManager::get_object_group_ref_from_id_skel, 0},
      {"_repository_id", &POA_CosLoadBalancing::LoadManager::_repository_id_skel, 0},
      {"get_member_ref", &POA_CosLoadBalancing::LoadManager::get_member_ref_skel, 0},
      {"get_load_alert", &POA_CosLoadBalancing::LoadManager::get_load_alert_skel, 0},
      {"get_object_group_ref", &POA_CosLoadBalancing::LoadManager::get_object_group_ref_skel, 0},
      {"_component", &POA_CosLoadBalancing::LoadManager::_component_skel, 0},
      {"_non_existent", &POA_CosLoadBalancing::LoadManager::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  10,  -1,  -1,  -1, 
       -1,  11,  -1,  -1,  -1,  12,  13,  -1,  14,  15,  -1,  -1,  16,  17, 
       18,  19,  20,  21,  -1,  -1,  22,  -1,  -1,  -1,  -1,  23, -30,  -2, 
       24,  25,  26,  27,  28,  29, -91,  32,  33,  -1,  34,  35,  36,  -1, 
       -1,  -1,  37,  38,  -1,  -1,  -1,  -1,  39,  -1,  -1,  -1,  -1,  40, 
       41,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  42,  -1,  -1,  43, 
      
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CosLoadBalancing_LoadManager_Perfect_Hash_OpTable tao_CosLoadBalancing_LoadManager_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
CosLoadBalancing__TAO_LoadManager_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CosLoadBalancing__TAO_LoadManager_Proxy_Broker_Factory_Initializer (size_t)
{
  CosLoadBalancing__TAO_LoadManager_Proxy_Broker_Factory_function_pointer = 
    CosLoadBalancing__TAO_LoadManager_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CosLoadBalancing__TAO_LoadManager_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CosLoadBalancing__TAO_LoadManager_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CosLoadBalancing__TAO_LoadManager_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_CosLoadBalancing::LoadManager::LoadManager (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CosLoadBalancing_LoadManager_optable;
}

POA_CosLoadBalancing::LoadManager::LoadManager (const LoadManager& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_PortableGroup::PropertyManager (rhs),
    POA_PortableGroup::ObjectGroupManager (rhs),
    POA_PortableGroup::GenericFactory (rhs)
{
}

POA_CosLoadBalancing::LoadManager::~LoadManager (void)
{
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class push_loads_LoadManager
    : public TAO::Upcall_Command
  {
  public:
    inline push_loads_LoadManager (
      POA_CosLoadBalancing::LoadManager * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::PortableGroup::Location> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CosLoadBalancing::LoadList> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->push_loads (
        arg_1
        , arg_2);
    }
  
  private:
    POA_CosLoadBalancing::LoadManager * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::LoadManager::push_loads_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location;
  TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::in_arg_val _tao_loads;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_location,
      &_tao_loads
    };
  
  static size_t const nargs = 3;

  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);

  push_loads_LoadManager command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_loads_LoadManager
    : public TAO::Upcall_Command
  {
  public:
    inline get_loads_LoadManager (
      POA_CosLoadBalancing::LoadManager * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CosLoadBalancing::LoadList> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::PortableGroup::Location> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->get_loads (
          arg_1);
    }
  
  private:
    POA_CosLoadBalancing::LoadManager * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::LoadManager::get_loads_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LocationNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::ret_val retval;
  TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_location
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);

  get_loads_LoadManager command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class enable_alert_LoadManager
    : public TAO::Upcall_Command
  {
  public:
    inline enable_alert_LoadManager (
      POA_CosLoadBalancing::LoadManager * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::PortableGroup::Location> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->enable_alert (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::LoadManager * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::LoadManager::enable_alert_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_location
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);

  enable_alert_LoadManager command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class disable_alert_LoadManager
    : public TAO::Upcall_Command
  {
  public:
    inline disable_alert_LoadManager (
      POA_CosLoadBalancing::LoadManager * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::PortableGroup::Location> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->disable_alert (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::LoadManager * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::LoadManager::disable_alert_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_location
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);

  disable_alert_LoadManager command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class register_load_alert_LoadManager
    : public TAO::Upcall_Command
  {
  public:
    inline register_load_alert_LoadManager (
      POA_CosLoadBalancing::LoadManager * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::PortableGroup::Location> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CosLoadBalancing::LoadAlert>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CosLoadBalancing::LoadAlert> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->register_load_alert (
        arg_1
        , arg_2);
    }
  
  private:
    POA_CosLoadBalancing::LoadManager * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::LoadManager::register_load_alert_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertAlreadyPresent,
      CosLoadBalancing::_tc_LoadAlertNotAdded
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location;
  TAO::SArg_Traits< ::CosLoadBalancing::LoadAlert>::in_arg_val _tao_load_alert;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_location,
      &_tao_load_alert
    };
  
  static size_t const nargs = 3;

  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);

  register_load_alert_LoadManager command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_load_alert_LoadManager
    : public TAO::Upcall_Command
  {
  public:
    inline get_load_alert_LoadManager (
      POA_CosLoadBalancing::LoadManager * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosLoadBalancing::LoadAlert>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CosLoadBalancing::LoadAlert> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::PortableGroup::Location> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->get_load_alert (
          arg_1);
    }
  
  private:
    POA_CosLoadBalancing::LoadManager * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::LoadManager::get_load_alert_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CosLoadBalancing::LoadAlert>::ret_val retval;
  TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_location
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);

  get_load_alert_LoadManager command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class remove_load_alert_LoadManager
    : public TAO::Upcall_Command
  {
  public:
    inline remove_load_alert_LoadManager (
      POA_CosLoadBalancing::LoadManager * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::PortableGroup::Location> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->remove_load_alert (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::LoadManager * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::LoadManager::remove_load_alert_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_location
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);

  remove_load_alert_LoadManager command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class register_load_monitor_LoadManager
    : public TAO::Upcall_Command
  {
  public:
    inline register_load_monitor_LoadManager (
      POA_CosLoadBalancing::LoadManager * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::PortableGroup::Location> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CosLoadBalancing::LoadMonitor>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CosLoadBalancing::LoadMonitor> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->register_load_monitor (
        arg_1
        , arg_2);
    }
  
  private:
    POA_CosLoadBalancing::LoadManager * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::LoadManager::register_load_monitor_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_MonitorAlreadyPresent
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location;
  TAO::SArg_Traits< ::CosLoadBalancing::LoadMonitor>::in_arg_val _tao_load_monitor;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_location,
      &_tao_load_monitor
    };
  
  static size_t const nargs = 3;

  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);

  register_load_monitor_LoadManager command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_load_monitor_LoadManager
    : public TAO::Upcall_Command
  {
  public:
    inline get_load_monitor_LoadManager (
      POA_CosLoadBalancing::LoadManager * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosLoadBalancing::LoadMonitor>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CosLoadBalancing::LoadMonitor> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::PortableGroup::Location> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->get_load_monitor (
          arg_1);
    }
  
  private:
    POA_CosLoadBalancing::LoadManager * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::LoadManager::get_load_monitor_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LocationNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CosLoadBalancing::LoadMonitor>::ret_val retval;
  TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_location
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);

  get_load_monitor_LoadManager command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class remove_load_monitor_LoadManager
    : public TAO::Upcall_Command
  {
  public:
    inline remove_load_monitor_LoadManager (
      POA_CosLoadBalancing::LoadManager * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::PortableGroup::Location> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->remove_load_monitor (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::LoadManager * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::LoadManager::remove_load_monitor_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LocationNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_location
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);

  remove_load_monitor_LoadManager command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_LoadManager_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_LoadManager_Upcall_Command (
      POA_CosLoadBalancing::LoadManager * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_CosLoadBalancing::LoadManager * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::LoadManager::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);
  
  _is_a_LoadManager_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_LoadManager_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_LoadManager_Upcall_Command (
      POA_CosLoadBalancing::LoadManager * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_CosLoadBalancing::LoadManager * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::LoadManager::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);
  
  _non_existent_LoadManager_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_LoadManager_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_LoadManager_Upcall_Command (
      POA_CosLoadBalancing::LoadManager * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_CosLoadBalancing::LoadManager * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::LoadManager::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);
  
  _repository_id_LoadManager_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_CosLoadBalancing::LoadManager::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_LoadManager_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_LoadManager_Upcall_Command (
      POA_CosLoadBalancing::LoadManager * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_CosLoadBalancing::LoadManager * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::LoadManager::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::LoadManager * const impl =
    static_cast<POA_CosLoadBalancing::LoadManager *> (servant);
  
  _get_component_LoadManager_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CosLoadBalancing::LoadManager::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/PropertyManager:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/ObjectGroupManager:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/GenericFactory:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/LoadManager:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CosLoadBalancing::LoadManager::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/LoadManager:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_CosLoadBalancing::LoadManager::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

CosLoadBalancing::LoadManager *
POA_CosLoadBalancing::LoadManager::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CosLoadBalancing::LoadManager STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_LoadManager_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_CosLoadBalancing_AMI_LoadManagerHandler_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CosLoadBalancing_AMI_LoadManagerHandler_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CosLoadBalancing_AMI_LoadManagerHandler_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
     133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
     133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
     133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
     133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
     133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
     133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
     133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
     133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
     133, 133, 133, 133, 133,  45, 133,   5, 133,  25,
      51,  22,  15,   2, 133, 133, 133, 133,  15, 133,
       0, 133,   0, 133,  20,  55,  30, 133, 133, 133,
     133,   5, 133, 133, 133, 133, 133, 133,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CosLoadBalancing_AMI_LoadManagerHandler_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 63,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 34,
      MIN_HASH_VALUE = 16,
      MAX_HASH_VALUE = 132,
      HASH_VALUE_RANGE = 117,
      DUPLICATES = 8,
      WORDLIST_SIZE = 79
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"push_loads_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::push_loads_excep_skel, 0},
      {"get_loads_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_loads_excep_skel, 0},
      {"groups_at_location", &POA_CosLoadBalancing::AMI_LoadManagerHandler::groups_at_location_skel, 0},
      {"add_member_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::add_member_excep_skel, 0},
      {"get_properties_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_properties_excep_skel, 0},
      {"get_load_alert_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_load_alert_excep_skel, 0},
      {"get_member_ref_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_member_ref_excep_skel, 0},
      {"get_load_monitor_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_load_monitor_excep_skel, 0},
      {"groups_at_location_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::groups_at_location_excep_skel, 0},
      {"get_type_properties_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_type_properties_excep_skel, 0},
      {"get_object_group_id_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_object_group_id_excep_skel, 0},
      {"get_object_group_ref_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_object_group_ref_excep_skel, 0},
      {"get_default_properties_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_default_properties_excep_skel, 0},
      {"get_member_ref", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_member_ref_skel, 0},
      {"add_member", &POA_CosLoadBalancing::AMI_LoadManagerHandler::add_member_skel, 0},
      {"get_object_group_ref_from_id_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_object_group_ref_from_id_excep_skel, 0},
      {"get_object_group_ref", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_object_group_ref_skel, 0},
      {"get_load_monitor", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_load_monitor_skel, 0},
      {"remove_member_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::remove_member_excep_skel, 0},
      {"enable_alert_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::enable_alert_excep_skel, 0},
      {"locations_of_members_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::locations_of_members_excep_skel, 0},
      {"remove_load_alert_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::remove_load_alert_excep_skel, 0},
      {"create_member_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::create_member_excep_skel, 0},
      {"create_object_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::create_object_excep_skel, 0},
      {"register_load_alert_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::register_load_alert_excep_skel, 0},
      {"remove_load_monitor_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::remove_load_monitor_excep_skel, 0},
      {"get_load_alert", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_load_alert_skel, 0},
      {"register_load_monitor_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::register_load_monitor_excep_skel, 0},
      {"remove_type_properties_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::remove_type_properties_excep_skel, 0},
      {"remove_default_properties_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::remove_default_properties_excep_skel, 0},
      {"remove_member", &POA_CosLoadBalancing::AMI_LoadManagerHandler::remove_member_skel, 0},
      {"_is_a", &POA_CosLoadBalancing::AMI_LoadManagerHandler::_is_a_skel, 0},
      {"create_member", &POA_CosLoadBalancing::AMI_LoadManagerHandler::create_member_skel, 0},
      {"remove_load_monitor", &POA_CosLoadBalancing::AMI_LoadManagerHandler::remove_load_monitor_skel, 0},
      {"register_load_monitor", &POA_CosLoadBalancing::AMI_LoadManagerHandler::register_load_monitor_skel, 0},
      {"enable_alert", &POA_CosLoadBalancing::AMI_LoadManagerHandler::enable_alert_skel, 0},
      {"push_loads", &POA_CosLoadBalancing::AMI_LoadManagerHandler::push_loads_skel, 0},
      {"get_loads", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_loads_skel, 0},
      {"remove_load_alert", &POA_CosLoadBalancing::AMI_LoadManagerHandler::remove_load_alert_skel, 0},
      {"create_object", &POA_CosLoadBalancing::AMI_LoadManagerHandler::create_object_skel, 0},
      {"register_load_alert", &POA_CosLoadBalancing::AMI_LoadManagerHandler::register_load_alert_skel, 0},
      {"delete_object_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::delete_object_excep_skel, 0},
      {"disable_alert_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::disable_alert_excep_skel, 0},
      {"get_properties", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_properties_skel, 0},
      {"get_object_group_id", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_object_group_id_skel, 0},
      {"get_type_properties", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_type_properties_skel, 0},
      {"_interface", &POA_CosLoadBalancing::AMI_LoadManagerHandler::_interface_skel, 0},
      {"get_default_properties", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_default_properties_skel, 0},
      {"set_type_properties_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::set_type_properties_excep_skel, 0},
      {"get_object_group_ref_from_id", &POA_CosLoadBalancing::AMI_LoadManagerHandler::get_object_group_ref_from_id_skel, 0},
      {"set_default_properties_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::set_default_properties_excep_skel, 0},
      {"_component", &POA_CosLoadBalancing::AMI_LoadManagerHandler::_component_skel, 0},
      {"set_properties_dynamically", &POA_CosLoadBalancing::AMI_LoadManagerHandler::set_properties_dynamically_skel, 0},
      {"set_properties_dynamically_excep", &POA_CosLoadBalancing::AMI_LoadManagerHandler::set_properties_dynamically_excep_skel, 0},
      {"_non_existent", &POA_CosLoadBalancing::AMI_LoadManagerHandler::_non_existent_skel, 0},
      {"locations_of_members", &POA_CosLoadBalancing::AMI_LoadManagerHandler::locations_of_members_skel, 0},
      {"delete_object", &POA_CosLoadBalancing::AMI_LoadManagerHandler::delete_object_skel, 0},
      {"disable_alert", &POA_CosLoadBalancing::AMI_LoadManagerHandler::disable_alert_skel, 0},
      {"remove_type_properties", &POA_CosLoadBalancing::AMI_LoadManagerHandler::remove_type_properties_skel, 0},
      {"remove_default_properties", &POA_CosLoadBalancing::AMI_LoadManagerHandler::remove_default_properties_skel, 0},
      {"_repository_id", &POA_CosLoadBalancing::AMI_LoadManagerHandler::_repository_id_skel, 0},
      {"set_type_properties", &POA_CosLoadBalancing::AMI_LoadManagerHandler::set_type_properties_skel, 0},
      {"set_default_properties", &POA_CosLoadBalancing::AMI_LoadManagerHandler::set_default_properties_skel, 0},
    };

  static const signed short lookup[] =
    {
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  -20,   -3, 
       -25,   -2,   16,   17,  -38,   -2,   18,   19, -142,   -1,   23,   -1,   24, -145, 
        27,   -1,   28,   29,   -1,  -40,   -2,   30,   31,   32,   33,   34,   35,   36, 
        -1,   37, -158, -144,   42,   43,   44,   -1,   -1,   45,   -1,   46,   -1,   47, 
        -1,   -1,   48,   49,   -1,   50,  -57,   -2,   51,   52,   53,   54,   55,   56, 
      -140,   59,   60,   -1,   -1,   -1,   61,   62,   -1,   63,   64,   65,   -1,   66, 
        -1,   67,   68,   69,   70,   -1,   71,   -1,  -72,   -2, -134,   -1,   -1,   74, 
        -1,   -1,   75,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   76,   -1, 
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, 
        -1,   -1,   -1,   77,   -1,   -1,   78, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CosLoadBalancing_AMI_LoadManagerHandler_Perfect_Hash_OpTable tao_CosLoadBalancing_AMI_LoadManagerHandler_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
CosLoadBalancing__TAO_AMI_LoadManagerHandler_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CosLoadBalancing__TAO_AMI_LoadManagerHandler_Proxy_Broker_Factory_Initializer (size_t)
{
  CosLoadBalancing__TAO_AMI_LoadManagerHandler_Proxy_Broker_Factory_function_pointer = 
    CosLoadBalancing__TAO_AMI_LoadManagerHandler_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CosLoadBalancing__TAO_AMI_LoadManagerHandler_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CosLoadBalancing__TAO_AMI_LoadManagerHandler_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CosLoadBalancing__TAO_AMI_LoadManagerHandler_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_CosLoadBalancing::AMI_LoadManagerHandler::AMI_LoadManagerHandler (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CosLoadBalancing_AMI_LoadManagerHandler_optable;
}

POA_CosLoadBalancing::AMI_LoadManagerHandler::AMI_LoadManagerHandler (const AMI_LoadManagerHandler& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ::POA_Messaging::ReplyHandler (rhs),
    POA_PortableGroup::AMI_PropertyManagerHandler (rhs),
    POA_PortableGroup::AMI_ObjectGroupManagerHandler (rhs),
    POA_PortableGroup::AMI_GenericFactoryHandler (rhs)
{
}

POA_CosLoadBalancing::AMI_LoadManagerHandler::~AMI_LoadManagerHandler (void)
{
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class push_loads_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline push_loads_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->push_loads ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::push_loads_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  push_loads_AMI_LoadManagerHandler command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class push_loads_excep_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline push_loads_excep_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->push_loads_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::push_loads_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  push_loads_excep_AMI_LoadManagerHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_loads_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_loads_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CosLoadBalancing::LoadList> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->get_loads (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::get_loads_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LocationNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CosLoadBalancing::LoadList>::in_arg_val _tao_ami_return_val;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_ami_return_val
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  get_loads_AMI_LoadManagerHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_loads_excep_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_loads_excep_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      

      static TAO::Exception_Data
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_loads_excep_exceptiondata [] = 
        {
          {
            "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
            CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
            , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
          }
        };
      TAO::ExceptionHolder *tao_excepholder = 
        dynamic_cast<TAO::ExceptionHolder *> (arg_1);
      if (tao_excepholder != 0)
        {
          tao_excepholder->set_exception_data (_tao_CosLoadBalancing_AMI_LoadManagerHandler_get_loads_excep_exceptiondata, 1);
        }
      
      this->servant_->get_loads_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::get_loads_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LocationNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  get_loads_excep_AMI_LoadManagerHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class enable_alert_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline enable_alert_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->enable_alert ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::enable_alert_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  enable_alert_AMI_LoadManagerHandler command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class enable_alert_excep_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline enable_alert_excep_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      

      static TAO::Exception_Data
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_enable_alert_excep_exceptiondata [] = 
        {
          {
            "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
            CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
            , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
          }
        };
      TAO::ExceptionHolder *tao_excepholder = 
        dynamic_cast<TAO::ExceptionHolder *> (arg_1);
      if (tao_excepholder != 0)
        {
          tao_excepholder->set_exception_data (_tao_CosLoadBalancing_AMI_LoadManagerHandler_enable_alert_excep_exceptiondata, 1);
        }
      
      this->servant_->enable_alert_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::enable_alert_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  enable_alert_excep_AMI_LoadManagerHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class disable_alert_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline disable_alert_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->disable_alert ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::disable_alert_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  disable_alert_AMI_LoadManagerHandler command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class disable_alert_excep_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline disable_alert_excep_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      

      static TAO::Exception_Data
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_disable_alert_excep_exceptiondata [] = 
        {
          {
            "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
            CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
            , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
          }
        };
      TAO::ExceptionHolder *tao_excepholder = 
        dynamic_cast<TAO::ExceptionHolder *> (arg_1);
      if (tao_excepholder != 0)
        {
          tao_excepholder->set_exception_data (_tao_CosLoadBalancing_AMI_LoadManagerHandler_disable_alert_excep_exceptiondata, 1);
        }
      
      this->servant_->disable_alert_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::disable_alert_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  disable_alert_excep_AMI_LoadManagerHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class register_load_alert_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline register_load_alert_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->register_load_alert ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::register_load_alert_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertAlreadyPresent,
      CosLoadBalancing::_tc_LoadAlertNotAdded
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  register_load_alert_AMI_LoadManagerHandler command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class register_load_alert_excep_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline register_load_alert_excep_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      

      static TAO::Exception_Data
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_register_load_alert_excep_exceptiondata [] = 
        {
          {
            "IDL:tao.lb/CosLoadBalancing/LoadAlertAlreadyPresent:1.0",
            CosLoadBalancing::LoadAlertAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
            , CosLoadBalancing::_tc_LoadAlertAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
          },

          {
            "IDL:tao.lb/CosLoadBalancing/LoadAlertNotAdded:1.0",
            CosLoadBalancing::LoadAlertNotAdded::_alloc
#if TAO_HAS_INTERCEPTORS == 1
            , CosLoadBalancing::_tc_LoadAlertNotAdded
#endif /* TAO_HAS_INTERCEPTORS */
          }
        };
      TAO::ExceptionHolder *tao_excepholder = 
        dynamic_cast<TAO::ExceptionHolder *> (arg_1);
      if (tao_excepholder != 0)
        {
          tao_excepholder->set_exception_data (_tao_CosLoadBalancing_AMI_LoadManagerHandler_register_load_alert_excep_exceptiondata, 2);
        }
      
      this->servant_->register_load_alert_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::register_load_alert_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertAlreadyPresent,
      CosLoadBalancing::_tc_LoadAlertNotAdded
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  register_load_alert_excep_AMI_LoadManagerHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_load_alert_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_load_alert_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosLoadBalancing::LoadAlert>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CosLoadBalancing::LoadAlert> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->get_load_alert (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::get_load_alert_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CosLoadBalancing::LoadAlert>::in_arg_val _tao_ami_return_val;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_ami_return_val
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  get_load_alert_AMI_LoadManagerHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_load_alert_excep_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_load_alert_excep_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      

      static TAO::Exception_Data
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_load_alert_excep_exceptiondata [] = 
        {
          {
            "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
            CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
            , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
          }
        };
      TAO::ExceptionHolder *tao_excepholder = 
        dynamic_cast<TAO::ExceptionHolder *> (arg_1);
      if (tao_excepholder != 0)
        {
          tao_excepholder->set_exception_data (_tao_CosLoadBalancing_AMI_LoadManagerHandler_get_load_alert_excep_exceptiondata, 1);
        }
      
      this->servant_->get_load_alert_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::get_load_alert_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  get_load_alert_excep_AMI_LoadManagerHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class remove_load_alert_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline remove_load_alert_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->remove_load_alert ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::remove_load_alert_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  remove_load_alert_AMI_LoadManagerHandler command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class remove_load_alert_excep_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline remove_load_alert_excep_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      

      static TAO::Exception_Data
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_remove_load_alert_excep_exceptiondata [] = 
        {
          {
            "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
            CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
            , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
          }
        };
      TAO::ExceptionHolder *tao_excepholder = 
        dynamic_cast<TAO::ExceptionHolder *> (arg_1);
      if (tao_excepholder != 0)
        {
          tao_excepholder->set_exception_data (_tao_CosLoadBalancing_AMI_LoadManagerHandler_remove_load_alert_excep_exceptiondata, 1);
        }
      
      this->servant_->remove_load_alert_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::remove_load_alert_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LoadAlertNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  remove_load_alert_excep_AMI_LoadManagerHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class register_load_monitor_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline register_load_monitor_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->register_load_monitor ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::register_load_monitor_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_MonitorAlreadyPresent
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  register_load_monitor_AMI_LoadManagerHandler command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class register_load_monitor_excep_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline register_load_monitor_excep_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      

      static TAO::Exception_Data
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_register_load_monitor_excep_exceptiondata [] = 
        {
          {
            "IDL:tao.lb/CosLoadBalancing/MonitorAlreadyPresent:1.0",
            CosLoadBalancing::MonitorAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
            , CosLoadBalancing::_tc_MonitorAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
          }
        };
      TAO::ExceptionHolder *tao_excepholder = 
        dynamic_cast<TAO::ExceptionHolder *> (arg_1);
      if (tao_excepholder != 0)
        {
          tao_excepholder->set_exception_data (_tao_CosLoadBalancing_AMI_LoadManagerHandler_register_load_monitor_excep_exceptiondata, 1);
        }
      
      this->servant_->register_load_monitor_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::register_load_monitor_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_MonitorAlreadyPresent
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  register_load_monitor_excep_AMI_LoadManagerHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_load_monitor_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_load_monitor_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosLoadBalancing::LoadMonitor>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CosLoadBalancing::LoadMonitor> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->get_load_monitor (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::get_load_monitor_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LocationNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CosLoadBalancing::LoadMonitor>::in_arg_val _tao_ami_return_val;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_ami_return_val
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  get_load_monitor_AMI_LoadManagerHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_load_monitor_excep_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline get_load_monitor_excep_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      

      static TAO::Exception_Data
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_load_monitor_excep_exceptiondata [] = 
        {
          {
            "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
            CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
            , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
          }
        };
      TAO::ExceptionHolder *tao_excepholder = 
        dynamic_cast<TAO::ExceptionHolder *> (arg_1);
      if (tao_excepholder != 0)
        {
          tao_excepholder->set_exception_data (_tao_CosLoadBalancing_AMI_LoadManagerHandler_get_load_monitor_excep_exceptiondata, 1);
        }
      
      this->servant_->get_load_monitor_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::get_load_monitor_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LocationNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  get_load_monitor_excep_AMI_LoadManagerHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class remove_load_monitor_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline remove_load_monitor_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->remove_load_monitor ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::remove_load_monitor_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LocationNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  remove_load_monitor_AMI_LoadManagerHandler command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class remove_load_monitor_excep_AMI_LoadManagerHandler
    : public TAO::Upcall_Command
  {
  public:
    inline remove_load_monitor_excep_AMI_LoadManagerHandler (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::Messaging::ExceptionHolder> (
          this->operation_details_,
          this->args_,
          1);
        
      

      static TAO::Exception_Data
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_remove_load_monitor_excep_exceptiondata [] = 
        {
          {
            "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
            CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
            , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
          }
        };
      TAO::ExceptionHolder *tao_excepholder = 
        dynamic_cast<TAO::ExceptionHolder *> (arg_1);
      if (tao_excepholder != 0)
        {
          tao_excepholder->set_exception_data (_tao_CosLoadBalancing_AMI_LoadManagerHandler_remove_load_monitor_excep_exceptiondata, 1);
        }
      
      this->servant_->remove_load_monitor_excep (
        arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_CosLoadBalancing::AMI_LoadManagerHandler::remove_load_monitor_excep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      CosLoadBalancing::_tc_LocationNotFound
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_excep_holder
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);

  remove_load_monitor_excep_AMI_LoadManagerHandler command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_AMI_LoadManagerHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_AMI_LoadManagerHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_LoadManagerHandler::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);
  
  _is_a_AMI_LoadManagerHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_AMI_LoadManagerHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_AMI_LoadManagerHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_LoadManagerHandler::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);
  
  _non_existent_AMI_LoadManagerHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_AMI_LoadManagerHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_AMI_LoadManagerHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_LoadManagerHandler::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);
  
  _repository_id_AMI_LoadManagerHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_CosLoadBalancing::AMI_LoadManagerHandler::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_CosLoadBalancing
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_AMI_LoadManagerHandler_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_AMI_LoadManagerHandler_Upcall_Command (
      POA_CosLoadBalancing::AMI_LoadManagerHandler * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_CosLoadBalancing::AMI_LoadManagerHandler * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_CosLoadBalancing::AMI_LoadManagerHandler::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CosLoadBalancing::AMI_LoadManagerHandler * const impl =
    static_cast<POA_CosLoadBalancing::AMI_LoadManagerHandler *> (servant);
  
  _get_component_AMI_LoadManagerHandler_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CosLoadBalancing::AMI_LoadManagerHandler::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/AMI_PropertyManagerHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/AMI_ObjectGroupManagerHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/AMI_GenericFactoryHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/AMI_LoadManagerHandler:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CosLoadBalancing::AMI_LoadManagerHandler::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/AMI_LoadManagerHandler:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_CosLoadBalancing::AMI_LoadManagerHandler::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

CosLoadBalancing::AMI_LoadManagerHandler *
POA_CosLoadBalancing::AMI_LoadManagerHandler::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CosLoadBalancing::AMI_LoadManagerHandler STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_AMI_LoadManagerHandler_Proxy_Broker_Factory_function_pointer
      );
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* ifndef */

