// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "RtecSchedulerC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "RtecSchedulerC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Time (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/Time:1.0",
    "Time",
    &TimeBase::_tc_TimeT);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Time =
    &_tao_tc_RtecScheduler_Time;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Quantum_t (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/Quantum_t:1.0",
    "Quantum_t",
    &RtecScheduler::_tc_Time);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Quantum_t =
    &_tao_tc_RtecScheduler_Quantum_t;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Period_t (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/Period_t:1.0",
    "Period_t",
    &CORBA::_tc_long);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Period_t =
    &_tao_tc_RtecScheduler_Period_t;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Threads_t (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/Threads_t:1.0",
    "Threads_t",
    &CORBA::_tc_long);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Threads_t =
    &_tao_tc_RtecScheduler_Threads_t;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_RTECSCHEDULER_PERIOD_SET_CS_)
#define _RTECSCHEDULER_PERIOD_SET_CS_

RtecScheduler::Period_Set::Period_Set (void)
{}

RtecScheduler::Period_Set::Period_Set (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Period_t
      > (max)
{}

RtecScheduler::Period_Set::Period_Set (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Period_t
      >
    (max, length, buffer, release)
{}

RtecScheduler::Period_Set::Period_Set (
    const Period_Set &seq)
  : ::TAO::unbounded_value_sequence<
        Period_t
      > (seq)
{}

RtecScheduler::Period_Set::~Period_Set (void)
{}

void RtecScheduler::Period_Set::_tao_any_destructor (
    void * _tao_void_pointer)
{
  Period_Set * _tao_tmp_pointer =
    static_cast<Period_Set *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_RtecScheduler_Period_Set_GUARD
#define _TAO_TYPECODE_RtecScheduler_Period_Set_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        RtecScheduler_Period_Set_0 (
          ::CORBA::tk_sequence,
          &RtecScheduler::_tc_Period_t,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_RtecScheduler_Period_Set_0 =
        &RtecScheduler_Period_Set_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_RtecScheduler_Period_Set_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Period_Set (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/Period_Set:1.0",
    "Period_Set",
    &TAO::TypeCode::tc_RtecScheduler_Period_Set_0);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Period_Set =
    &_tao_tc_RtecScheduler_Period_Set;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_RtecScheduler_Criticality_t[] =
  {
    "VERY_LOW_CRITICALITY",
    "LOW_CRITICALITY",
    "MEDIUM_CRITICALITY",
    "HIGH_CRITICALITY",
    "VERY_HIGH_CRITICALITY"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Criticality_t (
    "IDL:RtecScheduler/Criticality_t:1.0",
    "Criticality_t",
    _tao_enumerators_RtecScheduler_Criticality_t,
    5);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Criticality_t =
    &_tao_tc_RtecScheduler_Criticality_t;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_RtecScheduler_Importance_t[] =
  {
    "VERY_LOW_IMPORTANCE",
    "LOW_IMPORTANCE",
    "MEDIUM_IMPORTANCE",
    "HIGH_IMPORTANCE",
    "VERY_HIGH_IMPORTANCE"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Importance_t (
    "IDL:RtecScheduler/Importance_t:1.0",
    "Importance_t",
    _tao_enumerators_RtecScheduler_Importance_t,
    5);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Importance_t =
    &_tao_tc_RtecScheduler_Importance_t;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_RtecScheduler_Info_Type_t[] =
  {
    "OPERATION",
    "CONJUNCTION",
    "DISJUNCTION",
    "REMOTE_DEPENDANT"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Info_Type_t (
    "IDL:RtecScheduler/Info_Type_t:1.0",
    "Info_Type_t",
    _tao_enumerators_RtecScheduler_Info_Type_t,
    4);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Info_Type_t =
    &_tao_tc_RtecScheduler_Info_Type_t;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Dependency_Enabled_Type_t (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/Dependency_Enabled_Type_t:1.0",
    "Dependency_Enabled_Type_t",
    &RtecBase::_tc_Dependency_Enabled_Type_t);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Dependency_Enabled_Type_t =
    &_tao_tc_RtecScheduler_Dependency_Enabled_Type_t;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Dependency_Type_t (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/Dependency_Type_t:1.0",
    "Dependency_Type_t",
    &RtecBase::_tc_Dependency_Type_t);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Dependency_Type_t =
    &_tao_tc_RtecScheduler_Dependency_Type_t;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_RtecScheduler_RT_Info_Enabled_Type_t[] =
  {
    "RT_INFO_DISABLED",
    "RT_INFO_ENABLED",
    "RT_INFO_NON_VOLATILE"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_RT_Info_Enabled_Type_t (
    "IDL:RtecScheduler/RT_Info_Enabled_Type_t:1.0",
    "RT_Info_Enabled_Type_t",
    _tao_enumerators_RtecScheduler_RT_Info_Enabled_Type_t,
    3);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_RT_Info_Enabled_Type_t =
    &_tao_tc_RtecScheduler_RT_Info_Enabled_Type_t;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_handle_t (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/handle_t:1.0",
    "handle_t",
    &RtecBase::_tc_handle_t);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_handle_t =
    &_tao_tc_RtecScheduler_handle_t;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_RtecScheduler_RT_Info_Enable_State_Pair[] =
      {
        { "handle", &RtecScheduler::_tc_handle_t },
        { "enabled", &RtecScheduler::_tc_RT_Info_Enabled_Type_t }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_RT_Info_Enable_State_Pair (
  ::CORBA::tk_struct,
  "IDL:RtecScheduler/RT_Info_Enable_State_Pair:1.0",
  "RT_Info_Enable_State_Pair",
  _tao_fields_RtecScheduler_RT_Info_Enable_State_Pair,
  2);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_RT_Info_Enable_State_Pair =
    &_tao_tc_RtecScheduler_RT_Info_Enable_State_Pair;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
RtecScheduler::RT_Info_Enable_State_Pair::_tao_any_destructor (
    void *_tao_void_pointer)
{
  RT_Info_Enable_State_Pair *_tao_tmp_pointer =
    static_cast<RT_Info_Enable_State_Pair *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_RTECSCHEDULER_RT_INFO_ENABLE_STATE_PAIR_SET_CS_)
#define _RTECSCHEDULER_RT_INFO_ENABLE_STATE_PAIR_SET_CS_

RtecScheduler::RT_Info_Enable_State_Pair_Set::RT_Info_Enable_State_Pair_Set (void)
{}

RtecScheduler::RT_Info_Enable_State_Pair_Set::RT_Info_Enable_State_Pair_Set (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        RT_Info_Enable_State_Pair
      > (max)
{}

RtecScheduler::RT_Info_Enable_State_Pair_Set::RT_Info_Enable_State_Pair_Set (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    RtecScheduler::RT_Info_Enable_State_Pair * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        RT_Info_Enable_State_Pair
      >
    (max, length, buffer, release)
{}

RtecScheduler::RT_Info_Enable_State_Pair_Set::RT_Info_Enable_State_Pair_Set (
    const RT_Info_Enable_State_Pair_Set &seq)
  : ::TAO::unbounded_value_sequence<
        RT_Info_Enable_State_Pair
      > (seq)
{}

RtecScheduler::RT_Info_Enable_State_Pair_Set::~RT_Info_Enable_State_Pair_Set (void)
{}

void RtecScheduler::RT_Info_Enable_State_Pair_Set::_tao_any_destructor (
    void * _tao_void_pointer)
{
  RT_Info_Enable_State_Pair_Set * _tao_tmp_pointer =
    static_cast<RT_Info_Enable_State_Pair_Set *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_RtecScheduler_RT_Info_Enable_State_Pair_Set_GUARD
#define _TAO_TYPECODE_RtecScheduler_RT_Info_Enable_State_Pair_Set_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        RtecScheduler_RT_Info_Enable_State_Pair_Set_0 (
          ::CORBA::tk_sequence,
          &RtecScheduler::_tc_RT_Info_Enable_State_Pair,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_RtecScheduler_RT_Info_Enable_State_Pair_Set_0 =
        &RtecScheduler_RT_Info_Enable_State_Pair_Set_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_RtecScheduler_RT_Info_Enable_State_Pair_Set_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_RT_Info_Enable_State_Pair_Set (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/RT_Info_Enable_State_Pair_Set:1.0",
    "RT_Info_Enable_State_Pair_Set",
    &TAO::TypeCode::tc_RtecScheduler_RT_Info_Enable_State_Pair_Set_0);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_RT_Info_Enable_State_Pair_Set =
    &_tao_tc_RtecScheduler_RT_Info_Enable_State_Pair_Set;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Dependency_Info (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/Dependency_Info:1.0",
    "Dependency_Info",
    &RtecBase::_tc_Dependency_Info);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Dependency_Info =
    &_tao_tc_RtecScheduler_Dependency_Info;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_RTECSCHEDULER_DEPENDENCY_SET_CS_)
#define _RTECSCHEDULER_DEPENDENCY_SET_CS_

RtecScheduler::Dependency_Set::Dependency_Set (void)
{}

RtecScheduler::Dependency_Set::Dependency_Set (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Dependency_Info
      > (max)
{}

RtecScheduler::Dependency_Set::Dependency_Set (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    RtecScheduler::Dependency_Info * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Dependency_Info
      >
    (max, length, buffer, release)
{}

RtecScheduler::Dependency_Set::Dependency_Set (
    const Dependency_Set &seq)
  : ::TAO::unbounded_value_sequence<
        Dependency_Info
      > (seq)
{}

RtecScheduler::Dependency_Set::~Dependency_Set (void)
{}

void RtecScheduler::Dependency_Set::_tao_any_destructor (
    void * _tao_void_pointer)
{
  Dependency_Set * _tao_tmp_pointer =
    static_cast<Dependency_Set *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_RtecScheduler_Dependency_Set_GUARD
#define _TAO_TYPECODE_RtecScheduler_Dependency_Set_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        RtecScheduler_Dependency_Set_0 (
          ::CORBA::tk_sequence,
          &RtecScheduler::_tc_Dependency_Info,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_RtecScheduler_Dependency_Set_0 =
        &RtecScheduler_Dependency_Set_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_RtecScheduler_Dependency_Set_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Dependency_Set (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/Dependency_Set:1.0",
    "Dependency_Set",
    &TAO::TypeCode::tc_RtecScheduler_Dependency_Set_0);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Dependency_Set =
    &_tao_tc_RtecScheduler_Dependency_Set;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_OS_Priority (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/OS_Priority:1.0",
    "OS_Priority",
    &RtecBase::_tc_OS_Priority);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_OS_Priority =
    &_tao_tc_RtecScheduler_OS_Priority;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Preemption_Subpriority_t (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/Preemption_Subpriority_t:1.0",
    "Preemption_Subpriority_t",
    &RtecBase::_tc_Preemption_Subpriority_t);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Preemption_Subpriority_t =
    &_tao_tc_RtecScheduler_Preemption_Subpriority_t;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Preemption_Priority_t (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/Preemption_Priority_t:1.0",
    "Preemption_Priority_t",
    &RtecBase::_tc_Preemption_Priority_t);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Preemption_Priority_t =
    &_tao_tc_RtecScheduler_Preemption_Priority_t;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_RtecScheduler_RT_Info[] =
      {
        { "entry_point", &CORBA::_tc_string },
        { "handle", &RtecScheduler::_tc_handle_t },
        { "worst_case_execution_time", &RtecScheduler::_tc_Time },
        { "typical_execution_time", &RtecScheduler::_tc_Time },
        { "cached_execution_time", &RtecScheduler::_tc_Time },
        { "period", &RtecScheduler::_tc_Period_t },
        { "criticality", &RtecScheduler::_tc_Criticality_t },
        { "importance", &RtecScheduler::_tc_Importance_t },
        { "quantum", &RtecScheduler::_tc_Quantum_t },
        { "threads", &RtecScheduler::_tc_Threads_t },
        { "dependencies", &RtecScheduler::_tc_Dependency_Set },
        { "priority", &RtecScheduler::_tc_OS_Priority },
        { "preemption_subpriority", &RtecScheduler::_tc_Preemption_Subpriority_t },
        { "preemption_priority", &RtecScheduler::_tc_Preemption_Priority_t },
        { "info_type", &RtecScheduler::_tc_Info_Type_t },
        { "enabled", &RtecScheduler::_tc_RT_Info_Enabled_Type_t },
        { "volatile_token", &CORBA::_tc_ulonglong }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_RT_Info (
  ::CORBA::tk_struct,
  "IDL:RtecScheduler/RT_Info:1.0",
  "RT_Info",
  _tao_fields_RtecScheduler_RT_Info,
  17);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_RT_Info =
    &_tao_tc_RtecScheduler_RT_Info;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
RtecScheduler::RT_Info::_tao_any_destructor (
    void *_tao_void_pointer)
{
  RT_Info *_tao_tmp_pointer =
    static_cast<RT_Info *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_RtecScheduler_Dispatching_Type_t[] =
  {
    "STATIC_DISPATCHING",
    "DEADLINE_DISPATCHING",
    "LAXITY_DISPATCHING"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Dispatching_Type_t (
    "IDL:RtecScheduler/Dispatching_Type_t:1.0",
    "Dispatching_Type_t",
    _tao_enumerators_RtecScheduler_Dispatching_Type_t,
    3);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Dispatching_Type_t =
    &_tao_tc_RtecScheduler_Dispatching_Type_t;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_RtecScheduler_Config_Info[] =
      {
        { "preemption_priority", &RtecScheduler::_tc_Preemption_Priority_t },
        { "thread_priority", &RtecScheduler::_tc_OS_Priority },
        { "dispatching_type", &RtecScheduler::_tc_Dispatching_Type_t },
        { "timer_periods", &RtecScheduler::_tc_Period_Set }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_Config_Info (
  ::CORBA::tk_struct,
  "IDL:RtecScheduler/Config_Info:1.0",
  "Config_Info",
  _tao_fields_RtecScheduler_Config_Info,
  4);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Config_Info =
    &_tao_tc_RtecScheduler_Config_Info;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
RtecScheduler::Config_Info::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Config_Info *_tao_tmp_pointer =
    static_cast<Config_Info *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_RTECSCHEDULER_CONFIG_INFO_SET_CS_)
#define _RTECSCHEDULER_CONFIG_INFO_SET_CS_

RtecScheduler::Config_Info_Set::Config_Info_Set (void)
{}

RtecScheduler::Config_Info_Set::Config_Info_Set (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Config_Info
      > (max)
{}

RtecScheduler::Config_Info_Set::Config_Info_Set (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    RtecScheduler::Config_Info * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Config_Info
      >
    (max, length, buffer, release)
{}

RtecScheduler::Config_Info_Set::Config_Info_Set (
    const Config_Info_Set &seq)
  : ::TAO::unbounded_value_sequence<
        Config_Info
      > (seq)
{}

RtecScheduler::Config_Info_Set::~Config_Info_Set (void)
{}

void RtecScheduler::Config_Info_Set::_tao_any_destructor (
    void * _tao_void_pointer)
{
  Config_Info_Set * _tao_tmp_pointer =
    static_cast<Config_Info_Set *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_RtecScheduler_Config_Info_Set_GUARD
#define _TAO_TYPECODE_RtecScheduler_Config_Info_Set_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        RtecScheduler_Config_Info_Set_0 (
          ::CORBA::tk_sequence,
          &RtecScheduler::_tc_Config_Info,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_RtecScheduler_Config_Info_Set_0 =
        &RtecScheduler_Config_Info_Set_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_RtecScheduler_Config_Info_Set_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Config_Info_Set (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/Config_Info_Set:1.0",
    "Config_Info_Set",
    &TAO::TypeCode::tc_RtecScheduler_Config_Info_Set_0);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Config_Info_Set =
    &_tao_tc_RtecScheduler_Config_Info_Set;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_RtecScheduler_Anomaly_Severity[] =
  {
    "ANOMALY_FATAL",
    "ANOMALY_ERROR",
    "ANOMALY_WARNING",
    "ANOMALY_NONE"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Anomaly_Severity (
    "IDL:RtecScheduler/Anomaly_Severity:1.0",
    "Anomaly_Severity",
    _tao_enumerators_RtecScheduler_Anomaly_Severity,
    4);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Anomaly_Severity =
    &_tao_tc_RtecScheduler_Anomaly_Severity;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_RtecScheduler_Scheduling_Anomaly[] =
      {
        { "description", &CORBA::_tc_string },
        { "severity", &RtecScheduler::_tc_Anomaly_Severity }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_Scheduling_Anomaly (
  ::CORBA::tk_struct,
  "IDL:RtecScheduler/Scheduling_Anomaly:1.0",
  "Scheduling_Anomaly",
  _tao_fields_RtecScheduler_Scheduling_Anomaly,
  2);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Scheduling_Anomaly =
    &_tao_tc_RtecScheduler_Scheduling_Anomaly;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
RtecScheduler::Scheduling_Anomaly::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Scheduling_Anomaly *_tao_tmp_pointer =
    static_cast<Scheduling_Anomaly *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_RTECSCHEDULER_SCHEDULING_ANOMALY_SET_CS_)
#define _RTECSCHEDULER_SCHEDULING_ANOMALY_SET_CS_

RtecScheduler::Scheduling_Anomaly_Set::Scheduling_Anomaly_Set (void)
{}

RtecScheduler::Scheduling_Anomaly_Set::Scheduling_Anomaly_Set (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Scheduling_Anomaly
      > (max)
{}

RtecScheduler::Scheduling_Anomaly_Set::Scheduling_Anomaly_Set (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    RtecScheduler::Scheduling_Anomaly * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Scheduling_Anomaly
      >
    (max, length, buffer, release)
{}

RtecScheduler::Scheduling_Anomaly_Set::Scheduling_Anomaly_Set (
    const Scheduling_Anomaly_Set &seq)
  : ::TAO::unbounded_value_sequence<
        Scheduling_Anomaly
      > (seq)
{}

RtecScheduler::Scheduling_Anomaly_Set::~Scheduling_Anomaly_Set (void)
{}

void RtecScheduler::Scheduling_Anomaly_Set::_tao_any_destructor (
    void * _tao_void_pointer)
{
  Scheduling_Anomaly_Set * _tao_tmp_pointer =
    static_cast<Scheduling_Anomaly_Set *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_RtecScheduler_Scheduling_Anomaly_Set_GUARD
#define _TAO_TYPECODE_RtecScheduler_Scheduling_Anomaly_Set_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        RtecScheduler_Scheduling_Anomaly_Set_0 (
          ::CORBA::tk_sequence,
          &RtecScheduler::_tc_Scheduling_Anomaly,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_RtecScheduler_Scheduling_Anomaly_Set_0 =
        &RtecScheduler_Scheduling_Anomaly_Set_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_RtecScheduler_Scheduling_Anomaly_Set_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Scheduling_Anomaly_Set (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/Scheduling_Anomaly_Set:1.0",
    "Scheduling_Anomaly_Set",
    &TAO::TypeCode::tc_RtecScheduler_Scheduling_Anomaly_Set_0);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Scheduling_Anomaly_Set =
    &_tao_tc_RtecScheduler_Scheduling_Anomaly_Set;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

RtecScheduler::CYCLIC_DEPENDENCIES::CYCLIC_DEPENDENCIES (void)
  : ::CORBA::UserException (
        "IDL:RtecScheduler/CYCLIC_DEPENDENCIES:1.0",
        "CYCLIC_DEPENDENCIES"
      )
{
}

RtecScheduler::CYCLIC_DEPENDENCIES::~CYCLIC_DEPENDENCIES (void)
{
}

RtecScheduler::CYCLIC_DEPENDENCIES::CYCLIC_DEPENDENCIES (const ::RtecScheduler::CYCLIC_DEPENDENCIES &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RtecScheduler::CYCLIC_DEPENDENCIES&
RtecScheduler::CYCLIC_DEPENDENCIES::operator= (const ::RtecScheduler::CYCLIC_DEPENDENCIES &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void RtecScheduler::CYCLIC_DEPENDENCIES::_tao_any_destructor (void *_tao_void_pointer)
{
  CYCLIC_DEPENDENCIES *_tao_tmp_pointer =
    static_cast<CYCLIC_DEPENDENCIES *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

RtecScheduler::CYCLIC_DEPENDENCIES *
RtecScheduler::CYCLIC_DEPENDENCIES::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<CYCLIC_DEPENDENCIES *> (_tao_excp);
}

const RtecScheduler::CYCLIC_DEPENDENCIES *
RtecScheduler::CYCLIC_DEPENDENCIES::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const CYCLIC_DEPENDENCIES *> (_tao_excp);
}

::CORBA::Exception *RtecScheduler::CYCLIC_DEPENDENCIES::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RtecScheduler::CYCLIC_DEPENDENCIES, 0);
  return retval;
}

::CORBA::Exception *
RtecScheduler::CYCLIC_DEPENDENCIES::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::RtecScheduler::CYCLIC_DEPENDENCIES (*this),
      0
    );
  return result;
}

void RtecScheduler::CYCLIC_DEPENDENCIES::_raise (void) const
{
  throw *this;
}

void RtecScheduler::CYCLIC_DEPENDENCIES::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void RtecScheduler::CYCLIC_DEPENDENCIES::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr RtecScheduler::CYCLIC_DEPENDENCIES::_tao_type (void) const
{
  return ::RtecScheduler::_tc_CYCLIC_DEPENDENCIES;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_RtecScheduler_CYCLIC_DEPENDENCIES = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_CYCLIC_DEPENDENCIES (
  ::CORBA::tk_except,
  "IDL:RtecScheduler/CYCLIC_DEPENDENCIES:1.0",
  "CYCLIC_DEPENDENCIES",
  _tao_fields_RtecScheduler_CYCLIC_DEPENDENCIES,
  0);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_CYCLIC_DEPENDENCIES =
    &_tao_tc_RtecScheduler_CYCLIC_DEPENDENCIES;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::UNRESOLVED_LOCAL_DEPENDENCIES (void)
  : ::CORBA::UserException (
        "IDL:RtecScheduler/UNRESOLVED_LOCAL_DEPENDENCIES:1.0",
        "UNRESOLVED_LOCAL_DEPENDENCIES"
      )
{
}

RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::~UNRESOLVED_LOCAL_DEPENDENCIES (void)
{
}

RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::UNRESOLVED_LOCAL_DEPENDENCIES (const ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES&
RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::operator= (const ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_tao_any_destructor (void *_tao_void_pointer)
{
  UNRESOLVED_LOCAL_DEPENDENCIES *_tao_tmp_pointer =
    static_cast<UNRESOLVED_LOCAL_DEPENDENCIES *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES *
RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UNRESOLVED_LOCAL_DEPENDENCIES *> (_tao_excp);
}

const RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES *
RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UNRESOLVED_LOCAL_DEPENDENCIES *> (_tao_excp);
}

::CORBA::Exception *RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES, 0);
  return retval;
}

::CORBA::Exception *
RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES (*this),
      0
    );
  return result;
}

void RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_raise (void) const
{
  throw *this;
}

void RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_tao_type (void) const
{
  return ::RtecScheduler::_tc_UNRESOLVED_LOCAL_DEPENDENCIES;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_RtecScheduler_UNRESOLVED_LOCAL_DEPENDENCIES = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_UNRESOLVED_LOCAL_DEPENDENCIES (
  ::CORBA::tk_except,
  "IDL:RtecScheduler/UNRESOLVED_LOCAL_DEPENDENCIES:1.0",
  "UNRESOLVED_LOCAL_DEPENDENCIES",
  _tao_fields_RtecScheduler_UNRESOLVED_LOCAL_DEPENDENCIES,
  0);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_UNRESOLVED_LOCAL_DEPENDENCIES =
    &_tao_tc_RtecScheduler_UNRESOLVED_LOCAL_DEPENDENCIES;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

RtecScheduler::THREAD_SPECIFICATION::THREAD_SPECIFICATION (void)
  : ::CORBA::UserException (
        "IDL:RtecScheduler/THREAD_SPECIFICATION:1.0",
        "THREAD_SPECIFICATION"
      )
{
}

RtecScheduler::THREAD_SPECIFICATION::~THREAD_SPECIFICATION (void)
{
}

RtecScheduler::THREAD_SPECIFICATION::THREAD_SPECIFICATION (const ::RtecScheduler::THREAD_SPECIFICATION &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RtecScheduler::THREAD_SPECIFICATION&
RtecScheduler::THREAD_SPECIFICATION::operator= (const ::RtecScheduler::THREAD_SPECIFICATION &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void RtecScheduler::THREAD_SPECIFICATION::_tao_any_destructor (void *_tao_void_pointer)
{
  THREAD_SPECIFICATION *_tao_tmp_pointer =
    static_cast<THREAD_SPECIFICATION *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

RtecScheduler::THREAD_SPECIFICATION *
RtecScheduler::THREAD_SPECIFICATION::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<THREAD_SPECIFICATION *> (_tao_excp);
}

const RtecScheduler::THREAD_SPECIFICATION *
RtecScheduler::THREAD_SPECIFICATION::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const THREAD_SPECIFICATION *> (_tao_excp);
}

::CORBA::Exception *RtecScheduler::THREAD_SPECIFICATION::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RtecScheduler::THREAD_SPECIFICATION, 0);
  return retval;
}

::CORBA::Exception *
RtecScheduler::THREAD_SPECIFICATION::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::RtecScheduler::THREAD_SPECIFICATION (*this),
      0
    );
  return result;
}

void RtecScheduler::THREAD_SPECIFICATION::_raise (void) const
{
  throw *this;
}

void RtecScheduler::THREAD_SPECIFICATION::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void RtecScheduler::THREAD_SPECIFICATION::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr RtecScheduler::THREAD_SPECIFICATION::_tao_type (void) const
{
  return ::RtecScheduler::_tc_THREAD_SPECIFICATION;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_RtecScheduler_THREAD_SPECIFICATION = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_THREAD_SPECIFICATION (
  ::CORBA::tk_except,
  "IDL:RtecScheduler/THREAD_SPECIFICATION:1.0",
  "THREAD_SPECIFICATION",
  _tao_fields_RtecScheduler_THREAD_SPECIFICATION,
  0);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_THREAD_SPECIFICATION =
    &_tao_tc_RtecScheduler_THREAD_SPECIFICATION;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

RtecScheduler::DUPLICATE_NAME::DUPLICATE_NAME (void)
  : ::CORBA::UserException (
        "IDL:RtecScheduler/DUPLICATE_NAME:1.0",
        "DUPLICATE_NAME"
      )
{
}

RtecScheduler::DUPLICATE_NAME::~DUPLICATE_NAME (void)
{
}

RtecScheduler::DUPLICATE_NAME::DUPLICATE_NAME (const ::RtecScheduler::DUPLICATE_NAME &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RtecScheduler::DUPLICATE_NAME&
RtecScheduler::DUPLICATE_NAME::operator= (const ::RtecScheduler::DUPLICATE_NAME &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void RtecScheduler::DUPLICATE_NAME::_tao_any_destructor (void *_tao_void_pointer)
{
  DUPLICATE_NAME *_tao_tmp_pointer =
    static_cast<DUPLICATE_NAME *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

RtecScheduler::DUPLICATE_NAME *
RtecScheduler::DUPLICATE_NAME::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<DUPLICATE_NAME *> (_tao_excp);
}

const RtecScheduler::DUPLICATE_NAME *
RtecScheduler::DUPLICATE_NAME::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const DUPLICATE_NAME *> (_tao_excp);
}

::CORBA::Exception *RtecScheduler::DUPLICATE_NAME::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RtecScheduler::DUPLICATE_NAME, 0);
  return retval;
}

::CORBA::Exception *
RtecScheduler::DUPLICATE_NAME::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::RtecScheduler::DUPLICATE_NAME (*this),
      0
    );
  return result;
}

void RtecScheduler::DUPLICATE_NAME::_raise (void) const
{
  throw *this;
}

void RtecScheduler::DUPLICATE_NAME::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void RtecScheduler::DUPLICATE_NAME::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr RtecScheduler::DUPLICATE_NAME::_tao_type (void) const
{
  return ::RtecScheduler::_tc_DUPLICATE_NAME;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_RtecScheduler_DUPLICATE_NAME = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_DUPLICATE_NAME (
  ::CORBA::tk_except,
  "IDL:RtecScheduler/DUPLICATE_NAME:1.0",
  "DUPLICATE_NAME",
  _tao_fields_RtecScheduler_DUPLICATE_NAME,
  0);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_DUPLICATE_NAME =
    &_tao_tc_RtecScheduler_DUPLICATE_NAME;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

RtecScheduler::UNKNOWN_TASK::UNKNOWN_TASK (void)
  : ::CORBA::UserException (
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        "UNKNOWN_TASK"
      )
{
}

RtecScheduler::UNKNOWN_TASK::~UNKNOWN_TASK (void)
{
}

RtecScheduler::UNKNOWN_TASK::UNKNOWN_TASK (const ::RtecScheduler::UNKNOWN_TASK &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RtecScheduler::UNKNOWN_TASK&
RtecScheduler::UNKNOWN_TASK::operator= (const ::RtecScheduler::UNKNOWN_TASK &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void RtecScheduler::UNKNOWN_TASK::_tao_any_destructor (void *_tao_void_pointer)
{
  UNKNOWN_TASK *_tao_tmp_pointer =
    static_cast<UNKNOWN_TASK *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

RtecScheduler::UNKNOWN_TASK *
RtecScheduler::UNKNOWN_TASK::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UNKNOWN_TASK *> (_tao_excp);
}

const RtecScheduler::UNKNOWN_TASK *
RtecScheduler::UNKNOWN_TASK::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UNKNOWN_TASK *> (_tao_excp);
}

::CORBA::Exception *RtecScheduler::UNKNOWN_TASK::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RtecScheduler::UNKNOWN_TASK, 0);
  return retval;
}

::CORBA::Exception *
RtecScheduler::UNKNOWN_TASK::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::RtecScheduler::UNKNOWN_TASK (*this),
      0
    );
  return result;
}

void RtecScheduler::UNKNOWN_TASK::_raise (void) const
{
  throw *this;
}

void RtecScheduler::UNKNOWN_TASK::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void RtecScheduler::UNKNOWN_TASK::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr RtecScheduler::UNKNOWN_TASK::_tao_type (void) const
{
  return ::RtecScheduler::_tc_UNKNOWN_TASK;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_RtecScheduler_UNKNOWN_TASK = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_UNKNOWN_TASK (
  ::CORBA::tk_except,
  "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
  "UNKNOWN_TASK",
  _tao_fields_RtecScheduler_UNKNOWN_TASK,
  0);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_UNKNOWN_TASK =
    &_tao_tc_RtecScheduler_UNKNOWN_TASK;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

RtecScheduler::NOT_SCHEDULED::NOT_SCHEDULED (void)
  : ::CORBA::UserException (
        "IDL:RtecScheduler/NOT_SCHEDULED:1.0",
        "NOT_SCHEDULED"
      )
{
}

RtecScheduler::NOT_SCHEDULED::~NOT_SCHEDULED (void)
{
}

RtecScheduler::NOT_SCHEDULED::NOT_SCHEDULED (const ::RtecScheduler::NOT_SCHEDULED &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RtecScheduler::NOT_SCHEDULED&
RtecScheduler::NOT_SCHEDULED::operator= (const ::RtecScheduler::NOT_SCHEDULED &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void RtecScheduler::NOT_SCHEDULED::_tao_any_destructor (void *_tao_void_pointer)
{
  NOT_SCHEDULED *_tao_tmp_pointer =
    static_cast<NOT_SCHEDULED *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

RtecScheduler::NOT_SCHEDULED *
RtecScheduler::NOT_SCHEDULED::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NOT_SCHEDULED *> (_tao_excp);
}

const RtecScheduler::NOT_SCHEDULED *
RtecScheduler::NOT_SCHEDULED::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NOT_SCHEDULED *> (_tao_excp);
}

::CORBA::Exception *RtecScheduler::NOT_SCHEDULED::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RtecScheduler::NOT_SCHEDULED, 0);
  return retval;
}

::CORBA::Exception *
RtecScheduler::NOT_SCHEDULED::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::RtecScheduler::NOT_SCHEDULED (*this),
      0
    );
  return result;
}

void RtecScheduler::NOT_SCHEDULED::_raise (void) const
{
  throw *this;
}

void RtecScheduler::NOT_SCHEDULED::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void RtecScheduler::NOT_SCHEDULED::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr RtecScheduler::NOT_SCHEDULED::_tao_type (void) const
{
  return ::RtecScheduler::_tc_NOT_SCHEDULED;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_RtecScheduler_NOT_SCHEDULED = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_NOT_SCHEDULED (
  ::CORBA::tk_except,
  "IDL:RtecScheduler/NOT_SCHEDULED:1.0",
  "NOT_SCHEDULED",
  _tao_fields_RtecScheduler_NOT_SCHEDULED,
  0);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_NOT_SCHEDULED =
    &_tao_tc_RtecScheduler_NOT_SCHEDULED;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

RtecScheduler::UTILIZATION_BOUND_EXCEEDED::UTILIZATION_BOUND_EXCEEDED (void)
  : ::CORBA::UserException (
        "IDL:RtecScheduler/UTILIZATION_BOUND_EXCEEDED:1.0",
        "UTILIZATION_BOUND_EXCEEDED"
      )
{
}

RtecScheduler::UTILIZATION_BOUND_EXCEEDED::~UTILIZATION_BOUND_EXCEEDED (void)
{
}

RtecScheduler::UTILIZATION_BOUND_EXCEEDED::UTILIZATION_BOUND_EXCEEDED (const ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RtecScheduler::UTILIZATION_BOUND_EXCEEDED&
RtecScheduler::UTILIZATION_BOUND_EXCEEDED::operator= (const ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_tao_any_destructor (void *_tao_void_pointer)
{
  UTILIZATION_BOUND_EXCEEDED *_tao_tmp_pointer =
    static_cast<UTILIZATION_BOUND_EXCEEDED *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

RtecScheduler::UTILIZATION_BOUND_EXCEEDED *
RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UTILIZATION_BOUND_EXCEEDED *> (_tao_excp);
}

const RtecScheduler::UTILIZATION_BOUND_EXCEEDED *
RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UTILIZATION_BOUND_EXCEEDED *> (_tao_excp);
}

::CORBA::Exception *RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED, 0);
  return retval;
}

::CORBA::Exception *
RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED (*this),
      0
    );
  return result;
}

void RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_raise (void) const
{
  throw *this;
}

void RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_tao_type (void) const
{
  return ::RtecScheduler::_tc_UTILIZATION_BOUND_EXCEEDED;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_RtecScheduler_UTILIZATION_BOUND_EXCEEDED = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_UTILIZATION_BOUND_EXCEEDED (
  ::CORBA::tk_except,
  "IDL:RtecScheduler/UTILIZATION_BOUND_EXCEEDED:1.0",
  "UTILIZATION_BOUND_EXCEEDED",
  _tao_fields_RtecScheduler_UTILIZATION_BOUND_EXCEEDED,
  0);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_UTILIZATION_BOUND_EXCEEDED =
    &_tao_tc_RtecScheduler_UTILIZATION_BOUND_EXCEEDED;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::INSUFFICIENT_THREAD_PRIORITY_LEVELS (void)
  : ::CORBA::UserException (
        "IDL:RtecScheduler/INSUFFICIENT_THREAD_PRIORITY_LEVELS:1.0",
        "INSUFFICIENT_THREAD_PRIORITY_LEVELS"
      )
{
}

RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::~INSUFFICIENT_THREAD_PRIORITY_LEVELS (void)
{
}

RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::INSUFFICIENT_THREAD_PRIORITY_LEVELS (const ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS&
RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::operator= (const ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_tao_any_destructor (void *_tao_void_pointer)
{
  INSUFFICIENT_THREAD_PRIORITY_LEVELS *_tao_tmp_pointer =
    static_cast<INSUFFICIENT_THREAD_PRIORITY_LEVELS *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS *
RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<INSUFFICIENT_THREAD_PRIORITY_LEVELS *> (_tao_excp);
}

const RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS *
RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const INSUFFICIENT_THREAD_PRIORITY_LEVELS *> (_tao_excp);
}

::CORBA::Exception *RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS, 0);
  return retval;
}

::CORBA::Exception *
RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS (*this),
      0
    );
  return result;
}

void RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_raise (void) const
{
  throw *this;
}

void RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_tao_type (void) const
{
  return ::RtecScheduler::_tc_INSUFFICIENT_THREAD_PRIORITY_LEVELS;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_RtecScheduler_INSUFFICIENT_THREAD_PRIORITY_LEVELS = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_INSUFFICIENT_THREAD_PRIORITY_LEVELS (
  ::CORBA::tk_except,
  "IDL:RtecScheduler/INSUFFICIENT_THREAD_PRIORITY_LEVELS:1.0",
  "INSUFFICIENT_THREAD_PRIORITY_LEVELS",
  _tao_fields_RtecScheduler_INSUFFICIENT_THREAD_PRIORITY_LEVELS,
  0);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_INSUFFICIENT_THREAD_PRIORITY_LEVELS =
    &_tao_tc_RtecScheduler_INSUFFICIENT_THREAD_PRIORITY_LEVELS;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

RtecScheduler::TASK_COUNT_MISMATCH::TASK_COUNT_MISMATCH (void)
  : ::CORBA::UserException (
        "IDL:RtecScheduler/TASK_COUNT_MISMATCH:1.0",
        "TASK_COUNT_MISMATCH"
      )
{
}

RtecScheduler::TASK_COUNT_MISMATCH::~TASK_COUNT_MISMATCH (void)
{
}

RtecScheduler::TASK_COUNT_MISMATCH::TASK_COUNT_MISMATCH (const ::RtecScheduler::TASK_COUNT_MISMATCH &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RtecScheduler::TASK_COUNT_MISMATCH&
RtecScheduler::TASK_COUNT_MISMATCH::operator= (const ::RtecScheduler::TASK_COUNT_MISMATCH &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void RtecScheduler::TASK_COUNT_MISMATCH::_tao_any_destructor (void *_tao_void_pointer)
{
  TASK_COUNT_MISMATCH *_tao_tmp_pointer =
    static_cast<TASK_COUNT_MISMATCH *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

RtecScheduler::TASK_COUNT_MISMATCH *
RtecScheduler::TASK_COUNT_MISMATCH::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<TASK_COUNT_MISMATCH *> (_tao_excp);
}

const RtecScheduler::TASK_COUNT_MISMATCH *
RtecScheduler::TASK_COUNT_MISMATCH::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const TASK_COUNT_MISMATCH *> (_tao_excp);
}

::CORBA::Exception *RtecScheduler::TASK_COUNT_MISMATCH::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RtecScheduler::TASK_COUNT_MISMATCH, 0);
  return retval;
}

::CORBA::Exception *
RtecScheduler::TASK_COUNT_MISMATCH::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::RtecScheduler::TASK_COUNT_MISMATCH (*this),
      0
    );
  return result;
}

void RtecScheduler::TASK_COUNT_MISMATCH::_raise (void) const
{
  throw *this;
}

void RtecScheduler::TASK_COUNT_MISMATCH::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void RtecScheduler::TASK_COUNT_MISMATCH::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr RtecScheduler::TASK_COUNT_MISMATCH::_tao_type (void) const
{
  return ::RtecScheduler::_tc_TASK_COUNT_MISMATCH;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_RtecScheduler_TASK_COUNT_MISMATCH = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_TASK_COUNT_MISMATCH (
  ::CORBA::tk_except,
  "IDL:RtecScheduler/TASK_COUNT_MISMATCH:1.0",
  "TASK_COUNT_MISMATCH",
  _tao_fields_RtecScheduler_TASK_COUNT_MISMATCH,
  0);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_TASK_COUNT_MISMATCH =
    &_tao_tc_RtecScheduler_TASK_COUNT_MISMATCH;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

RtecScheduler::UNKNOWN_PRIORITY_LEVEL::UNKNOWN_PRIORITY_LEVEL (void)
  : ::CORBA::UserException (
        "IDL:RtecScheduler/UNKNOWN_PRIORITY_LEVEL:1.0",
        "UNKNOWN_PRIORITY_LEVEL"
      )
{
}

RtecScheduler::UNKNOWN_PRIORITY_LEVEL::~UNKNOWN_PRIORITY_LEVEL (void)
{
}

RtecScheduler::UNKNOWN_PRIORITY_LEVEL::UNKNOWN_PRIORITY_LEVEL (const ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RtecScheduler::UNKNOWN_PRIORITY_LEVEL&
RtecScheduler::UNKNOWN_PRIORITY_LEVEL::operator= (const ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_tao_any_destructor (void *_tao_void_pointer)
{
  UNKNOWN_PRIORITY_LEVEL *_tao_tmp_pointer =
    static_cast<UNKNOWN_PRIORITY_LEVEL *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

RtecScheduler::UNKNOWN_PRIORITY_LEVEL *
RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UNKNOWN_PRIORITY_LEVEL *> (_tao_excp);
}

const RtecScheduler::UNKNOWN_PRIORITY_LEVEL *
RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UNKNOWN_PRIORITY_LEVEL *> (_tao_excp);
}

::CORBA::Exception *RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL, 0);
  return retval;
}

::CORBA::Exception *
RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL (*this),
      0
    );
  return result;
}

void RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_raise (void) const
{
  throw *this;
}

void RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_tao_type (void) const
{
  return ::RtecScheduler::_tc_UNKNOWN_PRIORITY_LEVEL;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_RtecScheduler_UNKNOWN_PRIORITY_LEVEL = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_UNKNOWN_PRIORITY_LEVEL (
  ::CORBA::tk_except,
  "IDL:RtecScheduler/UNKNOWN_PRIORITY_LEVEL:1.0",
  "UNKNOWN_PRIORITY_LEVEL",
  _tao_fields_RtecScheduler_UNKNOWN_PRIORITY_LEVEL,
  0);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_UNKNOWN_PRIORITY_LEVEL =
    &_tao_tc_RtecScheduler_UNKNOWN_PRIORITY_LEVEL;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

RtecScheduler::SYNCHRONIZATION_FAILURE::SYNCHRONIZATION_FAILURE (void)
  : ::CORBA::UserException (
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        "SYNCHRONIZATION_FAILURE"
      )
{
}

RtecScheduler::SYNCHRONIZATION_FAILURE::~SYNCHRONIZATION_FAILURE (void)
{
}

RtecScheduler::SYNCHRONIZATION_FAILURE::SYNCHRONIZATION_FAILURE (const ::RtecScheduler::SYNCHRONIZATION_FAILURE &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RtecScheduler::SYNCHRONIZATION_FAILURE&
RtecScheduler::SYNCHRONIZATION_FAILURE::operator= (const ::RtecScheduler::SYNCHRONIZATION_FAILURE &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void RtecScheduler::SYNCHRONIZATION_FAILURE::_tao_any_destructor (void *_tao_void_pointer)
{
  SYNCHRONIZATION_FAILURE *_tao_tmp_pointer =
    static_cast<SYNCHRONIZATION_FAILURE *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

RtecScheduler::SYNCHRONIZATION_FAILURE *
RtecScheduler::SYNCHRONIZATION_FAILURE::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<SYNCHRONIZATION_FAILURE *> (_tao_excp);
}

const RtecScheduler::SYNCHRONIZATION_FAILURE *
RtecScheduler::SYNCHRONIZATION_FAILURE::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const SYNCHRONIZATION_FAILURE *> (_tao_excp);
}

::CORBA::Exception *RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RtecScheduler::SYNCHRONIZATION_FAILURE, 0);
  return retval;
}

::CORBA::Exception *
RtecScheduler::SYNCHRONIZATION_FAILURE::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::RtecScheduler::SYNCHRONIZATION_FAILURE (*this),
      0
    );
  return result;
}

void RtecScheduler::SYNCHRONIZATION_FAILURE::_raise (void) const
{
  throw *this;
}

void RtecScheduler::SYNCHRONIZATION_FAILURE::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void RtecScheduler::SYNCHRONIZATION_FAILURE::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr RtecScheduler::SYNCHRONIZATION_FAILURE::_tao_type (void) const
{
  return ::RtecScheduler::_tc_SYNCHRONIZATION_FAILURE;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_RtecScheduler_SYNCHRONIZATION_FAILURE = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_SYNCHRONIZATION_FAILURE (
  ::CORBA::tk_except,
  "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
  "SYNCHRONIZATION_FAILURE",
  _tao_fields_RtecScheduler_SYNCHRONIZATION_FAILURE,
  0);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_SYNCHRONIZATION_FAILURE =
    &_tao_tc_RtecScheduler_SYNCHRONIZATION_FAILURE;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

RtecScheduler::INTERNAL::INTERNAL (void)
  : ::CORBA::UserException (
        "IDL:RtecScheduler/INTERNAL:1.0",
        "INTERNAL"
      )
{
}

RtecScheduler::INTERNAL::~INTERNAL (void)
{
}

RtecScheduler::INTERNAL::INTERNAL (const ::RtecScheduler::INTERNAL &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RtecScheduler::INTERNAL&
RtecScheduler::INTERNAL::operator= (const ::RtecScheduler::INTERNAL &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void RtecScheduler::INTERNAL::_tao_any_destructor (void *_tao_void_pointer)
{
  INTERNAL *_tao_tmp_pointer =
    static_cast<INTERNAL *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

RtecScheduler::INTERNAL *
RtecScheduler::INTERNAL::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<INTERNAL *> (_tao_excp);
}

const RtecScheduler::INTERNAL *
RtecScheduler::INTERNAL::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const INTERNAL *> (_tao_excp);
}

::CORBA::Exception *RtecScheduler::INTERNAL::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RtecScheduler::INTERNAL, 0);
  return retval;
}

::CORBA::Exception *
RtecScheduler::INTERNAL::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::RtecScheduler::INTERNAL (*this),
      0
    );
  return result;
}

void RtecScheduler::INTERNAL::_raise (void) const
{
  throw *this;
}

void RtecScheduler::INTERNAL::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void RtecScheduler::INTERNAL::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr RtecScheduler::INTERNAL::_tao_type (void) const
{
  return ::RtecScheduler::_tc_INTERNAL;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_RtecScheduler_INTERNAL = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_RtecScheduler_INTERNAL (
  ::CORBA::tk_except,
  "IDL:RtecScheduler/INTERNAL:1.0",
  "INTERNAL",
  _tao_fields_RtecScheduler_INTERNAL,
  0);


namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_INTERNAL =
    &_tao_tc_RtecScheduler_INTERNAL;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_RTECSCHEDULER_RT_INFO_SET_CS_)
#define _RTECSCHEDULER_RT_INFO_SET_CS_

RtecScheduler::RT_Info_Set::RT_Info_Set (void)
{}

RtecScheduler::RT_Info_Set::RT_Info_Set (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        RT_Info
      > (max)
{}

RtecScheduler::RT_Info_Set::RT_Info_Set (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    RtecScheduler::RT_Info * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        RT_Info
      >
    (max, length, buffer, release)
{}

RtecScheduler::RT_Info_Set::RT_Info_Set (
    const RT_Info_Set &seq)
  : ::TAO::unbounded_value_sequence<
        RT_Info
      > (seq)
{}

RtecScheduler::RT_Info_Set::~RT_Info_Set (void)
{}

void RtecScheduler::RT_Info_Set::_tao_any_destructor (
    void * _tao_void_pointer)
{
  RT_Info_Set * _tao_tmp_pointer =
    static_cast<RT_Info_Set *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_RtecScheduler_RT_Info_Set_GUARD
#define _TAO_TYPECODE_RtecScheduler_RT_Info_Set_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        RtecScheduler_RT_Info_Set_0 (
          ::CORBA::tk_sequence,
          &RtecScheduler::_tc_RT_Info,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_RtecScheduler_RT_Info_Set_0 =
        &RtecScheduler_RT_Info_Set_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_RtecScheduler_RT_Info_Set_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_RT_Info_Set (
    ::CORBA::tk_alias,
    "IDL:RtecScheduler/RT_Info_Set:1.0",
    "RT_Info_Set",
    &TAO::TypeCode::tc_RtecScheduler_RT_Info_Set_0);
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_RT_Info_Set =
    &_tao_tc_RtecScheduler_RT_Info_Set;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for RtecScheduler::Scheduler.

RtecScheduler::Scheduler_ptr
TAO::Objref_Traits<RtecScheduler::Scheduler>::duplicate (
    RtecScheduler::Scheduler_ptr p)
{
  return RtecScheduler::Scheduler::_duplicate (p);
}

void
TAO::Objref_Traits<RtecScheduler::Scheduler>::release (
    RtecScheduler::Scheduler_ptr p)
{
  ::CORBA::release (p);
}

RtecScheduler::Scheduler_ptr
TAO::Objref_Traits<RtecScheduler::Scheduler>::nil (void)
{
  return RtecScheduler::Scheduler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<RtecScheduler::Scheduler>::marshal (
    const RtecScheduler::Scheduler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*RtecScheduler__TAO_Scheduler_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::RtecScheduler::handle_t
RtecScheduler::Scheduler::create (
  const char * entry_point)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_entry_point (entry_point);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_entry_point
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_create_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/DUPLICATE_NAME:1.0",
        RtecScheduler::DUPLICATE_NAME::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_DUPLICATE_NAME
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INTERNAL:1.0",
        RtecScheduler::INTERNAL::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INTERNAL
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "create",
      6,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_create_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::RtecScheduler::handle_t
RtecScheduler::Scheduler::lookup (
  const char * entry_point)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_entry_point (entry_point);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_entry_point
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_lookup_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "lookup",
      6,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_lookup_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::RtecScheduler::RT_Info *
RtecScheduler::Scheduler::get (
  ::RtecScheduler::handle_t handle)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::RtecScheduler::RT_Info>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_handle (handle);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_handle
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_get_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get",
      3,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_get_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::set (
  ::RtecScheduler::handle_t handle,
  ::RtecScheduler::Criticality_t criticality,
  ::RtecScheduler::Time wc_time,
  ::RtecScheduler::Time typical_time,
  ::RtecScheduler::Time cached_time,
  ::RtecScheduler::Period_t period,
  ::RtecScheduler::Importance_t importance,
  ::RtecScheduler::Quantum_t quantum,
  ::RtecScheduler::Threads_t threads,
  ::RtecScheduler::Info_Type_t info_type)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_handle (handle);
  TAO::Arg_Traits< ::RtecScheduler::Criticality_t>::in_arg_val _tao_criticality (criticality);
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_wc_time (wc_time);
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_typical_time (typical_time);
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_cached_time (cached_time);
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_period (period);
  TAO::Arg_Traits< ::RtecScheduler::Importance_t>::in_arg_val _tao_importance (importance);
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_quantum (quantum);
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_threads (threads);
  TAO::Arg_Traits< ::RtecScheduler::Info_Type_t>::in_arg_val _tao_info_type (info_type);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_handle,
      &_tao_criticality,
      &_tao_wc_time,
      &_tao_typical_time,
      &_tao_cached_time,
      &_tao_period,
      &_tao_importance,
      &_tao_quantum,
      &_tao_threads,
      &_tao_info_type
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_set_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INTERNAL:1.0",
        RtecScheduler::INTERNAL::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INTERNAL
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      11,
      "set",
      3,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_set_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::reset (
  ::RtecScheduler::handle_t handle,
  ::RtecScheduler::Criticality_t criticality,
  ::RtecScheduler::Time wc_time,
  ::RtecScheduler::Time typical_time,
  ::RtecScheduler::Time cached_time,
  ::RtecScheduler::Period_t period,
  ::RtecScheduler::Importance_t importance,
  ::RtecScheduler::Quantum_t quantum,
  ::RtecScheduler::Threads_t threads,
  ::RtecScheduler::Info_Type_t info_type)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_handle (handle);
  TAO::Arg_Traits< ::RtecScheduler::Criticality_t>::in_arg_val _tao_criticality (criticality);
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_wc_time (wc_time);
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_typical_time (typical_time);
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_cached_time (cached_time);
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_period (period);
  TAO::Arg_Traits< ::RtecScheduler::Importance_t>::in_arg_val _tao_importance (importance);
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_quantum (quantum);
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_threads (threads);
  TAO::Arg_Traits< ::RtecScheduler::Info_Type_t>::in_arg_val _tao_info_type (info_type);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_handle,
      &_tao_criticality,
      &_tao_wc_time,
      &_tao_typical_time,
      &_tao_cached_time,
      &_tao_period,
      &_tao_importance,
      &_tao_quantum,
      &_tao_threads,
      &_tao_info_type
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_reset_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INTERNAL:1.0",
        RtecScheduler::INTERNAL::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INTERNAL
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      11,
      "reset",
      5,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_reset_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::set_seq (
  const ::RtecScheduler::RT_Info_Set & infos)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::RtecScheduler::RT_Info_Set>::in_arg_val _tao_infos (infos);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_infos
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_set_seq_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INTERNAL:1.0",
        RtecScheduler::INTERNAL::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INTERNAL
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_seq",
      7,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_set_seq_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::reset_seq (
  const ::RtecScheduler::RT_Info_Set & infos)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::RtecScheduler::RT_Info_Set>::in_arg_val _tao_infos (infos);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_infos
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_reset_seq_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INTERNAL:1.0",
        RtecScheduler::INTERNAL::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INTERNAL
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "reset_seq",
      9,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_reset_seq_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::replace_seq (
  const ::RtecScheduler::RT_Info_Set & infos)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::RtecScheduler::RT_Info_Set>::in_arg_val _tao_infos (infos);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_infos
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_replace_seq_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INTERNAL:1.0",
        RtecScheduler::INTERNAL::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INTERNAL
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "replace_seq",
      11,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_replace_seq_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::add_dependency (
  ::RtecScheduler::handle_t handle,
  ::RtecScheduler::handle_t dependency,
  ::CORBA::Long number_of_calls,
  ::RtecScheduler::Dependency_Type_t dependency_type)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_handle (handle);
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_dependency (dependency);
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_number_of_calls (number_of_calls);
  TAO::Arg_Traits< ::RtecBase::Dependency_Type_t>::in_arg_val _tao_dependency_type (dependency_type);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_handle,
      &_tao_dependency,
      &_tao_number_of_calls,
      &_tao_dependency_type
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_add_dependency_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "add_dependency",
      14,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_add_dependency_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::remove_dependency (
  ::RtecScheduler::handle_t handle,
  ::RtecScheduler::handle_t dependency,
  ::CORBA::Long number_of_calls,
  ::RtecScheduler::Dependency_Type_t dependency_type)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_handle (handle);
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_dependency (dependency);
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_number_of_calls (number_of_calls);
  TAO::Arg_Traits< ::RtecBase::Dependency_Type_t>::in_arg_val _tao_dependency_type (dependency_type);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_handle,
      &_tao_dependency,
      &_tao_number_of_calls,
      &_tao_dependency_type
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_remove_dependency_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "remove_dependency",
      17,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_remove_dependency_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::set_dependency_enable_state (
  ::RtecScheduler::handle_t handle,
  ::RtecScheduler::handle_t dependency,
  ::CORBA::Long number_of_calls,
  ::RtecScheduler::Dependency_Type_t dependency_type,
  ::RtecScheduler::Dependency_Enabled_Type_t enabled)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_handle (handle);
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_dependency (dependency);
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_number_of_calls (number_of_calls);
  TAO::Arg_Traits< ::RtecBase::Dependency_Type_t>::in_arg_val _tao_dependency_type (dependency_type);
  TAO::Arg_Traits< ::RtecBase::Dependency_Enabled_Type_t>::in_arg_val _tao_enabled (enabled);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_handle,
      &_tao_dependency,
      &_tao_number_of_calls,
      &_tao_dependency_type,
      &_tao_enabled
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_set_dependency_enable_state_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      6,
      "set_dependency_enable_state",
      27,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_set_dependency_enable_state_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::set_dependency_enable_state_seq (
  const ::RtecScheduler::Dependency_Set & dependencies)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::RtecScheduler::Dependency_Set>::in_arg_val _tao_dependencies (dependencies);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_dependencies
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_set_dependency_enable_state_seq_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_dependency_enable_state_seq",
      31,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_set_dependency_enable_state_seq_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::set_rt_info_enable_state (
  ::RtecScheduler::handle_t handle,
  ::RtecScheduler::RT_Info_Enabled_Type_t enabled)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_handle (handle);
  TAO::Arg_Traits< ::RtecScheduler::RT_Info_Enabled_Type_t>::in_arg_val _tao_enabled (enabled);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_handle,
      &_tao_enabled
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_set_rt_info_enable_state_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INTERNAL:1.0",
        RtecScheduler::INTERNAL::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INTERNAL
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "set_rt_info_enable_state",
      24,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_set_rt_info_enable_state_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::set_rt_info_enable_state_seq (
  const ::RtecScheduler::RT_Info_Enable_State_Pair_Set & pair_set)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::RtecScheduler::RT_Info_Enable_State_Pair_Set>::in_arg_val _tao_pair_set (pair_set);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_pair_set
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_set_rt_info_enable_state_seq_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INTERNAL:1.0",
        RtecScheduler::INTERNAL::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INTERNAL
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_rt_info_enable_state_seq",
      28,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_set_rt_info_enable_state_seq_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::priority (
  ::RtecScheduler::handle_t handle,
  ::RtecScheduler::OS_Priority_out o_priority,
  ::RtecScheduler::Preemption_Subpriority_t_out p_subpriority,
  ::RtecScheduler::Preemption_Priority_t_out p_priority)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_handle (handle);
  TAO::Arg_Traits< ::CORBA::Long>::out_arg_val _tao_o_priority (o_priority);
  TAO::Arg_Traits< ::CORBA::Long>::out_arg_val _tao_p_subpriority (p_subpriority);
  TAO::Arg_Traits< ::CORBA::Long>::out_arg_val _tao_p_priority (p_priority);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_handle,
      &_tao_o_priority,
      &_tao_p_subpriority,
      &_tao_p_priority
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_priority_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/NOT_SCHEDULED:1.0",
        RtecScheduler::NOT_SCHEDULED::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_NOT_SCHEDULED
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "priority",
      8,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_priority_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::entry_point_priority (
  const char * entry_point,
  ::RtecScheduler::OS_Priority_out o_priority,
  ::RtecScheduler::Preemption_Subpriority_t_out p_subpriority,
  ::RtecScheduler::Preemption_Priority_t_out p_priority)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_entry_point (entry_point);
  TAO::Arg_Traits< ::CORBA::Long>::out_arg_val _tao_o_priority (o_priority);
  TAO::Arg_Traits< ::CORBA::Long>::out_arg_val _tao_p_subpriority (p_subpriority);
  TAO::Arg_Traits< ::CORBA::Long>::out_arg_val _tao_p_priority (p_priority);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_entry_point,
      &_tao_o_priority,
      &_tao_p_subpriority,
      &_tao_p_priority
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_entry_point_priority_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/UNKNOWN_TASK:1.0",
        RtecScheduler::UNKNOWN_TASK::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_TASK
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/NOT_SCHEDULED:1.0",
        RtecScheduler::NOT_SCHEDULED::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_NOT_SCHEDULED
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "entry_point_priority",
      20,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_entry_point_priority_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::compute_scheduling (
  ::CORBA::Long minimum_priority,
  ::CORBA::Long maximum_priority,
  ::RtecScheduler::RT_Info_Set_out infos,
  ::RtecScheduler::Dependency_Set_out dependencies,
  ::RtecScheduler::Config_Info_Set_out configs,
  ::RtecScheduler::Scheduling_Anomaly_Set_out anomalies)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_minimum_priority (minimum_priority);
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_maximum_priority (maximum_priority);
  TAO::Arg_Traits< ::RtecScheduler::RT_Info_Set>::out_arg_val _tao_infos (infos);
  TAO::Arg_Traits< ::RtecScheduler::Dependency_Set>::out_arg_val _tao_dependencies (dependencies);
  TAO::Arg_Traits< ::RtecScheduler::Config_Info_Set>::out_arg_val _tao_configs (configs);
  TAO::Arg_Traits< ::RtecScheduler::Scheduling_Anomaly_Set>::out_arg_val _tao_anomalies (anomalies);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_minimum_priority,
      &_tao_maximum_priority,
      &_tao_infos,
      &_tao_dependencies,
      &_tao_configs,
      &_tao_anomalies
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_compute_scheduling_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/UTILIZATION_BOUND_EXCEEDED:1.0",
        RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UTILIZATION_BOUND_EXCEEDED
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INSUFFICIENT_THREAD_PRIORITY_LEVELS:1.0",
        RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INSUFFICIENT_THREAD_PRIORITY_LEVELS
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/TASK_COUNT_MISMATCH:1.0",
        RtecScheduler::TASK_COUNT_MISMATCH::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_TASK_COUNT_MISMATCH
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INTERNAL:1.0",
        RtecScheduler::INTERNAL::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INTERNAL
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/DUPLICATE_NAME:1.0",
        RtecScheduler::DUPLICATE_NAME::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_DUPLICATE_NAME
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      7,
      "compute_scheduling",
      18,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_compute_scheduling_exceptiondata,
      6
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::recompute_scheduling (
  ::CORBA::Long minimum_priority,
  ::CORBA::Long maximum_priority,
  ::RtecScheduler::Scheduling_Anomaly_Set_out anomalies)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_minimum_priority (minimum_priority);
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_maximum_priority (maximum_priority);
  TAO::Arg_Traits< ::RtecScheduler::Scheduling_Anomaly_Set>::out_arg_val _tao_anomalies (anomalies);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_minimum_priority,
      &_tao_maximum_priority,
      &_tao_anomalies
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_recompute_scheduling_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/UTILIZATION_BOUND_EXCEEDED:1.0",
        RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UTILIZATION_BOUND_EXCEEDED
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INSUFFICIENT_THREAD_PRIORITY_LEVELS:1.0",
        RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INSUFFICIENT_THREAD_PRIORITY_LEVELS
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/TASK_COUNT_MISMATCH:1.0",
        RtecScheduler::TASK_COUNT_MISMATCH::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_TASK_COUNT_MISMATCH
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INTERNAL:1.0",
        RtecScheduler::INTERNAL::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INTERNAL
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/DUPLICATE_NAME:1.0",
        RtecScheduler::DUPLICATE_NAME::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_DUPLICATE_NAME
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "recompute_scheduling",
      20,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_recompute_scheduling_exceptiondata,
      6
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::get_rt_info_set (
  ::RtecScheduler::RT_Info_Set_out infos)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::RtecScheduler::RT_Info_Set>::out_arg_val _tao_infos (infos);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_infos
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_get_rt_info_set_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INTERNAL:1.0",
        RtecScheduler::INTERNAL::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INTERNAL
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_rt_info_set",
      15,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_get_rt_info_set_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::get_dependency_set (
  ::RtecScheduler::Dependency_Set_out dependencies)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::RtecScheduler::Dependency_Set>::out_arg_val _tao_dependencies (dependencies);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_dependencies
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_get_dependency_set_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INTERNAL:1.0",
        RtecScheduler::INTERNAL::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INTERNAL
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_dependency_set",
      18,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_get_dependency_set_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::get_config_info_set (
  ::RtecScheduler::Config_Info_Set_out configs)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::RtecScheduler::Config_Info_Set>::out_arg_val _tao_configs (configs);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_configs
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_get_config_info_set_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/INTERNAL:1.0",
        RtecScheduler::INTERNAL::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_INTERNAL
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_config_info_set",
      19,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_get_config_info_set_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::dispatch_configuration (
  ::RtecScheduler::Preemption_Priority_t p_priority,
  ::RtecScheduler::OS_Priority_out o_priority,
  ::RtecScheduler::Dispatching_Type_t_out d_type)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_p_priority (p_priority);
  TAO::Arg_Traits< ::CORBA::Long>::out_arg_val _tao_o_priority (o_priority);
  TAO::Arg_Traits< ::RtecScheduler::Dispatching_Type_t>::out_arg_val _tao_d_type (d_type);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_p_priority,
      &_tao_o_priority,
      &_tao_d_type
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_dispatch_configuration_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/NOT_SCHEDULED:1.0",
        RtecScheduler::NOT_SCHEDULED::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_NOT_SCHEDULED
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/UNKNOWN_PRIORITY_LEVEL:1.0",
        RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_UNKNOWN_PRIORITY_LEVEL
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "dispatch_configuration",
      22,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_dispatch_configuration_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::RtecScheduler::Preemption_Priority_t
RtecScheduler::Scheduler::last_scheduled_priority (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_last_scheduled_priority_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/NOT_SCHEDULED:1.0",
        RtecScheduler::NOT_SCHEDULED::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_NOT_SCHEDULED
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "last_scheduled_priority",
      23,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_last_scheduled_priority_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
RtecScheduler::Scheduler::get_config_infos (
  ::RtecScheduler::Config_Info_Set_out configs)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Scheduler_Proxy_Broker_ == 0)
    {
      RtecScheduler_Scheduler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::RtecScheduler::Config_Info_Set>::out_arg_val _tao_configs (configs);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_configs
    };

  static TAO::Exception_Data
  _tao_RtecScheduler_Scheduler_get_config_infos_exceptiondata [] = 
    {
      {
        "IDL:RtecScheduler/SYNCHRONIZATION_FAILURE:1.0",
        RtecScheduler::SYNCHRONIZATION_FAILURE::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_SYNCHRONIZATION_FAILURE
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:RtecScheduler/NOT_SCHEDULED:1.0",
        RtecScheduler::NOT_SCHEDULED::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , RtecScheduler::_tc_NOT_SCHEDULED
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_config_infos",
      16,
      this->the_TAO_Scheduler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_RtecScheduler_Scheduler_get_config_infos_exceptiondata,
      2
    );
}

RtecScheduler::Scheduler::Scheduler (void)
 : the_TAO_Scheduler_Proxy_Broker_ (0)
{
  this->RtecScheduler_Scheduler_setup_collocation ();
}

void
RtecScheduler::Scheduler::RtecScheduler_Scheduler_setup_collocation ()
{
  if (::RtecScheduler__TAO_Scheduler_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Scheduler_Proxy_Broker_ =
        ::RtecScheduler__TAO_Scheduler_Proxy_Broker_Factory_function_pointer (this);
    }
}

RtecScheduler::Scheduler::~Scheduler (void)
{}

void 
RtecScheduler::Scheduler::_tao_any_destructor (void *_tao_void_pointer)
{
  Scheduler *_tao_tmp_pointer =
    static_cast<Scheduler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

RtecScheduler::Scheduler_ptr
RtecScheduler::Scheduler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Scheduler>::narrow (
        _tao_objref,
        "IDL:RtecScheduler/Scheduler:1.0",
        RtecScheduler__TAO_Scheduler_Proxy_Broker_Factory_function_pointer
      );
}

RtecScheduler::Scheduler_ptr
RtecScheduler::Scheduler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Scheduler>::unchecked_narrow (
        _tao_objref,
        "IDL:RtecScheduler/Scheduler:1.0",
        RtecScheduler__TAO_Scheduler_Proxy_Broker_Factory_function_pointer
      );
}

RtecScheduler::Scheduler_ptr
RtecScheduler::Scheduler::_nil (void)
{
  return 0;
}

RtecScheduler::Scheduler_ptr
RtecScheduler::Scheduler::_duplicate (Scheduler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
RtecScheduler::Scheduler::_tao_release (Scheduler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
RtecScheduler::Scheduler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:RtecScheduler/Scheduler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* RtecScheduler::Scheduler::_interface_repository_id (void) const
{
  return "IDL:RtecScheduler/Scheduler:1.0";
}

::CORBA::Boolean
RtecScheduler::Scheduler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_RtecScheduler_Scheduler (
    ::CORBA::tk_objref,
    "IDL:RtecScheduler/Scheduler:1.0",
    "Scheduler");
  

namespace RtecScheduler
{
  ::CORBA::TypeCode_ptr const _tc_Scheduler =
    &_tao_tc_RtecScheduler_Scheduler;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::Period_Set &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::RtecScheduler::Period_Set *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::RtecScheduler::Period_Set>::insert_copy (
          _tao_any,
          ::RtecScheduler::Period_Set::_tao_any_destructor,
          ::RtecScheduler::_tc_Period_Set,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::Period_Set *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::Period_Set>::insert (
        _tao_any,
        ::RtecScheduler::Period_Set::_tao_any_destructor,
        ::RtecScheduler::_tc_Period_Set,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::Period_Set *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::Period_Set *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::Period_Set *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::Period_Set>::extract (
          _tao_any,
          ::RtecScheduler::Period_Set::_tao_any_destructor,
          ::RtecScheduler::_tc_Period_Set,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::Period_Set &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<RtecScheduler::Period_Set *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<RtecScheduler::Period_Set>::insert_copy (
        _tao_any,
        RtecScheduler::Period_Set::_tao_any_destructor,
        RtecScheduler::_tc_Period_Set,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::Period_Set *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::Period_Set>::insert (
      _tao_any,
      RtecScheduler::Period_Set::_tao_any_destructor,
      RtecScheduler::_tc_Period_Set,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::Period_Set *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::Period_Set *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::Period_Set *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::Period_Set>::extract (
        _tao_any,
        RtecScheduler::Period_Set::_tao_any_destructor,
        RtecScheduler::_tc_Period_Set,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::Criticality_t _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::RtecScheduler::Criticality_t>::insert (
        _tao_any,
        ::RtecScheduler::_tc_Criticality_t,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::Criticality_t &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::RtecScheduler::Criticality_t>::extract (
          _tao_any,
          ::RtecScheduler::_tc_Criticality_t,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::Criticality_t _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<RtecScheduler::Criticality_t>::insert (
      _tao_any,
      RtecScheduler::_tc_Criticality_t,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::Criticality_t &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<RtecScheduler::Criticality_t>::extract (
        _tao_any,
        RtecScheduler::_tc_Criticality_t,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::Importance_t _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::RtecScheduler::Importance_t>::insert (
        _tao_any,
        ::RtecScheduler::_tc_Importance_t,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::Importance_t &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::RtecScheduler::Importance_t>::extract (
          _tao_any,
          ::RtecScheduler::_tc_Importance_t,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::Importance_t _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<RtecScheduler::Importance_t>::insert (
      _tao_any,
      RtecScheduler::_tc_Importance_t,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::Importance_t &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<RtecScheduler::Importance_t>::extract (
        _tao_any,
        RtecScheduler::_tc_Importance_t,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::Info_Type_t _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::RtecScheduler::Info_Type_t>::insert (
        _tao_any,
        ::RtecScheduler::_tc_Info_Type_t,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::Info_Type_t &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::RtecScheduler::Info_Type_t>::extract (
          _tao_any,
          ::RtecScheduler::_tc_Info_Type_t,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::Info_Type_t _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<RtecScheduler::Info_Type_t>::insert (
      _tao_any,
      RtecScheduler::_tc_Info_Type_t,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::Info_Type_t &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<RtecScheduler::Info_Type_t>::extract (
        _tao_any,
        RtecScheduler::_tc_Info_Type_t,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::RT_Info_Enabled_Type_t _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::RtecScheduler::RT_Info_Enabled_Type_t>::insert (
        _tao_any,
        ::RtecScheduler::_tc_RT_Info_Enabled_Type_t,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::RT_Info_Enabled_Type_t &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::RtecScheduler::RT_Info_Enabled_Type_t>::extract (
          _tao_any,
          ::RtecScheduler::_tc_RT_Info_Enabled_Type_t,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::RT_Info_Enabled_Type_t _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<RtecScheduler::RT_Info_Enabled_Type_t>::insert (
      _tao_any,
      RtecScheduler::_tc_RT_Info_Enabled_Type_t,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::RT_Info_Enabled_Type_t &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<RtecScheduler::RT_Info_Enabled_Type_t>::extract (
        _tao_any,
        RtecScheduler::_tc_RT_Info_Enabled_Type_t,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::RT_Info_Enable_State_Pair &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::RtecScheduler::RT_Info_Enable_State_Pair *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::RtecScheduler::RT_Info_Enable_State_Pair>::insert_copy (
          _tao_any,
          ::RtecScheduler::RT_Info_Enable_State_Pair::_tao_any_destructor,
          ::RtecScheduler::_tc_RT_Info_Enable_State_Pair,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      RtecScheduler::RT_Info_Enable_State_Pair *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::RT_Info_Enable_State_Pair>::insert (
        _tao_any,
        ::RtecScheduler::RT_Info_Enable_State_Pair::_tao_any_destructor,
        ::RtecScheduler::_tc_RT_Info_Enable_State_Pair,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::RT_Info_Enable_State_Pair *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::RT_Info_Enable_State_Pair *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::RT_Info_Enable_State_Pair *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::RT_Info_Enable_State_Pair>::extract (
          _tao_any,
          ::RtecScheduler::RT_Info_Enable_State_Pair::_tao_any_destructor,
          ::RtecScheduler::_tc_RT_Info_Enable_State_Pair,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::RT_Info_Enable_State_Pair &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<RtecScheduler::RT_Info_Enable_State_Pair *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<RtecScheduler::RT_Info_Enable_State_Pair>::insert_copy (
        _tao_any,
        RtecScheduler::RT_Info_Enable_State_Pair::_tao_any_destructor,
        RtecScheduler::_tc_RT_Info_Enable_State_Pair,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::RT_Info_Enable_State_Pair *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::RT_Info_Enable_State_Pair>::insert (
      _tao_any,
      RtecScheduler::RT_Info_Enable_State_Pair::_tao_any_destructor,
      RtecScheduler::_tc_RT_Info_Enable_State_Pair,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::RT_Info_Enable_State_Pair *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::RT_Info_Enable_State_Pair *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::RT_Info_Enable_State_Pair *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::RT_Info_Enable_State_Pair>::extract (
        _tao_any,
        RtecScheduler::RT_Info_Enable_State_Pair::_tao_any_destructor,
        RtecScheduler::_tc_RT_Info_Enable_State_Pair,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::RT_Info_Enable_State_Pair_Set &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::RtecScheduler::RT_Info_Enable_State_Pair_Set *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::RtecScheduler::RT_Info_Enable_State_Pair_Set>::insert_copy (
          _tao_any,
          ::RtecScheduler::RT_Info_Enable_State_Pair_Set::_tao_any_destructor,
          ::RtecScheduler::_tc_RT_Info_Enable_State_Pair_Set,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::RT_Info_Enable_State_Pair_Set *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::RT_Info_Enable_State_Pair_Set>::insert (
        _tao_any,
        ::RtecScheduler::RT_Info_Enable_State_Pair_Set::_tao_any_destructor,
        ::RtecScheduler::_tc_RT_Info_Enable_State_Pair_Set,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::RT_Info_Enable_State_Pair_Set *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::RT_Info_Enable_State_Pair_Set *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::RT_Info_Enable_State_Pair_Set *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::RT_Info_Enable_State_Pair_Set>::extract (
          _tao_any,
          ::RtecScheduler::RT_Info_Enable_State_Pair_Set::_tao_any_destructor,
          ::RtecScheduler::_tc_RT_Info_Enable_State_Pair_Set,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::RT_Info_Enable_State_Pair_Set &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<RtecScheduler::RT_Info_Enable_State_Pair_Set *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<RtecScheduler::RT_Info_Enable_State_Pair_Set>::insert_copy (
        _tao_any,
        RtecScheduler::RT_Info_Enable_State_Pair_Set::_tao_any_destructor,
        RtecScheduler::_tc_RT_Info_Enable_State_Pair_Set,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::RT_Info_Enable_State_Pair_Set *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::RT_Info_Enable_State_Pair_Set>::insert (
      _tao_any,
      RtecScheduler::RT_Info_Enable_State_Pair_Set::_tao_any_destructor,
      RtecScheduler::_tc_RT_Info_Enable_State_Pair_Set,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::RT_Info_Enable_State_Pair_Set *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::RT_Info_Enable_State_Pair_Set *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::RT_Info_Enable_State_Pair_Set *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::RT_Info_Enable_State_Pair_Set>::extract (
        _tao_any,
        RtecScheduler::RT_Info_Enable_State_Pair_Set::_tao_any_destructor,
        RtecScheduler::_tc_RT_Info_Enable_State_Pair_Set,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::Dependency_Set &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::RtecScheduler::Dependency_Set *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::RtecScheduler::Dependency_Set>::insert_copy (
          _tao_any,
          ::RtecScheduler::Dependency_Set::_tao_any_destructor,
          ::RtecScheduler::_tc_Dependency_Set,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::Dependency_Set *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::Dependency_Set>::insert (
        _tao_any,
        ::RtecScheduler::Dependency_Set::_tao_any_destructor,
        ::RtecScheduler::_tc_Dependency_Set,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::Dependency_Set *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::Dependency_Set *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::Dependency_Set *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::Dependency_Set>::extract (
          _tao_any,
          ::RtecScheduler::Dependency_Set::_tao_any_destructor,
          ::RtecScheduler::_tc_Dependency_Set,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::Dependency_Set &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<RtecScheduler::Dependency_Set *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<RtecScheduler::Dependency_Set>::insert_copy (
        _tao_any,
        RtecScheduler::Dependency_Set::_tao_any_destructor,
        RtecScheduler::_tc_Dependency_Set,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::Dependency_Set *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::Dependency_Set>::insert (
      _tao_any,
      RtecScheduler::Dependency_Set::_tao_any_destructor,
      RtecScheduler::_tc_Dependency_Set,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::Dependency_Set *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::Dependency_Set *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::Dependency_Set *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::Dependency_Set>::extract (
        _tao_any,
        RtecScheduler::Dependency_Set::_tao_any_destructor,
        RtecScheduler::_tc_Dependency_Set,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::RT_Info &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::RtecScheduler::RT_Info *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::RtecScheduler::RT_Info>::insert_copy (
          _tao_any,
          ::RtecScheduler::RT_Info::_tao_any_destructor,
          ::RtecScheduler::_tc_RT_Info,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      RtecScheduler::RT_Info *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::RT_Info>::insert (
        _tao_any,
        ::RtecScheduler::RT_Info::_tao_any_destructor,
        ::RtecScheduler::_tc_RT_Info,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::RT_Info *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::RT_Info *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::RT_Info *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::RT_Info>::extract (
          _tao_any,
          ::RtecScheduler::RT_Info::_tao_any_destructor,
          ::RtecScheduler::_tc_RT_Info,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::RT_Info &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<RtecScheduler::RT_Info *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<RtecScheduler::RT_Info>::insert_copy (
        _tao_any,
        RtecScheduler::RT_Info::_tao_any_destructor,
        RtecScheduler::_tc_RT_Info,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::RT_Info *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::RT_Info>::insert (
      _tao_any,
      RtecScheduler::RT_Info::_tao_any_destructor,
      RtecScheduler::_tc_RT_Info,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::RT_Info *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::RT_Info *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::RT_Info *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::RT_Info>::extract (
        _tao_any,
        RtecScheduler::RT_Info::_tao_any_destructor,
        RtecScheduler::_tc_RT_Info,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::Dispatching_Type_t _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::RtecScheduler::Dispatching_Type_t>::insert (
        _tao_any,
        ::RtecScheduler::_tc_Dispatching_Type_t,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::Dispatching_Type_t &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::RtecScheduler::Dispatching_Type_t>::extract (
          _tao_any,
          ::RtecScheduler::_tc_Dispatching_Type_t,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::Dispatching_Type_t _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<RtecScheduler::Dispatching_Type_t>::insert (
      _tao_any,
      RtecScheduler::_tc_Dispatching_Type_t,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::Dispatching_Type_t &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<RtecScheduler::Dispatching_Type_t>::extract (
        _tao_any,
        RtecScheduler::_tc_Dispatching_Type_t,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::Config_Info &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::RtecScheduler::Config_Info *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::RtecScheduler::Config_Info>::insert_copy (
          _tao_any,
          ::RtecScheduler::Config_Info::_tao_any_destructor,
          ::RtecScheduler::_tc_Config_Info,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      RtecScheduler::Config_Info *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::Config_Info>::insert (
        _tao_any,
        ::RtecScheduler::Config_Info::_tao_any_destructor,
        ::RtecScheduler::_tc_Config_Info,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::Config_Info *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::Config_Info *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::Config_Info *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::Config_Info>::extract (
          _tao_any,
          ::RtecScheduler::Config_Info::_tao_any_destructor,
          ::RtecScheduler::_tc_Config_Info,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::Config_Info &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<RtecScheduler::Config_Info *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<RtecScheduler::Config_Info>::insert_copy (
        _tao_any,
        RtecScheduler::Config_Info::_tao_any_destructor,
        RtecScheduler::_tc_Config_Info,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::Config_Info *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::Config_Info>::insert (
      _tao_any,
      RtecScheduler::Config_Info::_tao_any_destructor,
      RtecScheduler::_tc_Config_Info,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::Config_Info *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::Config_Info *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::Config_Info *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::Config_Info>::extract (
        _tao_any,
        RtecScheduler::Config_Info::_tao_any_destructor,
        RtecScheduler::_tc_Config_Info,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::Config_Info_Set &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::RtecScheduler::Config_Info_Set *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::RtecScheduler::Config_Info_Set>::insert_copy (
          _tao_any,
          ::RtecScheduler::Config_Info_Set::_tao_any_destructor,
          ::RtecScheduler::_tc_Config_Info_Set,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::Config_Info_Set *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::Config_Info_Set>::insert (
        _tao_any,
        ::RtecScheduler::Config_Info_Set::_tao_any_destructor,
        ::RtecScheduler::_tc_Config_Info_Set,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::Config_Info_Set *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::Config_Info_Set *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::Config_Info_Set *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::Config_Info_Set>::extract (
          _tao_any,
          ::RtecScheduler::Config_Info_Set::_tao_any_destructor,
          ::RtecScheduler::_tc_Config_Info_Set,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::Config_Info_Set &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<RtecScheduler::Config_Info_Set *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<RtecScheduler::Config_Info_Set>::insert_copy (
        _tao_any,
        RtecScheduler::Config_Info_Set::_tao_any_destructor,
        RtecScheduler::_tc_Config_Info_Set,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::Config_Info_Set *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::Config_Info_Set>::insert (
      _tao_any,
      RtecScheduler::Config_Info_Set::_tao_any_destructor,
      RtecScheduler::_tc_Config_Info_Set,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::Config_Info_Set *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::Config_Info_Set *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::Config_Info_Set *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::Config_Info_Set>::extract (
        _tao_any,
        RtecScheduler::Config_Info_Set::_tao_any_destructor,
        RtecScheduler::_tc_Config_Info_Set,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::Anomaly_Severity _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::RtecScheduler::Anomaly_Severity>::insert (
        _tao_any,
        ::RtecScheduler::_tc_Anomaly_Severity,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::Anomaly_Severity &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::RtecScheduler::Anomaly_Severity>::extract (
          _tao_any,
          ::RtecScheduler::_tc_Anomaly_Severity,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::Anomaly_Severity _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<RtecScheduler::Anomaly_Severity>::insert (
      _tao_any,
      RtecScheduler::_tc_Anomaly_Severity,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::Anomaly_Severity &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<RtecScheduler::Anomaly_Severity>::extract (
        _tao_any,
        RtecScheduler::_tc_Anomaly_Severity,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::Scheduling_Anomaly &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::RtecScheduler::Scheduling_Anomaly *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::RtecScheduler::Scheduling_Anomaly>::insert_copy (
          _tao_any,
          ::RtecScheduler::Scheduling_Anomaly::_tao_any_destructor,
          ::RtecScheduler::_tc_Scheduling_Anomaly,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      RtecScheduler::Scheduling_Anomaly *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::Scheduling_Anomaly>::insert (
        _tao_any,
        ::RtecScheduler::Scheduling_Anomaly::_tao_any_destructor,
        ::RtecScheduler::_tc_Scheduling_Anomaly,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::Scheduling_Anomaly *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::Scheduling_Anomaly *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::Scheduling_Anomaly *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::Scheduling_Anomaly>::extract (
          _tao_any,
          ::RtecScheduler::Scheduling_Anomaly::_tao_any_destructor,
          ::RtecScheduler::_tc_Scheduling_Anomaly,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::Scheduling_Anomaly &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<RtecScheduler::Scheduling_Anomaly *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<RtecScheduler::Scheduling_Anomaly>::insert_copy (
        _tao_any,
        RtecScheduler::Scheduling_Anomaly::_tao_any_destructor,
        RtecScheduler::_tc_Scheduling_Anomaly,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::Scheduling_Anomaly *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::Scheduling_Anomaly>::insert (
      _tao_any,
      RtecScheduler::Scheduling_Anomaly::_tao_any_destructor,
      RtecScheduler::_tc_Scheduling_Anomaly,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::Scheduling_Anomaly *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::Scheduling_Anomaly *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::Scheduling_Anomaly *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::Scheduling_Anomaly>::extract (
        _tao_any,
        RtecScheduler::Scheduling_Anomaly::_tao_any_destructor,
        RtecScheduler::_tc_Scheduling_Anomaly,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::Scheduling_Anomaly_Set &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::RtecScheduler::Scheduling_Anomaly_Set *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::RtecScheduler::Scheduling_Anomaly_Set>::insert_copy (
          _tao_any,
          ::RtecScheduler::Scheduling_Anomaly_Set::_tao_any_destructor,
          ::RtecScheduler::_tc_Scheduling_Anomaly_Set,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::Scheduling_Anomaly_Set *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::Scheduling_Anomaly_Set>::insert (
        _tao_any,
        ::RtecScheduler::Scheduling_Anomaly_Set::_tao_any_destructor,
        ::RtecScheduler::_tc_Scheduling_Anomaly_Set,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::Scheduling_Anomaly_Set *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::Scheduling_Anomaly_Set *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::Scheduling_Anomaly_Set *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::Scheduling_Anomaly_Set>::extract (
          _tao_any,
          ::RtecScheduler::Scheduling_Anomaly_Set::_tao_any_destructor,
          ::RtecScheduler::_tc_Scheduling_Anomaly_Set,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::Scheduling_Anomaly_Set &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<RtecScheduler::Scheduling_Anomaly_Set *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<RtecScheduler::Scheduling_Anomaly_Set>::insert_copy (
        _tao_any,
        RtecScheduler::Scheduling_Anomaly_Set::_tao_any_destructor,
        RtecScheduler::_tc_Scheduling_Anomaly_Set,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::Scheduling_Anomaly_Set *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::Scheduling_Anomaly_Set>::insert (
      _tao_any,
      RtecScheduler::Scheduling_Anomaly_Set::_tao_any_destructor,
      RtecScheduler::_tc_Scheduling_Anomaly_Set,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::Scheduling_Anomaly_Set *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::Scheduling_Anomaly_Set *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::Scheduling_Anomaly_Set *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::Scheduling_Anomaly_Set>::extract (
        _tao_any,
        RtecScheduler::Scheduling_Anomaly_Set::_tao_any_destructor,
        RtecScheduler::_tc_Scheduling_Anomaly_Set,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<RtecScheduler::CYCLIC_DEPENDENCIES>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::CYCLIC_DEPENDENCIES &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::CYCLIC_DEPENDENCIES>::insert_copy (
        _tao_any,
        ::RtecScheduler::CYCLIC_DEPENDENCIES::_tao_any_destructor,
        ::RtecScheduler::_tc_CYCLIC_DEPENDENCIES,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::CYCLIC_DEPENDENCIES *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::CYCLIC_DEPENDENCIES>::insert (
        _tao_any,
        ::RtecScheduler::CYCLIC_DEPENDENCIES::_tao_any_destructor,
        ::RtecScheduler::_tc_CYCLIC_DEPENDENCIES,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::CYCLIC_DEPENDENCIES *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::CYCLIC_DEPENDENCIES *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::CYCLIC_DEPENDENCIES *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::CYCLIC_DEPENDENCIES>::extract (
          _tao_any,
          ::RtecScheduler::CYCLIC_DEPENDENCIES::_tao_any_destructor,
          ::RtecScheduler::_tc_CYCLIC_DEPENDENCIES,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::CYCLIC_DEPENDENCIES &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::CYCLIC_DEPENDENCIES>::insert_copy (
      _tao_any,
      RtecScheduler::CYCLIC_DEPENDENCIES::_tao_any_destructor,
      RtecScheduler::_tc_CYCLIC_DEPENDENCIES,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::CYCLIC_DEPENDENCIES *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::CYCLIC_DEPENDENCIES>::insert (
      _tao_any,
      RtecScheduler::CYCLIC_DEPENDENCIES::_tao_any_destructor,
      RtecScheduler::_tc_CYCLIC_DEPENDENCIES,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::CYCLIC_DEPENDENCIES *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::CYCLIC_DEPENDENCIES *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::CYCLIC_DEPENDENCIES *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::CYCLIC_DEPENDENCIES>::extract (
        _tao_any,
        RtecScheduler::CYCLIC_DEPENDENCIES::_tao_any_destructor,
        RtecScheduler::_tc_CYCLIC_DEPENDENCIES,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES>::insert_copy (
        _tao_any,
        ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_tao_any_destructor,
        ::RtecScheduler::_tc_UNRESOLVED_LOCAL_DEPENDENCIES,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES>::insert (
        _tao_any,
        ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_tao_any_destructor,
        ::RtecScheduler::_tc_UNRESOLVED_LOCAL_DEPENDENCIES,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES>::extract (
          _tao_any,
          ::RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_tao_any_destructor,
          ::RtecScheduler::_tc_UNRESOLVED_LOCAL_DEPENDENCIES,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES>::insert_copy (
      _tao_any,
      RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_tao_any_destructor,
      RtecScheduler::_tc_UNRESOLVED_LOCAL_DEPENDENCIES,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES>::insert (
      _tao_any,
      RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_tao_any_destructor,
      RtecScheduler::_tc_UNRESOLVED_LOCAL_DEPENDENCIES,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES>::extract (
        _tao_any,
        RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES::_tao_any_destructor,
        RtecScheduler::_tc_UNRESOLVED_LOCAL_DEPENDENCIES,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<RtecScheduler::THREAD_SPECIFICATION>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::THREAD_SPECIFICATION &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::THREAD_SPECIFICATION>::insert_copy (
        _tao_any,
        ::RtecScheduler::THREAD_SPECIFICATION::_tao_any_destructor,
        ::RtecScheduler::_tc_THREAD_SPECIFICATION,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::THREAD_SPECIFICATION *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::THREAD_SPECIFICATION>::insert (
        _tao_any,
        ::RtecScheduler::THREAD_SPECIFICATION::_tao_any_destructor,
        ::RtecScheduler::_tc_THREAD_SPECIFICATION,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::THREAD_SPECIFICATION *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::THREAD_SPECIFICATION *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::THREAD_SPECIFICATION *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::THREAD_SPECIFICATION>::extract (
          _tao_any,
          ::RtecScheduler::THREAD_SPECIFICATION::_tao_any_destructor,
          ::RtecScheduler::_tc_THREAD_SPECIFICATION,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::THREAD_SPECIFICATION &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::THREAD_SPECIFICATION>::insert_copy (
      _tao_any,
      RtecScheduler::THREAD_SPECIFICATION::_tao_any_destructor,
      RtecScheduler::_tc_THREAD_SPECIFICATION,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::THREAD_SPECIFICATION *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::THREAD_SPECIFICATION>::insert (
      _tao_any,
      RtecScheduler::THREAD_SPECIFICATION::_tao_any_destructor,
      RtecScheduler::_tc_THREAD_SPECIFICATION,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::THREAD_SPECIFICATION *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::THREAD_SPECIFICATION *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::THREAD_SPECIFICATION *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::THREAD_SPECIFICATION>::extract (
        _tao_any,
        RtecScheduler::THREAD_SPECIFICATION::_tao_any_destructor,
        RtecScheduler::_tc_THREAD_SPECIFICATION,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<RtecScheduler::DUPLICATE_NAME>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::DUPLICATE_NAME &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::DUPLICATE_NAME>::insert_copy (
        _tao_any,
        ::RtecScheduler::DUPLICATE_NAME::_tao_any_destructor,
        ::RtecScheduler::_tc_DUPLICATE_NAME,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::DUPLICATE_NAME *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::DUPLICATE_NAME>::insert (
        _tao_any,
        ::RtecScheduler::DUPLICATE_NAME::_tao_any_destructor,
        ::RtecScheduler::_tc_DUPLICATE_NAME,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::DUPLICATE_NAME *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::DUPLICATE_NAME *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::DUPLICATE_NAME *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::DUPLICATE_NAME>::extract (
          _tao_any,
          ::RtecScheduler::DUPLICATE_NAME::_tao_any_destructor,
          ::RtecScheduler::_tc_DUPLICATE_NAME,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::DUPLICATE_NAME &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::DUPLICATE_NAME>::insert_copy (
      _tao_any,
      RtecScheduler::DUPLICATE_NAME::_tao_any_destructor,
      RtecScheduler::_tc_DUPLICATE_NAME,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::DUPLICATE_NAME *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::DUPLICATE_NAME>::insert (
      _tao_any,
      RtecScheduler::DUPLICATE_NAME::_tao_any_destructor,
      RtecScheduler::_tc_DUPLICATE_NAME,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::DUPLICATE_NAME *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::DUPLICATE_NAME *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::DUPLICATE_NAME *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::DUPLICATE_NAME>::extract (
        _tao_any,
        RtecScheduler::DUPLICATE_NAME::_tao_any_destructor,
        RtecScheduler::_tc_DUPLICATE_NAME,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<RtecScheduler::UNKNOWN_TASK>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::UNKNOWN_TASK &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::UNKNOWN_TASK>::insert_copy (
        _tao_any,
        ::RtecScheduler::UNKNOWN_TASK::_tao_any_destructor,
        ::RtecScheduler::_tc_UNKNOWN_TASK,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::UNKNOWN_TASK *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::UNKNOWN_TASK>::insert (
        _tao_any,
        ::RtecScheduler::UNKNOWN_TASK::_tao_any_destructor,
        ::RtecScheduler::_tc_UNKNOWN_TASK,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::UNKNOWN_TASK *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::UNKNOWN_TASK *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::UNKNOWN_TASK *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::UNKNOWN_TASK>::extract (
          _tao_any,
          ::RtecScheduler::UNKNOWN_TASK::_tao_any_destructor,
          ::RtecScheduler::_tc_UNKNOWN_TASK,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::UNKNOWN_TASK &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::UNKNOWN_TASK>::insert_copy (
      _tao_any,
      RtecScheduler::UNKNOWN_TASK::_tao_any_destructor,
      RtecScheduler::_tc_UNKNOWN_TASK,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::UNKNOWN_TASK *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::UNKNOWN_TASK>::insert (
      _tao_any,
      RtecScheduler::UNKNOWN_TASK::_tao_any_destructor,
      RtecScheduler::_tc_UNKNOWN_TASK,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::UNKNOWN_TASK *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::UNKNOWN_TASK *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::UNKNOWN_TASK *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::UNKNOWN_TASK>::extract (
        _tao_any,
        RtecScheduler::UNKNOWN_TASK::_tao_any_destructor,
        RtecScheduler::_tc_UNKNOWN_TASK,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<RtecScheduler::NOT_SCHEDULED>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::NOT_SCHEDULED &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::NOT_SCHEDULED>::insert_copy (
        _tao_any,
        ::RtecScheduler::NOT_SCHEDULED::_tao_any_destructor,
        ::RtecScheduler::_tc_NOT_SCHEDULED,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::NOT_SCHEDULED *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::NOT_SCHEDULED>::insert (
        _tao_any,
        ::RtecScheduler::NOT_SCHEDULED::_tao_any_destructor,
        ::RtecScheduler::_tc_NOT_SCHEDULED,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::NOT_SCHEDULED *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::NOT_SCHEDULED *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::NOT_SCHEDULED *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::NOT_SCHEDULED>::extract (
          _tao_any,
          ::RtecScheduler::NOT_SCHEDULED::_tao_any_destructor,
          ::RtecScheduler::_tc_NOT_SCHEDULED,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::NOT_SCHEDULED &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::NOT_SCHEDULED>::insert_copy (
      _tao_any,
      RtecScheduler::NOT_SCHEDULED::_tao_any_destructor,
      RtecScheduler::_tc_NOT_SCHEDULED,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::NOT_SCHEDULED *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::NOT_SCHEDULED>::insert (
      _tao_any,
      RtecScheduler::NOT_SCHEDULED::_tao_any_destructor,
      RtecScheduler::_tc_NOT_SCHEDULED,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::NOT_SCHEDULED *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::NOT_SCHEDULED *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::NOT_SCHEDULED *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::NOT_SCHEDULED>::extract (
        _tao_any,
        RtecScheduler::NOT_SCHEDULED::_tao_any_destructor,
        RtecScheduler::_tc_NOT_SCHEDULED,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<RtecScheduler::UTILIZATION_BOUND_EXCEEDED>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED>::insert_copy (
        _tao_any,
        ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_tao_any_destructor,
        ::RtecScheduler::_tc_UTILIZATION_BOUND_EXCEEDED,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED>::insert (
        _tao_any,
        ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_tao_any_destructor,
        ::RtecScheduler::_tc_UTILIZATION_BOUND_EXCEEDED,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED>::extract (
          _tao_any,
          ::RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_tao_any_destructor,
          ::RtecScheduler::_tc_UTILIZATION_BOUND_EXCEEDED,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::UTILIZATION_BOUND_EXCEEDED &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::UTILIZATION_BOUND_EXCEEDED>::insert_copy (
      _tao_any,
      RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_tao_any_destructor,
      RtecScheduler::_tc_UTILIZATION_BOUND_EXCEEDED,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::UTILIZATION_BOUND_EXCEEDED *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::UTILIZATION_BOUND_EXCEEDED>::insert (
      _tao_any,
      RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_tao_any_destructor,
      RtecScheduler::_tc_UTILIZATION_BOUND_EXCEEDED,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::UTILIZATION_BOUND_EXCEEDED *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::UTILIZATION_BOUND_EXCEEDED *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::UTILIZATION_BOUND_EXCEEDED *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::UTILIZATION_BOUND_EXCEEDED>::extract (
        _tao_any,
        RtecScheduler::UTILIZATION_BOUND_EXCEEDED::_tao_any_destructor,
        RtecScheduler::_tc_UTILIZATION_BOUND_EXCEEDED,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS>::insert_copy (
        _tao_any,
        ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_tao_any_destructor,
        ::RtecScheduler::_tc_INSUFFICIENT_THREAD_PRIORITY_LEVELS,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS>::insert (
        _tao_any,
        ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_tao_any_destructor,
        ::RtecScheduler::_tc_INSUFFICIENT_THREAD_PRIORITY_LEVELS,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS>::extract (
          _tao_any,
          ::RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_tao_any_destructor,
          ::RtecScheduler::_tc_INSUFFICIENT_THREAD_PRIORITY_LEVELS,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS>::insert_copy (
      _tao_any,
      RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_tao_any_destructor,
      RtecScheduler::_tc_INSUFFICIENT_THREAD_PRIORITY_LEVELS,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS>::insert (
      _tao_any,
      RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_tao_any_destructor,
      RtecScheduler::_tc_INSUFFICIENT_THREAD_PRIORITY_LEVELS,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS>::extract (
        _tao_any,
        RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS::_tao_any_destructor,
        RtecScheduler::_tc_INSUFFICIENT_THREAD_PRIORITY_LEVELS,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<RtecScheduler::TASK_COUNT_MISMATCH>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::TASK_COUNT_MISMATCH &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::TASK_COUNT_MISMATCH>::insert_copy (
        _tao_any,
        ::RtecScheduler::TASK_COUNT_MISMATCH::_tao_any_destructor,
        ::RtecScheduler::_tc_TASK_COUNT_MISMATCH,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::TASK_COUNT_MISMATCH *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::TASK_COUNT_MISMATCH>::insert (
        _tao_any,
        ::RtecScheduler::TASK_COUNT_MISMATCH::_tao_any_destructor,
        ::RtecScheduler::_tc_TASK_COUNT_MISMATCH,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::TASK_COUNT_MISMATCH *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::TASK_COUNT_MISMATCH *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::TASK_COUNT_MISMATCH *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::TASK_COUNT_MISMATCH>::extract (
          _tao_any,
          ::RtecScheduler::TASK_COUNT_MISMATCH::_tao_any_destructor,
          ::RtecScheduler::_tc_TASK_COUNT_MISMATCH,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::TASK_COUNT_MISMATCH &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::TASK_COUNT_MISMATCH>::insert_copy (
      _tao_any,
      RtecScheduler::TASK_COUNT_MISMATCH::_tao_any_destructor,
      RtecScheduler::_tc_TASK_COUNT_MISMATCH,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::TASK_COUNT_MISMATCH *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::TASK_COUNT_MISMATCH>::insert (
      _tao_any,
      RtecScheduler::TASK_COUNT_MISMATCH::_tao_any_destructor,
      RtecScheduler::_tc_TASK_COUNT_MISMATCH,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::TASK_COUNT_MISMATCH *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::TASK_COUNT_MISMATCH *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::TASK_COUNT_MISMATCH *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::TASK_COUNT_MISMATCH>::extract (
        _tao_any,
        RtecScheduler::TASK_COUNT_MISMATCH::_tao_any_destructor,
        RtecScheduler::_tc_TASK_COUNT_MISMATCH,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<RtecScheduler::UNKNOWN_PRIORITY_LEVEL>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL>::insert_copy (
        _tao_any,
        ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_tao_any_destructor,
        ::RtecScheduler::_tc_UNKNOWN_PRIORITY_LEVEL,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL>::insert (
        _tao_any,
        ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_tao_any_destructor,
        ::RtecScheduler::_tc_UNKNOWN_PRIORITY_LEVEL,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL>::extract (
          _tao_any,
          ::RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_tao_any_destructor,
          ::RtecScheduler::_tc_UNKNOWN_PRIORITY_LEVEL,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::UNKNOWN_PRIORITY_LEVEL &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::UNKNOWN_PRIORITY_LEVEL>::insert_copy (
      _tao_any,
      RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_tao_any_destructor,
      RtecScheduler::_tc_UNKNOWN_PRIORITY_LEVEL,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::UNKNOWN_PRIORITY_LEVEL *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::UNKNOWN_PRIORITY_LEVEL>::insert (
      _tao_any,
      RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_tao_any_destructor,
      RtecScheduler::_tc_UNKNOWN_PRIORITY_LEVEL,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::UNKNOWN_PRIORITY_LEVEL *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::UNKNOWN_PRIORITY_LEVEL *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::UNKNOWN_PRIORITY_LEVEL *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::UNKNOWN_PRIORITY_LEVEL>::extract (
        _tao_any,
        RtecScheduler::UNKNOWN_PRIORITY_LEVEL::_tao_any_destructor,
        RtecScheduler::_tc_UNKNOWN_PRIORITY_LEVEL,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<RtecScheduler::SYNCHRONIZATION_FAILURE>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::SYNCHRONIZATION_FAILURE &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::SYNCHRONIZATION_FAILURE>::insert_copy (
        _tao_any,
        ::RtecScheduler::SYNCHRONIZATION_FAILURE::_tao_any_destructor,
        ::RtecScheduler::_tc_SYNCHRONIZATION_FAILURE,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::SYNCHRONIZATION_FAILURE *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::SYNCHRONIZATION_FAILURE>::insert (
        _tao_any,
        ::RtecScheduler::SYNCHRONIZATION_FAILURE::_tao_any_destructor,
        ::RtecScheduler::_tc_SYNCHRONIZATION_FAILURE,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::SYNCHRONIZATION_FAILURE *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::SYNCHRONIZATION_FAILURE *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::SYNCHRONIZATION_FAILURE *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::SYNCHRONIZATION_FAILURE>::extract (
          _tao_any,
          ::RtecScheduler::SYNCHRONIZATION_FAILURE::_tao_any_destructor,
          ::RtecScheduler::_tc_SYNCHRONIZATION_FAILURE,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::SYNCHRONIZATION_FAILURE &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::SYNCHRONIZATION_FAILURE>::insert_copy (
      _tao_any,
      RtecScheduler::SYNCHRONIZATION_FAILURE::_tao_any_destructor,
      RtecScheduler::_tc_SYNCHRONIZATION_FAILURE,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::SYNCHRONIZATION_FAILURE *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::SYNCHRONIZATION_FAILURE>::insert (
      _tao_any,
      RtecScheduler::SYNCHRONIZATION_FAILURE::_tao_any_destructor,
      RtecScheduler::_tc_SYNCHRONIZATION_FAILURE,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::SYNCHRONIZATION_FAILURE *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::SYNCHRONIZATION_FAILURE *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::SYNCHRONIZATION_FAILURE *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::SYNCHRONIZATION_FAILURE>::extract (
        _tao_any,
        RtecScheduler::SYNCHRONIZATION_FAILURE::_tao_any_destructor,
        RtecScheduler::_tc_SYNCHRONIZATION_FAILURE,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<RtecScheduler::INTERNAL>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::INTERNAL &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::INTERNAL>::insert_copy (
        _tao_any,
        ::RtecScheduler::INTERNAL::_tao_any_destructor,
        ::RtecScheduler::_tc_INTERNAL,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::INTERNAL *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::INTERNAL>::insert (
        _tao_any,
        ::RtecScheduler::INTERNAL::_tao_any_destructor,
        ::RtecScheduler::_tc_INTERNAL,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::INTERNAL *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::INTERNAL *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::INTERNAL *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::INTERNAL>::extract (
          _tao_any,
          ::RtecScheduler::INTERNAL::_tao_any_destructor,
          ::RtecScheduler::_tc_INTERNAL,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::INTERNAL &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::INTERNAL>::insert_copy (
      _tao_any,
      RtecScheduler::INTERNAL::_tao_any_destructor,
      RtecScheduler::_tc_INTERNAL,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::INTERNAL *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::INTERNAL>::insert (
      _tao_any,
      RtecScheduler::INTERNAL::_tao_any_destructor,
      RtecScheduler::_tc_INTERNAL,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::INTERNAL *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::INTERNAL *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::INTERNAL *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::INTERNAL>::extract (
        _tao_any,
        RtecScheduler::INTERNAL::_tao_any_destructor,
        RtecScheduler::_tc_INTERNAL,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::RtecScheduler::RT_Info_Set &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::RtecScheduler::RT_Info_Set *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::RtecScheduler::RT_Info_Set>::insert_copy (
          _tao_any,
          ::RtecScheduler::RT_Info_Set::_tao_any_destructor,
          ::RtecScheduler::_tc_RT_Info_Set,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::RtecScheduler::RT_Info_Set *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::RtecScheduler::RT_Info_Set>::insert (
        _tao_any,
        ::RtecScheduler::RT_Info_Set::_tao_any_destructor,
        ::RtecScheduler::_tc_RT_Info_Set,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::RtecScheduler::RT_Info_Set *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::RtecScheduler::RT_Info_Set *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::RtecScheduler::RT_Info_Set *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::RtecScheduler::RT_Info_Set>::extract (
          _tao_any,
          ::RtecScheduler::RT_Info_Set::_tao_any_destructor,
          ::RtecScheduler::_tc_RT_Info_Set,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const RtecScheduler::RT_Info_Set &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<RtecScheduler::RT_Info_Set *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<RtecScheduler::RT_Info_Set>::insert_copy (
        _tao_any,
        RtecScheduler::RT_Info_Set::_tao_any_destructor,
        RtecScheduler::_tc_RT_Info_Set,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::RT_Info_Set *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<RtecScheduler::RT_Info_Set>::insert (
      _tao_any,
      RtecScheduler::RT_Info_Set::_tao_any_destructor,
      RtecScheduler::_tc_RT_Info_Set,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::RT_Info_Set *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const RtecScheduler::RT_Info_Set *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const RtecScheduler::RT_Info_Set *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<RtecScheduler::RT_Info_Set>::extract (
        _tao_any,
        RtecScheduler::RT_Info_Set::_tao_any_destructor,
        RtecScheduler::_tc_RT_Info_Set,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<RtecScheduler::Scheduler>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace RtecScheduler
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Scheduler_ptr _tao_elem)
  {
    Scheduler_ptr _tao_objptr =
      Scheduler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Scheduler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Scheduler>::insert (
        _tao_any,
        Scheduler::_tao_any_destructor,
        _tc_Scheduler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Scheduler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Scheduler>::extract (
          _tao_any,
          Scheduler::_tao_any_destructor,
          _tc_Scheduler,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::Scheduler_ptr _tao_elem)
{
  RtecScheduler::Scheduler_ptr _tao_objptr =
    RtecScheduler::Scheduler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    RtecScheduler::Scheduler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<RtecScheduler::Scheduler>::insert (
      _tao_any,
      RtecScheduler::Scheduler::_tao_any_destructor,
      RtecScheduler::_tc_Scheduler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    RtecScheduler::Scheduler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<RtecScheduler::Scheduler>::extract (
        _tao_any,
        RtecScheduler::Scheduler::_tao_any_destructor,
        RtecScheduler::_tc_Scheduler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_RtecScheduler_Period_Set_CPP_
#define _TAO_CDR_OP_RtecScheduler_Period_Set_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::Period_Set &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RtecScheduler::Period_Set &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_RtecScheduler_Period_Set_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, RtecScheduler::Criticality_t _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, RtecScheduler::Criticality_t & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<RtecScheduler::Criticality_t> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, RtecScheduler::Importance_t _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, RtecScheduler::Importance_t & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<RtecScheduler::Importance_t> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, RtecScheduler::Info_Type_t _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, RtecScheduler::Info_Type_t & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<RtecScheduler::Info_Type_t> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, RtecScheduler::RT_Info_Enabled_Type_t _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, RtecScheduler::RT_Info_Enabled_Type_t & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<RtecScheduler::RT_Info_Enabled_Type_t> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::RT_Info_Enable_State_Pair &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.handle) &&
    (strm << _tao_aggregate.enabled);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RtecScheduler::RT_Info_Enable_State_Pair &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.handle) &&
    (strm >> _tao_aggregate.enabled);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_RtecScheduler_RT_Info_Enable_State_Pair_Set_CPP_
#define _TAO_CDR_OP_RtecScheduler_RT_Info_Enable_State_Pair_Set_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::RT_Info_Enable_State_Pair_Set &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RtecScheduler::RT_Info_Enable_State_Pair_Set &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_RtecScheduler_RT_Info_Enable_State_Pair_Set_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_RtecScheduler_Dependency_Set_CPP_
#define _TAO_CDR_OP_RtecScheduler_Dependency_Set_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::Dependency_Set &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RtecScheduler::Dependency_Set &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_RtecScheduler_Dependency_Set_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::RT_Info &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.entry_point.in ()) &&
    (strm << _tao_aggregate.handle) &&
    (strm << _tao_aggregate.worst_case_execution_time) &&
    (strm << _tao_aggregate.typical_execution_time) &&
    (strm << _tao_aggregate.cached_execution_time) &&
    (strm << _tao_aggregate.period) &&
    (strm << _tao_aggregate.criticality) &&
    (strm << _tao_aggregate.importance) &&
    (strm << _tao_aggregate.quantum) &&
    (strm << _tao_aggregate.threads) &&
    (strm << _tao_aggregate.dependencies) &&
    (strm << _tao_aggregate.priority) &&
    (strm << _tao_aggregate.preemption_subpriority) &&
    (strm << _tao_aggregate.preemption_priority) &&
    (strm << _tao_aggregate.info_type) &&
    (strm << _tao_aggregate.enabled) &&
    (strm << _tao_aggregate.volatile_token);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RtecScheduler::RT_Info &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.entry_point.out ()) &&
    (strm >> _tao_aggregate.handle) &&
    (strm >> _tao_aggregate.worst_case_execution_time) &&
    (strm >> _tao_aggregate.typical_execution_time) &&
    (strm >> _tao_aggregate.cached_execution_time) &&
    (strm >> _tao_aggregate.period) &&
    (strm >> _tao_aggregate.criticality) &&
    (strm >> _tao_aggregate.importance) &&
    (strm >> _tao_aggregate.quantum) &&
    (strm >> _tao_aggregate.threads) &&
    (strm >> _tao_aggregate.dependencies) &&
    (strm >> _tao_aggregate.priority) &&
    (strm >> _tao_aggregate.preemption_subpriority) &&
    (strm >> _tao_aggregate.preemption_priority) &&
    (strm >> _tao_aggregate.info_type) &&
    (strm >> _tao_aggregate.enabled) &&
    (strm >> _tao_aggregate.volatile_token);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, RtecScheduler::Dispatching_Type_t _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, RtecScheduler::Dispatching_Type_t & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<RtecScheduler::Dispatching_Type_t> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::Config_Info &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.preemption_priority) &&
    (strm << _tao_aggregate.thread_priority) &&
    (strm << _tao_aggregate.dispatching_type) &&
    (strm << _tao_aggregate.timer_periods);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RtecScheduler::Config_Info &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.preemption_priority) &&
    (strm >> _tao_aggregate.thread_priority) &&
    (strm >> _tao_aggregate.dispatching_type) &&
    (strm >> _tao_aggregate.timer_periods);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_RtecScheduler_Config_Info_Set_CPP_
#define _TAO_CDR_OP_RtecScheduler_Config_Info_Set_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::Config_Info_Set &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RtecScheduler::Config_Info_Set &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_RtecScheduler_Config_Info_Set_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, RtecScheduler::Anomaly_Severity _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, RtecScheduler::Anomaly_Severity & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<RtecScheduler::Anomaly_Severity> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::Scheduling_Anomaly &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.description.in ()) &&
    (strm << _tao_aggregate.severity);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RtecScheduler::Scheduling_Anomaly &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.description.out ()) &&
    (strm >> _tao_aggregate.severity);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_RtecScheduler_Scheduling_Anomaly_Set_CPP_
#define _TAO_CDR_OP_RtecScheduler_Scheduling_Anomaly_Set_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::Scheduling_Anomaly_Set &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RtecScheduler::Scheduling_Anomaly_Set &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_RtecScheduler_Scheduling_Anomaly_Set_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::CYCLIC_DEPENDENCIES &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    RtecScheduler::CYCLIC_DEPENDENCIES&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    RtecScheduler::UNRESOLVED_LOCAL_DEPENDENCIES&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::THREAD_SPECIFICATION &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    RtecScheduler::THREAD_SPECIFICATION&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::DUPLICATE_NAME &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    RtecScheduler::DUPLICATE_NAME&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::UNKNOWN_TASK &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    RtecScheduler::UNKNOWN_TASK&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::NOT_SCHEDULED &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    RtecScheduler::NOT_SCHEDULED&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::UTILIZATION_BOUND_EXCEEDED &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    RtecScheduler::UTILIZATION_BOUND_EXCEEDED&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    RtecScheduler::INSUFFICIENT_THREAD_PRIORITY_LEVELS&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::TASK_COUNT_MISMATCH &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    RtecScheduler::TASK_COUNT_MISMATCH&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::UNKNOWN_PRIORITY_LEVEL &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    RtecScheduler::UNKNOWN_PRIORITY_LEVEL&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::SYNCHRONIZATION_FAILURE &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    RtecScheduler::SYNCHRONIZATION_FAILURE&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::INTERNAL &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    RtecScheduler::INTERNAL&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_RtecScheduler_RT_Info_Set_CPP_
#define _TAO_CDR_OP_RtecScheduler_RT_Info_Set_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::RT_Info_Set &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RtecScheduler::RT_Info_Set &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_RtecScheduler_RT_Info_Set_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RtecScheduler::Scheduler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RtecScheduler::Scheduler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::RtecScheduler::Scheduler RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        RtecScheduler__TAO_Scheduler_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL





TAO_END_VERSIONED_NAMESPACE_DECL


