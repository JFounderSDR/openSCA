// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "CosLoadBalancingC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/Value_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Value_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Messaging/Asynch_Invocation_Adapter.h"
#include "tao/Messaging/ExceptionHolder_i.h"
#include "tao/Valuetype/ValueFactory.h"
#include "tao/Object_T.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "CosLoadBalancingC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosLoadBalancing_Location (
    ::CORBA::tk_alias,
    "IDL:tao.lb/CosLoadBalancing/Location:1.0",
    "Location",
    &PortableGroup::_tc_Location);
  

namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_Location =
    &_tao_tc_CosLoadBalancing_Location;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosLoadBalancing_Properties (
    ::CORBA::tk_alias,
    "IDL:tao.lb/CosLoadBalancing/Properties:1.0",
    "Properties",
    &PortableGroup::_tc_Properties);
  

namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_Properties =
    &_tao_tc_CosLoadBalancing_Properties;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosLoadBalancing_LoadId (
    ::CORBA::tk_alias,
    "IDL:tao.lb/CosLoadBalancing/LoadId:1.0",
    "LoadId",
    &CORBA::_tc_ulong);
  

namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_LoadId =
    &_tao_tc_CosLoadBalancing_LoadId;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosLoadBalancing_Load[] =
      {
        { "id", &CosLoadBalancing::_tc_LoadId },
        { "value", &CORBA::_tc_float }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosLoadBalancing_Load (
  ::CORBA::tk_struct,
  "IDL:tao.lb/CosLoadBalancing/Load:1.0",
  "Load",
  _tao_fields_CosLoadBalancing_Load,
  2);


namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_Load =
    &_tao_tc_CosLoadBalancing_Load;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosLoadBalancing::Load::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Load *_tao_tmp_pointer =
    static_cast<Load *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSLOADBALANCING_LOADLIST_CS_)
#define _COSLOADBALANCING_LOADLIST_CS_

CosLoadBalancing::LoadList::LoadList (void)
{}

CosLoadBalancing::LoadList::LoadList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Load
      > (max)
{}

CosLoadBalancing::LoadList::LoadList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CosLoadBalancing::Load * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Load
      >
    (max, length, buffer, release)
{}

CosLoadBalancing::LoadList::LoadList (
    const LoadList &seq)
  : ::TAO::unbounded_value_sequence<
        Load
      > (seq)
{}

CosLoadBalancing::LoadList::~LoadList (void)
{}

void CosLoadBalancing::LoadList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  LoadList * _tao_tmp_pointer =
    static_cast<LoadList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosLoadBalancing_LoadList_GUARD
#define _TAO_TYPECODE_CosLoadBalancing_LoadList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosLoadBalancing_LoadList_0 (
          ::CORBA::tk_sequence,
          &CosLoadBalancing::_tc_Load,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosLoadBalancing_LoadList_0 =
        &CosLoadBalancing_LoadList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosLoadBalancing_LoadList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosLoadBalancing_LoadList (
    ::CORBA::tk_alias,
    "IDL:tao.lb/CosLoadBalancing/LoadList:1.0",
    "LoadList",
    &TAO::TypeCode::tc_CosLoadBalancing_LoadList_0);
  

namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_LoadList =
    &_tao_tc_CosLoadBalancing_LoadList;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosLoadBalancing::MonitorAlreadyPresent::MonitorAlreadyPresent (void)
  : ::CORBA::UserException (
        "IDL:tao.lb/CosLoadBalancing/MonitorAlreadyPresent:1.0",
        "MonitorAlreadyPresent"
      )
{
}

CosLoadBalancing::MonitorAlreadyPresent::~MonitorAlreadyPresent (void)
{
}

CosLoadBalancing::MonitorAlreadyPresent::MonitorAlreadyPresent (const ::CosLoadBalancing::MonitorAlreadyPresent &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CosLoadBalancing::MonitorAlreadyPresent&
CosLoadBalancing::MonitorAlreadyPresent::operator= (const ::CosLoadBalancing::MonitorAlreadyPresent &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CosLoadBalancing::MonitorAlreadyPresent::_tao_any_destructor (void *_tao_void_pointer)
{
  MonitorAlreadyPresent *_tao_tmp_pointer =
    static_cast<MonitorAlreadyPresent *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosLoadBalancing::MonitorAlreadyPresent *
CosLoadBalancing::MonitorAlreadyPresent::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<MonitorAlreadyPresent *> (_tao_excp);
}

const CosLoadBalancing::MonitorAlreadyPresent *
CosLoadBalancing::MonitorAlreadyPresent::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const MonitorAlreadyPresent *> (_tao_excp);
}

::CORBA::Exception *CosLoadBalancing::MonitorAlreadyPresent::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosLoadBalancing::MonitorAlreadyPresent, 0);
  return retval;
}

::CORBA::Exception *
CosLoadBalancing::MonitorAlreadyPresent::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosLoadBalancing::MonitorAlreadyPresent (*this),
      0
    );
  return result;
}

void CosLoadBalancing::MonitorAlreadyPresent::_raise (void) const
{
  throw *this;
}

void CosLoadBalancing::MonitorAlreadyPresent::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosLoadBalancing::MonitorAlreadyPresent::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosLoadBalancing::MonitorAlreadyPresent::_tao_type (void) const
{
  return ::CosLoadBalancing::_tc_MonitorAlreadyPresent;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CosLoadBalancing_MonitorAlreadyPresent = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosLoadBalancing_MonitorAlreadyPresent (
  ::CORBA::tk_except,
  "IDL:tao.lb/CosLoadBalancing/MonitorAlreadyPresent:1.0",
  "MonitorAlreadyPresent",
  _tao_fields_CosLoadBalancing_MonitorAlreadyPresent,
  0);


namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_MonitorAlreadyPresent =
    &_tao_tc_CosLoadBalancing_MonitorAlreadyPresent;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosLoadBalancing::LocationNotFound::LocationNotFound (void)
  : ::CORBA::UserException (
        "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
        "LocationNotFound"
      )
{
}

CosLoadBalancing::LocationNotFound::~LocationNotFound (void)
{
}

CosLoadBalancing::LocationNotFound::LocationNotFound (const ::CosLoadBalancing::LocationNotFound &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CosLoadBalancing::LocationNotFound&
CosLoadBalancing::LocationNotFound::operator= (const ::CosLoadBalancing::LocationNotFound &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CosLoadBalancing::LocationNotFound::_tao_any_destructor (void *_tao_void_pointer)
{
  LocationNotFound *_tao_tmp_pointer =
    static_cast<LocationNotFound *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosLoadBalancing::LocationNotFound *
CosLoadBalancing::LocationNotFound::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<LocationNotFound *> (_tao_excp);
}

const CosLoadBalancing::LocationNotFound *
CosLoadBalancing::LocationNotFound::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const LocationNotFound *> (_tao_excp);
}

::CORBA::Exception *CosLoadBalancing::LocationNotFound::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosLoadBalancing::LocationNotFound, 0);
  return retval;
}

::CORBA::Exception *
CosLoadBalancing::LocationNotFound::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosLoadBalancing::LocationNotFound (*this),
      0
    );
  return result;
}

void CosLoadBalancing::LocationNotFound::_raise (void) const
{
  throw *this;
}

void CosLoadBalancing::LocationNotFound::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosLoadBalancing::LocationNotFound::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosLoadBalancing::LocationNotFound::_tao_type (void) const
{
  return ::CosLoadBalancing::_tc_LocationNotFound;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CosLoadBalancing_LocationNotFound = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosLoadBalancing_LocationNotFound (
  ::CORBA::tk_except,
  "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
  "LocationNotFound",
  _tao_fields_CosLoadBalancing_LocationNotFound,
  0);


namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_LocationNotFound =
    &_tao_tc_CosLoadBalancing_LocationNotFound;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosLoadBalancing::LoadAlertNotFound::LoadAlertNotFound (void)
  : ::CORBA::UserException (
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
        "LoadAlertNotFound"
      )
{
}

CosLoadBalancing::LoadAlertNotFound::~LoadAlertNotFound (void)
{
}

CosLoadBalancing::LoadAlertNotFound::LoadAlertNotFound (const ::CosLoadBalancing::LoadAlertNotFound &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CosLoadBalancing::LoadAlertNotFound&
CosLoadBalancing::LoadAlertNotFound::operator= (const ::CosLoadBalancing::LoadAlertNotFound &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CosLoadBalancing::LoadAlertNotFound::_tao_any_destructor (void *_tao_void_pointer)
{
  LoadAlertNotFound *_tao_tmp_pointer =
    static_cast<LoadAlertNotFound *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosLoadBalancing::LoadAlertNotFound *
CosLoadBalancing::LoadAlertNotFound::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<LoadAlertNotFound *> (_tao_excp);
}

const CosLoadBalancing::LoadAlertNotFound *
CosLoadBalancing::LoadAlertNotFound::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const LoadAlertNotFound *> (_tao_excp);
}

::CORBA::Exception *CosLoadBalancing::LoadAlertNotFound::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosLoadBalancing::LoadAlertNotFound, 0);
  return retval;
}

::CORBA::Exception *
CosLoadBalancing::LoadAlertNotFound::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosLoadBalancing::LoadAlertNotFound (*this),
      0
    );
  return result;
}

void CosLoadBalancing::LoadAlertNotFound::_raise (void) const
{
  throw *this;
}

void CosLoadBalancing::LoadAlertNotFound::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosLoadBalancing::LoadAlertNotFound::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosLoadBalancing::LoadAlertNotFound::_tao_type (void) const
{
  return ::CosLoadBalancing::_tc_LoadAlertNotFound;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CosLoadBalancing_LoadAlertNotFound = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosLoadBalancing_LoadAlertNotFound (
  ::CORBA::tk_except,
  "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
  "LoadAlertNotFound",
  _tao_fields_CosLoadBalancing_LoadAlertNotFound,
  0);


namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_LoadAlertNotFound =
    &_tao_tc_CosLoadBalancing_LoadAlertNotFound;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosLoadBalancing::LoadAlertAlreadyPresent::LoadAlertAlreadyPresent (void)
  : ::CORBA::UserException (
        "IDL:tao.lb/CosLoadBalancing/LoadAlertAlreadyPresent:1.0",
        "LoadAlertAlreadyPresent"
      )
{
}

CosLoadBalancing::LoadAlertAlreadyPresent::~LoadAlertAlreadyPresent (void)
{
}

CosLoadBalancing::LoadAlertAlreadyPresent::LoadAlertAlreadyPresent (const ::CosLoadBalancing::LoadAlertAlreadyPresent &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CosLoadBalancing::LoadAlertAlreadyPresent&
CosLoadBalancing::LoadAlertAlreadyPresent::operator= (const ::CosLoadBalancing::LoadAlertAlreadyPresent &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CosLoadBalancing::LoadAlertAlreadyPresent::_tao_any_destructor (void *_tao_void_pointer)
{
  LoadAlertAlreadyPresent *_tao_tmp_pointer =
    static_cast<LoadAlertAlreadyPresent *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosLoadBalancing::LoadAlertAlreadyPresent *
CosLoadBalancing::LoadAlertAlreadyPresent::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<LoadAlertAlreadyPresent *> (_tao_excp);
}

const CosLoadBalancing::LoadAlertAlreadyPresent *
CosLoadBalancing::LoadAlertAlreadyPresent::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const LoadAlertAlreadyPresent *> (_tao_excp);
}

::CORBA::Exception *CosLoadBalancing::LoadAlertAlreadyPresent::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosLoadBalancing::LoadAlertAlreadyPresent, 0);
  return retval;
}

::CORBA::Exception *
CosLoadBalancing::LoadAlertAlreadyPresent::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosLoadBalancing::LoadAlertAlreadyPresent (*this),
      0
    );
  return result;
}

void CosLoadBalancing::LoadAlertAlreadyPresent::_raise (void) const
{
  throw *this;
}

void CosLoadBalancing::LoadAlertAlreadyPresent::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosLoadBalancing::LoadAlertAlreadyPresent::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosLoadBalancing::LoadAlertAlreadyPresent::_tao_type (void) const
{
  return ::CosLoadBalancing::_tc_LoadAlertAlreadyPresent;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CosLoadBalancing_LoadAlertAlreadyPresent = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosLoadBalancing_LoadAlertAlreadyPresent (
  ::CORBA::tk_except,
  "IDL:tao.lb/CosLoadBalancing/LoadAlertAlreadyPresent:1.0",
  "LoadAlertAlreadyPresent",
  _tao_fields_CosLoadBalancing_LoadAlertAlreadyPresent,
  0);


namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_LoadAlertAlreadyPresent =
    &_tao_tc_CosLoadBalancing_LoadAlertAlreadyPresent;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosLoadBalancing::LoadAlertNotAdded::LoadAlertNotAdded (void)
  : ::CORBA::UserException (
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotAdded:1.0",
        "LoadAlertNotAdded"
      )
{
}

CosLoadBalancing::LoadAlertNotAdded::~LoadAlertNotAdded (void)
{
}

CosLoadBalancing::LoadAlertNotAdded::LoadAlertNotAdded (const ::CosLoadBalancing::LoadAlertNotAdded &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CosLoadBalancing::LoadAlertNotAdded&
CosLoadBalancing::LoadAlertNotAdded::operator= (const ::CosLoadBalancing::LoadAlertNotAdded &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CosLoadBalancing::LoadAlertNotAdded::_tao_any_destructor (void *_tao_void_pointer)
{
  LoadAlertNotAdded *_tao_tmp_pointer =
    static_cast<LoadAlertNotAdded *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosLoadBalancing::LoadAlertNotAdded *
CosLoadBalancing::LoadAlertNotAdded::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<LoadAlertNotAdded *> (_tao_excp);
}

const CosLoadBalancing::LoadAlertNotAdded *
CosLoadBalancing::LoadAlertNotAdded::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const LoadAlertNotAdded *> (_tao_excp);
}

::CORBA::Exception *CosLoadBalancing::LoadAlertNotAdded::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosLoadBalancing::LoadAlertNotAdded, 0);
  return retval;
}

::CORBA::Exception *
CosLoadBalancing::LoadAlertNotAdded::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosLoadBalancing::LoadAlertNotAdded (*this),
      0
    );
  return result;
}

void CosLoadBalancing::LoadAlertNotAdded::_raise (void) const
{
  throw *this;
}

void CosLoadBalancing::LoadAlertNotAdded::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosLoadBalancing::LoadAlertNotAdded::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosLoadBalancing::LoadAlertNotAdded::_tao_type (void) const
{
  return ::CosLoadBalancing::_tc_LoadAlertNotAdded;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CosLoadBalancing_LoadAlertNotAdded = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosLoadBalancing_LoadAlertNotAdded (
  ::CORBA::tk_except,
  "IDL:tao.lb/CosLoadBalancing/LoadAlertNotAdded:1.0",
  "LoadAlertNotAdded",
  _tao_fields_CosLoadBalancing_LoadAlertNotAdded,
  0);


namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_LoadAlertNotAdded =
    &_tao_tc_CosLoadBalancing_LoadAlertNotAdded;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosLoadBalancing::StrategyNotAdaptive::StrategyNotAdaptive (void)
  : ::CORBA::UserException (
        "IDL:tao.lb/CosLoadBalancing/StrategyNotAdaptive:1.0",
        "StrategyNotAdaptive"
      )
{
}

CosLoadBalancing::StrategyNotAdaptive::~StrategyNotAdaptive (void)
{
}

CosLoadBalancing::StrategyNotAdaptive::StrategyNotAdaptive (const ::CosLoadBalancing::StrategyNotAdaptive &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CosLoadBalancing::StrategyNotAdaptive&
CosLoadBalancing::StrategyNotAdaptive::operator= (const ::CosLoadBalancing::StrategyNotAdaptive &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CosLoadBalancing::StrategyNotAdaptive::_tao_any_destructor (void *_tao_void_pointer)
{
  StrategyNotAdaptive *_tao_tmp_pointer =
    static_cast<StrategyNotAdaptive *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosLoadBalancing::StrategyNotAdaptive *
CosLoadBalancing::StrategyNotAdaptive::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<StrategyNotAdaptive *> (_tao_excp);
}

const CosLoadBalancing::StrategyNotAdaptive *
CosLoadBalancing::StrategyNotAdaptive::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const StrategyNotAdaptive *> (_tao_excp);
}

::CORBA::Exception *CosLoadBalancing::StrategyNotAdaptive::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosLoadBalancing::StrategyNotAdaptive, 0);
  return retval;
}

::CORBA::Exception *
CosLoadBalancing::StrategyNotAdaptive::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosLoadBalancing::StrategyNotAdaptive (*this),
      0
    );
  return result;
}

void CosLoadBalancing::StrategyNotAdaptive::_raise (void) const
{
  throw *this;
}

void CosLoadBalancing::StrategyNotAdaptive::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosLoadBalancing::StrategyNotAdaptive::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosLoadBalancing::StrategyNotAdaptive::_tao_type (void) const
{
  return ::CosLoadBalancing::_tc_StrategyNotAdaptive;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CosLoadBalancing_StrategyNotAdaptive = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosLoadBalancing_StrategyNotAdaptive (
  ::CORBA::tk_except,
  "IDL:tao.lb/CosLoadBalancing/StrategyNotAdaptive:1.0",
  "StrategyNotAdaptive",
  _tao_fields_CosLoadBalancing_StrategyNotAdaptive,
  0);


namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_StrategyNotAdaptive =
    &_tao_tc_CosLoadBalancing_StrategyNotAdaptive;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosLoadBalancing::Strategy.

CosLoadBalancing::Strategy_ptr
TAO::Objref_Traits<CosLoadBalancing::Strategy>::duplicate (
    CosLoadBalancing::Strategy_ptr p)
{
  return CosLoadBalancing::Strategy::_duplicate (p);
}

void
TAO::Objref_Traits<CosLoadBalancing::Strategy>::release (
    CosLoadBalancing::Strategy_ptr p)
{
  ::CORBA::release (p);
}

CosLoadBalancing::Strategy_ptr
TAO::Objref_Traits<CosLoadBalancing::Strategy>::nil (void)
{
  return CosLoadBalancing::Strategy::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosLoadBalancing::Strategy>::marshal (
    const CosLoadBalancing::Strategy_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosLoadBalancing__TAO_Strategy_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CosLoadBalancing::Strategy::name (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Strategy_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_Strategy_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_name",
      9,
      this->the_TAO_Strategy_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosLoadBalancing::Properties *
CosLoadBalancing::Strategy::get_properties (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Strategy_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_Strategy_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosLoadBalancing::Properties>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_properties",
      14,
      this->the_TAO_Strategy_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::Strategy::push_loads (
  const ::PortableGroup::Location & the_location,
  const ::CosLoadBalancing::LoadList & loads)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Strategy_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_Strategy_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);
  TAO::Arg_Traits< ::CosLoadBalancing::LoadList>::in_arg_val _tao_loads (loads);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location,
      &_tao_loads
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_Strategy_push_loads_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/StrategyNotAdaptive:1.0",
        CosLoadBalancing::StrategyNotAdaptive::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_StrategyNotAdaptive
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "push_loads",
      10,
      this->the_TAO_Strategy_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_Strategy_push_loads_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosLoadBalancing::LoadList *
CosLoadBalancing::Strategy::get_loads (
  ::CosLoadBalancing::LoadManager_ptr load_manager,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Strategy_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_Strategy_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosLoadBalancing::LoadList>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosLoadBalancing::LoadManager>::in_arg_val _tao_load_manager (load_manager);
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_load_manager,
      &_tao_the_location
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_Strategy_get_loads_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
        CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "get_loads",
      9,
      this->the_TAO_Strategy_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_Strategy_get_loads_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Object_ptr
CosLoadBalancing::Strategy::next_member (
  ::PortableGroup::ObjectGroup_ptr object_group,
  ::CosLoadBalancing::LoadManager_ptr load_manager)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Strategy_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_Strategy_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);
  TAO::Arg_Traits< ::CosLoadBalancing::LoadManager>::in_arg_val _tao_load_manager (load_manager);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_object_group,
      &_tao_load_manager
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_Strategy_next_member_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
        PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "next_member",
      11,
      this->the_TAO_Strategy_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_Strategy_next_member_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::Strategy::analyze_loads (
  ::PortableGroup::ObjectGroup_ptr object_group,
  ::CosLoadBalancing::LoadManager_ptr load_manager)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Strategy_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_Strategy_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);
  TAO::Arg_Traits< ::CosLoadBalancing::LoadManager>::in_arg_val _tao_load_manager (load_manager);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_object_group,
      &_tao_load_manager
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "analyze_loads",
      13,
      this->the_TAO_Strategy_Proxy_Broker_,
      TAO::TAO_ONEWAY_INVOCATION
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::Strategy::sendc_get_name (
  ::CosLoadBalancing::AMI_StrategyHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Strategy_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_Strategy_setup_collocation ();
    }

  TAO::Argument ** _the_tao_operation_signature = 0;

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      0,
      "_get_name",
      9,
      this->the_TAO_Strategy_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_StrategyHandler::get_name_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::Strategy::sendc_get_properties (
  ::CosLoadBalancing::AMI_StrategyHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Strategy_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_Strategy_setup_collocation ();
    }

  TAO::Argument ** _the_tao_operation_signature = 0;

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      0,
      "get_properties",
      14,
      this->the_TAO_Strategy_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_StrategyHandler::get_properties_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::Strategy::sendc_push_loads (
  ::CosLoadBalancing::AMI_StrategyHandler_ptr ami_handler,
  const ::PortableGroup::Location & the_location,
  const ::CosLoadBalancing::LoadList & loads)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Strategy_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_Strategy_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);
  TAO::Arg_Traits< ::CosLoadBalancing::LoadList>::in_arg_val _tao_loads (loads);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_the_location,
      &_tao_loads
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "push_loads",
      10,
      this->the_TAO_Strategy_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_StrategyHandler::push_loads_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::Strategy::sendc_get_loads (
  ::CosLoadBalancing::AMI_StrategyHandler_ptr ami_handler,
  ::CosLoadBalancing::LoadManager_ptr load_manager,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Strategy_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_Strategy_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosLoadBalancing::LoadManager>::in_arg_val _tao_load_manager (load_manager);
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_load_manager,
      &_tao_the_location
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "get_loads",
      9,
      this->the_TAO_Strategy_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_StrategyHandler::get_loads_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::Strategy::sendc_next_member (
  ::CosLoadBalancing::AMI_StrategyHandler_ptr ami_handler,
  ::PortableGroup::ObjectGroup_ptr object_group,
  ::CosLoadBalancing::LoadManager_ptr load_manager)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Strategy_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_Strategy_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_object_group (object_group);
  TAO::Arg_Traits< ::CosLoadBalancing::LoadManager>::in_arg_val _tao_load_manager (load_manager);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_object_group,
      &_tao_load_manager
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "next_member",
      11,
      this->the_TAO_Strategy_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_StrategyHandler::next_member_reply_stub
    );
}

CosLoadBalancing::Strategy::Strategy (void)
 : the_TAO_Strategy_Proxy_Broker_ (0)
{
  this->CosLoadBalancing_Strategy_setup_collocation ();
}

void
CosLoadBalancing::Strategy::CosLoadBalancing_Strategy_setup_collocation ()
{
  if (::CosLoadBalancing__TAO_Strategy_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Strategy_Proxy_Broker_ =
        ::CosLoadBalancing__TAO_Strategy_Proxy_Broker_Factory_function_pointer (this);
    }
}

CosLoadBalancing::Strategy::~Strategy (void)
{}

void 
CosLoadBalancing::Strategy::_tao_any_destructor (void *_tao_void_pointer)
{
  Strategy *_tao_tmp_pointer =
    static_cast<Strategy *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosLoadBalancing::Strategy_ptr
CosLoadBalancing::Strategy::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Strategy>::narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/Strategy:1.0",
        CosLoadBalancing__TAO_Strategy_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::Strategy_ptr
CosLoadBalancing::Strategy::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Strategy>::unchecked_narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/Strategy:1.0",
        CosLoadBalancing__TAO_Strategy_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::Strategy_ptr
CosLoadBalancing::Strategy::_nil (void)
{
  return 0;
}

CosLoadBalancing::Strategy_ptr
CosLoadBalancing::Strategy::_duplicate (Strategy_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosLoadBalancing::Strategy::_tao_release (Strategy_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosLoadBalancing::Strategy::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/Strategy:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosLoadBalancing::Strategy::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/Strategy:1.0";
}

::CORBA::Boolean
CosLoadBalancing::Strategy::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosLoadBalancing_Strategy (
    ::CORBA::tk_objref,
    "IDL:tao.lb/CosLoadBalancing/Strategy:1.0",
    "Strategy");
  

namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_Strategy =
    &_tao_tc_CosLoadBalancing_Strategy;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosLoadBalancing::AMI_StrategyHandler.

CosLoadBalancing::AMI_StrategyHandler_ptr
TAO::Objref_Traits<CosLoadBalancing::AMI_StrategyHandler>::duplicate (
    CosLoadBalancing::AMI_StrategyHandler_ptr p)
{
  return CosLoadBalancing::AMI_StrategyHandler::_duplicate (p);
}

void
TAO::Objref_Traits<CosLoadBalancing::AMI_StrategyHandler>::release (
    CosLoadBalancing::AMI_StrategyHandler_ptr p)
{
  ::CORBA::release (p);
}

CosLoadBalancing::AMI_StrategyHandler_ptr
TAO::Objref_Traits<CosLoadBalancing::AMI_StrategyHandler>::nil (void)
{
  return CosLoadBalancing::AMI_StrategyHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosLoadBalancing::AMI_StrategyHandler>::marshal (
    const CosLoadBalancing::AMI_StrategyHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosLoadBalancing__TAO_AMI_StrategyHandler_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_StrategyHandler::get_name (
  const char * ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_StrategyHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_StrategyHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_name",
      8,
      this->the_TAO_AMI_StrategyHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
CosLoadBalancing::AMI_StrategyHandler::get_name_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_StrategyHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_StrategyHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CORBA::String_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_name (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_name_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_StrategyHandler::get_name_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_StrategyHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_StrategyHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_name_excep",
      14,
      this->the_TAO_AMI_StrategyHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_StrategyHandler::get_properties (
  const ::CosLoadBalancing::Properties & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_StrategyHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_StrategyHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosLoadBalancing::Properties>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_properties",
      14,
      this->the_TAO_AMI_StrategyHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
CosLoadBalancing::AMI_StrategyHandler::get_properties_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_StrategyHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_StrategyHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CosLoadBalancing::Properties ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_properties (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_properties_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_StrategyHandler::get_properties_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_StrategyHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_StrategyHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_properties_excep",
      20,
      this->the_TAO_AMI_StrategyHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_StrategyHandler::push_loads (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_StrategyHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_StrategyHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_StrategyHandler_push_loads_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/StrategyNotAdaptive:1.0",
        CosLoadBalancing::StrategyNotAdaptive::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_StrategyNotAdaptive
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "push_loads",
      10,
      this->the_TAO_AMI_StrategyHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_StrategyHandler_push_loads_exceptiondata,
      1
    );
}

void
CosLoadBalancing::AMI_StrategyHandler::push_loads_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_StrategyHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_StrategyHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->push_loads (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:tao.lb/CosLoadBalancing/StrategyNotAdaptive:1.0",
          CosLoadBalancing::StrategyNotAdaptive::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , CosLoadBalancing::_tc_StrategyNotAdaptive
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->push_loads_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_StrategyHandler::push_loads_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_StrategyHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_StrategyHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_StrategyHandler_push_loads_excep_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/StrategyNotAdaptive:1.0",
        CosLoadBalancing::StrategyNotAdaptive::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_StrategyNotAdaptive
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "push_loads_excep",
      16,
      this->the_TAO_AMI_StrategyHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_StrategyHandler_push_loads_excep_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_StrategyHandler::get_loads (
  const ::CosLoadBalancing::LoadList & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_StrategyHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_StrategyHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosLoadBalancing::LoadList>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_StrategyHandler_get_loads_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
        CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_loads",
      9,
      this->the_TAO_AMI_StrategyHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_StrategyHandler_get_loads_exceptiondata,
      1
    );
}

void
CosLoadBalancing::AMI_StrategyHandler::get_loads_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_StrategyHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_StrategyHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CosLoadBalancing::LoadList ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_loads (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
          CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_loads_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_StrategyHandler::get_loads_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_StrategyHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_StrategyHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_StrategyHandler_get_loads_excep_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
        CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_loads_excep",
      15,
      this->the_TAO_AMI_StrategyHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_StrategyHandler_get_loads_excep_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_StrategyHandler::next_member (
  ::CORBA::Object_ptr ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_StrategyHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_StrategyHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_StrategyHandler_next_member_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
        PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "next_member",
      11,
      this->the_TAO_AMI_StrategyHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_StrategyHandler_next_member_exceptiondata,
      2
    );
}

void
CosLoadBalancing::AMI_StrategyHandler::next_member_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_StrategyHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_StrategyHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CORBA::Object_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->next_member (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
          PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
          PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 2;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->next_member_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_StrategyHandler::next_member_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_StrategyHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_StrategyHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_StrategyHandler_next_member_excep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/PortableGroup/ObjectGroupNotFound:1.0",
        PortableGroup::ObjectGroupNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_ObjectGroupNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/PortableGroup/MemberNotFound:1.0",
        PortableGroup::MemberNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , PortableGroup::_tc_MemberNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "next_member_excep",
      17,
      this->the_TAO_AMI_StrategyHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_StrategyHandler_next_member_excep_exceptiondata,
      2
    );
}

CosLoadBalancing::AMI_StrategyHandler::AMI_StrategyHandler (void)
 : the_TAO_AMI_StrategyHandler_Proxy_Broker_ (0)
{
  this->CosLoadBalancing_AMI_StrategyHandler_setup_collocation ();
}

void
CosLoadBalancing::AMI_StrategyHandler::CosLoadBalancing_AMI_StrategyHandler_setup_collocation ()
{
  if (::CosLoadBalancing__TAO_AMI_StrategyHandler_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_AMI_StrategyHandler_Proxy_Broker_ =
        ::CosLoadBalancing__TAO_AMI_StrategyHandler_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->Messaging_ReplyHandler_setup_collocation ();
}

CosLoadBalancing::AMI_StrategyHandler::~AMI_StrategyHandler (void)
{}

void 
CosLoadBalancing::AMI_StrategyHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_StrategyHandler *_tao_tmp_pointer =
    static_cast<AMI_StrategyHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosLoadBalancing::AMI_StrategyHandler_ptr
CosLoadBalancing::AMI_StrategyHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_StrategyHandler>::narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/AMI_StrategyHandler:1.0",
        CosLoadBalancing__TAO_AMI_StrategyHandler_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::AMI_StrategyHandler_ptr
CosLoadBalancing::AMI_StrategyHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_StrategyHandler>::unchecked_narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/AMI_StrategyHandler:1.0",
        CosLoadBalancing__TAO_AMI_StrategyHandler_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::AMI_StrategyHandler_ptr
CosLoadBalancing::AMI_StrategyHandler::_nil (void)
{
  return 0;
}

CosLoadBalancing::AMI_StrategyHandler_ptr
CosLoadBalancing::AMI_StrategyHandler::_duplicate (AMI_StrategyHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosLoadBalancing::AMI_StrategyHandler::_tao_release (AMI_StrategyHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosLoadBalancing::AMI_StrategyHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/AMI_StrategyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosLoadBalancing::AMI_StrategyHandler::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/AMI_StrategyHandler:1.0";
}

::CORBA::Boolean
CosLoadBalancing::AMI_StrategyHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosLoadBalancing_AMI_StrategyHandler (
    ::CORBA::tk_objref,
    "IDL:tao.lb/CosLoadBalancing/AMI_StrategyHandler:1.0",
    "AMI_StrategyHandler");
  

namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_AMI_StrategyHandler =
    &_tao_tc_CosLoadBalancing_AMI_StrategyHandler;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosLoadBalancing_CustomStrategy (
    ::CORBA::tk_alias,
    "IDL:tao.lb/CosLoadBalancing/CustomStrategy:1.0",
    "CustomStrategy",
    &CosLoadBalancing::_tc_Strategy);
  

namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_CustomStrategy =
    &_tao_tc_CosLoadBalancing_CustomStrategy;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosLoadBalancing_StrategyInfo[] =
      {
        { "name", &CORBA::_tc_string },
        { "props", &CosLoadBalancing::_tc_Properties }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosLoadBalancing_StrategyInfo (
  ::CORBA::tk_struct,
  "IDL:tao.lb/CosLoadBalancing/StrategyInfo:1.0",
  "StrategyInfo",
  _tao_fields_CosLoadBalancing_StrategyInfo,
  2);


namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_StrategyInfo =
    &_tao_tc_CosLoadBalancing_StrategyInfo;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosLoadBalancing::StrategyInfo::_tao_any_destructor (
    void *_tao_void_pointer)
{
  StrategyInfo *_tao_tmp_pointer =
    static_cast<StrategyInfo *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosLoadBalancing::LoadAlert.

CosLoadBalancing::LoadAlert_ptr
TAO::Objref_Traits<CosLoadBalancing::LoadAlert>::duplicate (
    CosLoadBalancing::LoadAlert_ptr p)
{
  return CosLoadBalancing::LoadAlert::_duplicate (p);
}

void
TAO::Objref_Traits<CosLoadBalancing::LoadAlert>::release (
    CosLoadBalancing::LoadAlert_ptr p)
{
  ::CORBA::release (p);
}

CosLoadBalancing::LoadAlert_ptr
TAO::Objref_Traits<CosLoadBalancing::LoadAlert>::nil (void)
{
  return CosLoadBalancing::LoadAlert::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosLoadBalancing::LoadAlert>::marshal (
    const CosLoadBalancing::LoadAlert_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosLoadBalancing__TAO_LoadAlert_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::LoadAlert::enable_alert (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadAlert_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadAlert_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "enable_alert",
      12,
      this->the_TAO_LoadAlert_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::LoadAlert::disable_alert (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadAlert_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadAlert_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "disable_alert",
      13,
      this->the_TAO_LoadAlert_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::LoadAlert::sendc_enable_alert (
  ::CosLoadBalancing::AMI_LoadAlertHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadAlert_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadAlert_setup_collocation ();
    }

  TAO::Argument ** _the_tao_operation_signature = 0;

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      0,
      "enable_alert",
      12,
      this->the_TAO_LoadAlert_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_LoadAlertHandler::enable_alert_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::LoadAlert::sendc_disable_alert (
  ::CosLoadBalancing::AMI_LoadAlertHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadAlert_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadAlert_setup_collocation ();
    }

  TAO::Argument ** _the_tao_operation_signature = 0;

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      0,
      "disable_alert",
      13,
      this->the_TAO_LoadAlert_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_LoadAlertHandler::disable_alert_reply_stub
    );
}

CosLoadBalancing::LoadAlert::LoadAlert (void)
 : the_TAO_LoadAlert_Proxy_Broker_ (0)
{
  this->CosLoadBalancing_LoadAlert_setup_collocation ();
}

void
CosLoadBalancing::LoadAlert::CosLoadBalancing_LoadAlert_setup_collocation ()
{
  if (::CosLoadBalancing__TAO_LoadAlert_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_LoadAlert_Proxy_Broker_ =
        ::CosLoadBalancing__TAO_LoadAlert_Proxy_Broker_Factory_function_pointer (this);
    }
}

CosLoadBalancing::LoadAlert::~LoadAlert (void)
{}

void 
CosLoadBalancing::LoadAlert::_tao_any_destructor (void *_tao_void_pointer)
{
  LoadAlert *_tao_tmp_pointer =
    static_cast<LoadAlert *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosLoadBalancing::LoadAlert_ptr
CosLoadBalancing::LoadAlert::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<LoadAlert>::narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/LoadAlert:1.0",
        CosLoadBalancing__TAO_LoadAlert_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::LoadAlert_ptr
CosLoadBalancing::LoadAlert::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<LoadAlert>::unchecked_narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/LoadAlert:1.0",
        CosLoadBalancing__TAO_LoadAlert_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::LoadAlert_ptr
CosLoadBalancing::LoadAlert::_nil (void)
{
  return 0;
}

CosLoadBalancing::LoadAlert_ptr
CosLoadBalancing::LoadAlert::_duplicate (LoadAlert_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosLoadBalancing::LoadAlert::_tao_release (LoadAlert_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosLoadBalancing::LoadAlert::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/LoadAlert:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosLoadBalancing::LoadAlert::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/LoadAlert:1.0";
}

::CORBA::Boolean
CosLoadBalancing::LoadAlert::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosLoadBalancing_LoadAlert (
    ::CORBA::tk_objref,
    "IDL:tao.lb/CosLoadBalancing/LoadAlert:1.0",
    "LoadAlert");
  

namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_LoadAlert =
    &_tao_tc_CosLoadBalancing_LoadAlert;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosLoadBalancing::AMI_LoadAlertHandler.

CosLoadBalancing::AMI_LoadAlertHandler_ptr
TAO::Objref_Traits<CosLoadBalancing::AMI_LoadAlertHandler>::duplicate (
    CosLoadBalancing::AMI_LoadAlertHandler_ptr p)
{
  return CosLoadBalancing::AMI_LoadAlertHandler::_duplicate (p);
}

void
TAO::Objref_Traits<CosLoadBalancing::AMI_LoadAlertHandler>::release (
    CosLoadBalancing::AMI_LoadAlertHandler_ptr p)
{
  ::CORBA::release (p);
}

CosLoadBalancing::AMI_LoadAlertHandler_ptr
TAO::Objref_Traits<CosLoadBalancing::AMI_LoadAlertHandler>::nil (void)
{
  return CosLoadBalancing::AMI_LoadAlertHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosLoadBalancing::AMI_LoadAlertHandler>::marshal (
    const CosLoadBalancing::AMI_LoadAlertHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosLoadBalancing__TAO_AMI_LoadAlertHandler_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadAlertHandler::enable_alert (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadAlertHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadAlertHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "enable_alert",
      12,
      this->the_TAO_AMI_LoadAlertHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
CosLoadBalancing::AMI_LoadAlertHandler::enable_alert_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_LoadAlertHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_LoadAlertHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->enable_alert (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->enable_alert_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadAlertHandler::enable_alert_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadAlertHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadAlertHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "enable_alert_excep",
      18,
      this->the_TAO_AMI_LoadAlertHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadAlertHandler::disable_alert (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadAlertHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadAlertHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "disable_alert",
      13,
      this->the_TAO_AMI_LoadAlertHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
CosLoadBalancing::AMI_LoadAlertHandler::disable_alert_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_LoadAlertHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_LoadAlertHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->disable_alert (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->disable_alert_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadAlertHandler::disable_alert_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadAlertHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadAlertHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "disable_alert_excep",
      19,
      this->the_TAO_AMI_LoadAlertHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

CosLoadBalancing::AMI_LoadAlertHandler::AMI_LoadAlertHandler (void)
 : the_TAO_AMI_LoadAlertHandler_Proxy_Broker_ (0)
{
  this->CosLoadBalancing_AMI_LoadAlertHandler_setup_collocation ();
}

void
CosLoadBalancing::AMI_LoadAlertHandler::CosLoadBalancing_AMI_LoadAlertHandler_setup_collocation ()
{
  if (::CosLoadBalancing__TAO_AMI_LoadAlertHandler_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_AMI_LoadAlertHandler_Proxy_Broker_ =
        ::CosLoadBalancing__TAO_AMI_LoadAlertHandler_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->Messaging_ReplyHandler_setup_collocation ();
}

CosLoadBalancing::AMI_LoadAlertHandler::~AMI_LoadAlertHandler (void)
{}

void 
CosLoadBalancing::AMI_LoadAlertHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_LoadAlertHandler *_tao_tmp_pointer =
    static_cast<AMI_LoadAlertHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosLoadBalancing::AMI_LoadAlertHandler_ptr
CosLoadBalancing::AMI_LoadAlertHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_LoadAlertHandler>::narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/AMI_LoadAlertHandler:1.0",
        CosLoadBalancing__TAO_AMI_LoadAlertHandler_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::AMI_LoadAlertHandler_ptr
CosLoadBalancing::AMI_LoadAlertHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_LoadAlertHandler>::unchecked_narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/AMI_LoadAlertHandler:1.0",
        CosLoadBalancing__TAO_AMI_LoadAlertHandler_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::AMI_LoadAlertHandler_ptr
CosLoadBalancing::AMI_LoadAlertHandler::_nil (void)
{
  return 0;
}

CosLoadBalancing::AMI_LoadAlertHandler_ptr
CosLoadBalancing::AMI_LoadAlertHandler::_duplicate (AMI_LoadAlertHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosLoadBalancing::AMI_LoadAlertHandler::_tao_release (AMI_LoadAlertHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosLoadBalancing::AMI_LoadAlertHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/AMI_LoadAlertHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosLoadBalancing::AMI_LoadAlertHandler::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/AMI_LoadAlertHandler:1.0";
}

::CORBA::Boolean
CosLoadBalancing::AMI_LoadAlertHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosLoadBalancing_AMI_LoadAlertHandler (
    ::CORBA::tk_objref,
    "IDL:tao.lb/CosLoadBalancing/AMI_LoadAlertHandler:1.0",
    "AMI_LoadAlertHandler");
  

namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_AMI_LoadAlertHandler =
    &_tao_tc_CosLoadBalancing_AMI_LoadAlertHandler;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosLoadBalancing::LoadMonitor.

CosLoadBalancing::LoadMonitor_ptr
TAO::Objref_Traits<CosLoadBalancing::LoadMonitor>::duplicate (
    CosLoadBalancing::LoadMonitor_ptr p)
{
  return CosLoadBalancing::LoadMonitor::_duplicate (p);
}

void
TAO::Objref_Traits<CosLoadBalancing::LoadMonitor>::release (
    CosLoadBalancing::LoadMonitor_ptr p)
{
  ::CORBA::release (p);
}

CosLoadBalancing::LoadMonitor_ptr
TAO::Objref_Traits<CosLoadBalancing::LoadMonitor>::nil (void)
{
  return CosLoadBalancing::LoadMonitor::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosLoadBalancing::LoadMonitor>::marshal (
    const CosLoadBalancing::LoadMonitor_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosLoadBalancing__TAO_LoadMonitor_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosLoadBalancing::Location *
CosLoadBalancing::LoadMonitor::the_location (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadMonitor_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadMonitor_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosLoadBalancing::Location>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_the_location",
      17,
      this->the_TAO_LoadMonitor_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosLoadBalancing::LoadList *
CosLoadBalancing::LoadMonitor::loads (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadMonitor_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadMonitor_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosLoadBalancing::LoadList>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_loads",
      10,
      this->the_TAO_LoadMonitor_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::LoadMonitor::sendc_get_the_location (
  ::CosLoadBalancing::AMI_LoadMonitorHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadMonitor_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadMonitor_setup_collocation ();
    }

  TAO::Argument ** _the_tao_operation_signature = 0;

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      0,
      "_get_the_location",
      17,
      this->the_TAO_LoadMonitor_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_LoadMonitorHandler::get_the_location_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::LoadMonitor::sendc_get_loads (
  ::CosLoadBalancing::AMI_LoadMonitorHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadMonitor_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadMonitor_setup_collocation ();
    }

  TAO::Argument ** _the_tao_operation_signature = 0;

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      0,
      "_get_loads",
      10,
      this->the_TAO_LoadMonitor_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_LoadMonitorHandler::get_loads_reply_stub
    );
}

CosLoadBalancing::LoadMonitor::LoadMonitor (void)
 : the_TAO_LoadMonitor_Proxy_Broker_ (0)
{
  this->CosLoadBalancing_LoadMonitor_setup_collocation ();
}

void
CosLoadBalancing::LoadMonitor::CosLoadBalancing_LoadMonitor_setup_collocation ()
{
  if (::CosLoadBalancing__TAO_LoadMonitor_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_LoadMonitor_Proxy_Broker_ =
        ::CosLoadBalancing__TAO_LoadMonitor_Proxy_Broker_Factory_function_pointer (this);
    }
}

CosLoadBalancing::LoadMonitor::~LoadMonitor (void)
{}

void 
CosLoadBalancing::LoadMonitor::_tao_any_destructor (void *_tao_void_pointer)
{
  LoadMonitor *_tao_tmp_pointer =
    static_cast<LoadMonitor *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosLoadBalancing::LoadMonitor_ptr
CosLoadBalancing::LoadMonitor::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<LoadMonitor>::narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/LoadMonitor:1.0",
        CosLoadBalancing__TAO_LoadMonitor_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::LoadMonitor_ptr
CosLoadBalancing::LoadMonitor::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<LoadMonitor>::unchecked_narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/LoadMonitor:1.0",
        CosLoadBalancing__TAO_LoadMonitor_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::LoadMonitor_ptr
CosLoadBalancing::LoadMonitor::_nil (void)
{
  return 0;
}

CosLoadBalancing::LoadMonitor_ptr
CosLoadBalancing::LoadMonitor::_duplicate (LoadMonitor_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosLoadBalancing::LoadMonitor::_tao_release (LoadMonitor_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosLoadBalancing::LoadMonitor::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/LoadMonitor:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosLoadBalancing::LoadMonitor::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/LoadMonitor:1.0";
}

::CORBA::Boolean
CosLoadBalancing::LoadMonitor::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosLoadBalancing_LoadMonitor (
    ::CORBA::tk_objref,
    "IDL:tao.lb/CosLoadBalancing/LoadMonitor:1.0",
    "LoadMonitor");
  

namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_LoadMonitor =
    &_tao_tc_CosLoadBalancing_LoadMonitor;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosLoadBalancing::AMI_LoadMonitorHandler.

CosLoadBalancing::AMI_LoadMonitorHandler_ptr
TAO::Objref_Traits<CosLoadBalancing::AMI_LoadMonitorHandler>::duplicate (
    CosLoadBalancing::AMI_LoadMonitorHandler_ptr p)
{
  return CosLoadBalancing::AMI_LoadMonitorHandler::_duplicate (p);
}

void
TAO::Objref_Traits<CosLoadBalancing::AMI_LoadMonitorHandler>::release (
    CosLoadBalancing::AMI_LoadMonitorHandler_ptr p)
{
  ::CORBA::release (p);
}

CosLoadBalancing::AMI_LoadMonitorHandler_ptr
TAO::Objref_Traits<CosLoadBalancing::AMI_LoadMonitorHandler>::nil (void)
{
  return CosLoadBalancing::AMI_LoadMonitorHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosLoadBalancing::AMI_LoadMonitorHandler>::marshal (
    const CosLoadBalancing::AMI_LoadMonitorHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosLoadBalancing__TAO_AMI_LoadMonitorHandler_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadMonitorHandler::get_the_location (
  const ::CosLoadBalancing::Location & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadMonitorHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadMonitorHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosLoadBalancing::Location>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_the_location",
      16,
      this->the_TAO_AMI_LoadMonitorHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
CosLoadBalancing::AMI_LoadMonitorHandler::get_the_location_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_LoadMonitorHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_LoadMonitorHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CosLoadBalancing::Location ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_the_location (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_the_location_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadMonitorHandler::get_the_location_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadMonitorHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadMonitorHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_the_location_excep",
      22,
      this->the_TAO_AMI_LoadMonitorHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadMonitorHandler::get_loads (
  const ::CosLoadBalancing::LoadList & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadMonitorHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadMonitorHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosLoadBalancing::LoadList>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_loads",
      9,
      this->the_TAO_AMI_LoadMonitorHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
CosLoadBalancing::AMI_LoadMonitorHandler::get_loads_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_LoadMonitorHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_LoadMonitorHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CosLoadBalancing::LoadList ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_loads (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_loads_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadMonitorHandler::get_loads_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadMonitorHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadMonitorHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_loads_excep",
      15,
      this->the_TAO_AMI_LoadMonitorHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

CosLoadBalancing::AMI_LoadMonitorHandler::AMI_LoadMonitorHandler (void)
 : the_TAO_AMI_LoadMonitorHandler_Proxy_Broker_ (0)
{
  this->CosLoadBalancing_AMI_LoadMonitorHandler_setup_collocation ();
}

void
CosLoadBalancing::AMI_LoadMonitorHandler::CosLoadBalancing_AMI_LoadMonitorHandler_setup_collocation ()
{
  if (::CosLoadBalancing__TAO_AMI_LoadMonitorHandler_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_AMI_LoadMonitorHandler_Proxy_Broker_ =
        ::CosLoadBalancing__TAO_AMI_LoadMonitorHandler_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->Messaging_ReplyHandler_setup_collocation ();
}

CosLoadBalancing::AMI_LoadMonitorHandler::~AMI_LoadMonitorHandler (void)
{}

void 
CosLoadBalancing::AMI_LoadMonitorHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_LoadMonitorHandler *_tao_tmp_pointer =
    static_cast<AMI_LoadMonitorHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosLoadBalancing::AMI_LoadMonitorHandler_ptr
CosLoadBalancing::AMI_LoadMonitorHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_LoadMonitorHandler>::narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/AMI_LoadMonitorHandler:1.0",
        CosLoadBalancing__TAO_AMI_LoadMonitorHandler_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::AMI_LoadMonitorHandler_ptr
CosLoadBalancing::AMI_LoadMonitorHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_LoadMonitorHandler>::unchecked_narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/AMI_LoadMonitorHandler:1.0",
        CosLoadBalancing__TAO_AMI_LoadMonitorHandler_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::AMI_LoadMonitorHandler_ptr
CosLoadBalancing::AMI_LoadMonitorHandler::_nil (void)
{
  return 0;
}

CosLoadBalancing::AMI_LoadMonitorHandler_ptr
CosLoadBalancing::AMI_LoadMonitorHandler::_duplicate (AMI_LoadMonitorHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosLoadBalancing::AMI_LoadMonitorHandler::_tao_release (AMI_LoadMonitorHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosLoadBalancing::AMI_LoadMonitorHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/AMI_LoadMonitorHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosLoadBalancing::AMI_LoadMonitorHandler::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/AMI_LoadMonitorHandler:1.0";
}

::CORBA::Boolean
CosLoadBalancing::AMI_LoadMonitorHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosLoadBalancing_AMI_LoadMonitorHandler (
    ::CORBA::tk_objref,
    "IDL:tao.lb/CosLoadBalancing/AMI_LoadMonitorHandler:1.0",
    "AMI_LoadMonitorHandler");
  

namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_AMI_LoadMonitorHandler =
    &_tao_tc_CosLoadBalancing_AMI_LoadMonitorHandler;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosLoadBalancing::LoadManager.

CosLoadBalancing::LoadManager_ptr
TAO::Objref_Traits<CosLoadBalancing::LoadManager>::duplicate (
    CosLoadBalancing::LoadManager_ptr p)
{
  return CosLoadBalancing::LoadManager::_duplicate (p);
}

void
TAO::Objref_Traits<CosLoadBalancing::LoadManager>::release (
    CosLoadBalancing::LoadManager_ptr p)
{
  ::CORBA::release (p);
}

CosLoadBalancing::LoadManager_ptr
TAO::Objref_Traits<CosLoadBalancing::LoadManager>::nil (void)
{
  return CosLoadBalancing::LoadManager::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosLoadBalancing::LoadManager>::marshal (
    const CosLoadBalancing::LoadManager_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosLoadBalancing__TAO_LoadManager_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::LoadManager::push_loads (
  const ::PortableGroup::Location & the_location,
  const ::CosLoadBalancing::LoadList & loads)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);
  TAO::Arg_Traits< ::CosLoadBalancing::LoadList>::in_arg_val _tao_loads (loads);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location,
      &_tao_loads
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "push_loads",
      10,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosLoadBalancing::LoadList *
CosLoadBalancing::LoadManager::get_loads (
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosLoadBalancing::LoadList>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_LoadManager_get_loads_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
        CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_loads",
      9,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_LoadManager_get_loads_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::LoadManager::enable_alert (
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_LoadManager_enable_alert_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
        CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "enable_alert",
      12,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_LoadManager_enable_alert_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::LoadManager::disable_alert (
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_LoadManager_disable_alert_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
        CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "disable_alert",
      13,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_LoadManager_disable_alert_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::LoadManager::register_load_alert (
  const ::PortableGroup::Location & the_location,
  ::CosLoadBalancing::LoadAlert_ptr load_alert)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);
  TAO::Arg_Traits< ::CosLoadBalancing::LoadAlert>::in_arg_val _tao_load_alert (load_alert);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location,
      &_tao_load_alert
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_LoadManager_register_load_alert_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertAlreadyPresent:1.0",
        CosLoadBalancing::LoadAlertAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotAdded:1.0",
        CosLoadBalancing::LoadAlertNotAdded::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotAdded
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "register_load_alert",
      19,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_LoadManager_register_load_alert_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosLoadBalancing::LoadAlert_ptr
CosLoadBalancing::LoadManager::get_load_alert (
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosLoadBalancing::LoadAlert>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_LoadManager_get_load_alert_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
        CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_load_alert",
      14,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_LoadManager_get_load_alert_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::LoadManager::remove_load_alert (
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_LoadManager_remove_load_alert_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
        CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_load_alert",
      17,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_LoadManager_remove_load_alert_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::LoadManager::register_load_monitor (
  const ::PortableGroup::Location & the_location,
  ::CosLoadBalancing::LoadMonitor_ptr load_monitor)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);
  TAO::Arg_Traits< ::CosLoadBalancing::LoadMonitor>::in_arg_val _tao_load_monitor (load_monitor);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location,
      &_tao_load_monitor
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_LoadManager_register_load_monitor_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/MonitorAlreadyPresent:1.0",
        CosLoadBalancing::MonitorAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_MonitorAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "register_load_monitor",
      21,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_LoadManager_register_load_monitor_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosLoadBalancing::LoadMonitor_ptr
CosLoadBalancing::LoadManager::get_load_monitor (
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosLoadBalancing::LoadMonitor>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_LoadManager_get_load_monitor_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
        CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_load_monitor",
      16,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_LoadManager_get_load_monitor_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::LoadManager::remove_load_monitor (
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_LoadManager_remove_load_monitor_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
        CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_load_monitor",
      19,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_LoadManager_remove_load_monitor_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::LoadManager::sendc_push_loads (
  ::CosLoadBalancing::AMI_LoadManagerHandler_ptr ami_handler,
  const ::PortableGroup::Location & the_location,
  const ::CosLoadBalancing::LoadList & loads)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);
  TAO::Arg_Traits< ::CosLoadBalancing::LoadList>::in_arg_val _tao_loads (loads);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_the_location,
      &_tao_loads
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "push_loads",
      10,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_LoadManagerHandler::push_loads_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::LoadManager::sendc_get_loads (
  ::CosLoadBalancing::AMI_LoadManagerHandler_ptr ami_handler,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_loads",
      9,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_LoadManagerHandler::get_loads_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::LoadManager::sendc_enable_alert (
  ::CosLoadBalancing::AMI_LoadManagerHandler_ptr ami_handler,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "enable_alert",
      12,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_LoadManagerHandler::enable_alert_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::LoadManager::sendc_disable_alert (
  ::CosLoadBalancing::AMI_LoadManagerHandler_ptr ami_handler,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "disable_alert",
      13,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_LoadManagerHandler::disable_alert_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::LoadManager::sendc_register_load_alert (
  ::CosLoadBalancing::AMI_LoadManagerHandler_ptr ami_handler,
  const ::PortableGroup::Location & the_location,
  ::CosLoadBalancing::LoadAlert_ptr load_alert)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);
  TAO::Arg_Traits< ::CosLoadBalancing::LoadAlert>::in_arg_val _tao_load_alert (load_alert);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_the_location,
      &_tao_load_alert
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "register_load_alert",
      19,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_LoadManagerHandler::register_load_alert_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::LoadManager::sendc_get_load_alert (
  ::CosLoadBalancing::AMI_LoadManagerHandler_ptr ami_handler,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_load_alert",
      14,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_LoadManagerHandler::get_load_alert_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::LoadManager::sendc_remove_load_alert (
  ::CosLoadBalancing::AMI_LoadManagerHandler_ptr ami_handler,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_load_alert",
      17,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_LoadManagerHandler::remove_load_alert_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::LoadManager::sendc_register_load_monitor (
  ::CosLoadBalancing::AMI_LoadManagerHandler_ptr ami_handler,
  const ::PortableGroup::Location & the_location,
  ::CosLoadBalancing::LoadMonitor_ptr load_monitor)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);
  TAO::Arg_Traits< ::CosLoadBalancing::LoadMonitor>::in_arg_val _tao_load_monitor (load_monitor);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_the_location,
      &_tao_load_monitor
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "register_load_monitor",
      21,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_LoadManagerHandler::register_load_monitor_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::LoadManager::sendc_get_load_monitor (
  ::CosLoadBalancing::AMI_LoadManagerHandler_ptr ami_handler,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_load_monitor",
      16,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_LoadManagerHandler::get_load_monitor_reply_stub
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/ami_cs.cpp:61

void
CosLoadBalancing::LoadManager::sendc_remove_load_monitor (
  ::CosLoadBalancing::AMI_LoadManagerHandler_ptr ami_handler,
  const ::PortableGroup::Location & the_location)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_LoadManager_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_LoadManager_setup_collocation ();
    }
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::PortableGroup::Location>::in_arg_val _tao_the_location (the_location);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_the_location
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_load_monitor",
      19,
      this->the_TAO_LoadManager_Proxy_Broker_
    );

  _tao_call.invoke (
      ami_handler,
      &CosLoadBalancing::AMI_LoadManagerHandler::remove_load_monitor_reply_stub
    );
}

CosLoadBalancing::LoadManager::LoadManager (void)
 : the_TAO_LoadManager_Proxy_Broker_ (0)
{
  this->CosLoadBalancing_LoadManager_setup_collocation ();
}

void
CosLoadBalancing::LoadManager::CosLoadBalancing_LoadManager_setup_collocation ()
{
  if (::CosLoadBalancing__TAO_LoadManager_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_LoadManager_Proxy_Broker_ =
        ::CosLoadBalancing__TAO_LoadManager_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->PortableGroup_PropertyManager_setup_collocation ();
  this->PortableGroup_ObjectGroupManager_setup_collocation ();
  this->PortableGroup_GenericFactory_setup_collocation ();
}

CosLoadBalancing::LoadManager::~LoadManager (void)
{}

void 
CosLoadBalancing::LoadManager::_tao_any_destructor (void *_tao_void_pointer)
{
  LoadManager *_tao_tmp_pointer =
    static_cast<LoadManager *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosLoadBalancing::LoadManager_ptr
CosLoadBalancing::LoadManager::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<LoadManager>::narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/LoadManager:1.0",
        CosLoadBalancing__TAO_LoadManager_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::LoadManager_ptr
CosLoadBalancing::LoadManager::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<LoadManager>::unchecked_narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/LoadManager:1.0",
        CosLoadBalancing__TAO_LoadManager_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::LoadManager_ptr
CosLoadBalancing::LoadManager::_nil (void)
{
  return 0;
}

CosLoadBalancing::LoadManager_ptr
CosLoadBalancing::LoadManager::_duplicate (LoadManager_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosLoadBalancing::LoadManager::_tao_release (LoadManager_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosLoadBalancing::LoadManager::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/PropertyManager:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/ObjectGroupManager:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/GenericFactory:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/LoadManager:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosLoadBalancing::LoadManager::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/LoadManager:1.0";
}

::CORBA::Boolean
CosLoadBalancing::LoadManager::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosLoadBalancing_LoadManager (
    ::CORBA::tk_objref,
    "IDL:tao.lb/CosLoadBalancing/LoadManager:1.0",
    "LoadManager");
  

namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_LoadManager =
    &_tao_tc_CosLoadBalancing_LoadManager;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosLoadBalancing::AMI_LoadManagerHandler.

CosLoadBalancing::AMI_LoadManagerHandler_ptr
TAO::Objref_Traits<CosLoadBalancing::AMI_LoadManagerHandler>::duplicate (
    CosLoadBalancing::AMI_LoadManagerHandler_ptr p)
{
  return CosLoadBalancing::AMI_LoadManagerHandler::_duplicate (p);
}

void
TAO::Objref_Traits<CosLoadBalancing::AMI_LoadManagerHandler>::release (
    CosLoadBalancing::AMI_LoadManagerHandler_ptr p)
{
  ::CORBA::release (p);
}

CosLoadBalancing::AMI_LoadManagerHandler_ptr
TAO::Objref_Traits<CosLoadBalancing::AMI_LoadManagerHandler>::nil (void)
{
  return CosLoadBalancing::AMI_LoadManagerHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosLoadBalancing::AMI_LoadManagerHandler>::marshal (
    const CosLoadBalancing::AMI_LoadManagerHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosLoadBalancing__TAO_AMI_LoadManagerHandler_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::push_loads (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "push_loads",
      10,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

void
CosLoadBalancing::AMI_LoadManagerHandler::push_loads_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_LoadManagerHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_LoadManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->push_loads (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->push_loads_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::push_loads_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "push_loads_excep",
      16,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::get_loads (
  const ::CosLoadBalancing::LoadList & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosLoadBalancing::LoadList>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_loads_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
        CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_loads",
      9,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_loads_exceptiondata,
      1
    );
}

void
CosLoadBalancing::AMI_LoadManagerHandler::get_loads_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_LoadManagerHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_LoadManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CosLoadBalancing::LoadList ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_loads (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
          CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_loads_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::get_loads_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_loads_excep_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
        CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_loads_excep",
      15,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_loads_excep_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::enable_alert (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_enable_alert_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
        CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "enable_alert",
      12,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_enable_alert_exceptiondata,
      1
    );
}

void
CosLoadBalancing::AMI_LoadManagerHandler::enable_alert_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_LoadManagerHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_LoadManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->enable_alert (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
          CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->enable_alert_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::enable_alert_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_enable_alert_excep_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
        CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "enable_alert_excep",
      18,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_enable_alert_excep_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::disable_alert (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_disable_alert_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
        CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "disable_alert",
      13,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_disable_alert_exceptiondata,
      1
    );
}

void
CosLoadBalancing::AMI_LoadManagerHandler::disable_alert_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_LoadManagerHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_LoadManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->disable_alert (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
          CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->disable_alert_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::disable_alert_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_disable_alert_excep_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
        CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "disable_alert_excep",
      19,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_disable_alert_excep_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::register_load_alert (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_register_load_alert_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertAlreadyPresent:1.0",
        CosLoadBalancing::LoadAlertAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotAdded:1.0",
        CosLoadBalancing::LoadAlertNotAdded::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotAdded
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "register_load_alert",
      19,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_register_load_alert_exceptiondata,
      2
    );
}

void
CosLoadBalancing::AMI_LoadManagerHandler::register_load_alert_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_LoadManagerHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_LoadManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->register_load_alert (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:tao.lb/CosLoadBalancing/LoadAlertAlreadyPresent:1.0",
          CosLoadBalancing::LoadAlertAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , CosLoadBalancing::_tc_LoadAlertAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
        },
        {
          "IDL:tao.lb/CosLoadBalancing/LoadAlertNotAdded:1.0",
          CosLoadBalancing::LoadAlertNotAdded::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , CosLoadBalancing::_tc_LoadAlertNotAdded
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 2;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->register_load_alert_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::register_load_alert_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_register_load_alert_excep_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertAlreadyPresent:1.0",
        CosLoadBalancing::LoadAlertAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotAdded:1.0",
        CosLoadBalancing::LoadAlertNotAdded::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotAdded
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "register_load_alert_excep",
      25,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_register_load_alert_excep_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::get_load_alert (
  ::CosLoadBalancing::LoadAlert_ptr ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosLoadBalancing::LoadAlert>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_load_alert_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
        CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_load_alert",
      14,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_load_alert_exceptiondata,
      1
    );
}

void
CosLoadBalancing::AMI_LoadManagerHandler::get_load_alert_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_LoadManagerHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_LoadManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CosLoadBalancing::LoadAlert_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_load_alert (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
          CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_load_alert_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::get_load_alert_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_load_alert_excep_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
        CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_load_alert_excep",
      20,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_load_alert_excep_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::remove_load_alert (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_remove_load_alert_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
        CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "remove_load_alert",
      17,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_remove_load_alert_exceptiondata,
      1
    );
}

void
CosLoadBalancing::AMI_LoadManagerHandler::remove_load_alert_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_LoadManagerHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_LoadManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->remove_load_alert (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
          CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->remove_load_alert_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::remove_load_alert_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_remove_load_alert_excep_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LoadAlertNotFound:1.0",
        CosLoadBalancing::LoadAlertNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LoadAlertNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_load_alert_excep",
      23,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_remove_load_alert_excep_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::register_load_monitor (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_register_load_monitor_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/MonitorAlreadyPresent:1.0",
        CosLoadBalancing::MonitorAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_MonitorAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "register_load_monitor",
      21,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_register_load_monitor_exceptiondata,
      1
    );
}

void
CosLoadBalancing::AMI_LoadManagerHandler::register_load_monitor_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_LoadManagerHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_LoadManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->register_load_monitor (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:tao.lb/CosLoadBalancing/MonitorAlreadyPresent:1.0",
          CosLoadBalancing::MonitorAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , CosLoadBalancing::_tc_MonitorAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->register_load_monitor_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::register_load_monitor_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_register_load_monitor_excep_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/MonitorAlreadyPresent:1.0",
        CosLoadBalancing::MonitorAlreadyPresent::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_MonitorAlreadyPresent
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "register_load_monitor_excep",
      27,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_register_load_monitor_excep_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::get_load_monitor (
  ::CosLoadBalancing::LoadMonitor_ptr ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosLoadBalancing::LoadMonitor>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_load_monitor_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
        CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_load_monitor",
      16,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_load_monitor_exceptiondata,
      1
    );
}

void
CosLoadBalancing::AMI_LoadManagerHandler::get_load_monitor_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_LoadManagerHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_LoadManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CosLoadBalancing::LoadMonitor_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_load_monitor (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
          CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_load_monitor_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::get_load_monitor_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_load_monitor_excep_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
        CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_load_monitor_excep",
      22,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_get_load_monitor_excep_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::remove_load_monitor (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_remove_load_monitor_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
        CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "remove_load_monitor",
      19,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_remove_load_monitor_exceptiondata,
      1
    );
}

void
CosLoadBalancing::AMI_LoadManagerHandler::remove_load_monitor_reply_stub (
  TAO_InputCDR &_tao_in, 
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  CosLoadBalancing::AMI_LoadManagerHandler_var _tao_reply_handler_object =
    CosLoadBalancing::AMI_LoadManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->remove_load_monitor (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] = 
      {
        {
          "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
          CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0
        );
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ())
          );
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->remove_load_monitor_excep (
          exception_holder_var
        );
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosLoadBalancing::AMI_LoadManagerHandler::remove_load_monitor_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ == 0)
    {
      CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_CosLoadBalancing_AMI_LoadManagerHandler_remove_load_monitor_excep_exceptiondata [] = 
    {
      {
        "IDL:tao.lb/CosLoadBalancing/LocationNotFound:1.0",
        CosLoadBalancing::LocationNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosLoadBalancing::_tc_LocationNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_load_monitor_excep",
      25,
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosLoadBalancing_AMI_LoadManagerHandler_remove_load_monitor_excep_exceptiondata,
      1
    );
}

CosLoadBalancing::AMI_LoadManagerHandler::AMI_LoadManagerHandler (void)
 : the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ (0)
{
  this->CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ();
}

void
CosLoadBalancing::AMI_LoadManagerHandler::CosLoadBalancing_AMI_LoadManagerHandler_setup_collocation ()
{
  if (::CosLoadBalancing__TAO_AMI_LoadManagerHandler_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_AMI_LoadManagerHandler_Proxy_Broker_ =
        ::CosLoadBalancing__TAO_AMI_LoadManagerHandler_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->PortableGroup_AMI_PropertyManagerHandler_setup_collocation ();
  this->PortableGroup_AMI_ObjectGroupManagerHandler_setup_collocation ();
  this->PortableGroup_AMI_GenericFactoryHandler_setup_collocation ();
}

CosLoadBalancing::AMI_LoadManagerHandler::~AMI_LoadManagerHandler (void)
{}

void 
CosLoadBalancing::AMI_LoadManagerHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_LoadManagerHandler *_tao_tmp_pointer =
    static_cast<AMI_LoadManagerHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosLoadBalancing::AMI_LoadManagerHandler_ptr
CosLoadBalancing::AMI_LoadManagerHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_LoadManagerHandler>::narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/AMI_LoadManagerHandler:1.0",
        CosLoadBalancing__TAO_AMI_LoadManagerHandler_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::AMI_LoadManagerHandler_ptr
CosLoadBalancing::AMI_LoadManagerHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_LoadManagerHandler>::unchecked_narrow (
        _tao_objref,
        "IDL:tao.lb/CosLoadBalancing/AMI_LoadManagerHandler:1.0",
        CosLoadBalancing__TAO_AMI_LoadManagerHandler_Proxy_Broker_Factory_function_pointer
      );
}

CosLoadBalancing::AMI_LoadManagerHandler_ptr
CosLoadBalancing::AMI_LoadManagerHandler::_nil (void)
{
  return 0;
}

CosLoadBalancing::AMI_LoadManagerHandler_ptr
CosLoadBalancing::AMI_LoadManagerHandler::_duplicate (AMI_LoadManagerHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosLoadBalancing::AMI_LoadManagerHandler::_tao_release (AMI_LoadManagerHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosLoadBalancing::AMI_LoadManagerHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/AMI_PropertyManagerHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/AMI_ObjectGroupManagerHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/PortableGroup/AMI_GenericFactoryHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:tao.lb/CosLoadBalancing/AMI_LoadManagerHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosLoadBalancing::AMI_LoadManagerHandler::_interface_repository_id (void) const
{
  return "IDL:tao.lb/CosLoadBalancing/AMI_LoadManagerHandler:1.0";
}

::CORBA::Boolean
CosLoadBalancing::AMI_LoadManagerHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosLoadBalancing_AMI_LoadManagerHandler (
    ::CORBA::tk_objref,
    "IDL:tao.lb/CosLoadBalancing/AMI_LoadManagerHandler:1.0",
    "AMI_LoadManagerHandler");
  

namespace CosLoadBalancing
{
  ::CORBA::TypeCode_ptr const _tc_AMI_LoadManagerHandler =
    &_tao_tc_CosLoadBalancing_AMI_LoadManagerHandler;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::Load &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosLoadBalancing::Load *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosLoadBalancing::Load>::insert_copy (
          _tao_any,
          ::CosLoadBalancing::Load::_tao_any_destructor,
          ::CosLoadBalancing::_tc_Load,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosLoadBalancing::Load *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::Load>::insert (
        _tao_any,
        ::CosLoadBalancing::Load::_tao_any_destructor,
        ::CosLoadBalancing::_tc_Load,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::Load *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosLoadBalancing::Load *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::Load *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosLoadBalancing::Load>::extract (
          _tao_any,
          ::CosLoadBalancing::Load::_tao_any_destructor,
          ::CosLoadBalancing::_tc_Load,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosLoadBalancing::Load &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosLoadBalancing::Load *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosLoadBalancing::Load>::insert_copy (
        _tao_any,
        CosLoadBalancing::Load::_tao_any_destructor,
        CosLoadBalancing::_tc_Load,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::Load *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::Load>::insert (
      _tao_any,
      CosLoadBalancing::Load::_tao_any_destructor,
      CosLoadBalancing::_tc_Load,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::Load *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosLoadBalancing::Load *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosLoadBalancing::Load *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosLoadBalancing::Load>::extract (
        _tao_any,
        CosLoadBalancing::Load::_tao_any_destructor,
        CosLoadBalancing::_tc_Load,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::LoadList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosLoadBalancing::LoadList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LoadList>::insert_copy (
          _tao_any,
          ::CosLoadBalancing::LoadList::_tao_any_destructor,
          ::CosLoadBalancing::_tc_LoadList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::LoadList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LoadList>::insert (
        _tao_any,
        ::CosLoadBalancing::LoadList::_tao_any_destructor,
        ::CosLoadBalancing::_tc_LoadList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::LoadList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosLoadBalancing::LoadList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::LoadList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LoadList>::extract (
          _tao_any,
          ::CosLoadBalancing::LoadList::_tao_any_destructor,
          ::CosLoadBalancing::_tc_LoadList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosLoadBalancing::LoadList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosLoadBalancing::LoadList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosLoadBalancing::LoadList>::insert_copy (
        _tao_any,
        CosLoadBalancing::LoadList::_tao_any_destructor,
        CosLoadBalancing::_tc_LoadList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::LoadList>::insert (
      _tao_any,
      CosLoadBalancing::LoadList::_tao_any_destructor,
      CosLoadBalancing::_tc_LoadList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosLoadBalancing::LoadList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosLoadBalancing::LoadList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosLoadBalancing::LoadList>::extract (
        _tao_any,
        CosLoadBalancing::LoadList::_tao_any_destructor,
        CosLoadBalancing::_tc_LoadList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosLoadBalancing::MonitorAlreadyPresent>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::MonitorAlreadyPresent &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::MonitorAlreadyPresent>::insert_copy (
        _tao_any,
        ::CosLoadBalancing::MonitorAlreadyPresent::_tao_any_destructor,
        ::CosLoadBalancing::_tc_MonitorAlreadyPresent,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::MonitorAlreadyPresent *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::MonitorAlreadyPresent>::insert (
        _tao_any,
        ::CosLoadBalancing::MonitorAlreadyPresent::_tao_any_destructor,
        ::CosLoadBalancing::_tc_MonitorAlreadyPresent,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::MonitorAlreadyPresent *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosLoadBalancing::MonitorAlreadyPresent *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::MonitorAlreadyPresent *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosLoadBalancing::MonitorAlreadyPresent>::extract (
          _tao_any,
          ::CosLoadBalancing::MonitorAlreadyPresent::_tao_any_destructor,
          ::CosLoadBalancing::_tc_MonitorAlreadyPresent,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosLoadBalancing::MonitorAlreadyPresent &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::MonitorAlreadyPresent>::insert_copy (
      _tao_any,
      CosLoadBalancing::MonitorAlreadyPresent::_tao_any_destructor,
      CosLoadBalancing::_tc_MonitorAlreadyPresent,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::MonitorAlreadyPresent *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::MonitorAlreadyPresent>::insert (
      _tao_any,
      CosLoadBalancing::MonitorAlreadyPresent::_tao_any_destructor,
      CosLoadBalancing::_tc_MonitorAlreadyPresent,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::MonitorAlreadyPresent *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosLoadBalancing::MonitorAlreadyPresent *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosLoadBalancing::MonitorAlreadyPresent *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosLoadBalancing::MonitorAlreadyPresent>::extract (
        _tao_any,
        CosLoadBalancing::MonitorAlreadyPresent::_tao_any_destructor,
        CosLoadBalancing::_tc_MonitorAlreadyPresent,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosLoadBalancing::LocationNotFound>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::LocationNotFound &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LocationNotFound>::insert_copy (
        _tao_any,
        ::CosLoadBalancing::LocationNotFound::_tao_any_destructor,
        ::CosLoadBalancing::_tc_LocationNotFound,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::LocationNotFound *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LocationNotFound>::insert (
        _tao_any,
        ::CosLoadBalancing::LocationNotFound::_tao_any_destructor,
        ::CosLoadBalancing::_tc_LocationNotFound,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::LocationNotFound *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosLoadBalancing::LocationNotFound *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::LocationNotFound *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LocationNotFound>::extract (
          _tao_any,
          ::CosLoadBalancing::LocationNotFound::_tao_any_destructor,
          ::CosLoadBalancing::_tc_LocationNotFound,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosLoadBalancing::LocationNotFound &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::LocationNotFound>::insert_copy (
      _tao_any,
      CosLoadBalancing::LocationNotFound::_tao_any_destructor,
      CosLoadBalancing::_tc_LocationNotFound,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::LocationNotFound *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::LocationNotFound>::insert (
      _tao_any,
      CosLoadBalancing::LocationNotFound::_tao_any_destructor,
      CosLoadBalancing::_tc_LocationNotFound,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::LocationNotFound *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosLoadBalancing::LocationNotFound *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosLoadBalancing::LocationNotFound *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosLoadBalancing::LocationNotFound>::extract (
        _tao_any,
        CosLoadBalancing::LocationNotFound::_tao_any_destructor,
        CosLoadBalancing::_tc_LocationNotFound,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosLoadBalancing::LoadAlertNotFound>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::LoadAlertNotFound &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LoadAlertNotFound>::insert_copy (
        _tao_any,
        ::CosLoadBalancing::LoadAlertNotFound::_tao_any_destructor,
        ::CosLoadBalancing::_tc_LoadAlertNotFound,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::LoadAlertNotFound *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LoadAlertNotFound>::insert (
        _tao_any,
        ::CosLoadBalancing::LoadAlertNotFound::_tao_any_destructor,
        ::CosLoadBalancing::_tc_LoadAlertNotFound,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::LoadAlertNotFound *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosLoadBalancing::LoadAlertNotFound *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::LoadAlertNotFound *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LoadAlertNotFound>::extract (
          _tao_any,
          ::CosLoadBalancing::LoadAlertNotFound::_tao_any_destructor,
          ::CosLoadBalancing::_tc_LoadAlertNotFound,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosLoadBalancing::LoadAlertNotFound &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::LoadAlertNotFound>::insert_copy (
      _tao_any,
      CosLoadBalancing::LoadAlertNotFound::_tao_any_destructor,
      CosLoadBalancing::_tc_LoadAlertNotFound,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadAlertNotFound *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::LoadAlertNotFound>::insert (
      _tao_any,
      CosLoadBalancing::LoadAlertNotFound::_tao_any_destructor,
      CosLoadBalancing::_tc_LoadAlertNotFound,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadAlertNotFound *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosLoadBalancing::LoadAlertNotFound *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosLoadBalancing::LoadAlertNotFound *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosLoadBalancing::LoadAlertNotFound>::extract (
        _tao_any,
        CosLoadBalancing::LoadAlertNotFound::_tao_any_destructor,
        CosLoadBalancing::_tc_LoadAlertNotFound,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosLoadBalancing::LoadAlertAlreadyPresent>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::LoadAlertAlreadyPresent &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LoadAlertAlreadyPresent>::insert_copy (
        _tao_any,
        ::CosLoadBalancing::LoadAlertAlreadyPresent::_tao_any_destructor,
        ::CosLoadBalancing::_tc_LoadAlertAlreadyPresent,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::LoadAlertAlreadyPresent *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LoadAlertAlreadyPresent>::insert (
        _tao_any,
        ::CosLoadBalancing::LoadAlertAlreadyPresent::_tao_any_destructor,
        ::CosLoadBalancing::_tc_LoadAlertAlreadyPresent,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::LoadAlertAlreadyPresent *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosLoadBalancing::LoadAlertAlreadyPresent *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::LoadAlertAlreadyPresent *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LoadAlertAlreadyPresent>::extract (
          _tao_any,
          ::CosLoadBalancing::LoadAlertAlreadyPresent::_tao_any_destructor,
          ::CosLoadBalancing::_tc_LoadAlertAlreadyPresent,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosLoadBalancing::LoadAlertAlreadyPresent &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::LoadAlertAlreadyPresent>::insert_copy (
      _tao_any,
      CosLoadBalancing::LoadAlertAlreadyPresent::_tao_any_destructor,
      CosLoadBalancing::_tc_LoadAlertAlreadyPresent,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadAlertAlreadyPresent *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::LoadAlertAlreadyPresent>::insert (
      _tao_any,
      CosLoadBalancing::LoadAlertAlreadyPresent::_tao_any_destructor,
      CosLoadBalancing::_tc_LoadAlertAlreadyPresent,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadAlertAlreadyPresent *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosLoadBalancing::LoadAlertAlreadyPresent *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosLoadBalancing::LoadAlertAlreadyPresent *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosLoadBalancing::LoadAlertAlreadyPresent>::extract (
        _tao_any,
        CosLoadBalancing::LoadAlertAlreadyPresent::_tao_any_destructor,
        CosLoadBalancing::_tc_LoadAlertAlreadyPresent,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosLoadBalancing::LoadAlertNotAdded>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::LoadAlertNotAdded &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LoadAlertNotAdded>::insert_copy (
        _tao_any,
        ::CosLoadBalancing::LoadAlertNotAdded::_tao_any_destructor,
        ::CosLoadBalancing::_tc_LoadAlertNotAdded,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::LoadAlertNotAdded *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LoadAlertNotAdded>::insert (
        _tao_any,
        ::CosLoadBalancing::LoadAlertNotAdded::_tao_any_destructor,
        ::CosLoadBalancing::_tc_LoadAlertNotAdded,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::LoadAlertNotAdded *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosLoadBalancing::LoadAlertNotAdded *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::LoadAlertNotAdded *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosLoadBalancing::LoadAlertNotAdded>::extract (
          _tao_any,
          ::CosLoadBalancing::LoadAlertNotAdded::_tao_any_destructor,
          ::CosLoadBalancing::_tc_LoadAlertNotAdded,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosLoadBalancing::LoadAlertNotAdded &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::LoadAlertNotAdded>::insert_copy (
      _tao_any,
      CosLoadBalancing::LoadAlertNotAdded::_tao_any_destructor,
      CosLoadBalancing::_tc_LoadAlertNotAdded,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadAlertNotAdded *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::LoadAlertNotAdded>::insert (
      _tao_any,
      CosLoadBalancing::LoadAlertNotAdded::_tao_any_destructor,
      CosLoadBalancing::_tc_LoadAlertNotAdded,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadAlertNotAdded *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosLoadBalancing::LoadAlertNotAdded *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosLoadBalancing::LoadAlertNotAdded *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosLoadBalancing::LoadAlertNotAdded>::extract (
        _tao_any,
        CosLoadBalancing::LoadAlertNotAdded::_tao_any_destructor,
        CosLoadBalancing::_tc_LoadAlertNotAdded,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosLoadBalancing::StrategyNotAdaptive>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::StrategyNotAdaptive &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::StrategyNotAdaptive>::insert_copy (
        _tao_any,
        ::CosLoadBalancing::StrategyNotAdaptive::_tao_any_destructor,
        ::CosLoadBalancing::_tc_StrategyNotAdaptive,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::StrategyNotAdaptive *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::StrategyNotAdaptive>::insert (
        _tao_any,
        ::CosLoadBalancing::StrategyNotAdaptive::_tao_any_destructor,
        ::CosLoadBalancing::_tc_StrategyNotAdaptive,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::StrategyNotAdaptive *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosLoadBalancing::StrategyNotAdaptive *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::StrategyNotAdaptive *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosLoadBalancing::StrategyNotAdaptive>::extract (
          _tao_any,
          ::CosLoadBalancing::StrategyNotAdaptive::_tao_any_destructor,
          ::CosLoadBalancing::_tc_StrategyNotAdaptive,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosLoadBalancing::StrategyNotAdaptive &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::StrategyNotAdaptive>::insert_copy (
      _tao_any,
      CosLoadBalancing::StrategyNotAdaptive::_tao_any_destructor,
      CosLoadBalancing::_tc_StrategyNotAdaptive,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::StrategyNotAdaptive *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::StrategyNotAdaptive>::insert (
      _tao_any,
      CosLoadBalancing::StrategyNotAdaptive::_tao_any_destructor,
      CosLoadBalancing::_tc_StrategyNotAdaptive,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::StrategyNotAdaptive *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosLoadBalancing::StrategyNotAdaptive *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosLoadBalancing::StrategyNotAdaptive *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosLoadBalancing::StrategyNotAdaptive>::extract (
        _tao_any,
        CosLoadBalancing::StrategyNotAdaptive::_tao_any_destructor,
        CosLoadBalancing::_tc_StrategyNotAdaptive,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosLoadBalancing::Strategy>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Strategy_ptr _tao_elem)
  {
    Strategy_ptr _tao_objptr =
      Strategy::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Strategy_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Strategy>::insert (
        _tao_any,
        Strategy::_tao_any_destructor,
        _tc_Strategy,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Strategy_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Strategy>::extract (
          _tao_any,
          Strategy::_tao_any_destructor,
          _tc_Strategy,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::Strategy_ptr _tao_elem)
{
  CosLoadBalancing::Strategy_ptr _tao_objptr =
    CosLoadBalancing::Strategy::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::Strategy_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosLoadBalancing::Strategy>::insert (
      _tao_any,
      CosLoadBalancing::Strategy::_tao_any_destructor,
      CosLoadBalancing::_tc_Strategy,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::Strategy_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosLoadBalancing::Strategy>::extract (
        _tao_any,
        CosLoadBalancing::Strategy::_tao_any_destructor,
        CosLoadBalancing::_tc_Strategy,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosLoadBalancing::AMI_StrategyHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_StrategyHandler_ptr _tao_elem)
  {
    AMI_StrategyHandler_ptr _tao_objptr =
      AMI_StrategyHandler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_StrategyHandler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AMI_StrategyHandler>::insert (
        _tao_any,
        AMI_StrategyHandler::_tao_any_destructor,
        _tc_AMI_StrategyHandler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMI_StrategyHandler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AMI_StrategyHandler>::extract (
          _tao_any,
          AMI_StrategyHandler::_tao_any_destructor,
          _tc_AMI_StrategyHandler,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::AMI_StrategyHandler_ptr _tao_elem)
{
  CosLoadBalancing::AMI_StrategyHandler_ptr _tao_objptr =
    CosLoadBalancing::AMI_StrategyHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::AMI_StrategyHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosLoadBalancing::AMI_StrategyHandler>::insert (
      _tao_any,
      CosLoadBalancing::AMI_StrategyHandler::_tao_any_destructor,
      CosLoadBalancing::_tc_AMI_StrategyHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::AMI_StrategyHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosLoadBalancing::AMI_StrategyHandler>::extract (
        _tao_any,
        CosLoadBalancing::AMI_StrategyHandler::_tao_any_destructor,
        CosLoadBalancing::_tc_AMI_StrategyHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::StrategyInfo &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosLoadBalancing::StrategyInfo *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosLoadBalancing::StrategyInfo>::insert_copy (
          _tao_any,
          ::CosLoadBalancing::StrategyInfo::_tao_any_destructor,
          ::CosLoadBalancing::_tc_StrategyInfo,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosLoadBalancing::StrategyInfo *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosLoadBalancing::StrategyInfo>::insert (
        _tao_any,
        ::CosLoadBalancing::StrategyInfo::_tao_any_destructor,
        ::CosLoadBalancing::_tc_StrategyInfo,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosLoadBalancing::StrategyInfo *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosLoadBalancing::StrategyInfo *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosLoadBalancing::StrategyInfo *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosLoadBalancing::StrategyInfo>::extract (
          _tao_any,
          ::CosLoadBalancing::StrategyInfo::_tao_any_destructor,
          ::CosLoadBalancing::_tc_StrategyInfo,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosLoadBalancing::StrategyInfo &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosLoadBalancing::StrategyInfo *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosLoadBalancing::StrategyInfo>::insert_copy (
        _tao_any,
        CosLoadBalancing::StrategyInfo::_tao_any_destructor,
        CosLoadBalancing::_tc_StrategyInfo,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::StrategyInfo *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosLoadBalancing::StrategyInfo>::insert (
      _tao_any,
      CosLoadBalancing::StrategyInfo::_tao_any_destructor,
      CosLoadBalancing::_tc_StrategyInfo,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::StrategyInfo *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosLoadBalancing::StrategyInfo *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosLoadBalancing::StrategyInfo *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosLoadBalancing::StrategyInfo>::extract (
        _tao_any,
        CosLoadBalancing::StrategyInfo::_tao_any_destructor,
        CosLoadBalancing::_tc_StrategyInfo,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosLoadBalancing::LoadAlert>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      LoadAlert_ptr _tao_elem)
  {
    LoadAlert_ptr _tao_objptr =
      LoadAlert::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      LoadAlert_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<LoadAlert>::insert (
        _tao_any,
        LoadAlert::_tao_any_destructor,
        _tc_LoadAlert,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      LoadAlert_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<LoadAlert>::extract (
          _tao_any,
          LoadAlert::_tao_any_destructor,
          _tc_LoadAlert,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadAlert_ptr _tao_elem)
{
  CosLoadBalancing::LoadAlert_ptr _tao_objptr =
    CosLoadBalancing::LoadAlert::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadAlert_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosLoadBalancing::LoadAlert>::insert (
      _tao_any,
      CosLoadBalancing::LoadAlert::_tao_any_destructor,
      CosLoadBalancing::_tc_LoadAlert,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadAlert_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosLoadBalancing::LoadAlert>::extract (
        _tao_any,
        CosLoadBalancing::LoadAlert::_tao_any_destructor,
        CosLoadBalancing::_tc_LoadAlert,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosLoadBalancing::AMI_LoadAlertHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_LoadAlertHandler_ptr _tao_elem)
  {
    AMI_LoadAlertHandler_ptr _tao_objptr =
      AMI_LoadAlertHandler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_LoadAlertHandler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AMI_LoadAlertHandler>::insert (
        _tao_any,
        AMI_LoadAlertHandler::_tao_any_destructor,
        _tc_AMI_LoadAlertHandler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMI_LoadAlertHandler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AMI_LoadAlertHandler>::extract (
          _tao_any,
          AMI_LoadAlertHandler::_tao_any_destructor,
          _tc_AMI_LoadAlertHandler,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::AMI_LoadAlertHandler_ptr _tao_elem)
{
  CosLoadBalancing::AMI_LoadAlertHandler_ptr _tao_objptr =
    CosLoadBalancing::AMI_LoadAlertHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::AMI_LoadAlertHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosLoadBalancing::AMI_LoadAlertHandler>::insert (
      _tao_any,
      CosLoadBalancing::AMI_LoadAlertHandler::_tao_any_destructor,
      CosLoadBalancing::_tc_AMI_LoadAlertHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::AMI_LoadAlertHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosLoadBalancing::AMI_LoadAlertHandler>::extract (
        _tao_any,
        CosLoadBalancing::AMI_LoadAlertHandler::_tao_any_destructor,
        CosLoadBalancing::_tc_AMI_LoadAlertHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosLoadBalancing::LoadMonitor>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      LoadMonitor_ptr _tao_elem)
  {
    LoadMonitor_ptr _tao_objptr =
      LoadMonitor::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      LoadMonitor_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<LoadMonitor>::insert (
        _tao_any,
        LoadMonitor::_tao_any_destructor,
        _tc_LoadMonitor,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      LoadMonitor_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<LoadMonitor>::extract (
          _tao_any,
          LoadMonitor::_tao_any_destructor,
          _tc_LoadMonitor,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadMonitor_ptr _tao_elem)
{
  CosLoadBalancing::LoadMonitor_ptr _tao_objptr =
    CosLoadBalancing::LoadMonitor::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadMonitor_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosLoadBalancing::LoadMonitor>::insert (
      _tao_any,
      CosLoadBalancing::LoadMonitor::_tao_any_destructor,
      CosLoadBalancing::_tc_LoadMonitor,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadMonitor_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosLoadBalancing::LoadMonitor>::extract (
        _tao_any,
        CosLoadBalancing::LoadMonitor::_tao_any_destructor,
        CosLoadBalancing::_tc_LoadMonitor,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosLoadBalancing::AMI_LoadMonitorHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_LoadMonitorHandler_ptr _tao_elem)
  {
    AMI_LoadMonitorHandler_ptr _tao_objptr =
      AMI_LoadMonitorHandler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_LoadMonitorHandler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AMI_LoadMonitorHandler>::insert (
        _tao_any,
        AMI_LoadMonitorHandler::_tao_any_destructor,
        _tc_AMI_LoadMonitorHandler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMI_LoadMonitorHandler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AMI_LoadMonitorHandler>::extract (
          _tao_any,
          AMI_LoadMonitorHandler::_tao_any_destructor,
          _tc_AMI_LoadMonitorHandler,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::AMI_LoadMonitorHandler_ptr _tao_elem)
{
  CosLoadBalancing::AMI_LoadMonitorHandler_ptr _tao_objptr =
    CosLoadBalancing::AMI_LoadMonitorHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::AMI_LoadMonitorHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosLoadBalancing::AMI_LoadMonitorHandler>::insert (
      _tao_any,
      CosLoadBalancing::AMI_LoadMonitorHandler::_tao_any_destructor,
      CosLoadBalancing::_tc_AMI_LoadMonitorHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::AMI_LoadMonitorHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosLoadBalancing::AMI_LoadMonitorHandler>::extract (
        _tao_any,
        CosLoadBalancing::AMI_LoadMonitorHandler::_tao_any_destructor,
        CosLoadBalancing::_tc_AMI_LoadMonitorHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosLoadBalancing::LoadManager>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      LoadManager_ptr _tao_elem)
  {
    LoadManager_ptr _tao_objptr =
      LoadManager::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      LoadManager_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<LoadManager>::insert (
        _tao_any,
        LoadManager::_tao_any_destructor,
        _tc_LoadManager,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      LoadManager_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<LoadManager>::extract (
          _tao_any,
          LoadManager::_tao_any_destructor,
          _tc_LoadManager,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadManager_ptr _tao_elem)
{
  CosLoadBalancing::LoadManager_ptr _tao_objptr =
    CosLoadBalancing::LoadManager::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadManager_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosLoadBalancing::LoadManager>::insert (
      _tao_any,
      CosLoadBalancing::LoadManager::_tao_any_destructor,
      CosLoadBalancing::_tc_LoadManager,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::LoadManager_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosLoadBalancing::LoadManager>::extract (
        _tao_any,
        CosLoadBalancing::LoadManager::_tao_any_destructor,
        CosLoadBalancing::_tc_LoadManager,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosLoadBalancing::AMI_LoadManagerHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosLoadBalancing
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_LoadManagerHandler_ptr _tao_elem)
  {
    AMI_LoadManagerHandler_ptr _tao_objptr =
      AMI_LoadManagerHandler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_LoadManagerHandler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AMI_LoadManagerHandler>::insert (
        _tao_any,
        AMI_LoadManagerHandler::_tao_any_destructor,
        _tc_AMI_LoadManagerHandler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMI_LoadManagerHandler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AMI_LoadManagerHandler>::extract (
          _tao_any,
          AMI_LoadManagerHandler::_tao_any_destructor,
          _tc_AMI_LoadManagerHandler,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::AMI_LoadManagerHandler_ptr _tao_elem)
{
  CosLoadBalancing::AMI_LoadManagerHandler_ptr _tao_objptr =
    CosLoadBalancing::AMI_LoadManagerHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosLoadBalancing::AMI_LoadManagerHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosLoadBalancing::AMI_LoadManagerHandler>::insert (
      _tao_any,
      CosLoadBalancing::AMI_LoadManagerHandler::_tao_any_destructor,
      CosLoadBalancing::_tc_AMI_LoadManagerHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosLoadBalancing::AMI_LoadManagerHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosLoadBalancing::AMI_LoadManagerHandler>::extract (
        _tao_any,
        CosLoadBalancing::AMI_LoadManagerHandler::_tao_any_destructor,
        CosLoadBalancing::_tc_AMI_LoadManagerHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::Load &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.id) &&
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosLoadBalancing::Load &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.id) &&
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosLoadBalancing_LoadList_CPP_
#define _TAO_CDR_OP_CosLoadBalancing_LoadList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::LoadList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosLoadBalancing::LoadList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosLoadBalancing_LoadList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::MonitorAlreadyPresent &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CosLoadBalancing::MonitorAlreadyPresent&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::LocationNotFound &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CosLoadBalancing::LocationNotFound&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::LoadAlertNotFound &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CosLoadBalancing::LoadAlertNotFound&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::LoadAlertAlreadyPresent &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CosLoadBalancing::LoadAlertAlreadyPresent&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::LoadAlertNotAdded &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CosLoadBalancing::LoadAlertNotAdded&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::StrategyNotAdaptive &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CosLoadBalancing::StrategyNotAdaptive&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::Strategy_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosLoadBalancing::Strategy_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosLoadBalancing::Strategy RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_Strategy_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::AMI_StrategyHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosLoadBalancing::AMI_StrategyHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosLoadBalancing::AMI_StrategyHandler RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_AMI_StrategyHandler_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::StrategyInfo &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.props);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosLoadBalancing::StrategyInfo &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.props);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::LoadAlert_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosLoadBalancing::LoadAlert_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosLoadBalancing::LoadAlert RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_LoadAlert_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::AMI_LoadAlertHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosLoadBalancing::AMI_LoadAlertHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosLoadBalancing::AMI_LoadAlertHandler RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_AMI_LoadAlertHandler_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::LoadMonitor_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosLoadBalancing::LoadMonitor_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosLoadBalancing::LoadMonitor RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_LoadMonitor_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::AMI_LoadMonitorHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosLoadBalancing::AMI_LoadMonitorHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosLoadBalancing::AMI_LoadMonitorHandler RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_AMI_LoadMonitorHandler_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::LoadManager_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosLoadBalancing::LoadManager_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosLoadBalancing::LoadManager RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_LoadManager_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosLoadBalancing::AMI_LoadManagerHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosLoadBalancing::AMI_LoadManagerHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosLoadBalancing::AMI_LoadManagerHandler RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosLoadBalancing__TAO_AMI_LoadManagerHandler_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL





TAO_END_VERSIONED_NAMESPACE_DECL


