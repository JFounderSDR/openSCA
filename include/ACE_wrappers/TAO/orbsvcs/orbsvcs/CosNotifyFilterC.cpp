// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "CosNotifyFilterC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "CosNotifyFilterC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosNotifyFilter_ConstraintID (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosNotifyFilter/ConstraintID:1.0",
    "ConstraintID",
    &CORBA::_tc_long);
  

namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_ConstraintID =
    &_tao_tc_CosNotifyFilter_ConstraintID;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosNotifyFilter_ConstraintExp[] =
      {
        { "event_types", &CosNotification::_tc_EventTypeSeq },
        { "constraint_expr", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosNotifyFilter_ConstraintExp (
  ::CORBA::tk_struct,
  "IDL:omg.org/CosNotifyFilter/ConstraintExp:1.0",
  "ConstraintExp",
  _tao_fields_CosNotifyFilter_ConstraintExp,
  2);


namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_ConstraintExp =
    &_tao_tc_CosNotifyFilter_ConstraintExp;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosNotifyFilter::ConstraintExp::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ConstraintExp *_tao_tmp_pointer =
    static_cast<ConstraintExp *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSNOTIFYFILTER_CONSTRAINTIDSEQ_CS_)
#define _COSNOTIFYFILTER_CONSTRAINTIDSEQ_CS_

CosNotifyFilter::ConstraintIDSeq::ConstraintIDSeq (void)
{}

CosNotifyFilter::ConstraintIDSeq::ConstraintIDSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ConstraintID
      > (max)
{}

CosNotifyFilter::ConstraintIDSeq::ConstraintIDSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ConstraintID
      >
    (max, length, buffer, release)
{}

CosNotifyFilter::ConstraintIDSeq::ConstraintIDSeq (
    const ConstraintIDSeq &seq)
  : ::TAO::unbounded_value_sequence<
        ConstraintID
      > (seq)
{}

CosNotifyFilter::ConstraintIDSeq::~ConstraintIDSeq (void)
{}

void CosNotifyFilter::ConstraintIDSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ConstraintIDSeq * _tao_tmp_pointer =
    static_cast<ConstraintIDSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosNotifyFilter_ConstraintIDSeq_GUARD
#define _TAO_TYPECODE_CosNotifyFilter_ConstraintIDSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosNotifyFilter_ConstraintIDSeq_0 (
          ::CORBA::tk_sequence,
          &CosNotifyFilter::_tc_ConstraintID,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosNotifyFilter_ConstraintIDSeq_0 =
        &CosNotifyFilter_ConstraintIDSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosNotifyFilter_ConstraintIDSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosNotifyFilter_ConstraintIDSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosNotifyFilter/ConstraintIDSeq:1.0",
    "ConstraintIDSeq",
    &TAO::TypeCode::tc_CosNotifyFilter_ConstraintIDSeq_0);
  

namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_ConstraintIDSeq =
    &_tao_tc_CosNotifyFilter_ConstraintIDSeq;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSNOTIFYFILTER_CONSTRAINTEXPSEQ_CS_)
#define _COSNOTIFYFILTER_CONSTRAINTEXPSEQ_CS_

CosNotifyFilter::ConstraintExpSeq::ConstraintExpSeq (void)
{}

CosNotifyFilter::ConstraintExpSeq::ConstraintExpSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ConstraintExp
      > (max)
{}

CosNotifyFilter::ConstraintExpSeq::ConstraintExpSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CosNotifyFilter::ConstraintExp * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ConstraintExp
      >
    (max, length, buffer, release)
{}

CosNotifyFilter::ConstraintExpSeq::ConstraintExpSeq (
    const ConstraintExpSeq &seq)
  : ::TAO::unbounded_value_sequence<
        ConstraintExp
      > (seq)
{}

CosNotifyFilter::ConstraintExpSeq::~ConstraintExpSeq (void)
{}

void CosNotifyFilter::ConstraintExpSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ConstraintExpSeq * _tao_tmp_pointer =
    static_cast<ConstraintExpSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosNotifyFilter_ConstraintExpSeq_GUARD
#define _TAO_TYPECODE_CosNotifyFilter_ConstraintExpSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosNotifyFilter_ConstraintExpSeq_0 (
          ::CORBA::tk_sequence,
          &CosNotifyFilter::_tc_ConstraintExp,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosNotifyFilter_ConstraintExpSeq_0 =
        &CosNotifyFilter_ConstraintExpSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosNotifyFilter_ConstraintExpSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosNotifyFilter_ConstraintExpSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosNotifyFilter/ConstraintExpSeq:1.0",
    "ConstraintExpSeq",
    &TAO::TypeCode::tc_CosNotifyFilter_ConstraintExpSeq_0);
  

namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_ConstraintExpSeq =
    &_tao_tc_CosNotifyFilter_ConstraintExpSeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosNotifyFilter_ConstraintInfo[] =
      {
        { "constraint_expression", &CosNotifyFilter::_tc_ConstraintExp },
        { "constraint_id", &CosNotifyFilter::_tc_ConstraintID }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosNotifyFilter_ConstraintInfo (
  ::CORBA::tk_struct,
  "IDL:omg.org/CosNotifyFilter/ConstraintInfo:1.0",
  "ConstraintInfo",
  _tao_fields_CosNotifyFilter_ConstraintInfo,
  2);


namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_ConstraintInfo =
    &_tao_tc_CosNotifyFilter_ConstraintInfo;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosNotifyFilter::ConstraintInfo::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ConstraintInfo *_tao_tmp_pointer =
    static_cast<ConstraintInfo *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSNOTIFYFILTER_CONSTRAINTINFOSEQ_CS_)
#define _COSNOTIFYFILTER_CONSTRAINTINFOSEQ_CS_

CosNotifyFilter::ConstraintInfoSeq::ConstraintInfoSeq (void)
{}

CosNotifyFilter::ConstraintInfoSeq::ConstraintInfoSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ConstraintInfo
      > (max)
{}

CosNotifyFilter::ConstraintInfoSeq::ConstraintInfoSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CosNotifyFilter::ConstraintInfo * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ConstraintInfo
      >
    (max, length, buffer, release)
{}

CosNotifyFilter::ConstraintInfoSeq::ConstraintInfoSeq (
    const ConstraintInfoSeq &seq)
  : ::TAO::unbounded_value_sequence<
        ConstraintInfo
      > (seq)
{}

CosNotifyFilter::ConstraintInfoSeq::~ConstraintInfoSeq (void)
{}

void CosNotifyFilter::ConstraintInfoSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ConstraintInfoSeq * _tao_tmp_pointer =
    static_cast<ConstraintInfoSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosNotifyFilter_ConstraintInfoSeq_GUARD
#define _TAO_TYPECODE_CosNotifyFilter_ConstraintInfoSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosNotifyFilter_ConstraintInfoSeq_0 (
          ::CORBA::tk_sequence,
          &CosNotifyFilter::_tc_ConstraintInfo,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosNotifyFilter_ConstraintInfoSeq_0 =
        &CosNotifyFilter_ConstraintInfoSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosNotifyFilter_ConstraintInfoSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosNotifyFilter_ConstraintInfoSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosNotifyFilter/ConstraintInfoSeq:1.0",
    "ConstraintInfoSeq",
    &TAO::TypeCode::tc_CosNotifyFilter_ConstraintInfoSeq_0);
  

namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_ConstraintInfoSeq =
    &_tao_tc_CosNotifyFilter_ConstraintInfoSeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosNotifyFilter_MappingConstraintPair[] =
      {
        { "constraint_expression", &CosNotifyFilter::_tc_ConstraintExp },
        { "result_to_set", &CORBA::_tc_any }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosNotifyFilter_MappingConstraintPair (
  ::CORBA::tk_struct,
  "IDL:omg.org/CosNotifyFilter/MappingConstraintPair:1.0",
  "MappingConstraintPair",
  _tao_fields_CosNotifyFilter_MappingConstraintPair,
  2);


namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_MappingConstraintPair =
    &_tao_tc_CosNotifyFilter_MappingConstraintPair;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosNotifyFilter::MappingConstraintPair::_tao_any_destructor (
    void *_tao_void_pointer)
{
  MappingConstraintPair *_tao_tmp_pointer =
    static_cast<MappingConstraintPair *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSNOTIFYFILTER_MAPPINGCONSTRAINTPAIRSEQ_CS_)
#define _COSNOTIFYFILTER_MAPPINGCONSTRAINTPAIRSEQ_CS_

CosNotifyFilter::MappingConstraintPairSeq::MappingConstraintPairSeq (void)
{}

CosNotifyFilter::MappingConstraintPairSeq::MappingConstraintPairSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        MappingConstraintPair
      > (max)
{}

CosNotifyFilter::MappingConstraintPairSeq::MappingConstraintPairSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CosNotifyFilter::MappingConstraintPair * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        MappingConstraintPair
      >
    (max, length, buffer, release)
{}

CosNotifyFilter::MappingConstraintPairSeq::MappingConstraintPairSeq (
    const MappingConstraintPairSeq &seq)
  : ::TAO::unbounded_value_sequence<
        MappingConstraintPair
      > (seq)
{}

CosNotifyFilter::MappingConstraintPairSeq::~MappingConstraintPairSeq (void)
{}

void CosNotifyFilter::MappingConstraintPairSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  MappingConstraintPairSeq * _tao_tmp_pointer =
    static_cast<MappingConstraintPairSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosNotifyFilter_MappingConstraintPairSeq_GUARD
#define _TAO_TYPECODE_CosNotifyFilter_MappingConstraintPairSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosNotifyFilter_MappingConstraintPairSeq_0 (
          ::CORBA::tk_sequence,
          &CosNotifyFilter::_tc_MappingConstraintPair,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosNotifyFilter_MappingConstraintPairSeq_0 =
        &CosNotifyFilter_MappingConstraintPairSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosNotifyFilter_MappingConstraintPairSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosNotifyFilter_MappingConstraintPairSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosNotifyFilter/MappingConstraintPairSeq:1.0",
    "MappingConstraintPairSeq",
    &TAO::TypeCode::tc_CosNotifyFilter_MappingConstraintPairSeq_0);
  

namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_MappingConstraintPairSeq =
    &_tao_tc_CosNotifyFilter_MappingConstraintPairSeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosNotifyFilter_MappingConstraintInfo[] =
      {
        { "constraint_expression", &CosNotifyFilter::_tc_ConstraintExp },
        { "constraint_id", &CosNotifyFilter::_tc_ConstraintID },
        { "value", &CORBA::_tc_any }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosNotifyFilter_MappingConstraintInfo (
  ::CORBA::tk_struct,
  "IDL:omg.org/CosNotifyFilter/MappingConstraintInfo:1.0",
  "MappingConstraintInfo",
  _tao_fields_CosNotifyFilter_MappingConstraintInfo,
  3);


namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_MappingConstraintInfo =
    &_tao_tc_CosNotifyFilter_MappingConstraintInfo;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CosNotifyFilter::MappingConstraintInfo::_tao_any_destructor (
    void *_tao_void_pointer)
{
  MappingConstraintInfo *_tao_tmp_pointer =
    static_cast<MappingConstraintInfo *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSNOTIFYFILTER_MAPPINGCONSTRAINTINFOSEQ_CS_)
#define _COSNOTIFYFILTER_MAPPINGCONSTRAINTINFOSEQ_CS_

CosNotifyFilter::MappingConstraintInfoSeq::MappingConstraintInfoSeq (void)
{}

CosNotifyFilter::MappingConstraintInfoSeq::MappingConstraintInfoSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        MappingConstraintInfo
      > (max)
{}

CosNotifyFilter::MappingConstraintInfoSeq::MappingConstraintInfoSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CosNotifyFilter::MappingConstraintInfo * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        MappingConstraintInfo
      >
    (max, length, buffer, release)
{}

CosNotifyFilter::MappingConstraintInfoSeq::MappingConstraintInfoSeq (
    const MappingConstraintInfoSeq &seq)
  : ::TAO::unbounded_value_sequence<
        MappingConstraintInfo
      > (seq)
{}

CosNotifyFilter::MappingConstraintInfoSeq::~MappingConstraintInfoSeq (void)
{}

void CosNotifyFilter::MappingConstraintInfoSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  MappingConstraintInfoSeq * _tao_tmp_pointer =
    static_cast<MappingConstraintInfoSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosNotifyFilter_MappingConstraintInfoSeq_GUARD
#define _TAO_TYPECODE_CosNotifyFilter_MappingConstraintInfoSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosNotifyFilter_MappingConstraintInfoSeq_0 (
          ::CORBA::tk_sequence,
          &CosNotifyFilter::_tc_MappingConstraintInfo,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosNotifyFilter_MappingConstraintInfoSeq_0 =
        &CosNotifyFilter_MappingConstraintInfoSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosNotifyFilter_MappingConstraintInfoSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosNotifyFilter_MappingConstraintInfoSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosNotifyFilter/MappingConstraintInfoSeq:1.0",
    "MappingConstraintInfoSeq",
    &TAO::TypeCode::tc_CosNotifyFilter_MappingConstraintInfoSeq_0);
  

namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_MappingConstraintInfoSeq =
    &_tao_tc_CosNotifyFilter_MappingConstraintInfoSeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosNotifyFilter_CallbackID (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosNotifyFilter/CallbackID:1.0",
    "CallbackID",
    &CORBA::_tc_long);
  

namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_CallbackID =
    &_tao_tc_CosNotifyFilter_CallbackID;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSNOTIFYFILTER_CALLBACKIDSEQ_CS_)
#define _COSNOTIFYFILTER_CALLBACKIDSEQ_CS_

CosNotifyFilter::CallbackIDSeq::CallbackIDSeq (void)
{}

CosNotifyFilter::CallbackIDSeq::CallbackIDSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        CallbackID
      > (max)
{}

CosNotifyFilter::CallbackIDSeq::CallbackIDSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        CallbackID
      >
    (max, length, buffer, release)
{}

CosNotifyFilter::CallbackIDSeq::CallbackIDSeq (
    const CallbackIDSeq &seq)
  : ::TAO::unbounded_value_sequence<
        CallbackID
      > (seq)
{}

CosNotifyFilter::CallbackIDSeq::~CallbackIDSeq (void)
{}

void CosNotifyFilter::CallbackIDSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  CallbackIDSeq * _tao_tmp_pointer =
    static_cast<CallbackIDSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosNotifyFilter_CallbackIDSeq_GUARD
#define _TAO_TYPECODE_CosNotifyFilter_CallbackIDSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosNotifyFilter_CallbackIDSeq_0 (
          ::CORBA::tk_sequence,
          &CosNotifyFilter::_tc_CallbackID,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosNotifyFilter_CallbackIDSeq_0 =
        &CosNotifyFilter_CallbackIDSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosNotifyFilter_CallbackIDSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosNotifyFilter_CallbackIDSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosNotifyFilter/CallbackIDSeq:1.0",
    "CallbackIDSeq",
    &TAO::TypeCode::tc_CosNotifyFilter_CallbackIDSeq_0);
  

namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_CallbackIDSeq =
    &_tao_tc_CosNotifyFilter_CallbackIDSeq;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosNotifyFilter::UnsupportedFilterableData::UnsupportedFilterableData (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosNotifyFilter/UnsupportedFilterableData:1.0",
        "UnsupportedFilterableData"
      )
{
}

CosNotifyFilter::UnsupportedFilterableData::~UnsupportedFilterableData (void)
{
}

CosNotifyFilter::UnsupportedFilterableData::UnsupportedFilterableData (const ::CosNotifyFilter::UnsupportedFilterableData &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CosNotifyFilter::UnsupportedFilterableData&
CosNotifyFilter::UnsupportedFilterableData::operator= (const ::CosNotifyFilter::UnsupportedFilterableData &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CosNotifyFilter::UnsupportedFilterableData::_tao_any_destructor (void *_tao_void_pointer)
{
  UnsupportedFilterableData *_tao_tmp_pointer =
    static_cast<UnsupportedFilterableData *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosNotifyFilter::UnsupportedFilterableData *
CosNotifyFilter::UnsupportedFilterableData::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<UnsupportedFilterableData *> (_tao_excp);
}

const CosNotifyFilter::UnsupportedFilterableData *
CosNotifyFilter::UnsupportedFilterableData::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const UnsupportedFilterableData *> (_tao_excp);
}

::CORBA::Exception *CosNotifyFilter::UnsupportedFilterableData::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosNotifyFilter::UnsupportedFilterableData, 0);
  return retval;
}

::CORBA::Exception *
CosNotifyFilter::UnsupportedFilterableData::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosNotifyFilter::UnsupportedFilterableData (*this),
      0
    );
  return result;
}

void CosNotifyFilter::UnsupportedFilterableData::_raise (void) const
{
  throw *this;
}

void CosNotifyFilter::UnsupportedFilterableData::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosNotifyFilter::UnsupportedFilterableData::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosNotifyFilter::UnsupportedFilterableData::_tao_type (void) const
{
  return ::CosNotifyFilter::_tc_UnsupportedFilterableData;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CosNotifyFilter_UnsupportedFilterableData = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosNotifyFilter_UnsupportedFilterableData (
  ::CORBA::tk_except,
  "IDL:omg.org/CosNotifyFilter/UnsupportedFilterableData:1.0",
  "UnsupportedFilterableData",
  _tao_fields_CosNotifyFilter_UnsupportedFilterableData,
  0);


namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_UnsupportedFilterableData =
    &_tao_tc_CosNotifyFilter_UnsupportedFilterableData;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosNotifyFilter::InvalidGrammar::InvalidGrammar (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosNotifyFilter/InvalidGrammar:1.0",
        "InvalidGrammar"
      )
{
}

CosNotifyFilter::InvalidGrammar::~InvalidGrammar (void)
{
}

CosNotifyFilter::InvalidGrammar::InvalidGrammar (const ::CosNotifyFilter::InvalidGrammar &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CosNotifyFilter::InvalidGrammar&
CosNotifyFilter::InvalidGrammar::operator= (const ::CosNotifyFilter::InvalidGrammar &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CosNotifyFilter::InvalidGrammar::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidGrammar *_tao_tmp_pointer =
    static_cast<InvalidGrammar *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosNotifyFilter::InvalidGrammar *
CosNotifyFilter::InvalidGrammar::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidGrammar *> (_tao_excp);
}

const CosNotifyFilter::InvalidGrammar *
CosNotifyFilter::InvalidGrammar::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidGrammar *> (_tao_excp);
}

::CORBA::Exception *CosNotifyFilter::InvalidGrammar::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosNotifyFilter::InvalidGrammar, 0);
  return retval;
}

::CORBA::Exception *
CosNotifyFilter::InvalidGrammar::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosNotifyFilter::InvalidGrammar (*this),
      0
    );
  return result;
}

void CosNotifyFilter::InvalidGrammar::_raise (void) const
{
  throw *this;
}

void CosNotifyFilter::InvalidGrammar::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosNotifyFilter::InvalidGrammar::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosNotifyFilter::InvalidGrammar::_tao_type (void) const
{
  return ::CosNotifyFilter::_tc_InvalidGrammar;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CosNotifyFilter_InvalidGrammar = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosNotifyFilter_InvalidGrammar (
  ::CORBA::tk_except,
  "IDL:omg.org/CosNotifyFilter/InvalidGrammar:1.0",
  "InvalidGrammar",
  _tao_fields_CosNotifyFilter_InvalidGrammar,
  0);


namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_InvalidGrammar =
    &_tao_tc_CosNotifyFilter_InvalidGrammar;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosNotifyFilter::InvalidConstraint::InvalidConstraint (
    const CosNotifyFilter::ConstraintExp & _tao_constr)
  : ::CORBA::UserException (
        "IDL:omg.org/CosNotifyFilter/InvalidConstraint:1.0",
        "InvalidConstraint"
      )
{
  this->constr = _tao_constr;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosNotifyFilter::InvalidConstraint::InvalidConstraint (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosNotifyFilter/InvalidConstraint:1.0",
        "InvalidConstraint"
      )
{
}

CosNotifyFilter::InvalidConstraint::~InvalidConstraint (void)
{
}

CosNotifyFilter::InvalidConstraint::InvalidConstraint (const ::CosNotifyFilter::InvalidConstraint &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->constr = _tao_excp.constr;
}

CosNotifyFilter::InvalidConstraint&
CosNotifyFilter::InvalidConstraint::operator= (const ::CosNotifyFilter::InvalidConstraint &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->constr = _tao_excp.constr;
  return *this;
}

void CosNotifyFilter::InvalidConstraint::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidConstraint *_tao_tmp_pointer =
    static_cast<InvalidConstraint *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosNotifyFilter::InvalidConstraint *
CosNotifyFilter::InvalidConstraint::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidConstraint *> (_tao_excp);
}

const CosNotifyFilter::InvalidConstraint *
CosNotifyFilter::InvalidConstraint::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidConstraint *> (_tao_excp);
}

::CORBA::Exception *CosNotifyFilter::InvalidConstraint::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosNotifyFilter::InvalidConstraint, 0);
  return retval;
}

::CORBA::Exception *
CosNotifyFilter::InvalidConstraint::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosNotifyFilter::InvalidConstraint (*this),
      0
    );
  return result;
}

void CosNotifyFilter::InvalidConstraint::_raise (void) const
{
  throw *this;
}

void CosNotifyFilter::InvalidConstraint::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosNotifyFilter::InvalidConstraint::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosNotifyFilter::InvalidConstraint::_tao_type (void) const
{
  return ::CosNotifyFilter::_tc_InvalidConstraint;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosNotifyFilter_InvalidConstraint[] =
      {
        { "constr", &CosNotifyFilter::_tc_ConstraintExp }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosNotifyFilter_InvalidConstraint (
  ::CORBA::tk_except,
  "IDL:omg.org/CosNotifyFilter/InvalidConstraint:1.0",
  "InvalidConstraint",
  _tao_fields_CosNotifyFilter_InvalidConstraint,
  1);


namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_InvalidConstraint =
    &_tao_tc_CosNotifyFilter_InvalidConstraint;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosNotifyFilter::DuplicateConstraintID::DuplicateConstraintID (
    ::CosNotifyFilter::ConstraintID _tao_id)
  : ::CORBA::UserException (
        "IDL:omg.org/CosNotifyFilter/DuplicateConstraintID:1.0",
        "DuplicateConstraintID"
      )
{
  this->id = _tao_id;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosNotifyFilter::DuplicateConstraintID::DuplicateConstraintID (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosNotifyFilter/DuplicateConstraintID:1.0",
        "DuplicateConstraintID"
      )
{
}

CosNotifyFilter::DuplicateConstraintID::~DuplicateConstraintID (void)
{
}

CosNotifyFilter::DuplicateConstraintID::DuplicateConstraintID (const ::CosNotifyFilter::DuplicateConstraintID &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->id = _tao_excp.id;
}

CosNotifyFilter::DuplicateConstraintID&
CosNotifyFilter::DuplicateConstraintID::operator= (const ::CosNotifyFilter::DuplicateConstraintID &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->id = _tao_excp.id;
  return *this;
}

void CosNotifyFilter::DuplicateConstraintID::_tao_any_destructor (void *_tao_void_pointer)
{
  DuplicateConstraintID *_tao_tmp_pointer =
    static_cast<DuplicateConstraintID *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosNotifyFilter::DuplicateConstraintID *
CosNotifyFilter::DuplicateConstraintID::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<DuplicateConstraintID *> (_tao_excp);
}

const CosNotifyFilter::DuplicateConstraintID *
CosNotifyFilter::DuplicateConstraintID::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const DuplicateConstraintID *> (_tao_excp);
}

::CORBA::Exception *CosNotifyFilter::DuplicateConstraintID::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosNotifyFilter::DuplicateConstraintID, 0);
  return retval;
}

::CORBA::Exception *
CosNotifyFilter::DuplicateConstraintID::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosNotifyFilter::DuplicateConstraintID (*this),
      0
    );
  return result;
}

void CosNotifyFilter::DuplicateConstraintID::_raise (void) const
{
  throw *this;
}

void CosNotifyFilter::DuplicateConstraintID::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosNotifyFilter::DuplicateConstraintID::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosNotifyFilter::DuplicateConstraintID::_tao_type (void) const
{
  return ::CosNotifyFilter::_tc_DuplicateConstraintID;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosNotifyFilter_DuplicateConstraintID[] =
      {
        { "id", &CosNotifyFilter::_tc_ConstraintID }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosNotifyFilter_DuplicateConstraintID (
  ::CORBA::tk_except,
  "IDL:omg.org/CosNotifyFilter/DuplicateConstraintID:1.0",
  "DuplicateConstraintID",
  _tao_fields_CosNotifyFilter_DuplicateConstraintID,
  1);


namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_DuplicateConstraintID =
    &_tao_tc_CosNotifyFilter_DuplicateConstraintID;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosNotifyFilter::ConstraintNotFound::ConstraintNotFound (
    ::CosNotifyFilter::ConstraintID _tao_id)
  : ::CORBA::UserException (
        "IDL:omg.org/CosNotifyFilter/ConstraintNotFound:1.0",
        "ConstraintNotFound"
      )
{
  this->id = _tao_id;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosNotifyFilter::ConstraintNotFound::ConstraintNotFound (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosNotifyFilter/ConstraintNotFound:1.0",
        "ConstraintNotFound"
      )
{
}

CosNotifyFilter::ConstraintNotFound::~ConstraintNotFound (void)
{
}

CosNotifyFilter::ConstraintNotFound::ConstraintNotFound (const ::CosNotifyFilter::ConstraintNotFound &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->id = _tao_excp.id;
}

CosNotifyFilter::ConstraintNotFound&
CosNotifyFilter::ConstraintNotFound::operator= (const ::CosNotifyFilter::ConstraintNotFound &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->id = _tao_excp.id;
  return *this;
}

void CosNotifyFilter::ConstraintNotFound::_tao_any_destructor (void *_tao_void_pointer)
{
  ConstraintNotFound *_tao_tmp_pointer =
    static_cast<ConstraintNotFound *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosNotifyFilter::ConstraintNotFound *
CosNotifyFilter::ConstraintNotFound::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ConstraintNotFound *> (_tao_excp);
}

const CosNotifyFilter::ConstraintNotFound *
CosNotifyFilter::ConstraintNotFound::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ConstraintNotFound *> (_tao_excp);
}

::CORBA::Exception *CosNotifyFilter::ConstraintNotFound::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosNotifyFilter::ConstraintNotFound, 0);
  return retval;
}

::CORBA::Exception *
CosNotifyFilter::ConstraintNotFound::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosNotifyFilter::ConstraintNotFound (*this),
      0
    );
  return result;
}

void CosNotifyFilter::ConstraintNotFound::_raise (void) const
{
  throw *this;
}

void CosNotifyFilter::ConstraintNotFound::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosNotifyFilter::ConstraintNotFound::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosNotifyFilter::ConstraintNotFound::_tao_type (void) const
{
  return ::CosNotifyFilter::_tc_ConstraintNotFound;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosNotifyFilter_ConstraintNotFound[] =
      {
        { "id", &CosNotifyFilter::_tc_ConstraintID }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosNotifyFilter_ConstraintNotFound (
  ::CORBA::tk_except,
  "IDL:omg.org/CosNotifyFilter/ConstraintNotFound:1.0",
  "ConstraintNotFound",
  _tao_fields_CosNotifyFilter_ConstraintNotFound,
  1);


namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_ConstraintNotFound =
    &_tao_tc_CosNotifyFilter_ConstraintNotFound;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosNotifyFilter::CallbackNotFound::CallbackNotFound (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosNotifyFilter/CallbackNotFound:1.0",
        "CallbackNotFound"
      )
{
}

CosNotifyFilter::CallbackNotFound::~CallbackNotFound (void)
{
}

CosNotifyFilter::CallbackNotFound::CallbackNotFound (const ::CosNotifyFilter::CallbackNotFound &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CosNotifyFilter::CallbackNotFound&
CosNotifyFilter::CallbackNotFound::operator= (const ::CosNotifyFilter::CallbackNotFound &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CosNotifyFilter::CallbackNotFound::_tao_any_destructor (void *_tao_void_pointer)
{
  CallbackNotFound *_tao_tmp_pointer =
    static_cast<CallbackNotFound *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosNotifyFilter::CallbackNotFound *
CosNotifyFilter::CallbackNotFound::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<CallbackNotFound *> (_tao_excp);
}

const CosNotifyFilter::CallbackNotFound *
CosNotifyFilter::CallbackNotFound::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const CallbackNotFound *> (_tao_excp);
}

::CORBA::Exception *CosNotifyFilter::CallbackNotFound::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosNotifyFilter::CallbackNotFound, 0);
  return retval;
}

::CORBA::Exception *
CosNotifyFilter::CallbackNotFound::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosNotifyFilter::CallbackNotFound (*this),
      0
    );
  return result;
}

void CosNotifyFilter::CallbackNotFound::_raise (void) const
{
  throw *this;
}

void CosNotifyFilter::CallbackNotFound::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosNotifyFilter::CallbackNotFound::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosNotifyFilter::CallbackNotFound::_tao_type (void) const
{
  return ::CosNotifyFilter::_tc_CallbackNotFound;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CosNotifyFilter_CallbackNotFound = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosNotifyFilter_CallbackNotFound (
  ::CORBA::tk_except,
  "IDL:omg.org/CosNotifyFilter/CallbackNotFound:1.0",
  "CallbackNotFound",
  _tao_fields_CosNotifyFilter_CallbackNotFound,
  0);


namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_CallbackNotFound =
    &_tao_tc_CosNotifyFilter_CallbackNotFound;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

CosNotifyFilter::InvalidValue::InvalidValue (
    const CosNotifyFilter::ConstraintExp & _tao_constr,
    const ::CORBA::Any & _tao_value)
  : ::CORBA::UserException (
        "IDL:omg.org/CosNotifyFilter/InvalidValue:1.0",
        "InvalidValue"
      )
{
  this->constr = _tao_constr;
  this->value = _tao_value;
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosNotifyFilter::InvalidValue::InvalidValue (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosNotifyFilter/InvalidValue:1.0",
        "InvalidValue"
      )
{
}

CosNotifyFilter::InvalidValue::~InvalidValue (void)
{
}

CosNotifyFilter::InvalidValue::InvalidValue (const ::CosNotifyFilter::InvalidValue &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->constr = _tao_excp.constr;
  this->value = _tao_excp.value;
}

CosNotifyFilter::InvalidValue&
CosNotifyFilter::InvalidValue::operator= (const ::CosNotifyFilter::InvalidValue &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->constr = _tao_excp.constr;
  this->value = _tao_excp.value;
  return *this;
}

void CosNotifyFilter::InvalidValue::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidValue *_tao_tmp_pointer =
    static_cast<InvalidValue *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosNotifyFilter::InvalidValue *
CosNotifyFilter::InvalidValue::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidValue *> (_tao_excp);
}

const CosNotifyFilter::InvalidValue *
CosNotifyFilter::InvalidValue::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidValue *> (_tao_excp);
}

::CORBA::Exception *CosNotifyFilter::InvalidValue::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosNotifyFilter::InvalidValue, 0);
  return retval;
}

::CORBA::Exception *
CosNotifyFilter::InvalidValue::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosNotifyFilter::InvalidValue (*this),
      0
    );
  return result;
}

void CosNotifyFilter::InvalidValue::_raise (void) const
{
  throw *this;
}

void CosNotifyFilter::InvalidValue::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosNotifyFilter::InvalidValue::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosNotifyFilter::InvalidValue::_tao_type (void) const
{
  return ::CosNotifyFilter::_tc_InvalidValue;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CosNotifyFilter_InvalidValue[] =
      {
        { "constr", &CosNotifyFilter::_tc_ConstraintExp },
        { "value", &CORBA::_tc_any }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosNotifyFilter_InvalidValue (
  ::CORBA::tk_except,
  "IDL:omg.org/CosNotifyFilter/InvalidValue:1.0",
  "InvalidValue",
  _tao_fields_CosNotifyFilter_InvalidValue,
  2);


namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_InvalidValue =
    &_tao_tc_CosNotifyFilter_InvalidValue;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosNotifyFilter::Filter.

CosNotifyFilter::Filter_ptr
TAO::Objref_Traits<CosNotifyFilter::Filter>::duplicate (
    CosNotifyFilter::Filter_ptr p)
{
  return CosNotifyFilter::Filter::_duplicate (p);
}

void
TAO::Objref_Traits<CosNotifyFilter::Filter>::release (
    CosNotifyFilter::Filter_ptr p)
{
  ::CORBA::release (p);
}

CosNotifyFilter::Filter_ptr
TAO::Objref_Traits<CosNotifyFilter::Filter>::nil (void)
{
  return CosNotifyFilter::Filter::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosNotifyFilter::Filter>::marshal (
    const CosNotifyFilter::Filter_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosNotifyFilter__TAO_Filter_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CosNotifyFilter::Filter::constraint_grammar (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Filter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_Filter_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_constraint_grammar",
      23,
      this->the_TAO_Filter_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosNotifyFilter::ConstraintInfoSeq *
CosNotifyFilter::Filter::add_constraints (
  const ::CosNotifyFilter::ConstraintExpSeq & constraint_list)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Filter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_Filter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosNotifyFilter::ConstraintInfoSeq>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosNotifyFilter::ConstraintExpSeq>::in_arg_val _tao_constraint_list (constraint_list);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_constraint_list
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_Filter_add_constraints_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/InvalidConstraint:1.0",
        CosNotifyFilter::InvalidConstraint::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_InvalidConstraint
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "add_constraints",
      15,
      this->the_TAO_Filter_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_Filter_add_constraints_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosNotifyFilter::Filter::modify_constraints (
  const ::CosNotifyFilter::ConstraintIDSeq & del_list,
  const ::CosNotifyFilter::ConstraintInfoSeq & modify_list)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Filter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_Filter_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosNotifyFilter::ConstraintIDSeq>::in_arg_val _tao_del_list (del_list);
  TAO::Arg_Traits< ::CosNotifyFilter::ConstraintInfoSeq>::in_arg_val _tao_modify_list (modify_list);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_del_list,
      &_tao_modify_list
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_Filter_modify_constraints_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/InvalidConstraint:1.0",
        CosNotifyFilter::InvalidConstraint::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_InvalidConstraint
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosNotifyFilter/ConstraintNotFound:1.0",
        CosNotifyFilter::ConstraintNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_ConstraintNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "modify_constraints",
      18,
      this->the_TAO_Filter_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_Filter_modify_constraints_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosNotifyFilter::ConstraintInfoSeq *
CosNotifyFilter::Filter::get_constraints (
  const ::CosNotifyFilter::ConstraintIDSeq & id_list)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Filter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_Filter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosNotifyFilter::ConstraintInfoSeq>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosNotifyFilter::ConstraintIDSeq>::in_arg_val _tao_id_list (id_list);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_id_list
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_Filter_get_constraints_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/ConstraintNotFound:1.0",
        CosNotifyFilter::ConstraintNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_ConstraintNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_constraints",
      15,
      this->the_TAO_Filter_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_Filter_get_constraints_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosNotifyFilter::ConstraintInfoSeq *
CosNotifyFilter::Filter::get_all_constraints (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Filter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_Filter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosNotifyFilter::ConstraintInfoSeq>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_all_constraints",
      19,
      this->the_TAO_Filter_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosNotifyFilter::Filter::remove_all_constraints (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Filter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_Filter_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "remove_all_constraints",
      22,
      this->the_TAO_Filter_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosNotifyFilter::Filter::destroy (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Filter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_Filter_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "destroy",
      7,
      this->the_TAO_Filter_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CosNotifyFilter::Filter::match (
  const ::CORBA::Any & filterable_data)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Filter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_Filter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Any>::in_arg_val _tao_filterable_data (filterable_data);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_filterable_data
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_Filter_match_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/UnsupportedFilterableData:1.0",
        CosNotifyFilter::UnsupportedFilterableData::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_UnsupportedFilterableData
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "match",
      5,
      this->the_TAO_Filter_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_Filter_match_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CosNotifyFilter::Filter::match_structured (
  const ::CosNotification::StructuredEvent & filterable_data)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Filter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_Filter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosNotification::StructuredEvent>::in_arg_val _tao_filterable_data (filterable_data);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_filterable_data
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_Filter_match_structured_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/UnsupportedFilterableData:1.0",
        CosNotifyFilter::UnsupportedFilterableData::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_UnsupportedFilterableData
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "match_structured",
      16,
      this->the_TAO_Filter_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_Filter_match_structured_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CosNotifyFilter::Filter::match_typed (
  const ::CosNotification::PropertySeq & filterable_data)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Filter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_Filter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosNotification::PropertySeq>::in_arg_val _tao_filterable_data (filterable_data);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_filterable_data
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_Filter_match_typed_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/UnsupportedFilterableData:1.0",
        CosNotifyFilter::UnsupportedFilterableData::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_UnsupportedFilterableData
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "match_typed",
      11,
      this->the_TAO_Filter_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_Filter_match_typed_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosNotifyFilter::CallbackID
CosNotifyFilter::Filter::attach_callback (
  ::CosNotifyComm::NotifySubscribe_ptr callback)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Filter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_Filter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosNotifyComm::NotifySubscribe>::in_arg_val _tao_callback (callback);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_callback
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "attach_callback",
      15,
      this->the_TAO_Filter_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosNotifyFilter::Filter::detach_callback (
  ::CosNotifyFilter::CallbackID callback)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Filter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_Filter_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_callback (callback);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_callback
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_Filter_detach_callback_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/CallbackNotFound:1.0",
        CosNotifyFilter::CallbackNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_CallbackNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "detach_callback",
      15,
      this->the_TAO_Filter_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_Filter_detach_callback_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosNotifyFilter::CallbackIDSeq *
CosNotifyFilter::Filter::get_callbacks (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Filter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_Filter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosNotifyFilter::CallbackIDSeq>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_callbacks",
      13,
      this->the_TAO_Filter_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

CosNotifyFilter::Filter::Filter (void)
 : the_TAO_Filter_Proxy_Broker_ (0)
{
  this->CosNotifyFilter_Filter_setup_collocation ();
}

void
CosNotifyFilter::Filter::CosNotifyFilter_Filter_setup_collocation ()
{
  if (::CosNotifyFilter__TAO_Filter_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Filter_Proxy_Broker_ =
        ::CosNotifyFilter__TAO_Filter_Proxy_Broker_Factory_function_pointer (this);
    }
}

CosNotifyFilter::Filter::~Filter (void)
{}

void 
CosNotifyFilter::Filter::_tao_any_destructor (void *_tao_void_pointer)
{
  Filter *_tao_tmp_pointer =
    static_cast<Filter *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosNotifyFilter::Filter_ptr
CosNotifyFilter::Filter::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Filter>::narrow (
        _tao_objref,
        "IDL:omg.org/CosNotifyFilter/Filter:1.0",
        CosNotifyFilter__TAO_Filter_Proxy_Broker_Factory_function_pointer
      );
}

CosNotifyFilter::Filter_ptr
CosNotifyFilter::Filter::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Filter>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosNotifyFilter/Filter:1.0",
        CosNotifyFilter__TAO_Filter_Proxy_Broker_Factory_function_pointer
      );
}

CosNotifyFilter::Filter_ptr
CosNotifyFilter::Filter::_nil (void)
{
  return 0;
}

CosNotifyFilter::Filter_ptr
CosNotifyFilter::Filter::_duplicate (Filter_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosNotifyFilter::Filter::_tao_release (Filter_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosNotifyFilter::Filter::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosNotifyFilter/Filter:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosNotifyFilter::Filter::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosNotifyFilter/Filter:1.0";
}

::CORBA::Boolean
CosNotifyFilter::Filter::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosNotifyFilter_Filter (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosNotifyFilter/Filter:1.0",
    "Filter");
  

namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_Filter =
    &_tao_tc_CosNotifyFilter_Filter;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosNotifyFilter::MappingFilter.

CosNotifyFilter::MappingFilter_ptr
TAO::Objref_Traits<CosNotifyFilter::MappingFilter>::duplicate (
    CosNotifyFilter::MappingFilter_ptr p)
{
  return CosNotifyFilter::MappingFilter::_duplicate (p);
}

void
TAO::Objref_Traits<CosNotifyFilter::MappingFilter>::release (
    CosNotifyFilter::MappingFilter_ptr p)
{
  ::CORBA::release (p);
}

CosNotifyFilter::MappingFilter_ptr
TAO::Objref_Traits<CosNotifyFilter::MappingFilter>::nil (void)
{
  return CosNotifyFilter::MappingFilter::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosNotifyFilter::MappingFilter>::marshal (
    const CosNotifyFilter::MappingFilter_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosNotifyFilter__TAO_MappingFilter_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
CosNotifyFilter::MappingFilter::constraint_grammar (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MappingFilter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_MappingFilter_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_constraint_grammar",
      23,
      this->the_TAO_MappingFilter_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::TypeCode_ptr
CosNotifyFilter::MappingFilter::value_type (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MappingFilter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_MappingFilter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::TypeCode>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_value_type",
      15,
      this->the_TAO_MappingFilter_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Any *
CosNotifyFilter::MappingFilter::default_value (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MappingFilter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_MappingFilter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Any>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_default_value",
      18,
      this->the_TAO_MappingFilter_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosNotifyFilter::MappingConstraintInfoSeq *
CosNotifyFilter::MappingFilter::add_mapping_constraints (
  const ::CosNotifyFilter::MappingConstraintPairSeq & pair_list)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MappingFilter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_MappingFilter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosNotifyFilter::MappingConstraintInfoSeq>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosNotifyFilter::MappingConstraintPairSeq>::in_arg_val _tao_pair_list (pair_list);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_pair_list
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_MappingFilter_add_mapping_constraints_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/InvalidConstraint:1.0",
        CosNotifyFilter::InvalidConstraint::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_InvalidConstraint
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosNotifyFilter/InvalidValue:1.0",
        CosNotifyFilter::InvalidValue::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_InvalidValue
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "add_mapping_constraints",
      23,
      this->the_TAO_MappingFilter_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_MappingFilter_add_mapping_constraints_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosNotifyFilter::MappingFilter::modify_mapping_constraints (
  const ::CosNotifyFilter::ConstraintIDSeq & del_list,
  const ::CosNotifyFilter::MappingConstraintInfoSeq & modify_list)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MappingFilter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_MappingFilter_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosNotifyFilter::ConstraintIDSeq>::in_arg_val _tao_del_list (del_list);
  TAO::Arg_Traits< ::CosNotifyFilter::MappingConstraintInfoSeq>::in_arg_val _tao_modify_list (modify_list);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_del_list,
      &_tao_modify_list
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_MappingFilter_modify_mapping_constraints_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/InvalidConstraint:1.0",
        CosNotifyFilter::InvalidConstraint::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_InvalidConstraint
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosNotifyFilter/InvalidValue:1.0",
        CosNotifyFilter::InvalidValue::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_InvalidValue
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/CosNotifyFilter/ConstraintNotFound:1.0",
        CosNotifyFilter::ConstraintNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_ConstraintNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "modify_mapping_constraints",
      26,
      this->the_TAO_MappingFilter_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_MappingFilter_modify_mapping_constraints_exceptiondata,
      3
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosNotifyFilter::MappingConstraintInfoSeq *
CosNotifyFilter::MappingFilter::get_mapping_constraints (
  const ::CosNotifyFilter::ConstraintIDSeq & id_list)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MappingFilter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_MappingFilter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosNotifyFilter::MappingConstraintInfoSeq>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosNotifyFilter::ConstraintIDSeq>::in_arg_val _tao_id_list (id_list);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_id_list
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_MappingFilter_get_mapping_constraints_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/ConstraintNotFound:1.0",
        CosNotifyFilter::ConstraintNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_ConstraintNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_mapping_constraints",
      23,
      this->the_TAO_MappingFilter_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_MappingFilter_get_mapping_constraints_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosNotifyFilter::MappingConstraintInfoSeq *
CosNotifyFilter::MappingFilter::get_all_mapping_constraints (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MappingFilter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_MappingFilter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosNotifyFilter::MappingConstraintInfoSeq>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_all_mapping_constraints",
      27,
      this->the_TAO_MappingFilter_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosNotifyFilter::MappingFilter::remove_all_mapping_constraints (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MappingFilter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_MappingFilter_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "remove_all_mapping_constraints",
      30,
      this->the_TAO_MappingFilter_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosNotifyFilter::MappingFilter::destroy (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MappingFilter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_MappingFilter_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "destroy",
      7,
      this->the_TAO_MappingFilter_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CosNotifyFilter::MappingFilter::match (
  const ::CORBA::Any & filterable_data,
  ::CORBA::Any_out result_to_set)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MappingFilter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_MappingFilter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Any>::in_arg_val _tao_filterable_data (filterable_data);
  TAO::Arg_Traits< ::CORBA::Any>::out_arg_val _tao_result_to_set (result_to_set);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_filterable_data,
      &_tao_result_to_set
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_MappingFilter_match_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/UnsupportedFilterableData:1.0",
        CosNotifyFilter::UnsupportedFilterableData::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_UnsupportedFilterableData
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "match",
      5,
      this->the_TAO_MappingFilter_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_MappingFilter_match_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CosNotifyFilter::MappingFilter::match_structured (
  const ::CosNotification::StructuredEvent & filterable_data,
  ::CORBA::Any_out result_to_set)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MappingFilter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_MappingFilter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosNotification::StructuredEvent>::in_arg_val _tao_filterable_data (filterable_data);
  TAO::Arg_Traits< ::CORBA::Any>::out_arg_val _tao_result_to_set (result_to_set);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_filterable_data,
      &_tao_result_to_set
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_MappingFilter_match_structured_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/UnsupportedFilterableData:1.0",
        CosNotifyFilter::UnsupportedFilterableData::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_UnsupportedFilterableData
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "match_structured",
      16,
      this->the_TAO_MappingFilter_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_MappingFilter_match_structured_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
CosNotifyFilter::MappingFilter::match_typed (
  const ::CosNotification::PropertySeq & filterable_data,
  ::CORBA::Any_out result_to_set)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MappingFilter_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_MappingFilter_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosNotification::PropertySeq>::in_arg_val _tao_filterable_data (filterable_data);
  TAO::Arg_Traits< ::CORBA::Any>::out_arg_val _tao_result_to_set (result_to_set);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_filterable_data,
      &_tao_result_to_set
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_MappingFilter_match_typed_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/UnsupportedFilterableData:1.0",
        CosNotifyFilter::UnsupportedFilterableData::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_UnsupportedFilterableData
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "match_typed",
      11,
      this->the_TAO_MappingFilter_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_MappingFilter_match_typed_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

CosNotifyFilter::MappingFilter::MappingFilter (void)
 : the_TAO_MappingFilter_Proxy_Broker_ (0)
{
  this->CosNotifyFilter_MappingFilter_setup_collocation ();
}

void
CosNotifyFilter::MappingFilter::CosNotifyFilter_MappingFilter_setup_collocation ()
{
  if (::CosNotifyFilter__TAO_MappingFilter_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_MappingFilter_Proxy_Broker_ =
        ::CosNotifyFilter__TAO_MappingFilter_Proxy_Broker_Factory_function_pointer (this);
    }
}

CosNotifyFilter::MappingFilter::~MappingFilter (void)
{}

void 
CosNotifyFilter::MappingFilter::_tao_any_destructor (void *_tao_void_pointer)
{
  MappingFilter *_tao_tmp_pointer =
    static_cast<MappingFilter *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosNotifyFilter::MappingFilter_ptr
CosNotifyFilter::MappingFilter::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<MappingFilter>::narrow (
        _tao_objref,
        "IDL:omg.org/CosNotifyFilter/MappingFilter:1.0",
        CosNotifyFilter__TAO_MappingFilter_Proxy_Broker_Factory_function_pointer
      );
}

CosNotifyFilter::MappingFilter_ptr
CosNotifyFilter::MappingFilter::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<MappingFilter>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosNotifyFilter/MappingFilter:1.0",
        CosNotifyFilter__TAO_MappingFilter_Proxy_Broker_Factory_function_pointer
      );
}

CosNotifyFilter::MappingFilter_ptr
CosNotifyFilter::MappingFilter::_nil (void)
{
  return 0;
}

CosNotifyFilter::MappingFilter_ptr
CosNotifyFilter::MappingFilter::_duplicate (MappingFilter_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosNotifyFilter::MappingFilter::_tao_release (MappingFilter_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosNotifyFilter::MappingFilter::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosNotifyFilter/MappingFilter:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosNotifyFilter::MappingFilter::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosNotifyFilter/MappingFilter:1.0";
}

::CORBA::Boolean
CosNotifyFilter::MappingFilter::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosNotifyFilter_MappingFilter (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosNotifyFilter/MappingFilter:1.0",
    "MappingFilter");
  

namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_MappingFilter =
    &_tao_tc_CosNotifyFilter_MappingFilter;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosNotifyFilter::FilterFactory.

CosNotifyFilter::FilterFactory_ptr
TAO::Objref_Traits<CosNotifyFilter::FilterFactory>::duplicate (
    CosNotifyFilter::FilterFactory_ptr p)
{
  return CosNotifyFilter::FilterFactory::_duplicate (p);
}

void
TAO::Objref_Traits<CosNotifyFilter::FilterFactory>::release (
    CosNotifyFilter::FilterFactory_ptr p)
{
  ::CORBA::release (p);
}

CosNotifyFilter::FilterFactory_ptr
TAO::Objref_Traits<CosNotifyFilter::FilterFactory>::nil (void)
{
  return CosNotifyFilter::FilterFactory::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosNotifyFilter::FilterFactory>::marshal (
    const CosNotifyFilter::FilterFactory_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosNotifyFilter__TAO_FilterFactory_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosNotifyFilter::Filter_ptr
CosNotifyFilter::FilterFactory::create_filter (
  const char * constraint_grammar)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FilterFactory_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_FilterFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosNotifyFilter::Filter>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_constraint_grammar (constraint_grammar);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_constraint_grammar
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_FilterFactory_create_filter_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/InvalidGrammar:1.0",
        CosNotifyFilter::InvalidGrammar::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_InvalidGrammar
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "create_filter",
      13,
      this->the_TAO_FilterFactory_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_FilterFactory_create_filter_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosNotifyFilter::MappingFilter_ptr
CosNotifyFilter::FilterFactory::create_mapping_filter (
  const char * constraint_grammar,
  const ::CORBA::Any & default_value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FilterFactory_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_FilterFactory_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosNotifyFilter::MappingFilter>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_constraint_grammar (constraint_grammar);
  TAO::Arg_Traits< ::CORBA::Any>::in_arg_val _tao_default_value (default_value);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_constraint_grammar,
      &_tao_default_value
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_FilterFactory_create_mapping_filter_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/InvalidGrammar:1.0",
        CosNotifyFilter::InvalidGrammar::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_InvalidGrammar
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "create_mapping_filter",
      21,
      this->the_TAO_FilterFactory_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_FilterFactory_create_mapping_filter_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

CosNotifyFilter::FilterFactory::FilterFactory (void)
 : the_TAO_FilterFactory_Proxy_Broker_ (0)
{
  this->CosNotifyFilter_FilterFactory_setup_collocation ();
}

void
CosNotifyFilter::FilterFactory::CosNotifyFilter_FilterFactory_setup_collocation ()
{
  if (::CosNotifyFilter__TAO_FilterFactory_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_FilterFactory_Proxy_Broker_ =
        ::CosNotifyFilter__TAO_FilterFactory_Proxy_Broker_Factory_function_pointer (this);
    }
}

CosNotifyFilter::FilterFactory::~FilterFactory (void)
{}

void 
CosNotifyFilter::FilterFactory::_tao_any_destructor (void *_tao_void_pointer)
{
  FilterFactory *_tao_tmp_pointer =
    static_cast<FilterFactory *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosNotifyFilter::FilterFactory_ptr
CosNotifyFilter::FilterFactory::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FilterFactory>::narrow (
        _tao_objref,
        "IDL:omg.org/CosNotifyFilter/FilterFactory:1.0",
        CosNotifyFilter__TAO_FilterFactory_Proxy_Broker_Factory_function_pointer
      );
}

CosNotifyFilter::FilterFactory_ptr
CosNotifyFilter::FilterFactory::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FilterFactory>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosNotifyFilter/FilterFactory:1.0",
        CosNotifyFilter__TAO_FilterFactory_Proxy_Broker_Factory_function_pointer
      );
}

CosNotifyFilter::FilterFactory_ptr
CosNotifyFilter::FilterFactory::_nil (void)
{
  return 0;
}

CosNotifyFilter::FilterFactory_ptr
CosNotifyFilter::FilterFactory::_duplicate (FilterFactory_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosNotifyFilter::FilterFactory::_tao_release (FilterFactory_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosNotifyFilter::FilterFactory::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosNotifyFilter/FilterFactory:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosNotifyFilter::FilterFactory::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosNotifyFilter/FilterFactory:1.0";
}

::CORBA::Boolean
CosNotifyFilter::FilterFactory::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosNotifyFilter_FilterFactory (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosNotifyFilter/FilterFactory:1.0",
    "FilterFactory");
  

namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_FilterFactory =
    &_tao_tc_CosNotifyFilter_FilterFactory;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosNotifyFilter_FilterID (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosNotifyFilter/FilterID:1.0",
    "FilterID",
    &CORBA::_tc_long);
  

namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_FilterID =
    &_tao_tc_CosNotifyFilter_FilterID;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_COSNOTIFYFILTER_FILTERIDSEQ_CS_)
#define _COSNOTIFYFILTER_FILTERIDSEQ_CS_

CosNotifyFilter::FilterIDSeq::FilterIDSeq (void)
{}

CosNotifyFilter::FilterIDSeq::FilterIDSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        FilterID
      > (max)
{}

CosNotifyFilter::FilterIDSeq::FilterIDSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        FilterID
      >
    (max, length, buffer, release)
{}

CosNotifyFilter::FilterIDSeq::FilterIDSeq (
    const FilterIDSeq &seq)
  : ::TAO::unbounded_value_sequence<
        FilterID
      > (seq)
{}

CosNotifyFilter::FilterIDSeq::~FilterIDSeq (void)
{}

void CosNotifyFilter::FilterIDSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  FilterIDSeq * _tao_tmp_pointer =
    static_cast<FilterIDSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CosNotifyFilter_FilterIDSeq_GUARD
#define _TAO_TYPECODE_CosNotifyFilter_FilterIDSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CosNotifyFilter_FilterIDSeq_0 (
          ::CORBA::tk_sequence,
          &CosNotifyFilter::_tc_FilterID,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CosNotifyFilter_FilterIDSeq_0 =
        &CosNotifyFilter_FilterIDSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CosNotifyFilter_FilterIDSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CosNotifyFilter_FilterIDSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/CosNotifyFilter/FilterIDSeq:1.0",
    "FilterIDSeq",
    &TAO::TypeCode::tc_CosNotifyFilter_FilterIDSeq_0);
  

namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_FilterIDSeq =
    &_tao_tc_CosNotifyFilter_FilterIDSeq;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

CosNotifyFilter::FilterNotFound::FilterNotFound (void)
  : ::CORBA::UserException (
        "IDL:omg.org/CosNotifyFilter/FilterNotFound:1.0",
        "FilterNotFound"
      )
{
}

CosNotifyFilter::FilterNotFound::~FilterNotFound (void)
{
}

CosNotifyFilter::FilterNotFound::FilterNotFound (const ::CosNotifyFilter::FilterNotFound &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

CosNotifyFilter::FilterNotFound&
CosNotifyFilter::FilterNotFound::operator= (const ::CosNotifyFilter::FilterNotFound &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void CosNotifyFilter::FilterNotFound::_tao_any_destructor (void *_tao_void_pointer)
{
  FilterNotFound *_tao_tmp_pointer =
    static_cast<FilterNotFound *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

CosNotifyFilter::FilterNotFound *
CosNotifyFilter::FilterNotFound::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<FilterNotFound *> (_tao_excp);
}

const CosNotifyFilter::FilterNotFound *
CosNotifyFilter::FilterNotFound::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const FilterNotFound *> (_tao_excp);
}

::CORBA::Exception *CosNotifyFilter::FilterNotFound::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::CosNotifyFilter::FilterNotFound, 0);
  return retval;
}

::CORBA::Exception *
CosNotifyFilter::FilterNotFound::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::CosNotifyFilter::FilterNotFound (*this),
      0
    );
  return result;
}

void CosNotifyFilter::FilterNotFound::_raise (void) const
{
  throw *this;
}

void CosNotifyFilter::FilterNotFound::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void CosNotifyFilter::FilterNotFound::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr CosNotifyFilter::FilterNotFound::_tao_type (void) const
{
  return ::CosNotifyFilter::_tc_FilterNotFound;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_CosNotifyFilter_FilterNotFound = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CosNotifyFilter_FilterNotFound (
  ::CORBA::tk_except,
  "IDL:omg.org/CosNotifyFilter/FilterNotFound:1.0",
  "FilterNotFound",
  _tao_fields_CosNotifyFilter_FilterNotFound,
  0);


namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_FilterNotFound =
    &_tao_tc_CosNotifyFilter_FilterNotFound;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for CosNotifyFilter::FilterAdmin.

CosNotifyFilter::FilterAdmin_ptr
TAO::Objref_Traits<CosNotifyFilter::FilterAdmin>::duplicate (
    CosNotifyFilter::FilterAdmin_ptr p)
{
  return CosNotifyFilter::FilterAdmin::_duplicate (p);
}

void
TAO::Objref_Traits<CosNotifyFilter::FilterAdmin>::release (
    CosNotifyFilter::FilterAdmin_ptr p)
{
  ::CORBA::release (p);
}

CosNotifyFilter::FilterAdmin_ptr
TAO::Objref_Traits<CosNotifyFilter::FilterAdmin>::nil (void)
{
  return CosNotifyFilter::FilterAdmin::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<CosNotifyFilter::FilterAdmin>::marshal (
    const CosNotifyFilter::FilterAdmin_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*CosNotifyFilter__TAO_FilterAdmin_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosNotifyFilter::FilterID
CosNotifyFilter::FilterAdmin::add_filter (
  ::CosNotifyFilter::Filter_ptr new_filter)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FilterAdmin_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_FilterAdmin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosNotifyFilter::Filter>::in_arg_val _tao_new_filter (new_filter);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_new_filter
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "add_filter",
      10,
      this->the_TAO_FilterAdmin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosNotifyFilter::FilterAdmin::remove_filter (
  ::CosNotifyFilter::FilterID filter)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FilterAdmin_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_FilterAdmin_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_filter (filter);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_filter
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_FilterAdmin_remove_filter_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/FilterNotFound:1.0",
        CosNotifyFilter::FilterNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_FilterNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_filter",
      13,
      this->the_TAO_FilterAdmin_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_FilterAdmin_remove_filter_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosNotifyFilter::Filter_ptr
CosNotifyFilter::FilterAdmin::get_filter (
  ::CosNotifyFilter::FilterID filter)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FilterAdmin_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_FilterAdmin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosNotifyFilter::Filter>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_filter (filter);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_filter
    };

  static TAO::Exception_Data
  _tao_CosNotifyFilter_FilterAdmin_get_filter_exceptiondata [] = 
    {
      {
        "IDL:omg.org/CosNotifyFilter/FilterNotFound:1.0",
        CosNotifyFilter::FilterNotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , CosNotifyFilter::_tc_FilterNotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_filter",
      10,
      this->the_TAO_FilterAdmin_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_CosNotifyFilter_FilterAdmin_get_filter_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CosNotifyFilter::FilterIDSeq *
CosNotifyFilter::FilterAdmin::get_all_filters (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FilterAdmin_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_FilterAdmin_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CosNotifyFilter::FilterIDSeq>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_all_filters",
      15,
      this->the_TAO_FilterAdmin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
CosNotifyFilter::FilterAdmin::remove_all_filters (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FilterAdmin_Proxy_Broker_ == 0)
    {
      CosNotifyFilter_FilterAdmin_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "remove_all_filters",
      18,
      this->the_TAO_FilterAdmin_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

CosNotifyFilter::FilterAdmin::FilterAdmin (void)
 : the_TAO_FilterAdmin_Proxy_Broker_ (0)
{
  this->CosNotifyFilter_FilterAdmin_setup_collocation ();
}

void
CosNotifyFilter::FilterAdmin::CosNotifyFilter_FilterAdmin_setup_collocation ()
{
  if (::CosNotifyFilter__TAO_FilterAdmin_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_FilterAdmin_Proxy_Broker_ =
        ::CosNotifyFilter__TAO_FilterAdmin_Proxy_Broker_Factory_function_pointer (this);
    }
}

CosNotifyFilter::FilterAdmin::~FilterAdmin (void)
{}

void 
CosNotifyFilter::FilterAdmin::_tao_any_destructor (void *_tao_void_pointer)
{
  FilterAdmin *_tao_tmp_pointer =
    static_cast<FilterAdmin *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

CosNotifyFilter::FilterAdmin_ptr
CosNotifyFilter::FilterAdmin::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FilterAdmin>::narrow (
        _tao_objref,
        "IDL:omg.org/CosNotifyFilter/FilterAdmin:1.0",
        CosNotifyFilter__TAO_FilterAdmin_Proxy_Broker_Factory_function_pointer
      );
}

CosNotifyFilter::FilterAdmin_ptr
CosNotifyFilter::FilterAdmin::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FilterAdmin>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/CosNotifyFilter/FilterAdmin:1.0",
        CosNotifyFilter__TAO_FilterAdmin_Proxy_Broker_Factory_function_pointer
      );
}

CosNotifyFilter::FilterAdmin_ptr
CosNotifyFilter::FilterAdmin::_nil (void)
{
  return 0;
}

CosNotifyFilter::FilterAdmin_ptr
CosNotifyFilter::FilterAdmin::_duplicate (FilterAdmin_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
CosNotifyFilter::FilterAdmin::_tao_release (FilterAdmin_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
CosNotifyFilter::FilterAdmin::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosNotifyFilter/FilterAdmin:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* CosNotifyFilter::FilterAdmin::_interface_repository_id (void) const
{
  return "IDL:omg.org/CosNotifyFilter/FilterAdmin:1.0";
}

::CORBA::Boolean
CosNotifyFilter::FilterAdmin::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_CosNotifyFilter_FilterAdmin (
    ::CORBA::tk_objref,
    "IDL:omg.org/CosNotifyFilter/FilterAdmin:1.0",
    "FilterAdmin");
  

namespace CosNotifyFilter
{
  ::CORBA::TypeCode_ptr const _tc_FilterAdmin =
    &_tao_tc_CosNotifyFilter_FilterAdmin;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::ConstraintExp &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosNotifyFilter::ConstraintExp *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintExp>::insert_copy (
          _tao_any,
          ::CosNotifyFilter::ConstraintExp::_tao_any_destructor,
          ::CosNotifyFilter::_tc_ConstraintExp,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosNotifyFilter::ConstraintExp *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintExp>::insert (
        _tao_any,
        ::CosNotifyFilter::ConstraintExp::_tao_any_destructor,
        ::CosNotifyFilter::_tc_ConstraintExp,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::ConstraintExp *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::ConstraintExp *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::ConstraintExp *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintExp>::extract (
          _tao_any,
          ::CosNotifyFilter::ConstraintExp::_tao_any_destructor,
          ::CosNotifyFilter::_tc_ConstraintExp,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::ConstraintExp &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosNotifyFilter::ConstraintExp *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintExp>::insert_copy (
        _tao_any,
        CosNotifyFilter::ConstraintExp::_tao_any_destructor,
        CosNotifyFilter::_tc_ConstraintExp,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::ConstraintExp *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintExp>::insert (
      _tao_any,
      CosNotifyFilter::ConstraintExp::_tao_any_destructor,
      CosNotifyFilter::_tc_ConstraintExp,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::ConstraintExp *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::ConstraintExp *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::ConstraintExp *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintExp>::extract (
        _tao_any,
        CosNotifyFilter::ConstraintExp::_tao_any_destructor,
        CosNotifyFilter::_tc_ConstraintExp,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::ConstraintIDSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosNotifyFilter::ConstraintIDSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintIDSeq>::insert_copy (
          _tao_any,
          ::CosNotifyFilter::ConstraintIDSeq::_tao_any_destructor,
          ::CosNotifyFilter::_tc_ConstraintIDSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::ConstraintIDSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintIDSeq>::insert (
        _tao_any,
        ::CosNotifyFilter::ConstraintIDSeq::_tao_any_destructor,
        ::CosNotifyFilter::_tc_ConstraintIDSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::ConstraintIDSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::ConstraintIDSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::ConstraintIDSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintIDSeq>::extract (
          _tao_any,
          ::CosNotifyFilter::ConstraintIDSeq::_tao_any_destructor,
          ::CosNotifyFilter::_tc_ConstraintIDSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::ConstraintIDSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosNotifyFilter::ConstraintIDSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintIDSeq>::insert_copy (
        _tao_any,
        CosNotifyFilter::ConstraintIDSeq::_tao_any_destructor,
        CosNotifyFilter::_tc_ConstraintIDSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::ConstraintIDSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintIDSeq>::insert (
      _tao_any,
      CosNotifyFilter::ConstraintIDSeq::_tao_any_destructor,
      CosNotifyFilter::_tc_ConstraintIDSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::ConstraintIDSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::ConstraintIDSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::ConstraintIDSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintIDSeq>::extract (
        _tao_any,
        CosNotifyFilter::ConstraintIDSeq::_tao_any_destructor,
        CosNotifyFilter::_tc_ConstraintIDSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::ConstraintExpSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosNotifyFilter::ConstraintExpSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintExpSeq>::insert_copy (
          _tao_any,
          ::CosNotifyFilter::ConstraintExpSeq::_tao_any_destructor,
          ::CosNotifyFilter::_tc_ConstraintExpSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::ConstraintExpSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintExpSeq>::insert (
        _tao_any,
        ::CosNotifyFilter::ConstraintExpSeq::_tao_any_destructor,
        ::CosNotifyFilter::_tc_ConstraintExpSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::ConstraintExpSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::ConstraintExpSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::ConstraintExpSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintExpSeq>::extract (
          _tao_any,
          ::CosNotifyFilter::ConstraintExpSeq::_tao_any_destructor,
          ::CosNotifyFilter::_tc_ConstraintExpSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::ConstraintExpSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosNotifyFilter::ConstraintExpSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintExpSeq>::insert_copy (
        _tao_any,
        CosNotifyFilter::ConstraintExpSeq::_tao_any_destructor,
        CosNotifyFilter::_tc_ConstraintExpSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::ConstraintExpSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintExpSeq>::insert (
      _tao_any,
      CosNotifyFilter::ConstraintExpSeq::_tao_any_destructor,
      CosNotifyFilter::_tc_ConstraintExpSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::ConstraintExpSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::ConstraintExpSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::ConstraintExpSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintExpSeq>::extract (
        _tao_any,
        CosNotifyFilter::ConstraintExpSeq::_tao_any_destructor,
        CosNotifyFilter::_tc_ConstraintExpSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::ConstraintInfo &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosNotifyFilter::ConstraintInfo *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintInfo>::insert_copy (
          _tao_any,
          ::CosNotifyFilter::ConstraintInfo::_tao_any_destructor,
          ::CosNotifyFilter::_tc_ConstraintInfo,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosNotifyFilter::ConstraintInfo *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintInfo>::insert (
        _tao_any,
        ::CosNotifyFilter::ConstraintInfo::_tao_any_destructor,
        ::CosNotifyFilter::_tc_ConstraintInfo,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::ConstraintInfo *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::ConstraintInfo *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::ConstraintInfo *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintInfo>::extract (
          _tao_any,
          ::CosNotifyFilter::ConstraintInfo::_tao_any_destructor,
          ::CosNotifyFilter::_tc_ConstraintInfo,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::ConstraintInfo &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosNotifyFilter::ConstraintInfo *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintInfo>::insert_copy (
        _tao_any,
        CosNotifyFilter::ConstraintInfo::_tao_any_destructor,
        CosNotifyFilter::_tc_ConstraintInfo,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::ConstraintInfo *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintInfo>::insert (
      _tao_any,
      CosNotifyFilter::ConstraintInfo::_tao_any_destructor,
      CosNotifyFilter::_tc_ConstraintInfo,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::ConstraintInfo *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::ConstraintInfo *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::ConstraintInfo *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintInfo>::extract (
        _tao_any,
        CosNotifyFilter::ConstraintInfo::_tao_any_destructor,
        CosNotifyFilter::_tc_ConstraintInfo,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::ConstraintInfoSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosNotifyFilter::ConstraintInfoSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintInfoSeq>::insert_copy (
          _tao_any,
          ::CosNotifyFilter::ConstraintInfoSeq::_tao_any_destructor,
          ::CosNotifyFilter::_tc_ConstraintInfoSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::ConstraintInfoSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintInfoSeq>::insert (
        _tao_any,
        ::CosNotifyFilter::ConstraintInfoSeq::_tao_any_destructor,
        ::CosNotifyFilter::_tc_ConstraintInfoSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::ConstraintInfoSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::ConstraintInfoSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::ConstraintInfoSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintInfoSeq>::extract (
          _tao_any,
          ::CosNotifyFilter::ConstraintInfoSeq::_tao_any_destructor,
          ::CosNotifyFilter::_tc_ConstraintInfoSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::ConstraintInfoSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosNotifyFilter::ConstraintInfoSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintInfoSeq>::insert_copy (
        _tao_any,
        CosNotifyFilter::ConstraintInfoSeq::_tao_any_destructor,
        CosNotifyFilter::_tc_ConstraintInfoSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::ConstraintInfoSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintInfoSeq>::insert (
      _tao_any,
      CosNotifyFilter::ConstraintInfoSeq::_tao_any_destructor,
      CosNotifyFilter::_tc_ConstraintInfoSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::ConstraintInfoSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::ConstraintInfoSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::ConstraintInfoSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintInfoSeq>::extract (
        _tao_any,
        CosNotifyFilter::ConstraintInfoSeq::_tao_any_destructor,
        CosNotifyFilter::_tc_ConstraintInfoSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::MappingConstraintPair &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosNotifyFilter::MappingConstraintPair *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::MappingConstraintPair>::insert_copy (
          _tao_any,
          ::CosNotifyFilter::MappingConstraintPair::_tao_any_destructor,
          ::CosNotifyFilter::_tc_MappingConstraintPair,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosNotifyFilter::MappingConstraintPair *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::MappingConstraintPair>::insert (
        _tao_any,
        ::CosNotifyFilter::MappingConstraintPair::_tao_any_destructor,
        ::CosNotifyFilter::_tc_MappingConstraintPair,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::MappingConstraintPair *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::MappingConstraintPair *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::MappingConstraintPair *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::MappingConstraintPair>::extract (
          _tao_any,
          ::CosNotifyFilter::MappingConstraintPair::_tao_any_destructor,
          ::CosNotifyFilter::_tc_MappingConstraintPair,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::MappingConstraintPair &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosNotifyFilter::MappingConstraintPair *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosNotifyFilter::MappingConstraintPair>::insert_copy (
        _tao_any,
        CosNotifyFilter::MappingConstraintPair::_tao_any_destructor,
        CosNotifyFilter::_tc_MappingConstraintPair,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::MappingConstraintPair *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::MappingConstraintPair>::insert (
      _tao_any,
      CosNotifyFilter::MappingConstraintPair::_tao_any_destructor,
      CosNotifyFilter::_tc_MappingConstraintPair,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::MappingConstraintPair *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::MappingConstraintPair *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::MappingConstraintPair *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::MappingConstraintPair>::extract (
        _tao_any,
        CosNotifyFilter::MappingConstraintPair::_tao_any_destructor,
        CosNotifyFilter::_tc_MappingConstraintPair,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::MappingConstraintPairSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosNotifyFilter::MappingConstraintPairSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::MappingConstraintPairSeq>::insert_copy (
          _tao_any,
          ::CosNotifyFilter::MappingConstraintPairSeq::_tao_any_destructor,
          ::CosNotifyFilter::_tc_MappingConstraintPairSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::MappingConstraintPairSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::MappingConstraintPairSeq>::insert (
        _tao_any,
        ::CosNotifyFilter::MappingConstraintPairSeq::_tao_any_destructor,
        ::CosNotifyFilter::_tc_MappingConstraintPairSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::MappingConstraintPairSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::MappingConstraintPairSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::MappingConstraintPairSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::MappingConstraintPairSeq>::extract (
          _tao_any,
          ::CosNotifyFilter::MappingConstraintPairSeq::_tao_any_destructor,
          ::CosNotifyFilter::_tc_MappingConstraintPairSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::MappingConstraintPairSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosNotifyFilter::MappingConstraintPairSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosNotifyFilter::MappingConstraintPairSeq>::insert_copy (
        _tao_any,
        CosNotifyFilter::MappingConstraintPairSeq::_tao_any_destructor,
        CosNotifyFilter::_tc_MappingConstraintPairSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::MappingConstraintPairSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::MappingConstraintPairSeq>::insert (
      _tao_any,
      CosNotifyFilter::MappingConstraintPairSeq::_tao_any_destructor,
      CosNotifyFilter::_tc_MappingConstraintPairSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::MappingConstraintPairSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::MappingConstraintPairSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::MappingConstraintPairSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::MappingConstraintPairSeq>::extract (
        _tao_any,
        CosNotifyFilter::MappingConstraintPairSeq::_tao_any_destructor,
        CosNotifyFilter::_tc_MappingConstraintPairSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::MappingConstraintInfo &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosNotifyFilter::MappingConstraintInfo *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::MappingConstraintInfo>::insert_copy (
          _tao_any,
          ::CosNotifyFilter::MappingConstraintInfo::_tao_any_destructor,
          ::CosNotifyFilter::_tc_MappingConstraintInfo,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CosNotifyFilter::MappingConstraintInfo *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::MappingConstraintInfo>::insert (
        _tao_any,
        ::CosNotifyFilter::MappingConstraintInfo::_tao_any_destructor,
        ::CosNotifyFilter::_tc_MappingConstraintInfo,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::MappingConstraintInfo *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::MappingConstraintInfo *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::MappingConstraintInfo *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::MappingConstraintInfo>::extract (
          _tao_any,
          ::CosNotifyFilter::MappingConstraintInfo::_tao_any_destructor,
          ::CosNotifyFilter::_tc_MappingConstraintInfo,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::MappingConstraintInfo &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosNotifyFilter::MappingConstraintInfo *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosNotifyFilter::MappingConstraintInfo>::insert_copy (
        _tao_any,
        CosNotifyFilter::MappingConstraintInfo::_tao_any_destructor,
        CosNotifyFilter::_tc_MappingConstraintInfo,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::MappingConstraintInfo *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::MappingConstraintInfo>::insert (
      _tao_any,
      CosNotifyFilter::MappingConstraintInfo::_tao_any_destructor,
      CosNotifyFilter::_tc_MappingConstraintInfo,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::MappingConstraintInfo *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::MappingConstraintInfo *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::MappingConstraintInfo *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::MappingConstraintInfo>::extract (
        _tao_any,
        CosNotifyFilter::MappingConstraintInfo::_tao_any_destructor,
        CosNotifyFilter::_tc_MappingConstraintInfo,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::MappingConstraintInfoSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosNotifyFilter::MappingConstraintInfoSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::MappingConstraintInfoSeq>::insert_copy (
          _tao_any,
          ::CosNotifyFilter::MappingConstraintInfoSeq::_tao_any_destructor,
          ::CosNotifyFilter::_tc_MappingConstraintInfoSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::MappingConstraintInfoSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::MappingConstraintInfoSeq>::insert (
        _tao_any,
        ::CosNotifyFilter::MappingConstraintInfoSeq::_tao_any_destructor,
        ::CosNotifyFilter::_tc_MappingConstraintInfoSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::MappingConstraintInfoSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::MappingConstraintInfoSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::MappingConstraintInfoSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::MappingConstraintInfoSeq>::extract (
          _tao_any,
          ::CosNotifyFilter::MappingConstraintInfoSeq::_tao_any_destructor,
          ::CosNotifyFilter::_tc_MappingConstraintInfoSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::MappingConstraintInfoSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosNotifyFilter::MappingConstraintInfoSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosNotifyFilter::MappingConstraintInfoSeq>::insert_copy (
        _tao_any,
        CosNotifyFilter::MappingConstraintInfoSeq::_tao_any_destructor,
        CosNotifyFilter::_tc_MappingConstraintInfoSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::MappingConstraintInfoSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::MappingConstraintInfoSeq>::insert (
      _tao_any,
      CosNotifyFilter::MappingConstraintInfoSeq::_tao_any_destructor,
      CosNotifyFilter::_tc_MappingConstraintInfoSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::MappingConstraintInfoSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::MappingConstraintInfoSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::MappingConstraintInfoSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::MappingConstraintInfoSeq>::extract (
        _tao_any,
        CosNotifyFilter::MappingConstraintInfoSeq::_tao_any_destructor,
        CosNotifyFilter::_tc_MappingConstraintInfoSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::CallbackIDSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosNotifyFilter::CallbackIDSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::CallbackIDSeq>::insert_copy (
          _tao_any,
          ::CosNotifyFilter::CallbackIDSeq::_tao_any_destructor,
          ::CosNotifyFilter::_tc_CallbackIDSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::CallbackIDSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::CallbackIDSeq>::insert (
        _tao_any,
        ::CosNotifyFilter::CallbackIDSeq::_tao_any_destructor,
        ::CosNotifyFilter::_tc_CallbackIDSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::CallbackIDSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::CallbackIDSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::CallbackIDSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::CallbackIDSeq>::extract (
          _tao_any,
          ::CosNotifyFilter::CallbackIDSeq::_tao_any_destructor,
          ::CosNotifyFilter::_tc_CallbackIDSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::CallbackIDSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosNotifyFilter::CallbackIDSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosNotifyFilter::CallbackIDSeq>::insert_copy (
        _tao_any,
        CosNotifyFilter::CallbackIDSeq::_tao_any_destructor,
        CosNotifyFilter::_tc_CallbackIDSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::CallbackIDSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::CallbackIDSeq>::insert (
      _tao_any,
      CosNotifyFilter::CallbackIDSeq::_tao_any_destructor,
      CosNotifyFilter::_tc_CallbackIDSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::CallbackIDSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::CallbackIDSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::CallbackIDSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::CallbackIDSeq>::extract (
        _tao_any,
        CosNotifyFilter::CallbackIDSeq::_tao_any_destructor,
        CosNotifyFilter::_tc_CallbackIDSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosNotifyFilter::UnsupportedFilterableData>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::UnsupportedFilterableData &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::UnsupportedFilterableData>::insert_copy (
        _tao_any,
        ::CosNotifyFilter::UnsupportedFilterableData::_tao_any_destructor,
        ::CosNotifyFilter::_tc_UnsupportedFilterableData,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::UnsupportedFilterableData *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::UnsupportedFilterableData>::insert (
        _tao_any,
        ::CosNotifyFilter::UnsupportedFilterableData::_tao_any_destructor,
        ::CosNotifyFilter::_tc_UnsupportedFilterableData,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::UnsupportedFilterableData *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::UnsupportedFilterableData *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::UnsupportedFilterableData *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::UnsupportedFilterableData>::extract (
          _tao_any,
          ::CosNotifyFilter::UnsupportedFilterableData::_tao_any_destructor,
          ::CosNotifyFilter::_tc_UnsupportedFilterableData,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::UnsupportedFilterableData &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::UnsupportedFilterableData>::insert_copy (
      _tao_any,
      CosNotifyFilter::UnsupportedFilterableData::_tao_any_destructor,
      CosNotifyFilter::_tc_UnsupportedFilterableData,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::UnsupportedFilterableData *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::UnsupportedFilterableData>::insert (
      _tao_any,
      CosNotifyFilter::UnsupportedFilterableData::_tao_any_destructor,
      CosNotifyFilter::_tc_UnsupportedFilterableData,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::UnsupportedFilterableData *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::UnsupportedFilterableData *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::UnsupportedFilterableData *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::UnsupportedFilterableData>::extract (
        _tao_any,
        CosNotifyFilter::UnsupportedFilterableData::_tao_any_destructor,
        CosNotifyFilter::_tc_UnsupportedFilterableData,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosNotifyFilter::InvalidGrammar>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::InvalidGrammar &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::InvalidGrammar>::insert_copy (
        _tao_any,
        ::CosNotifyFilter::InvalidGrammar::_tao_any_destructor,
        ::CosNotifyFilter::_tc_InvalidGrammar,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::InvalidGrammar *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::InvalidGrammar>::insert (
        _tao_any,
        ::CosNotifyFilter::InvalidGrammar::_tao_any_destructor,
        ::CosNotifyFilter::_tc_InvalidGrammar,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::InvalidGrammar *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::InvalidGrammar *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::InvalidGrammar *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::InvalidGrammar>::extract (
          _tao_any,
          ::CosNotifyFilter::InvalidGrammar::_tao_any_destructor,
          ::CosNotifyFilter::_tc_InvalidGrammar,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::InvalidGrammar &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::InvalidGrammar>::insert_copy (
      _tao_any,
      CosNotifyFilter::InvalidGrammar::_tao_any_destructor,
      CosNotifyFilter::_tc_InvalidGrammar,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::InvalidGrammar *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::InvalidGrammar>::insert (
      _tao_any,
      CosNotifyFilter::InvalidGrammar::_tao_any_destructor,
      CosNotifyFilter::_tc_InvalidGrammar,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::InvalidGrammar *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::InvalidGrammar *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::InvalidGrammar *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::InvalidGrammar>::extract (
        _tao_any,
        CosNotifyFilter::InvalidGrammar::_tao_any_destructor,
        CosNotifyFilter::_tc_InvalidGrammar,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosNotifyFilter::InvalidConstraint>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::InvalidConstraint &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::InvalidConstraint>::insert_copy (
        _tao_any,
        ::CosNotifyFilter::InvalidConstraint::_tao_any_destructor,
        ::CosNotifyFilter::_tc_InvalidConstraint,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::InvalidConstraint *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::InvalidConstraint>::insert (
        _tao_any,
        ::CosNotifyFilter::InvalidConstraint::_tao_any_destructor,
        ::CosNotifyFilter::_tc_InvalidConstraint,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::InvalidConstraint *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::InvalidConstraint *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::InvalidConstraint *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::InvalidConstraint>::extract (
          _tao_any,
          ::CosNotifyFilter::InvalidConstraint::_tao_any_destructor,
          ::CosNotifyFilter::_tc_InvalidConstraint,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::InvalidConstraint &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::InvalidConstraint>::insert_copy (
      _tao_any,
      CosNotifyFilter::InvalidConstraint::_tao_any_destructor,
      CosNotifyFilter::_tc_InvalidConstraint,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::InvalidConstraint *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::InvalidConstraint>::insert (
      _tao_any,
      CosNotifyFilter::InvalidConstraint::_tao_any_destructor,
      CosNotifyFilter::_tc_InvalidConstraint,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::InvalidConstraint *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::InvalidConstraint *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::InvalidConstraint *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::InvalidConstraint>::extract (
        _tao_any,
        CosNotifyFilter::InvalidConstraint::_tao_any_destructor,
        CosNotifyFilter::_tc_InvalidConstraint,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosNotifyFilter::DuplicateConstraintID>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::DuplicateConstraintID &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::DuplicateConstraintID>::insert_copy (
        _tao_any,
        ::CosNotifyFilter::DuplicateConstraintID::_tao_any_destructor,
        ::CosNotifyFilter::_tc_DuplicateConstraintID,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::DuplicateConstraintID *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::DuplicateConstraintID>::insert (
        _tao_any,
        ::CosNotifyFilter::DuplicateConstraintID::_tao_any_destructor,
        ::CosNotifyFilter::_tc_DuplicateConstraintID,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::DuplicateConstraintID *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::DuplicateConstraintID *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::DuplicateConstraintID *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::DuplicateConstraintID>::extract (
          _tao_any,
          ::CosNotifyFilter::DuplicateConstraintID::_tao_any_destructor,
          ::CosNotifyFilter::_tc_DuplicateConstraintID,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::DuplicateConstraintID &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::DuplicateConstraintID>::insert_copy (
      _tao_any,
      CosNotifyFilter::DuplicateConstraintID::_tao_any_destructor,
      CosNotifyFilter::_tc_DuplicateConstraintID,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::DuplicateConstraintID *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::DuplicateConstraintID>::insert (
      _tao_any,
      CosNotifyFilter::DuplicateConstraintID::_tao_any_destructor,
      CosNotifyFilter::_tc_DuplicateConstraintID,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::DuplicateConstraintID *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::DuplicateConstraintID *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::DuplicateConstraintID *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::DuplicateConstraintID>::extract (
        _tao_any,
        CosNotifyFilter::DuplicateConstraintID::_tao_any_destructor,
        CosNotifyFilter::_tc_DuplicateConstraintID,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosNotifyFilter::ConstraintNotFound>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::ConstraintNotFound &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintNotFound>::insert_copy (
        _tao_any,
        ::CosNotifyFilter::ConstraintNotFound::_tao_any_destructor,
        ::CosNotifyFilter::_tc_ConstraintNotFound,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::ConstraintNotFound *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintNotFound>::insert (
        _tao_any,
        ::CosNotifyFilter::ConstraintNotFound::_tao_any_destructor,
        ::CosNotifyFilter::_tc_ConstraintNotFound,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::ConstraintNotFound *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::ConstraintNotFound *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::ConstraintNotFound *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::ConstraintNotFound>::extract (
          _tao_any,
          ::CosNotifyFilter::ConstraintNotFound::_tao_any_destructor,
          ::CosNotifyFilter::_tc_ConstraintNotFound,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::ConstraintNotFound &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintNotFound>::insert_copy (
      _tao_any,
      CosNotifyFilter::ConstraintNotFound::_tao_any_destructor,
      CosNotifyFilter::_tc_ConstraintNotFound,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::ConstraintNotFound *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintNotFound>::insert (
      _tao_any,
      CosNotifyFilter::ConstraintNotFound::_tao_any_destructor,
      CosNotifyFilter::_tc_ConstraintNotFound,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::ConstraintNotFound *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::ConstraintNotFound *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::ConstraintNotFound *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::ConstraintNotFound>::extract (
        _tao_any,
        CosNotifyFilter::ConstraintNotFound::_tao_any_destructor,
        CosNotifyFilter::_tc_ConstraintNotFound,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosNotifyFilter::CallbackNotFound>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::CallbackNotFound &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::CallbackNotFound>::insert_copy (
        _tao_any,
        ::CosNotifyFilter::CallbackNotFound::_tao_any_destructor,
        ::CosNotifyFilter::_tc_CallbackNotFound,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::CallbackNotFound *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::CallbackNotFound>::insert (
        _tao_any,
        ::CosNotifyFilter::CallbackNotFound::_tao_any_destructor,
        ::CosNotifyFilter::_tc_CallbackNotFound,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::CallbackNotFound *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::CallbackNotFound *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::CallbackNotFound *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::CallbackNotFound>::extract (
          _tao_any,
          ::CosNotifyFilter::CallbackNotFound::_tao_any_destructor,
          ::CosNotifyFilter::_tc_CallbackNotFound,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::CallbackNotFound &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::CallbackNotFound>::insert_copy (
      _tao_any,
      CosNotifyFilter::CallbackNotFound::_tao_any_destructor,
      CosNotifyFilter::_tc_CallbackNotFound,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::CallbackNotFound *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::CallbackNotFound>::insert (
      _tao_any,
      CosNotifyFilter::CallbackNotFound::_tao_any_destructor,
      CosNotifyFilter::_tc_CallbackNotFound,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::CallbackNotFound *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::CallbackNotFound *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::CallbackNotFound *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::CallbackNotFound>::extract (
        _tao_any,
        CosNotifyFilter::CallbackNotFound::_tao_any_destructor,
        CosNotifyFilter::_tc_CallbackNotFound,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosNotifyFilter::InvalidValue>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::InvalidValue &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::InvalidValue>::insert_copy (
        _tao_any,
        ::CosNotifyFilter::InvalidValue::_tao_any_destructor,
        ::CosNotifyFilter::_tc_InvalidValue,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::InvalidValue *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::InvalidValue>::insert (
        _tao_any,
        ::CosNotifyFilter::InvalidValue::_tao_any_destructor,
        ::CosNotifyFilter::_tc_InvalidValue,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::InvalidValue *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::InvalidValue *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::InvalidValue *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::InvalidValue>::extract (
          _tao_any,
          ::CosNotifyFilter::InvalidValue::_tao_any_destructor,
          ::CosNotifyFilter::_tc_InvalidValue,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::InvalidValue &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::InvalidValue>::insert_copy (
      _tao_any,
      CosNotifyFilter::InvalidValue::_tao_any_destructor,
      CosNotifyFilter::_tc_InvalidValue,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::InvalidValue *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::InvalidValue>::insert (
      _tao_any,
      CosNotifyFilter::InvalidValue::_tao_any_destructor,
      CosNotifyFilter::_tc_InvalidValue,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::InvalidValue *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::InvalidValue *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::InvalidValue *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::InvalidValue>::extract (
        _tao_any,
        CosNotifyFilter::InvalidValue::_tao_any_destructor,
        CosNotifyFilter::_tc_InvalidValue,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosNotifyFilter::Filter>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Filter_ptr _tao_elem)
  {
    Filter_ptr _tao_objptr =
      Filter::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Filter_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Filter>::insert (
        _tao_any,
        Filter::_tao_any_destructor,
        _tc_Filter,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Filter_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Filter>::extract (
          _tao_any,
          Filter::_tao_any_destructor,
          _tc_Filter,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::Filter_ptr _tao_elem)
{
  CosNotifyFilter::Filter_ptr _tao_objptr =
    CosNotifyFilter::Filter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::Filter_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosNotifyFilter::Filter>::insert (
      _tao_any,
      CosNotifyFilter::Filter::_tao_any_destructor,
      CosNotifyFilter::_tc_Filter,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::Filter_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosNotifyFilter::Filter>::extract (
        _tao_any,
        CosNotifyFilter::Filter::_tao_any_destructor,
        CosNotifyFilter::_tc_Filter,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosNotifyFilter::MappingFilter>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      MappingFilter_ptr _tao_elem)
  {
    MappingFilter_ptr _tao_objptr =
      MappingFilter::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      MappingFilter_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<MappingFilter>::insert (
        _tao_any,
        MappingFilter::_tao_any_destructor,
        _tc_MappingFilter,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      MappingFilter_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<MappingFilter>::extract (
          _tao_any,
          MappingFilter::_tao_any_destructor,
          _tc_MappingFilter,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::MappingFilter_ptr _tao_elem)
{
  CosNotifyFilter::MappingFilter_ptr _tao_objptr =
    CosNotifyFilter::MappingFilter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::MappingFilter_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosNotifyFilter::MappingFilter>::insert (
      _tao_any,
      CosNotifyFilter::MappingFilter::_tao_any_destructor,
      CosNotifyFilter::_tc_MappingFilter,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::MappingFilter_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosNotifyFilter::MappingFilter>::extract (
        _tao_any,
        CosNotifyFilter::MappingFilter::_tao_any_destructor,
        CosNotifyFilter::_tc_MappingFilter,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosNotifyFilter::FilterFactory>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FilterFactory_ptr _tao_elem)
  {
    FilterFactory_ptr _tao_objptr =
      FilterFactory::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FilterFactory_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<FilterFactory>::insert (
        _tao_any,
        FilterFactory::_tao_any_destructor,
        _tc_FilterFactory,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      FilterFactory_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<FilterFactory>::extract (
          _tao_any,
          FilterFactory::_tao_any_destructor,
          _tc_FilterFactory,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::FilterFactory_ptr _tao_elem)
{
  CosNotifyFilter::FilterFactory_ptr _tao_objptr =
    CosNotifyFilter::FilterFactory::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::FilterFactory_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosNotifyFilter::FilterFactory>::insert (
      _tao_any,
      CosNotifyFilter::FilterFactory::_tao_any_destructor,
      CosNotifyFilter::_tc_FilterFactory,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::FilterFactory_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosNotifyFilter::FilterFactory>::extract (
        _tao_any,
        CosNotifyFilter::FilterFactory::_tao_any_destructor,
        CosNotifyFilter::_tc_FilterFactory,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::FilterIDSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CosNotifyFilter::FilterIDSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::FilterIDSeq>::insert_copy (
          _tao_any,
          ::CosNotifyFilter::FilterIDSeq::_tao_any_destructor,
          ::CosNotifyFilter::_tc_FilterIDSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::FilterIDSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::FilterIDSeq>::insert (
        _tao_any,
        ::CosNotifyFilter::FilterIDSeq::_tao_any_destructor,
        ::CosNotifyFilter::_tc_FilterIDSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::FilterIDSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::FilterIDSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::FilterIDSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::FilterIDSeq>::extract (
          _tao_any,
          ::CosNotifyFilter::FilterIDSeq::_tao_any_destructor,
          ::CosNotifyFilter::_tc_FilterIDSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::FilterIDSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CosNotifyFilter::FilterIDSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CosNotifyFilter::FilterIDSeq>::insert_copy (
        _tao_any,
        CosNotifyFilter::FilterIDSeq::_tao_any_destructor,
        CosNotifyFilter::_tc_FilterIDSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::FilterIDSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::FilterIDSeq>::insert (
      _tao_any,
      CosNotifyFilter::FilterIDSeq::_tao_any_destructor,
      CosNotifyFilter::_tc_FilterIDSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::FilterIDSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::FilterIDSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::FilterIDSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::FilterIDSeq>::extract (
        _tao_any,
        CosNotifyFilter::FilterIDSeq::_tao_any_destructor,
        CosNotifyFilter::_tc_FilterIDSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<CosNotifyFilter::FilterNotFound>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::FilterNotFound &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::FilterNotFound>::insert_copy (
        _tao_any,
        ::CosNotifyFilter::FilterNotFound::_tao_any_destructor,
        ::CosNotifyFilter::_tc_FilterNotFound,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::FilterNotFound *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CosNotifyFilter::FilterNotFound>::insert (
        _tao_any,
        ::CosNotifyFilter::FilterNotFound::_tao_any_destructor,
        ::CosNotifyFilter::_tc_FilterNotFound,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CosNotifyFilter::FilterNotFound *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CosNotifyFilter::FilterNotFound *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CosNotifyFilter::FilterNotFound *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CosNotifyFilter::FilterNotFound>::extract (
          _tao_any,
          ::CosNotifyFilter::FilterNotFound::_tao_any_destructor,
          ::CosNotifyFilter::_tc_FilterNotFound,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CosNotifyFilter::FilterNotFound &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::FilterNotFound>::insert_copy (
      _tao_any,
      CosNotifyFilter::FilterNotFound::_tao_any_destructor,
      CosNotifyFilter::_tc_FilterNotFound,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::FilterNotFound *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CosNotifyFilter::FilterNotFound>::insert (
      _tao_any,
      CosNotifyFilter::FilterNotFound::_tao_any_destructor,
      CosNotifyFilter::_tc_FilterNotFound,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::FilterNotFound *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CosNotifyFilter::FilterNotFound *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CosNotifyFilter::FilterNotFound *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CosNotifyFilter::FilterNotFound>::extract (
        _tao_any,
        CosNotifyFilter::FilterNotFound::_tao_any_destructor,
        CosNotifyFilter::_tc_FilterNotFound,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<CosNotifyFilter::FilterAdmin>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CosNotifyFilter
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FilterAdmin_ptr _tao_elem)
  {
    FilterAdmin_ptr _tao_objptr =
      FilterAdmin::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FilterAdmin_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<FilterAdmin>::insert (
        _tao_any,
        FilterAdmin::_tao_any_destructor,
        _tc_FilterAdmin,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      FilterAdmin_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<FilterAdmin>::extract (
          _tao_any,
          FilterAdmin::_tao_any_destructor,
          _tc_FilterAdmin,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::FilterAdmin_ptr _tao_elem)
{
  CosNotifyFilter::FilterAdmin_ptr _tao_objptr =
    CosNotifyFilter::FilterAdmin::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    CosNotifyFilter::FilterAdmin_ptr *_tao_elem)
{
  TAO::Any_Impl_T<CosNotifyFilter::FilterAdmin>::insert (
      _tao_any,
      CosNotifyFilter::FilterAdmin::_tao_any_destructor,
      CosNotifyFilter::_tc_FilterAdmin,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    CosNotifyFilter::FilterAdmin_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<CosNotifyFilter::FilterAdmin>::extract (
        _tao_any,
        CosNotifyFilter::FilterAdmin::_tao_any_destructor,
        CosNotifyFilter::_tc_FilterAdmin,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::ConstraintExp &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.event_types) &&
    (strm << _tao_aggregate.constraint_expr.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::ConstraintExp &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.event_types) &&
    (strm >> _tao_aggregate.constraint_expr.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosNotifyFilter_ConstraintIDSeq_CPP_
#define _TAO_CDR_OP_CosNotifyFilter_ConstraintIDSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::ConstraintIDSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::ConstraintIDSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosNotifyFilter_ConstraintIDSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosNotifyFilter_ConstraintExpSeq_CPP_
#define _TAO_CDR_OP_CosNotifyFilter_ConstraintExpSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::ConstraintExpSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::ConstraintExpSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosNotifyFilter_ConstraintExpSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::ConstraintInfo &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.constraint_expression) &&
    (strm << _tao_aggregate.constraint_id);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::ConstraintInfo &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.constraint_expression) &&
    (strm >> _tao_aggregate.constraint_id);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosNotifyFilter_ConstraintInfoSeq_CPP_
#define _TAO_CDR_OP_CosNotifyFilter_ConstraintInfoSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::ConstraintInfoSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::ConstraintInfoSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosNotifyFilter_ConstraintInfoSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::MappingConstraintPair &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.constraint_expression) &&
    (strm << _tao_aggregate.result_to_set);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::MappingConstraintPair &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.constraint_expression) &&
    (strm >> _tao_aggregate.result_to_set);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosNotifyFilter_MappingConstraintPairSeq_CPP_
#define _TAO_CDR_OP_CosNotifyFilter_MappingConstraintPairSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::MappingConstraintPairSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::MappingConstraintPairSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosNotifyFilter_MappingConstraintPairSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::MappingConstraintInfo &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.constraint_expression) &&
    (strm << _tao_aggregate.constraint_id) &&
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::MappingConstraintInfo &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.constraint_expression) &&
    (strm >> _tao_aggregate.constraint_id) &&
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosNotifyFilter_MappingConstraintInfoSeq_CPP_
#define _TAO_CDR_OP_CosNotifyFilter_MappingConstraintInfoSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::MappingConstraintInfoSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::MappingConstraintInfoSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosNotifyFilter_MappingConstraintInfoSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosNotifyFilter_CallbackIDSeq_CPP_
#define _TAO_CDR_OP_CosNotifyFilter_CallbackIDSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::CallbackIDSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::CallbackIDSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosNotifyFilter_CallbackIDSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::UnsupportedFilterableData &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CosNotifyFilter::UnsupportedFilterableData&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::InvalidGrammar &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CosNotifyFilter::InvalidGrammar&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::InvalidConstraint &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.constr)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::InvalidConstraint &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.constr)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::DuplicateConstraintID &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.id)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::DuplicateConstraintID &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.id)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::ConstraintNotFound &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.id)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::ConstraintNotFound &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.id)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::CallbackNotFound &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CosNotifyFilter::CallbackNotFound&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::InvalidValue &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.constr) &&
        (strm << _tao_aggregate.value)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::InvalidValue &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.constr) &&
    (strm >> _tao_aggregate.value)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::Filter_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::Filter_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosNotifyFilter::Filter RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosNotifyFilter__TAO_Filter_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::MappingFilter_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::MappingFilter_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosNotifyFilter::MappingFilter RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosNotifyFilter__TAO_MappingFilter_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::FilterFactory_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::FilterFactory_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosNotifyFilter::FilterFactory RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosNotifyFilter__TAO_FilterFactory_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CosNotifyFilter_FilterIDSeq_CPP_
#define _TAO_CDR_OP_CosNotifyFilter_FilterIDSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::FilterIDSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::FilterIDSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CosNotifyFilter_FilterIDSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::FilterNotFound &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CosNotifyFilter::FilterNotFound&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CosNotifyFilter::FilterAdmin_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CosNotifyFilter::FilterAdmin_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::CosNotifyFilter::FilterAdmin RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CosNotifyFilter__TAO_FilterAdmin_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL





TAO_END_VERSIONED_NAMESPACE_DECL


