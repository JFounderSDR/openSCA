// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "CSIIOPC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/CDR.h"
#include "tao/ORB_Core.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"

#if !defined (__ACE_INLINE__)
#include "CSIIOPC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSIIOP_AssociationOptions (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSIIOP/AssociationOptions:1.0",
    "AssociationOptions",
    &CORBA::_tc_ushort);
  

namespace CSIIOP
{
  ::CORBA::TypeCode_ptr const _tc_AssociationOptions =
    &_tao_tc_CSIIOP_AssociationOptions;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSIIOP_ServiceConfigurationSyntax (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSIIOP/ServiceConfigurationSyntax:1.0",
    "ServiceConfigurationSyntax",
    &CORBA::_tc_ulong);
  

namespace CSIIOP
{
  ::CORBA::TypeCode_ptr const _tc_ServiceConfigurationSyntax =
    &_tao_tc_CSIIOP_ServiceConfigurationSyntax;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSIIOP_SERVICESPECIFICNAME_CS_)
#define _CSIIOP_SERVICESPECIFICNAME_CS_

CSIIOP::ServiceSpecificName::ServiceSpecificName (void)
{}

CSIIOP::ServiceSpecificName::ServiceSpecificName (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

CSIIOP::ServiceSpecificName::ServiceSpecificName (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

CSIIOP::ServiceSpecificName::ServiceSpecificName (
    const ServiceSpecificName &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

CSIIOP::ServiceSpecificName::~ServiceSpecificName (void)
{}

void CSIIOP::ServiceSpecificName::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ServiceSpecificName * _tao_tmp_pointer =
    static_cast<ServiceSpecificName *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSIIOP_ServiceSpecificName_GUARD
#define _TAO_TYPECODE_CSIIOP_ServiceSpecificName_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSIIOP_ServiceSpecificName_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSIIOP_ServiceSpecificName_0 =
        &CSIIOP_ServiceSpecificName_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSIIOP_ServiceSpecificName_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSIIOP_ServiceSpecificName (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSIIOP/ServiceSpecificName:1.0",
    "ServiceSpecificName",
    &TAO::TypeCode::tc_CSIIOP_ServiceSpecificName_0);
  

namespace CSIIOP
{
  ::CORBA::TypeCode_ptr const _tc_ServiceSpecificName =
    &_tao_tc_CSIIOP_ServiceSpecificName;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CSIIOP_ServiceConfiguration[] =
      {
        { "syntax", &CSIIOP::_tc_ServiceConfigurationSyntax },
        { "name", &CSIIOP::_tc_ServiceSpecificName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CSIIOP_ServiceConfiguration (
  ::CORBA::tk_struct,
  "IDL:omg.org/CSIIOP/ServiceConfiguration:1.0",
  "ServiceConfiguration",
  _tao_fields_CSIIOP_ServiceConfiguration,
  2);


namespace CSIIOP
{
  ::CORBA::TypeCode_ptr const _tc_ServiceConfiguration =
    &_tao_tc_CSIIOP_ServiceConfiguration;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CSIIOP::ServiceConfiguration::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ServiceConfiguration *_tao_tmp_pointer =
    static_cast<ServiceConfiguration *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSIIOP_SERVICECONFIGURATIONLIST_CS_)
#define _CSIIOP_SERVICECONFIGURATIONLIST_CS_

CSIIOP::ServiceConfigurationList::ServiceConfigurationList (void)
{}

CSIIOP::ServiceConfigurationList::ServiceConfigurationList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ServiceConfiguration
      > (max)
{}

CSIIOP::ServiceConfigurationList::ServiceConfigurationList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CSIIOP::ServiceConfiguration * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ServiceConfiguration
      >
    (max, length, buffer, release)
{}

CSIIOP::ServiceConfigurationList::ServiceConfigurationList (
    const ServiceConfigurationList &seq)
  : ::TAO::unbounded_value_sequence<
        ServiceConfiguration
      > (seq)
{}

CSIIOP::ServiceConfigurationList::~ServiceConfigurationList (void)
{}

void CSIIOP::ServiceConfigurationList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ServiceConfigurationList * _tao_tmp_pointer =
    static_cast<ServiceConfigurationList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSIIOP_ServiceConfigurationList_GUARD
#define _TAO_TYPECODE_CSIIOP_ServiceConfigurationList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSIIOP_ServiceConfigurationList_0 (
          ::CORBA::tk_sequence,
          &CSIIOP::_tc_ServiceConfiguration,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSIIOP_ServiceConfigurationList_0 =
        &CSIIOP_ServiceConfigurationList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSIIOP_ServiceConfigurationList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSIIOP_ServiceConfigurationList (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSIIOP/ServiceConfigurationList:1.0",
    "ServiceConfigurationList",
    &TAO::TypeCode::tc_CSIIOP_ServiceConfigurationList_0);
  

namespace CSIIOP
{
  ::CORBA::TypeCode_ptr const _tc_ServiceConfigurationList =
    &_tao_tc_CSIIOP_ServiceConfigurationList;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CSIIOP_AS_ContextSec[] =
      {
        { "target_supports", &CSIIOP::_tc_AssociationOptions },
        { "target_requires", &CSIIOP::_tc_AssociationOptions },
        { "client_authentication_mech", &CSI::_tc_OID },
        { "target_name", &CSI::_tc_GSS_NT_ExportedName }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CSIIOP_AS_ContextSec (
  ::CORBA::tk_struct,
  "IDL:omg.org/CSIIOP/AS_ContextSec:1.0",
  "AS_ContextSec",
  _tao_fields_CSIIOP_AS_ContextSec,
  4);


namespace CSIIOP
{
  ::CORBA::TypeCode_ptr const _tc_AS_ContextSec =
    &_tao_tc_CSIIOP_AS_ContextSec;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CSIIOP::AS_ContextSec::_tao_any_destructor (
    void *_tao_void_pointer)
{
  AS_ContextSec *_tao_tmp_pointer =
    static_cast<AS_ContextSec *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CSIIOP_SAS_ContextSec[] =
      {
        { "target_supports", &CSIIOP::_tc_AssociationOptions },
        { "target_requires", &CSIIOP::_tc_AssociationOptions },
        { "privilege_authorities", &CSIIOP::_tc_ServiceConfigurationList },
        { "supported_naming_mechanisms", &CSI::_tc_OIDList },
        { "supported_identity_types", &CSI::_tc_IdentityTokenType }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CSIIOP_SAS_ContextSec (
  ::CORBA::tk_struct,
  "IDL:omg.org/CSIIOP/SAS_ContextSec:1.0",
  "SAS_ContextSec",
  _tao_fields_CSIIOP_SAS_ContextSec,
  5);


namespace CSIIOP
{
  ::CORBA::TypeCode_ptr const _tc_SAS_ContextSec =
    &_tao_tc_CSIIOP_SAS_ContextSec;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CSIIOP::SAS_ContextSec::_tao_any_destructor (
    void *_tao_void_pointer)
{
  SAS_ContextSec *_tao_tmp_pointer =
    static_cast<SAS_ContextSec *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CSIIOP_CompoundSecMech[] =
      {
        { "target_requires", &CSIIOP::_tc_AssociationOptions },
        { "transport_mech", &IOP::_tc_TaggedComponent },
        { "as_context_mech", &CSIIOP::_tc_AS_ContextSec },
        { "sas_context_mech", &CSIIOP::_tc_SAS_ContextSec }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CSIIOP_CompoundSecMech (
  ::CORBA::tk_struct,
  "IDL:omg.org/CSIIOP/CompoundSecMech:1.0",
  "CompoundSecMech",
  _tao_fields_CSIIOP_CompoundSecMech,
  4);


namespace CSIIOP
{
  ::CORBA::TypeCode_ptr const _tc_CompoundSecMech =
    &_tao_tc_CSIIOP_CompoundSecMech;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CSIIOP::CompoundSecMech::_tao_any_destructor (
    void *_tao_void_pointer)
{
  CompoundSecMech *_tao_tmp_pointer =
    static_cast<CompoundSecMech *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSIIOP_COMPOUNDSECMECHANISMS_CS_)
#define _CSIIOP_COMPOUNDSECMECHANISMS_CS_

CSIIOP::CompoundSecMechanisms::CompoundSecMechanisms (void)
{}

CSIIOP::CompoundSecMechanisms::CompoundSecMechanisms (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        CompoundSecMech
      > (max)
{}

CSIIOP::CompoundSecMechanisms::CompoundSecMechanisms (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CSIIOP::CompoundSecMech * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        CompoundSecMech
      >
    (max, length, buffer, release)
{}

CSIIOP::CompoundSecMechanisms::CompoundSecMechanisms (
    const CompoundSecMechanisms &seq)
  : ::TAO::unbounded_value_sequence<
        CompoundSecMech
      > (seq)
{}

CSIIOP::CompoundSecMechanisms::~CompoundSecMechanisms (void)
{}

void CSIIOP::CompoundSecMechanisms::_tao_any_destructor (
    void * _tao_void_pointer)
{
  CompoundSecMechanisms * _tao_tmp_pointer =
    static_cast<CompoundSecMechanisms *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSIIOP_CompoundSecMechanisms_GUARD
#define _TAO_TYPECODE_CSIIOP_CompoundSecMechanisms_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSIIOP_CompoundSecMechanisms_0 (
          ::CORBA::tk_sequence,
          &CSIIOP::_tc_CompoundSecMech,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSIIOP_CompoundSecMechanisms_0 =
        &CSIIOP_CompoundSecMechanisms_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSIIOP_CompoundSecMechanisms_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSIIOP_CompoundSecMechanisms (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSIIOP/CompoundSecMechanisms:1.0",
    "CompoundSecMechanisms",
    &TAO::TypeCode::tc_CSIIOP_CompoundSecMechanisms_0);
  

namespace CSIIOP
{
  ::CORBA::TypeCode_ptr const _tc_CompoundSecMechanisms =
    &_tao_tc_CSIIOP_CompoundSecMechanisms;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CSIIOP_CompoundSecMechList[] =
      {
        { "stateful", &CORBA::_tc_boolean },
        { "mechanism_list", &CSIIOP::_tc_CompoundSecMechanisms }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CSIIOP_CompoundSecMechList (
  ::CORBA::tk_struct,
  "IDL:omg.org/CSIIOP/CompoundSecMechList:1.0",
  "CompoundSecMechList",
  _tao_fields_CSIIOP_CompoundSecMechList,
  2);


namespace CSIIOP
{
  ::CORBA::TypeCode_ptr const _tc_CompoundSecMechList =
    &_tao_tc_CSIIOP_CompoundSecMechList;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CSIIOP::CompoundSecMechList::_tao_any_destructor (
    void *_tao_void_pointer)
{
  CompoundSecMechList *_tao_tmp_pointer =
    static_cast<CompoundSecMechList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CSIIOP_TransportAddress[] =
      {
        { "host_name", &CORBA::_tc_string },
        { "port", &CORBA::_tc_ushort }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CSIIOP_TransportAddress (
  ::CORBA::tk_struct,
  "IDL:omg.org/CSIIOP/TransportAddress:1.0",
  "TransportAddress",
  _tao_fields_CSIIOP_TransportAddress,
  2);


namespace CSIIOP
{
  ::CORBA::TypeCode_ptr const _tc_TransportAddress =
    &_tao_tc_CSIIOP_TransportAddress;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CSIIOP::TransportAddress::_tao_any_destructor (
    void *_tao_void_pointer)
{
  TransportAddress *_tao_tmp_pointer =
    static_cast<TransportAddress *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_CSIIOP_TRANSPORTADDRESSLIST_CS_)
#define _CSIIOP_TRANSPORTADDRESSLIST_CS_

CSIIOP::TransportAddressList::TransportAddressList (void)
{}

CSIIOP::TransportAddressList::TransportAddressList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        TransportAddress
      > (max)
{}

CSIIOP::TransportAddressList::TransportAddressList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CSIIOP::TransportAddress * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        TransportAddress
      >
    (max, length, buffer, release)
{}

CSIIOP::TransportAddressList::TransportAddressList (
    const TransportAddressList &seq)
  : ::TAO::unbounded_value_sequence<
        TransportAddress
      > (seq)
{}

CSIIOP::TransportAddressList::~TransportAddressList (void)
{}

void CSIIOP::TransportAddressList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  TransportAddressList * _tao_tmp_pointer =
    static_cast<TransportAddressList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_CSIIOP_TransportAddressList_GUARD
#define _TAO_TYPECODE_CSIIOP_TransportAddressList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        CSIIOP_TransportAddressList_0 (
          ::CORBA::tk_sequence,
          &CSIIOP::_tc_TransportAddress,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_CSIIOP_TransportAddressList_0 =
        &CSIIOP_TransportAddressList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_CSIIOP_TransportAddressList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_CSIIOP_TransportAddressList (
    ::CORBA::tk_alias,
    "IDL:omg.org/CSIIOP/TransportAddressList:1.0",
    "TransportAddressList",
    &TAO::TypeCode::tc_CSIIOP_TransportAddressList_0);
  

namespace CSIIOP
{
  ::CORBA::TypeCode_ptr const _tc_TransportAddressList =
    &_tao_tc_CSIIOP_TransportAddressList;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CSIIOP_SECIOP_SEC_TRANS[] =
      {
        { "target_supports", &CSIIOP::_tc_AssociationOptions },
        { "target_requires", &CSIIOP::_tc_AssociationOptions },
        { "mech_oid", &CSI::_tc_OID },
        { "target_name", &CSI::_tc_GSS_NT_ExportedName },
        { "addresses", &CSIIOP::_tc_TransportAddressList }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CSIIOP_SECIOP_SEC_TRANS (
  ::CORBA::tk_struct,
  "IDL:omg.org/CSIIOP/SECIOP_SEC_TRANS:1.0",
  "SECIOP_SEC_TRANS",
  _tao_fields_CSIIOP_SECIOP_SEC_TRANS,
  5);


namespace CSIIOP
{
  ::CORBA::TypeCode_ptr const _tc_SECIOP_SEC_TRANS =
    &_tao_tc_CSIIOP_SECIOP_SEC_TRANS;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CSIIOP::SECIOP_SEC_TRANS::_tao_any_destructor (
    void *_tao_void_pointer)
{
  SECIOP_SEC_TRANS *_tao_tmp_pointer =
    static_cast<SECIOP_SEC_TRANS *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_CSIIOP_TLS_SEC_TRANS[] =
      {
        { "target_supports", &CSIIOP::_tc_AssociationOptions },
        { "target_requires", &CSIIOP::_tc_AssociationOptions },
        { "addresses", &CSIIOP::_tc_TransportAddressList }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_CSIIOP_TLS_SEC_TRANS (
  ::CORBA::tk_struct,
  "IDL:omg.org/CSIIOP/TLS_SEC_TRANS:1.0",
  "TLS_SEC_TRANS",
  _tao_fields_CSIIOP_TLS_SEC_TRANS,
  3);


namespace CSIIOP
{
  ::CORBA::TypeCode_ptr const _tc_TLS_SEC_TRANS =
    &_tao_tc_CSIIOP_TLS_SEC_TRANS;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
CSIIOP::TLS_SEC_TRANS::_tao_any_destructor (
    void *_tao_void_pointer)
{
  TLS_SEC_TRANS *_tao_tmp_pointer =
    static_cast<TLS_SEC_TRANS *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSIIOP
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSIIOP::ServiceSpecificName &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSIIOP::ServiceSpecificName *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSIIOP::ServiceSpecificName>::insert_copy (
          _tao_any,
          ::CSIIOP::ServiceSpecificName::_tao_any_destructor,
          ::CSIIOP::_tc_ServiceSpecificName,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSIIOP::ServiceSpecificName *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSIIOP::ServiceSpecificName>::insert (
        _tao_any,
        ::CSIIOP::ServiceSpecificName::_tao_any_destructor,
        ::CSIIOP::_tc_ServiceSpecificName,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSIIOP::ServiceSpecificName *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSIIOP::ServiceSpecificName *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSIIOP::ServiceSpecificName *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSIIOP::ServiceSpecificName>::extract (
          _tao_any,
          ::CSIIOP::ServiceSpecificName::_tao_any_destructor,
          ::CSIIOP::_tc_ServiceSpecificName,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSIIOP::ServiceSpecificName &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSIIOP::ServiceSpecificName *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSIIOP::ServiceSpecificName>::insert_copy (
        _tao_any,
        CSIIOP::ServiceSpecificName::_tao_any_destructor,
        CSIIOP::_tc_ServiceSpecificName,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSIIOP::ServiceSpecificName *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSIIOP::ServiceSpecificName>::insert (
      _tao_any,
      CSIIOP::ServiceSpecificName::_tao_any_destructor,
      CSIIOP::_tc_ServiceSpecificName,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSIIOP::ServiceSpecificName *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSIIOP::ServiceSpecificName *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSIIOP::ServiceSpecificName *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSIIOP::ServiceSpecificName>::extract (
        _tao_any,
        CSIIOP::ServiceSpecificName::_tao_any_destructor,
        CSIIOP::_tc_ServiceSpecificName,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSIIOP
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSIIOP::ServiceConfiguration &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSIIOP::ServiceConfiguration *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSIIOP::ServiceConfiguration>::insert_copy (
          _tao_any,
          ::CSIIOP::ServiceConfiguration::_tao_any_destructor,
          ::CSIIOP::_tc_ServiceConfiguration,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CSIIOP::ServiceConfiguration *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSIIOP::ServiceConfiguration>::insert (
        _tao_any,
        ::CSIIOP::ServiceConfiguration::_tao_any_destructor,
        ::CSIIOP::_tc_ServiceConfiguration,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSIIOP::ServiceConfiguration *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSIIOP::ServiceConfiguration *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSIIOP::ServiceConfiguration *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSIIOP::ServiceConfiguration>::extract (
          _tao_any,
          ::CSIIOP::ServiceConfiguration::_tao_any_destructor,
          ::CSIIOP::_tc_ServiceConfiguration,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSIIOP::ServiceConfiguration &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSIIOP::ServiceConfiguration *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSIIOP::ServiceConfiguration>::insert_copy (
        _tao_any,
        CSIIOP::ServiceConfiguration::_tao_any_destructor,
        CSIIOP::_tc_ServiceConfiguration,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSIIOP::ServiceConfiguration *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSIIOP::ServiceConfiguration>::insert (
      _tao_any,
      CSIIOP::ServiceConfiguration::_tao_any_destructor,
      CSIIOP::_tc_ServiceConfiguration,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSIIOP::ServiceConfiguration *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSIIOP::ServiceConfiguration *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSIIOP::ServiceConfiguration *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSIIOP::ServiceConfiguration>::extract (
        _tao_any,
        CSIIOP::ServiceConfiguration::_tao_any_destructor,
        CSIIOP::_tc_ServiceConfiguration,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSIIOP
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSIIOP::ServiceConfigurationList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSIIOP::ServiceConfigurationList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSIIOP::ServiceConfigurationList>::insert_copy (
          _tao_any,
          ::CSIIOP::ServiceConfigurationList::_tao_any_destructor,
          ::CSIIOP::_tc_ServiceConfigurationList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSIIOP::ServiceConfigurationList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSIIOP::ServiceConfigurationList>::insert (
        _tao_any,
        ::CSIIOP::ServiceConfigurationList::_tao_any_destructor,
        ::CSIIOP::_tc_ServiceConfigurationList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSIIOP::ServiceConfigurationList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSIIOP::ServiceConfigurationList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSIIOP::ServiceConfigurationList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSIIOP::ServiceConfigurationList>::extract (
          _tao_any,
          ::CSIIOP::ServiceConfigurationList::_tao_any_destructor,
          ::CSIIOP::_tc_ServiceConfigurationList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSIIOP::ServiceConfigurationList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSIIOP::ServiceConfigurationList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSIIOP::ServiceConfigurationList>::insert_copy (
        _tao_any,
        CSIIOP::ServiceConfigurationList::_tao_any_destructor,
        CSIIOP::_tc_ServiceConfigurationList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSIIOP::ServiceConfigurationList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSIIOP::ServiceConfigurationList>::insert (
      _tao_any,
      CSIIOP::ServiceConfigurationList::_tao_any_destructor,
      CSIIOP::_tc_ServiceConfigurationList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSIIOP::ServiceConfigurationList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSIIOP::ServiceConfigurationList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSIIOP::ServiceConfigurationList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSIIOP::ServiceConfigurationList>::extract (
        _tao_any,
        CSIIOP::ServiceConfigurationList::_tao_any_destructor,
        CSIIOP::_tc_ServiceConfigurationList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSIIOP
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSIIOP::AS_ContextSec &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSIIOP::AS_ContextSec *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSIIOP::AS_ContextSec>::insert_copy (
          _tao_any,
          ::CSIIOP::AS_ContextSec::_tao_any_destructor,
          ::CSIIOP::_tc_AS_ContextSec,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CSIIOP::AS_ContextSec *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSIIOP::AS_ContextSec>::insert (
        _tao_any,
        ::CSIIOP::AS_ContextSec::_tao_any_destructor,
        ::CSIIOP::_tc_AS_ContextSec,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSIIOP::AS_ContextSec *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSIIOP::AS_ContextSec *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSIIOP::AS_ContextSec *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSIIOP::AS_ContextSec>::extract (
          _tao_any,
          ::CSIIOP::AS_ContextSec::_tao_any_destructor,
          ::CSIIOP::_tc_AS_ContextSec,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSIIOP::AS_ContextSec &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSIIOP::AS_ContextSec *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSIIOP::AS_ContextSec>::insert_copy (
        _tao_any,
        CSIIOP::AS_ContextSec::_tao_any_destructor,
        CSIIOP::_tc_AS_ContextSec,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSIIOP::AS_ContextSec *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSIIOP::AS_ContextSec>::insert (
      _tao_any,
      CSIIOP::AS_ContextSec::_tao_any_destructor,
      CSIIOP::_tc_AS_ContextSec,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSIIOP::AS_ContextSec *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSIIOP::AS_ContextSec *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSIIOP::AS_ContextSec *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSIIOP::AS_ContextSec>::extract (
        _tao_any,
        CSIIOP::AS_ContextSec::_tao_any_destructor,
        CSIIOP::_tc_AS_ContextSec,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSIIOP
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSIIOP::SAS_ContextSec &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSIIOP::SAS_ContextSec *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSIIOP::SAS_ContextSec>::insert_copy (
          _tao_any,
          ::CSIIOP::SAS_ContextSec::_tao_any_destructor,
          ::CSIIOP::_tc_SAS_ContextSec,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CSIIOP::SAS_ContextSec *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSIIOP::SAS_ContextSec>::insert (
        _tao_any,
        ::CSIIOP::SAS_ContextSec::_tao_any_destructor,
        ::CSIIOP::_tc_SAS_ContextSec,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSIIOP::SAS_ContextSec *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSIIOP::SAS_ContextSec *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSIIOP::SAS_ContextSec *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSIIOP::SAS_ContextSec>::extract (
          _tao_any,
          ::CSIIOP::SAS_ContextSec::_tao_any_destructor,
          ::CSIIOP::_tc_SAS_ContextSec,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSIIOP::SAS_ContextSec &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSIIOP::SAS_ContextSec *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSIIOP::SAS_ContextSec>::insert_copy (
        _tao_any,
        CSIIOP::SAS_ContextSec::_tao_any_destructor,
        CSIIOP::_tc_SAS_ContextSec,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSIIOP::SAS_ContextSec *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSIIOP::SAS_ContextSec>::insert (
      _tao_any,
      CSIIOP::SAS_ContextSec::_tao_any_destructor,
      CSIIOP::_tc_SAS_ContextSec,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSIIOP::SAS_ContextSec *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSIIOP::SAS_ContextSec *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSIIOP::SAS_ContextSec *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSIIOP::SAS_ContextSec>::extract (
        _tao_any,
        CSIIOP::SAS_ContextSec::_tao_any_destructor,
        CSIIOP::_tc_SAS_ContextSec,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSIIOP
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSIIOP::CompoundSecMech &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSIIOP::CompoundSecMech *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSIIOP::CompoundSecMech>::insert_copy (
          _tao_any,
          ::CSIIOP::CompoundSecMech::_tao_any_destructor,
          ::CSIIOP::_tc_CompoundSecMech,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CSIIOP::CompoundSecMech *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSIIOP::CompoundSecMech>::insert (
        _tao_any,
        ::CSIIOP::CompoundSecMech::_tao_any_destructor,
        ::CSIIOP::_tc_CompoundSecMech,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSIIOP::CompoundSecMech *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSIIOP::CompoundSecMech *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSIIOP::CompoundSecMech *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSIIOP::CompoundSecMech>::extract (
          _tao_any,
          ::CSIIOP::CompoundSecMech::_tao_any_destructor,
          ::CSIIOP::_tc_CompoundSecMech,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSIIOP::CompoundSecMech &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSIIOP::CompoundSecMech *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSIIOP::CompoundSecMech>::insert_copy (
        _tao_any,
        CSIIOP::CompoundSecMech::_tao_any_destructor,
        CSIIOP::_tc_CompoundSecMech,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSIIOP::CompoundSecMech *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSIIOP::CompoundSecMech>::insert (
      _tao_any,
      CSIIOP::CompoundSecMech::_tao_any_destructor,
      CSIIOP::_tc_CompoundSecMech,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSIIOP::CompoundSecMech *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSIIOP::CompoundSecMech *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSIIOP::CompoundSecMech *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSIIOP::CompoundSecMech>::extract (
        _tao_any,
        CSIIOP::CompoundSecMech::_tao_any_destructor,
        CSIIOP::_tc_CompoundSecMech,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSIIOP
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSIIOP::CompoundSecMechanisms &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSIIOP::CompoundSecMechanisms *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSIIOP::CompoundSecMechanisms>::insert_copy (
          _tao_any,
          ::CSIIOP::CompoundSecMechanisms::_tao_any_destructor,
          ::CSIIOP::_tc_CompoundSecMechanisms,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSIIOP::CompoundSecMechanisms *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSIIOP::CompoundSecMechanisms>::insert (
        _tao_any,
        ::CSIIOP::CompoundSecMechanisms::_tao_any_destructor,
        ::CSIIOP::_tc_CompoundSecMechanisms,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSIIOP::CompoundSecMechanisms *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSIIOP::CompoundSecMechanisms *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSIIOP::CompoundSecMechanisms *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSIIOP::CompoundSecMechanisms>::extract (
          _tao_any,
          ::CSIIOP::CompoundSecMechanisms::_tao_any_destructor,
          ::CSIIOP::_tc_CompoundSecMechanisms,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSIIOP::CompoundSecMechanisms &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSIIOP::CompoundSecMechanisms *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSIIOP::CompoundSecMechanisms>::insert_copy (
        _tao_any,
        CSIIOP::CompoundSecMechanisms::_tao_any_destructor,
        CSIIOP::_tc_CompoundSecMechanisms,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSIIOP::CompoundSecMechanisms *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSIIOP::CompoundSecMechanisms>::insert (
      _tao_any,
      CSIIOP::CompoundSecMechanisms::_tao_any_destructor,
      CSIIOP::_tc_CompoundSecMechanisms,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSIIOP::CompoundSecMechanisms *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSIIOP::CompoundSecMechanisms *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSIIOP::CompoundSecMechanisms *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSIIOP::CompoundSecMechanisms>::extract (
        _tao_any,
        CSIIOP::CompoundSecMechanisms::_tao_any_destructor,
        CSIIOP::_tc_CompoundSecMechanisms,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSIIOP
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSIIOP::CompoundSecMechList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSIIOP::CompoundSecMechList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSIIOP::CompoundSecMechList>::insert_copy (
          _tao_any,
          ::CSIIOP::CompoundSecMechList::_tao_any_destructor,
          ::CSIIOP::_tc_CompoundSecMechList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CSIIOP::CompoundSecMechList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSIIOP::CompoundSecMechList>::insert (
        _tao_any,
        ::CSIIOP::CompoundSecMechList::_tao_any_destructor,
        ::CSIIOP::_tc_CompoundSecMechList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSIIOP::CompoundSecMechList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSIIOP::CompoundSecMechList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSIIOP::CompoundSecMechList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSIIOP::CompoundSecMechList>::extract (
          _tao_any,
          ::CSIIOP::CompoundSecMechList::_tao_any_destructor,
          ::CSIIOP::_tc_CompoundSecMechList,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSIIOP::CompoundSecMechList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSIIOP::CompoundSecMechList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSIIOP::CompoundSecMechList>::insert_copy (
        _tao_any,
        CSIIOP::CompoundSecMechList::_tao_any_destructor,
        CSIIOP::_tc_CompoundSecMechList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSIIOP::CompoundSecMechList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSIIOP::CompoundSecMechList>::insert (
      _tao_any,
      CSIIOP::CompoundSecMechList::_tao_any_destructor,
      CSIIOP::_tc_CompoundSecMechList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSIIOP::CompoundSecMechList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSIIOP::CompoundSecMechList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSIIOP::CompoundSecMechList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSIIOP::CompoundSecMechList>::extract (
        _tao_any,
        CSIIOP::CompoundSecMechList::_tao_any_destructor,
        CSIIOP::_tc_CompoundSecMechList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSIIOP
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSIIOP::TransportAddress &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSIIOP::TransportAddress *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSIIOP::TransportAddress>::insert_copy (
          _tao_any,
          ::CSIIOP::TransportAddress::_tao_any_destructor,
          ::CSIIOP::_tc_TransportAddress,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CSIIOP::TransportAddress *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSIIOP::TransportAddress>::insert (
        _tao_any,
        ::CSIIOP::TransportAddress::_tao_any_destructor,
        ::CSIIOP::_tc_TransportAddress,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSIIOP::TransportAddress *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSIIOP::TransportAddress *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSIIOP::TransportAddress *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSIIOP::TransportAddress>::extract (
          _tao_any,
          ::CSIIOP::TransportAddress::_tao_any_destructor,
          ::CSIIOP::_tc_TransportAddress,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSIIOP::TransportAddress &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSIIOP::TransportAddress *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSIIOP::TransportAddress>::insert_copy (
        _tao_any,
        CSIIOP::TransportAddress::_tao_any_destructor,
        CSIIOP::_tc_TransportAddress,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSIIOP::TransportAddress *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSIIOP::TransportAddress>::insert (
      _tao_any,
      CSIIOP::TransportAddress::_tao_any_destructor,
      CSIIOP::_tc_TransportAddress,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSIIOP::TransportAddress *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSIIOP::TransportAddress *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSIIOP::TransportAddress *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSIIOP::TransportAddress>::extract (
        _tao_any,
        CSIIOP::TransportAddress::_tao_any_destructor,
        CSIIOP::_tc_TransportAddress,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSIIOP
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSIIOP::TransportAddressList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSIIOP::TransportAddressList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSIIOP::TransportAddressList>::insert_copy (
          _tao_any,
          ::CSIIOP::TransportAddressList::_tao_any_destructor,
          ::CSIIOP::_tc_TransportAddressList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::CSIIOP::TransportAddressList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSIIOP::TransportAddressList>::insert (
        _tao_any,
        ::CSIIOP::TransportAddressList::_tao_any_destructor,
        ::CSIIOP::_tc_TransportAddressList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSIIOP::TransportAddressList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSIIOP::TransportAddressList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSIIOP::TransportAddressList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSIIOP::TransportAddressList>::extract (
          _tao_any,
          ::CSIIOP::TransportAddressList::_tao_any_destructor,
          ::CSIIOP::_tc_TransportAddressList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSIIOP::TransportAddressList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSIIOP::TransportAddressList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSIIOP::TransportAddressList>::insert_copy (
        _tao_any,
        CSIIOP::TransportAddressList::_tao_any_destructor,
        CSIIOP::_tc_TransportAddressList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSIIOP::TransportAddressList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSIIOP::TransportAddressList>::insert (
      _tao_any,
      CSIIOP::TransportAddressList::_tao_any_destructor,
      CSIIOP::_tc_TransportAddressList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSIIOP::TransportAddressList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSIIOP::TransportAddressList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSIIOP::TransportAddressList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSIIOP::TransportAddressList>::extract (
        _tao_any,
        CSIIOP::TransportAddressList::_tao_any_destructor,
        CSIIOP::_tc_TransportAddressList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSIIOP
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSIIOP::SECIOP_SEC_TRANS &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSIIOP::SECIOP_SEC_TRANS *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSIIOP::SECIOP_SEC_TRANS>::insert_copy (
          _tao_any,
          ::CSIIOP::SECIOP_SEC_TRANS::_tao_any_destructor,
          ::CSIIOP::_tc_SECIOP_SEC_TRANS,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CSIIOP::SECIOP_SEC_TRANS *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSIIOP::SECIOP_SEC_TRANS>::insert (
        _tao_any,
        ::CSIIOP::SECIOP_SEC_TRANS::_tao_any_destructor,
        ::CSIIOP::_tc_SECIOP_SEC_TRANS,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSIIOP::SECIOP_SEC_TRANS *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSIIOP::SECIOP_SEC_TRANS *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSIIOP::SECIOP_SEC_TRANS *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSIIOP::SECIOP_SEC_TRANS>::extract (
          _tao_any,
          ::CSIIOP::SECIOP_SEC_TRANS::_tao_any_destructor,
          ::CSIIOP::_tc_SECIOP_SEC_TRANS,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSIIOP::SECIOP_SEC_TRANS &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSIIOP::SECIOP_SEC_TRANS *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSIIOP::SECIOP_SEC_TRANS>::insert_copy (
        _tao_any,
        CSIIOP::SECIOP_SEC_TRANS::_tao_any_destructor,
        CSIIOP::_tc_SECIOP_SEC_TRANS,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSIIOP::SECIOP_SEC_TRANS *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSIIOP::SECIOP_SEC_TRANS>::insert (
      _tao_any,
      CSIIOP::SECIOP_SEC_TRANS::_tao_any_destructor,
      CSIIOP::_tc_SECIOP_SEC_TRANS,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSIIOP::SECIOP_SEC_TRANS *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSIIOP::SECIOP_SEC_TRANS *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSIIOP::SECIOP_SEC_TRANS *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSIIOP::SECIOP_SEC_TRANS>::extract (
        _tao_any,
        CSIIOP::SECIOP_SEC_TRANS::_tao_any_destructor,
        CSIIOP::_tc_SECIOP_SEC_TRANS,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace CSIIOP
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::CSIIOP::TLS_SEC_TRANS &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::CSIIOP::TLS_SEC_TRANS *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::CSIIOP::TLS_SEC_TRANS>::insert_copy (
          _tao_any,
          ::CSIIOP::TLS_SEC_TRANS::_tao_any_destructor,
          ::CSIIOP::_tc_TLS_SEC_TRANS,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      CSIIOP::TLS_SEC_TRANS *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::CSIIOP::TLS_SEC_TRANS>::insert (
        _tao_any,
        ::CSIIOP::TLS_SEC_TRANS::_tao_any_destructor,
        ::CSIIOP::_tc_TLS_SEC_TRANS,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::CSIIOP::TLS_SEC_TRANS *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::CSIIOP::TLS_SEC_TRANS *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::CSIIOP::TLS_SEC_TRANS *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::CSIIOP::TLS_SEC_TRANS>::extract (
          _tao_any,
          ::CSIIOP::TLS_SEC_TRANS::_tao_any_destructor,
          ::CSIIOP::_tc_TLS_SEC_TRANS,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const CSIIOP::TLS_SEC_TRANS &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<CSIIOP::TLS_SEC_TRANS *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<CSIIOP::TLS_SEC_TRANS>::insert_copy (
        _tao_any,
        CSIIOP::TLS_SEC_TRANS::_tao_any_destructor,
        CSIIOP::_tc_TLS_SEC_TRANS,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    CSIIOP::TLS_SEC_TRANS *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CSIIOP::TLS_SEC_TRANS>::insert (
      _tao_any,
      CSIIOP::TLS_SEC_TRANS::_tao_any_destructor,
      CSIIOP::_tc_TLS_SEC_TRANS,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    CSIIOP::TLS_SEC_TRANS *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const CSIIOP::TLS_SEC_TRANS *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const CSIIOP::TLS_SEC_TRANS *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CSIIOP::TLS_SEC_TRANS>::extract (
        _tao_any,
        CSIIOP::TLS_SEC_TRANS::_tao_any_destructor,
        CSIIOP::_tc_TLS_SEC_TRANS,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSIIOP_ServiceSpecificName_CPP_
#define _TAO_CDR_OP_CSIIOP_ServiceSpecificName_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSIIOP::ServiceSpecificName &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSIIOP::ServiceSpecificName &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSIIOP_ServiceSpecificName_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSIIOP::ServiceConfiguration &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.syntax) &&
    (strm << _tao_aggregate.name);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSIIOP::ServiceConfiguration &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.syntax) &&
    (strm >> _tao_aggregate.name);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSIIOP_ServiceConfigurationList_CPP_
#define _TAO_CDR_OP_CSIIOP_ServiceConfigurationList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSIIOP::ServiceConfigurationList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSIIOP::ServiceConfigurationList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSIIOP_ServiceConfigurationList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSIIOP::AS_ContextSec &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.target_supports) &&
    (strm << _tao_aggregate.target_requires) &&
    (strm << _tao_aggregate.client_authentication_mech) &&
    (strm << _tao_aggregate.target_name);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSIIOP::AS_ContextSec &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.target_supports) &&
    (strm >> _tao_aggregate.target_requires) &&
    (strm >> _tao_aggregate.client_authentication_mech) &&
    (strm >> _tao_aggregate.target_name);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSIIOP::SAS_ContextSec &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.target_supports) &&
    (strm << _tao_aggregate.target_requires) &&
    (strm << _tao_aggregate.privilege_authorities) &&
    (strm << _tao_aggregate.supported_naming_mechanisms) &&
    (strm << _tao_aggregate.supported_identity_types);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSIIOP::SAS_ContextSec &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.target_supports) &&
    (strm >> _tao_aggregate.target_requires) &&
    (strm >> _tao_aggregate.privilege_authorities) &&
    (strm >> _tao_aggregate.supported_naming_mechanisms) &&
    (strm >> _tao_aggregate.supported_identity_types);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSIIOP::CompoundSecMech &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.target_requires) &&
    (strm << _tao_aggregate.transport_mech) &&
    (strm << _tao_aggregate.as_context_mech) &&
    (strm << _tao_aggregate.sas_context_mech);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSIIOP::CompoundSecMech &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.target_requires) &&
    (strm >> _tao_aggregate.transport_mech) &&
    (strm >> _tao_aggregate.as_context_mech) &&
    (strm >> _tao_aggregate.sas_context_mech);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSIIOP_CompoundSecMechanisms_CPP_
#define _TAO_CDR_OP_CSIIOP_CompoundSecMechanisms_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSIIOP::CompoundSecMechanisms &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSIIOP::CompoundSecMechanisms &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSIIOP_CompoundSecMechanisms_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSIIOP::CompoundSecMechList &_tao_aggregate)
{
  return
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.stateful)) &&
    (strm << _tao_aggregate.mechanism_list);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSIIOP::CompoundSecMechList &_tao_aggregate)
{
  return
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.stateful)) &&
    (strm >> _tao_aggregate.mechanism_list);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSIIOP::TransportAddress &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.host_name.in ()) &&
    (strm << _tao_aggregate.port);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSIIOP::TransportAddress &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.host_name.out ()) &&
    (strm >> _tao_aggregate.port);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_CSIIOP_TransportAddressList_CPP_
#define _TAO_CDR_OP_CSIIOP_TransportAddressList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSIIOP::TransportAddressList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSIIOP::TransportAddressList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_CSIIOP_TransportAddressList_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSIIOP::SECIOP_SEC_TRANS &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.target_supports) &&
    (strm << _tao_aggregate.target_requires) &&
    (strm << _tao_aggregate.mech_oid) &&
    (strm << _tao_aggregate.target_name) &&
    (strm << _tao_aggregate.addresses);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSIIOP::SECIOP_SEC_TRANS &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.target_supports) &&
    (strm >> _tao_aggregate.target_requires) &&
    (strm >> _tao_aggregate.mech_oid) &&
    (strm >> _tao_aggregate.target_name) &&
    (strm >> _tao_aggregate.addresses);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CSIIOP::TLS_SEC_TRANS &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.target_supports) &&
    (strm << _tao_aggregate.target_requires) &&
    (strm << _tao_aggregate.addresses);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CSIIOP::TLS_SEC_TRANS &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.target_supports) &&
    (strm >> _tao_aggregate.target_requires) &&
    (strm >> _tao_aggregate.addresses);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL





TAO_END_VERSIONED_NAMESPACE_DECL


