// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "AVStreamsC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/ORB_Core.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "AVStreamsC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_AVStreams_QoS[] =
      {
        { "QoSType", &CORBA::_tc_string },
        { "QoSParams", &CosPropertyService::_tc_Properties }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_QoS (
  ::CORBA::tk_struct,
  "IDL:omg.org/AVStreams/QoS:1.0",
  "QoS",
  _tao_fields_AVStreams_QoS,
  2);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_QoS =
    &_tao_tc_AVStreams_QoS;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
AVStreams::QoS::_tao_any_destructor (
    void *_tao_void_pointer)
{
  QoS *_tao_tmp_pointer =
    static_cast<QoS *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_AVSTREAMS_STREAMQOS_CS_)
#define _AVSTREAMS_STREAMQOS_CS_

AVStreams::streamQoS::streamQoS (void)
{}

AVStreams::streamQoS::streamQoS (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        QoS
      > (max)
{}

AVStreams::streamQoS::streamQoS (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    AVStreams::QoS * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        QoS
      >
    (max, length, buffer, release)
{}

AVStreams::streamQoS::streamQoS (
    const streamQoS &seq)
  : ::TAO::unbounded_value_sequence<
        QoS
      > (seq)
{}

AVStreams::streamQoS::~streamQoS (void)
{}

void AVStreams::streamQoS::_tao_any_destructor (
    void * _tao_void_pointer)
{
  streamQoS * _tao_tmp_pointer =
    static_cast<streamQoS *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_AVStreams_streamQoS_GUARD
#define _TAO_TYPECODE_AVStreams_streamQoS_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        AVStreams_streamQoS_0 (
          ::CORBA::tk_sequence,
          &AVStreams::_tc_QoS,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_AVStreams_streamQoS_0 =
        &AVStreams_streamQoS_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_AVStreams_streamQoS_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_streamQoS (
    ::CORBA::tk_alias,
    "IDL:omg.org/AVStreams/streamQoS:1.0",
    "streamQoS",
    &TAO::TypeCode::tc_AVStreams_streamQoS_0);
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_streamQoS =
    &_tao_tc_AVStreams_streamQoS;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_AVSTREAMS_FLOWSPEC_CS_)
#define _AVSTREAMS_FLOWSPEC_CS_

AVStreams::flowSpec::flowSpec (void)
{}

AVStreams::flowSpec::flowSpec (
    ::CORBA::ULong max)
  : ::TAO::unbounded_basic_string_sequence<char> (max)
{}

AVStreams::flowSpec::flowSpec (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Char * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_basic_string_sequence<char>
    (max, length, buffer, release)
{}

AVStreams::flowSpec::flowSpec (
    const flowSpec &seq)
  : ::TAO::unbounded_basic_string_sequence<char> (seq)
{}

AVStreams::flowSpec::~flowSpec (void)
{}

void AVStreams::flowSpec::_tao_any_destructor (
    void * _tao_void_pointer)
{
  flowSpec * _tao_tmp_pointer =
    static_cast<flowSpec *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_AVStreams_flowSpec_GUARD
#define _TAO_TYPECODE_AVStreams_flowSpec_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        AVStreams_flowSpec_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_string,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_AVStreams_flowSpec_0 =
        &AVStreams_flowSpec_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_AVStreams_flowSpec_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_flowSpec (
    ::CORBA::tk_alias,
    "IDL:omg.org/AVStreams/flowSpec:1.0",
    "flowSpec",
    &TAO::TypeCode::tc_AVStreams_flowSpec_0);
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_flowSpec =
    &_tao_tc_AVStreams_flowSpec;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_AVSTREAMS_PROTOCOLSPEC_CS_)
#define _AVSTREAMS_PROTOCOLSPEC_CS_

AVStreams::protocolSpec::protocolSpec (void)
{}

AVStreams::protocolSpec::protocolSpec (
    ::CORBA::ULong max)
  : ::TAO::unbounded_basic_string_sequence<char> (max)
{}

AVStreams::protocolSpec::protocolSpec (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Char * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_basic_string_sequence<char>
    (max, length, buffer, release)
{}

AVStreams::protocolSpec::protocolSpec (
    const protocolSpec &seq)
  : ::TAO::unbounded_basic_string_sequence<char> (seq)
{}

AVStreams::protocolSpec::~protocolSpec (void)
{}

void AVStreams::protocolSpec::_tao_any_destructor (
    void * _tao_void_pointer)
{
  protocolSpec * _tao_tmp_pointer =
    static_cast<protocolSpec *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_AVStreams_protocolSpec_GUARD
#define _TAO_TYPECODE_AVStreams_protocolSpec_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        AVStreams_protocolSpec_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_string,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_AVStreams_protocolSpec_0 =
        &AVStreams_protocolSpec_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_AVStreams_protocolSpec_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_protocolSpec (
    ::CORBA::tk_alias,
    "IDL:omg.org/AVStreams/protocolSpec:1.0",
    "protocolSpec",
    &TAO::TypeCode::tc_AVStreams_protocolSpec_0);
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_protocolSpec =
    &_tao_tc_AVStreams_protocolSpec;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_AVSTREAMS_KEY_CS_)
#define _AVSTREAMS_KEY_CS_

AVStreams::key::key (void)
{}

AVStreams::key::key (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (max)
{}

AVStreams::key::key (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Octet * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      >
    (max, length, buffer, release)
{}

AVStreams::key::key (
    const key &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Octet
      > (seq)
{}

AVStreams::key::~key (void)
{}

void AVStreams::key::_tao_any_destructor (
    void * _tao_void_pointer)
{
  key * _tao_tmp_pointer =
    static_cast<key *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_AVStreams_key_GUARD
#define _TAO_TYPECODE_AVStreams_key_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        AVStreams_key_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_octet,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_AVStreams_key_0 =
        &AVStreams_key_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_AVStreams_key_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_key (
    ::CORBA::tk_alias,
    "IDL:omg.org/AVStreams/key:1.0",
    "key",
    &TAO::TypeCode::tc_AVStreams_key_0);
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_key =
    &_tao_tc_AVStreams_key;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_AVStreams_SFPStatus[] =
      {
        { "isFormatted", &CORBA::_tc_boolean },
        { "isSpecialFormat", &CORBA::_tc_boolean },
        { "seqNums", &CORBA::_tc_boolean },
        { "timestamps", &CORBA::_tc_boolean },
        { "sourceIndicators", &CORBA::_tc_boolean }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_SFPStatus (
  ::CORBA::tk_struct,
  "IDL:omg.org/AVStreams/SFPStatus:1.0",
  "SFPStatus",
  _tao_fields_AVStreams_SFPStatus,
  5);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_SFPStatus =
    &_tao_tc_AVStreams_SFPStatus;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
AVStreams::SFPStatus::_tao_any_destructor (
    void *_tao_void_pointer)
{
  SFPStatus *_tao_tmp_pointer =
    static_cast<SFPStatus *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_AVStreams_flowState[] =
  {
    "stopped",
    "started",
    "dead"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_flowState (
    "IDL:omg.org/AVStreams/flowState:1.0",
    "flowState",
    _tao_enumerators_AVStreams_flowState,
    3);
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_flowState =
    &_tao_tc_AVStreams_flowState;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_AVStreams_dirType[] =
  {
    "dir_in",
    "dir_out"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_dirType (
    "IDL:omg.org/AVStreams/dirType:1.0",
    "dirType",
    _tao_enumerators_AVStreams_dirType,
    2);
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_dirType =
    &_tao_tc_AVStreams_dirType;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_AVStreams_flowStatus[] =
      {
        { "flowName", &CORBA::_tc_string },
        { "directionality", &AVStreams::_tc_dirType },
        { "status", &AVStreams::_tc_flowState },
        { "theFormat", &AVStreams::_tc_SFPStatus },
        { "theQoS", &AVStreams::_tc_QoS }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_flowStatus (
  ::CORBA::tk_struct,
  "IDL:omg.org/AVStreams/flowStatus:1.0",
  "flowStatus",
  _tao_fields_AVStreams_flowStatus,
  5);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_flowStatus =
    &_tao_tc_AVStreams_flowStatus;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
AVStreams::flowStatus::_tao_any_destructor (
    void *_tao_void_pointer)
{
  flowStatus *_tao_tmp_pointer =
    static_cast<flowStatus *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_streamEvent (
    ::CORBA::tk_alias,
    "IDL:omg.org/AVStreams/streamEvent:1.0",
    "streamEvent",
    &CosPropertyService::_tc_Property);
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_streamEvent =
    &_tao_tc_AVStreams_streamEvent;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::notSupported::notSupported (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/notSupported:1.0",
        "notSupported"
      )
{
}

AVStreams::notSupported::~notSupported (void)
{
}

AVStreams::notSupported::notSupported (const ::AVStreams::notSupported &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

AVStreams::notSupported&
AVStreams::notSupported::operator= (const ::AVStreams::notSupported &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void AVStreams::notSupported::_tao_any_destructor (void *_tao_void_pointer)
{
  notSupported *_tao_tmp_pointer =
    static_cast<notSupported *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::notSupported *
AVStreams::notSupported::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<notSupported *> (_tao_excp);
}

const AVStreams::notSupported *
AVStreams::notSupported::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const notSupported *> (_tao_excp);
}

::CORBA::Exception *AVStreams::notSupported::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::notSupported, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::notSupported::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::notSupported (*this),
      0
    );
  return result;
}

void AVStreams::notSupported::_raise (void) const
{
  throw *this;
}

void AVStreams::notSupported::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::notSupported::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::notSupported::_tao_type (void) const
{
  return ::AVStreams::_tc_notSupported;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_AVStreams_notSupported = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_notSupported (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/notSupported:1.0",
  "notSupported",
  _tao_fields_AVStreams_notSupported,
  0);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_notSupported =
    &_tao_tc_AVStreams_notSupported;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::PropertyException::PropertyException (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/PropertyException:1.0",
        "PropertyException"
      )
{
}

AVStreams::PropertyException::~PropertyException (void)
{
}

AVStreams::PropertyException::PropertyException (const ::AVStreams::PropertyException &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

AVStreams::PropertyException&
AVStreams::PropertyException::operator= (const ::AVStreams::PropertyException &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void AVStreams::PropertyException::_tao_any_destructor (void *_tao_void_pointer)
{
  PropertyException *_tao_tmp_pointer =
    static_cast<PropertyException *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::PropertyException *
AVStreams::PropertyException::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<PropertyException *> (_tao_excp);
}

const AVStreams::PropertyException *
AVStreams::PropertyException::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const PropertyException *> (_tao_excp);
}

::CORBA::Exception *AVStreams::PropertyException::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::PropertyException, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::PropertyException::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::PropertyException (*this),
      0
    );
  return result;
}

void AVStreams::PropertyException::_raise (void) const
{
  throw *this;
}

void AVStreams::PropertyException::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::PropertyException::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::PropertyException::_tao_type (void) const
{
  return ::AVStreams::_tc_PropertyException;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_AVStreams_PropertyException = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_PropertyException (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/PropertyException:1.0",
  "PropertyException",
  _tao_fields_AVStreams_PropertyException,
  0);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_PropertyException =
    &_tao_tc_AVStreams_PropertyException;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

AVStreams::FPError::FPError (
    const char * _tao_flow_name)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/FPError:1.0",
        "FPError"
      )
{
  this->flow_name = ::CORBA::string_dup (_tao_flow_name);
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::FPError::FPError (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/FPError:1.0",
        "FPError"
      )
{
}

AVStreams::FPError::~FPError (void)
{
}

AVStreams::FPError::FPError (const ::AVStreams::FPError &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->flow_name = ::CORBA::string_dup (_tao_excp.flow_name.in ());
}

AVStreams::FPError&
AVStreams::FPError::operator= (const ::AVStreams::FPError &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->flow_name = ::CORBA::string_dup (_tao_excp.flow_name.in ());
  return *this;
}

void AVStreams::FPError::_tao_any_destructor (void *_tao_void_pointer)
{
  FPError *_tao_tmp_pointer =
    static_cast<FPError *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::FPError *
AVStreams::FPError::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<FPError *> (_tao_excp);
}

const AVStreams::FPError *
AVStreams::FPError::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const FPError *> (_tao_excp);
}

::CORBA::Exception *AVStreams::FPError::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::FPError, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::FPError::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::FPError (*this),
      0
    );
  return result;
}

void AVStreams::FPError::_raise (void) const
{
  throw *this;
}

void AVStreams::FPError::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::FPError::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::FPError::_tao_type (void) const
{
  return ::AVStreams::_tc_FPError;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_AVStreams_FPError[] =
      {
        { "flow_name", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_FPError (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/FPError:1.0",
  "FPError",
  _tao_fields_AVStreams_FPError,
  1);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_FPError =
    &_tao_tc_AVStreams_FPError;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

AVStreams::streamOpFailed::streamOpFailed (
    const char * _tao_reason)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        "streamOpFailed"
      )
{
  this->reason = ::CORBA::string_dup (_tao_reason);
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::streamOpFailed::streamOpFailed (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        "streamOpFailed"
      )
{
}

AVStreams::streamOpFailed::~streamOpFailed (void)
{
}

AVStreams::streamOpFailed::streamOpFailed (const ::AVStreams::streamOpFailed &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
}

AVStreams::streamOpFailed&
AVStreams::streamOpFailed::operator= (const ::AVStreams::streamOpFailed &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
  return *this;
}

void AVStreams::streamOpFailed::_tao_any_destructor (void *_tao_void_pointer)
{
  streamOpFailed *_tao_tmp_pointer =
    static_cast<streamOpFailed *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::streamOpFailed *
AVStreams::streamOpFailed::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<streamOpFailed *> (_tao_excp);
}

const AVStreams::streamOpFailed *
AVStreams::streamOpFailed::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const streamOpFailed *> (_tao_excp);
}

::CORBA::Exception *AVStreams::streamOpFailed::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::streamOpFailed, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::streamOpFailed::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::streamOpFailed (*this),
      0
    );
  return result;
}

void AVStreams::streamOpFailed::_raise (void) const
{
  throw *this;
}

void AVStreams::streamOpFailed::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::streamOpFailed::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::streamOpFailed::_tao_type (void) const
{
  return ::AVStreams::_tc_streamOpFailed;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_AVStreams_streamOpFailed[] =
      {
        { "reason", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_streamOpFailed (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/streamOpFailed:1.0",
  "streamOpFailed",
  _tao_fields_AVStreams_streamOpFailed,
  1);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_streamOpFailed =
    &_tao_tc_AVStreams_streamOpFailed;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

AVStreams::streamOpDenied::streamOpDenied (
    const char * _tao_reason)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/streamOpDenied:1.0",
        "streamOpDenied"
      )
{
  this->reason = ::CORBA::string_dup (_tao_reason);
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::streamOpDenied::streamOpDenied (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/streamOpDenied:1.0",
        "streamOpDenied"
      )
{
}

AVStreams::streamOpDenied::~streamOpDenied (void)
{
}

AVStreams::streamOpDenied::streamOpDenied (const ::AVStreams::streamOpDenied &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
}

AVStreams::streamOpDenied&
AVStreams::streamOpDenied::operator= (const ::AVStreams::streamOpDenied &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
  return *this;
}

void AVStreams::streamOpDenied::_tao_any_destructor (void *_tao_void_pointer)
{
  streamOpDenied *_tao_tmp_pointer =
    static_cast<streamOpDenied *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::streamOpDenied *
AVStreams::streamOpDenied::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<streamOpDenied *> (_tao_excp);
}

const AVStreams::streamOpDenied *
AVStreams::streamOpDenied::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const streamOpDenied *> (_tao_excp);
}

::CORBA::Exception *AVStreams::streamOpDenied::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::streamOpDenied, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::streamOpDenied::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::streamOpDenied (*this),
      0
    );
  return result;
}

void AVStreams::streamOpDenied::_raise (void) const
{
  throw *this;
}

void AVStreams::streamOpDenied::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::streamOpDenied::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::streamOpDenied::_tao_type (void) const
{
  return ::AVStreams::_tc_streamOpDenied;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_AVStreams_streamOpDenied[] =
      {
        { "reason", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_streamOpDenied (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/streamOpDenied:1.0",
  "streamOpDenied",
  _tao_fields_AVStreams_streamOpDenied,
  1);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_streamOpDenied =
    &_tao_tc_AVStreams_streamOpDenied;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::noSuchFlow::noSuchFlow (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        "noSuchFlow"
      )
{
}

AVStreams::noSuchFlow::~noSuchFlow (void)
{
}

AVStreams::noSuchFlow::noSuchFlow (const ::AVStreams::noSuchFlow &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

AVStreams::noSuchFlow&
AVStreams::noSuchFlow::operator= (const ::AVStreams::noSuchFlow &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void AVStreams::noSuchFlow::_tao_any_destructor (void *_tao_void_pointer)
{
  noSuchFlow *_tao_tmp_pointer =
    static_cast<noSuchFlow *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::noSuchFlow *
AVStreams::noSuchFlow::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<noSuchFlow *> (_tao_excp);
}

const AVStreams::noSuchFlow *
AVStreams::noSuchFlow::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const noSuchFlow *> (_tao_excp);
}

::CORBA::Exception *AVStreams::noSuchFlow::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::noSuchFlow, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::noSuchFlow::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::noSuchFlow (*this),
      0
    );
  return result;
}

void AVStreams::noSuchFlow::_raise (void) const
{
  throw *this;
}

void AVStreams::noSuchFlow::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::noSuchFlow::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::noSuchFlow::_tao_type (void) const
{
  return ::AVStreams::_tc_noSuchFlow;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_AVStreams_noSuchFlow = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_noSuchFlow (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/noSuchFlow:1.0",
  "noSuchFlow",
  _tao_fields_AVStreams_noSuchFlow,
  0);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_noSuchFlow =
    &_tao_tc_AVStreams_noSuchFlow;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

AVStreams::QoSRequestFailed::QoSRequestFailed (
    const char * _tao_reason)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        "QoSRequestFailed"
      )
{
  this->reason = ::CORBA::string_dup (_tao_reason);
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::QoSRequestFailed::QoSRequestFailed (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        "QoSRequestFailed"
      )
{
}

AVStreams::QoSRequestFailed::~QoSRequestFailed (void)
{
}

AVStreams::QoSRequestFailed::QoSRequestFailed (const ::AVStreams::QoSRequestFailed &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
}

AVStreams::QoSRequestFailed&
AVStreams::QoSRequestFailed::operator= (const ::AVStreams::QoSRequestFailed &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
  return *this;
}

void AVStreams::QoSRequestFailed::_tao_any_destructor (void *_tao_void_pointer)
{
  QoSRequestFailed *_tao_tmp_pointer =
    static_cast<QoSRequestFailed *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::QoSRequestFailed *
AVStreams::QoSRequestFailed::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<QoSRequestFailed *> (_tao_excp);
}

const AVStreams::QoSRequestFailed *
AVStreams::QoSRequestFailed::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const QoSRequestFailed *> (_tao_excp);
}

::CORBA::Exception *AVStreams::QoSRequestFailed::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::QoSRequestFailed, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::QoSRequestFailed::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::QoSRequestFailed (*this),
      0
    );
  return result;
}

void AVStreams::QoSRequestFailed::_raise (void) const
{
  throw *this;
}

void AVStreams::QoSRequestFailed::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::QoSRequestFailed::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::QoSRequestFailed::_tao_type (void) const
{
  return ::AVStreams::_tc_QoSRequestFailed;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_AVStreams_QoSRequestFailed[] =
      {
        { "reason", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_QoSRequestFailed (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
  "QoSRequestFailed",
  _tao_fields_AVStreams_QoSRequestFailed,
  1);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_QoSRequestFailed =
    &_tao_tc_AVStreams_QoSRequestFailed;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::Basic_StreamCtrl.

AVStreams::Basic_StreamCtrl_ptr
TAO::Objref_Traits<AVStreams::Basic_StreamCtrl>::duplicate (
    AVStreams::Basic_StreamCtrl_ptr p)
{
  return AVStreams::Basic_StreamCtrl::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::Basic_StreamCtrl>::release (
    AVStreams::Basic_StreamCtrl_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::Basic_StreamCtrl_ptr
TAO::Objref_Traits<AVStreams::Basic_StreamCtrl>::nil (void)
{
  return AVStreams::Basic_StreamCtrl::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::Basic_StreamCtrl>::marshal (
    const AVStreams::Basic_StreamCtrl_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_Basic_StreamCtrl_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::Basic_StreamCtrl::stop (
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Basic_StreamCtrl_Proxy_Broker_ == 0)
    {
      AVStreams_Basic_StreamCtrl_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_Basic_StreamCtrl_stop_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "stop",
      4,
      this->the_TAO_Basic_StreamCtrl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_Basic_StreamCtrl_stop_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::Basic_StreamCtrl::start (
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Basic_StreamCtrl_Proxy_Broker_ == 0)
    {
      AVStreams_Basic_StreamCtrl_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_Basic_StreamCtrl_start_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "start",
      5,
      this->the_TAO_Basic_StreamCtrl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_Basic_StreamCtrl_start_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::Basic_StreamCtrl::destroy (
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Basic_StreamCtrl_Proxy_Broker_ == 0)
    {
      AVStreams_Basic_StreamCtrl_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_Basic_StreamCtrl_destroy_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "destroy",
      7,
      this->the_TAO_Basic_StreamCtrl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_Basic_StreamCtrl_destroy_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::Basic_StreamCtrl::modify_QoS (
  ::AVStreams::streamQoS & new_qos,
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Basic_StreamCtrl_Proxy_Broker_ == 0)
    {
      AVStreams_Basic_StreamCtrl_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_new_qos (new_qos);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_new_qos,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_Basic_StreamCtrl_modify_QoS_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "modify_QoS",
      10,
      this->the_TAO_Basic_StreamCtrl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_Basic_StreamCtrl_modify_QoS_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::Basic_StreamCtrl::push_event (
  const ::AVStreams::streamEvent & the_event)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Basic_StreamCtrl_Proxy_Broker_ == 0)
    {
      AVStreams_Basic_StreamCtrl_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosPropertyService::Property>::in_arg_val _tao_the_event (the_event);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_event
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "push_event",
      10,
      this->the_TAO_Basic_StreamCtrl_Proxy_Broker_,
      TAO::TAO_ONEWAY_INVOCATION
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::Basic_StreamCtrl::set_FPStatus (
  const ::AVStreams::flowSpec & the_spec,
  const char * fp_name,
  const ::CORBA::Any & fp_settings)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Basic_StreamCtrl_Proxy_Broker_ == 0)
    {
      AVStreams_Basic_StreamCtrl_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);
  TAO::Arg_Traits< char *>::in_arg_val _tao_fp_name (fp_name);
  TAO::Arg_Traits< ::CORBA::Any>::in_arg_val _tao_fp_settings (fp_settings);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_spec,
      &_tao_fp_name,
      &_tao_fp_settings
    };

  static TAO::Exception_Data
  _tao_AVStreams_Basic_StreamCtrl_set_FPStatus_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/FPError:1.0",
        AVStreams::FPError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_FPError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "set_FPStatus",
      12,
      this->the_TAO_Basic_StreamCtrl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_Basic_StreamCtrl_set_FPStatus_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Object_ptr
AVStreams::Basic_StreamCtrl::get_flow_connection (
  const char * flow_name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Basic_StreamCtrl_Proxy_Broker_ == 0)
    {
      AVStreams_Basic_StreamCtrl_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_flow_name (flow_name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_flow_name
    };

  static TAO::Exception_Data
  _tao_AVStreams_Basic_StreamCtrl_get_flow_connection_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_flow_connection",
      19,
      this->the_TAO_Basic_StreamCtrl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_Basic_StreamCtrl_get_flow_connection_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::Basic_StreamCtrl::set_flow_connection (
  const char * flow_name,
  ::CORBA::Object_ptr flow_connection)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Basic_StreamCtrl_Proxy_Broker_ == 0)
    {
      AVStreams_Basic_StreamCtrl_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_flow_name (flow_name);
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_flow_connection (flow_connection);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_flow_name,
      &_tao_flow_connection
    };

  static TAO::Exception_Data
  _tao_AVStreams_Basic_StreamCtrl_set_flow_connection_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "set_flow_connection",
      19,
      this->the_TAO_Basic_StreamCtrl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_Basic_StreamCtrl_set_flow_connection_exceptiondata,
      2
    );
}

AVStreams::Basic_StreamCtrl::Basic_StreamCtrl (void)
 : the_TAO_Basic_StreamCtrl_Proxy_Broker_ (0)
{
  this->AVStreams_Basic_StreamCtrl_setup_collocation ();
}

void
AVStreams::Basic_StreamCtrl::AVStreams_Basic_StreamCtrl_setup_collocation ()
{
  if (::AVStreams__TAO_Basic_StreamCtrl_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Basic_StreamCtrl_Proxy_Broker_ =
        ::AVStreams__TAO_Basic_StreamCtrl_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CosPropertyService_PropertySet_setup_collocation ();
}

AVStreams::Basic_StreamCtrl::~Basic_StreamCtrl (void)
{}

void 
AVStreams::Basic_StreamCtrl::_tao_any_destructor (void *_tao_void_pointer)
{
  Basic_StreamCtrl *_tao_tmp_pointer =
    static_cast<Basic_StreamCtrl *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::Basic_StreamCtrl_ptr
AVStreams::Basic_StreamCtrl::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Basic_StreamCtrl>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/Basic_StreamCtrl:1.0",
        AVStreams__TAO_Basic_StreamCtrl_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::Basic_StreamCtrl_ptr
AVStreams::Basic_StreamCtrl::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Basic_StreamCtrl>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/Basic_StreamCtrl:1.0",
        AVStreams__TAO_Basic_StreamCtrl_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::Basic_StreamCtrl_ptr
AVStreams::Basic_StreamCtrl::_nil (void)
{
  return 0;
}

AVStreams::Basic_StreamCtrl_ptr
AVStreams::Basic_StreamCtrl::_duplicate (Basic_StreamCtrl_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::Basic_StreamCtrl::_tao_release (Basic_StreamCtrl_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::Basic_StreamCtrl::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/Basic_StreamCtrl:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::Basic_StreamCtrl::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/Basic_StreamCtrl:1.0";
}

::CORBA::Boolean
AVStreams::Basic_StreamCtrl::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_Basic_StreamCtrl (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/Basic_StreamCtrl:1.0",
    "Basic_StreamCtrl");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_Basic_StreamCtrl =
    &_tao_tc_AVStreams_Basic_StreamCtrl;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::Negotiator.

AVStreams::Negotiator_ptr
TAO::Objref_Traits<AVStreams::Negotiator>::duplicate (
    AVStreams::Negotiator_ptr p)
{
  return AVStreams::Negotiator::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::Negotiator>::release (
    AVStreams::Negotiator_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::Negotiator_ptr
TAO::Objref_Traits<AVStreams::Negotiator>::nil (void)
{
  return AVStreams::Negotiator::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::Negotiator>::marshal (
    const AVStreams::Negotiator_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_Negotiator_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::Negotiator::negotiate (
  ::AVStreams::Negotiator_ptr remote_negotiator,
  const ::AVStreams::streamQoS & qos_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Negotiator_Proxy_Broker_ == 0)
    {
      AVStreams_Negotiator_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::Negotiator>::in_arg_val _tao_remote_negotiator (remote_negotiator);
  TAO::Arg_Traits< ::AVStreams::streamQoS>::in_arg_val _tao_qos_spec (qos_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_remote_negotiator,
      &_tao_qos_spec
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "negotiate",
      9,
      this->the_TAO_Negotiator_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

AVStreams::Negotiator::Negotiator (void)
 : the_TAO_Negotiator_Proxy_Broker_ (0)
{
  this->AVStreams_Negotiator_setup_collocation ();
}

void
AVStreams::Negotiator::AVStreams_Negotiator_setup_collocation ()
{
  if (::AVStreams__TAO_Negotiator_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Negotiator_Proxy_Broker_ =
        ::AVStreams__TAO_Negotiator_Proxy_Broker_Factory_function_pointer (this);
    }
}

AVStreams::Negotiator::~Negotiator (void)
{}

void 
AVStreams::Negotiator::_tao_any_destructor (void *_tao_void_pointer)
{
  Negotiator *_tao_tmp_pointer =
    static_cast<Negotiator *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::Negotiator_ptr
AVStreams::Negotiator::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Negotiator>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/Negotiator:1.0",
        AVStreams__TAO_Negotiator_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::Negotiator_ptr
AVStreams::Negotiator::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Negotiator>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/Negotiator:1.0",
        AVStreams__TAO_Negotiator_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::Negotiator_ptr
AVStreams::Negotiator::_nil (void)
{
  return 0;
}

AVStreams::Negotiator_ptr
AVStreams::Negotiator::_duplicate (Negotiator_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::Negotiator::_tao_release (Negotiator_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::Negotiator::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/Negotiator:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::Negotiator::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/Negotiator:1.0";
}

::CORBA::Boolean
AVStreams::Negotiator::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_Negotiator (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/Negotiator:1.0",
    "Negotiator");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_Negotiator =
    &_tao_tc_AVStreams_Negotiator;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::StreamCtrl.

AVStreams::StreamCtrl_ptr
TAO::Objref_Traits<AVStreams::StreamCtrl>::duplicate (
    AVStreams::StreamCtrl_ptr p)
{
  return AVStreams::StreamCtrl::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::StreamCtrl>::release (
    AVStreams::StreamCtrl_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::StreamCtrl_ptr
TAO::Objref_Traits<AVStreams::StreamCtrl>::nil (void)
{
  return AVStreams::StreamCtrl::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::StreamCtrl>::marshal (
    const AVStreams::StreamCtrl_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_StreamCtrl_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::StreamCtrl::bind_devs (
  ::AVStreams::MMDevice_ptr a_party,
  ::AVStreams::MMDevice_ptr b_party,
  ::AVStreams::streamQoS & the_qos,
  const ::AVStreams::flowSpec & the_flows)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamCtrl_Proxy_Broker_ == 0)
    {
      AVStreams_StreamCtrl_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::MMDevice>::in_arg_val _tao_a_party (a_party);
  TAO::Arg_Traits< ::AVStreams::MMDevice>::in_arg_val _tao_b_party (b_party);
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_flows (the_flows);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_a_party,
      &_tao_b_party,
      &_tao_the_qos,
      &_tao_the_flows
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamCtrl_bind_devs_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "bind_devs",
      9,
      this->the_TAO_StreamCtrl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamCtrl_bind_devs_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::StreamCtrl::bind (
  ::AVStreams::StreamEndPoint_A_ptr a_party,
  ::AVStreams::StreamEndPoint_B_ptr b_party,
  ::AVStreams::streamQoS & the_qos,
  const ::AVStreams::flowSpec & the_flows)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamCtrl_Proxy_Broker_ == 0)
    {
      AVStreams_StreamCtrl_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::StreamEndPoint_A>::in_arg_val _tao_a_party (a_party);
  TAO::Arg_Traits< ::AVStreams::StreamEndPoint_B>::in_arg_val _tao_b_party (b_party);
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_flows (the_flows);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_a_party,
      &_tao_b_party,
      &_tao_the_qos,
      &_tao_the_flows
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamCtrl_bind_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "bind",
      4,
      this->the_TAO_StreamCtrl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamCtrl_bind_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::StreamCtrl::unbind_dev (
  ::AVStreams::MMDevice_ptr dev,
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamCtrl_Proxy_Broker_ == 0)
    {
      AVStreams_StreamCtrl_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::MMDevice>::in_arg_val _tao_dev (dev);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_dev,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamCtrl_unbind_dev_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "unbind_dev",
      10,
      this->the_TAO_StreamCtrl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamCtrl_unbind_dev_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::StreamCtrl::unbind_party (
  ::AVStreams::StreamEndPoint_ptr the_ep,
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamCtrl_Proxy_Broker_ == 0)
    {
      AVStreams_StreamCtrl_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::StreamEndPoint>::in_arg_val _tao_the_ep (the_ep);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_ep,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamCtrl_unbind_party_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "unbind_party",
      12,
      this->the_TAO_StreamCtrl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamCtrl_unbind_party_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::StreamCtrl::unbind (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamCtrl_Proxy_Broker_ == 0)
    {
      AVStreams_StreamCtrl_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamCtrl_unbind_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "unbind",
      6,
      this->the_TAO_StreamCtrl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamCtrl_unbind_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::AVStreams::VDev_ptr
AVStreams::StreamCtrl::get_related_vdev (
  ::AVStreams::MMDevice_ptr adev,
  ::AVStreams::StreamEndPoint_out sep)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamCtrl_Proxy_Broker_ == 0)
    {
      AVStreams_StreamCtrl_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::AVStreams::VDev>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::MMDevice>::in_arg_val _tao_adev (adev);
  TAO::Arg_Traits< ::AVStreams::StreamEndPoint>::out_arg_val _tao_sep (sep);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_adev,
      &_tao_sep
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamCtrl_get_related_vdev_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "get_related_vdev",
      16,
      this->the_TAO_StreamCtrl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamCtrl_get_related_vdev_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

AVStreams::StreamCtrl::StreamCtrl (void)
 : the_TAO_StreamCtrl_Proxy_Broker_ (0)
{
  this->AVStreams_StreamCtrl_setup_collocation ();
}

void
AVStreams::StreamCtrl::AVStreams_StreamCtrl_setup_collocation ()
{
  if (::AVStreams__TAO_StreamCtrl_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_StreamCtrl_Proxy_Broker_ =
        ::AVStreams__TAO_StreamCtrl_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->AVStreams_Basic_StreamCtrl_setup_collocation ();
}

AVStreams::StreamCtrl::~StreamCtrl (void)
{}

void 
AVStreams::StreamCtrl::_tao_any_destructor (void *_tao_void_pointer)
{
  StreamCtrl *_tao_tmp_pointer =
    static_cast<StreamCtrl *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::StreamCtrl_ptr
AVStreams::StreamCtrl::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<StreamCtrl>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/StreamCtrl:1.0",
        AVStreams__TAO_StreamCtrl_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::StreamCtrl_ptr
AVStreams::StreamCtrl::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<StreamCtrl>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/StreamCtrl:1.0",
        AVStreams__TAO_StreamCtrl_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::StreamCtrl_ptr
AVStreams::StreamCtrl::_nil (void)
{
  return 0;
}

AVStreams::StreamCtrl_ptr
AVStreams::StreamCtrl::_duplicate (StreamCtrl_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::StreamCtrl::_tao_release (StreamCtrl_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::StreamCtrl::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/Basic_StreamCtrl:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/StreamCtrl:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::StreamCtrl::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/StreamCtrl:1.0";
}

::CORBA::Boolean
AVStreams::StreamCtrl::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_StreamCtrl (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/StreamCtrl:1.0",
    "StreamCtrl");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_StreamCtrl =
    &_tao_tc_AVStreams_StreamCtrl;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::MCastConfigIf.

AVStreams::MCastConfigIf_ptr
TAO::Objref_Traits<AVStreams::MCastConfigIf>::duplicate (
    AVStreams::MCastConfigIf_ptr p)
{
  return AVStreams::MCastConfigIf::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::MCastConfigIf>::release (
    AVStreams::MCastConfigIf_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::MCastConfigIf_ptr
TAO::Objref_Traits<AVStreams::MCastConfigIf>::nil (void)
{
  return AVStreams::MCastConfigIf::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::MCastConfigIf>::marshal (
    const AVStreams::MCastConfigIf_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_MCastConfigIf_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::MCastConfigIf::set_peer (
  ::CORBA::Object_ptr peer,
  ::AVStreams::streamQoS & the_qos,
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MCastConfigIf_Proxy_Broker_ == 0)
    {
      AVStreams_MCastConfigIf_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_peer (peer);
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_peer,
      &_tao_the_qos,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_MCastConfigIf_set_peer_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "set_peer",
      8,
      this->the_TAO_MCastConfigIf_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MCastConfigIf_set_peer_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::MCastConfigIf::configure (
  const ::CosPropertyService::Property & a_configuration)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MCastConfigIf_Proxy_Broker_ == 0)
    {
      AVStreams_MCastConfigIf_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosPropertyService::Property>::in_arg_val _tao_a_configuration (a_configuration);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_a_configuration
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "configure",
      9,
      this->the_TAO_MCastConfigIf_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::MCastConfigIf::set_initial_configuration (
  const ::CosPropertyService::Properties & initial)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MCastConfigIf_Proxy_Broker_ == 0)
    {
      AVStreams_MCastConfigIf_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosPropertyService::Properties>::in_arg_val _tao_initial (initial);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_initial
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_initial_configuration",
      25,
      this->the_TAO_MCastConfigIf_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::MCastConfigIf::set_format (
  const char * flowName,
  const char * format_name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MCastConfigIf_Proxy_Broker_ == 0)
    {
      AVStreams_MCastConfigIf_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_flowName (flowName);
  TAO::Arg_Traits< char *>::in_arg_val _tao_format_name (format_name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_flowName,
      &_tao_format_name
    };

  static TAO::Exception_Data
  _tao_AVStreams_MCastConfigIf_set_format_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "set_format",
      10,
      this->the_TAO_MCastConfigIf_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MCastConfigIf_set_format_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::MCastConfigIf::set_dev_params (
  const char * flowName,
  const ::CosPropertyService::Properties & new_params)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MCastConfigIf_Proxy_Broker_ == 0)
    {
      AVStreams_MCastConfigIf_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_flowName (flowName);
  TAO::Arg_Traits< ::CosPropertyService::Properties>::in_arg_val _tao_new_params (new_params);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_flowName,
      &_tao_new_params
    };

  static TAO::Exception_Data
  _tao_AVStreams_MCastConfigIf_set_dev_params_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/PropertyException:1.0",
        AVStreams::PropertyException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_PropertyException
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "set_dev_params",
      14,
      this->the_TAO_MCastConfigIf_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MCastConfigIf_set_dev_params_exceptiondata,
      2
    );
}

AVStreams::MCastConfigIf::MCastConfigIf (void)
 : the_TAO_MCastConfigIf_Proxy_Broker_ (0)
{
  this->AVStreams_MCastConfigIf_setup_collocation ();
}

void
AVStreams::MCastConfigIf::AVStreams_MCastConfigIf_setup_collocation ()
{
  if (::AVStreams__TAO_MCastConfigIf_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_MCastConfigIf_Proxy_Broker_ =
        ::AVStreams__TAO_MCastConfigIf_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CosPropertyService_PropertySet_setup_collocation ();
}

AVStreams::MCastConfigIf::~MCastConfigIf (void)
{}

void 
AVStreams::MCastConfigIf::_tao_any_destructor (void *_tao_void_pointer)
{
  MCastConfigIf *_tao_tmp_pointer =
    static_cast<MCastConfigIf *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::MCastConfigIf_ptr
AVStreams::MCastConfigIf::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<MCastConfigIf>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/MCastConfigIf:1.0",
        AVStreams__TAO_MCastConfigIf_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::MCastConfigIf_ptr
AVStreams::MCastConfigIf::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<MCastConfigIf>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/MCastConfigIf:1.0",
        AVStreams__TAO_MCastConfigIf_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::MCastConfigIf_ptr
AVStreams::MCastConfigIf::_nil (void)
{
  return 0;
}

AVStreams::MCastConfigIf_ptr
AVStreams::MCastConfigIf::_duplicate (MCastConfigIf_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::MCastConfigIf::_tao_release (MCastConfigIf_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::MCastConfigIf::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/MCastConfigIf:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::MCastConfigIf::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/MCastConfigIf:1.0";
}

::CORBA::Boolean
AVStreams::MCastConfigIf::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_MCastConfigIf (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/MCastConfigIf:1.0",
    "MCastConfigIf");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_MCastConfigIf =
    &_tao_tc_AVStreams_MCastConfigIf;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::StreamEndPoint.

AVStreams::StreamEndPoint_ptr
TAO::Objref_Traits<AVStreams::StreamEndPoint>::duplicate (
    AVStreams::StreamEndPoint_ptr p)
{
  return AVStreams::StreamEndPoint::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::StreamEndPoint>::release (
    AVStreams::StreamEndPoint_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::StreamEndPoint_ptr
TAO::Objref_Traits<AVStreams::StreamEndPoint>::nil (void)
{
  return AVStreams::StreamEndPoint::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::StreamEndPoint>::marshal (
    const AVStreams::StreamEndPoint_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_StreamEndPoint_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::StreamEndPoint::stop (
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_stop_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "stop",
      4,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_stop_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::StreamEndPoint::start (
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_start_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "start",
      5,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_start_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::StreamEndPoint::destroy (
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_destroy_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "destroy",
      7,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_destroy_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::StreamEndPoint::connect (
  ::AVStreams::StreamEndPoint_ptr responder,
  ::AVStreams::streamQoS & qos_spec,
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::StreamEndPoint>::in_arg_val _tao_responder (responder);
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_qos_spec (qos_spec);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_responder,
      &_tao_qos_spec,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_connect_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "connect",
      7,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_connect_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::StreamEndPoint::request_connection (
  ::AVStreams::StreamEndPoint_ptr initiator,
  ::CORBA::Boolean is_mcast,
  ::AVStreams::streamQoS & qos,
  ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::StreamEndPoint>::in_arg_val _tao_initiator (initiator);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_mcast (is_mcast);
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_qos (qos);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::inout_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_initiator,
      &_tao_is_mcast,
      &_tao_qos,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_request_connection_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpDenied:1.0",
        AVStreams::streamOpDenied::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpDenied
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/FPError:1.0",
        AVStreams::FPError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_FPError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "request_connection",
      18,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_request_connection_exceptiondata,
      4
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::StreamEndPoint::modify_QoS (
  ::AVStreams::streamQoS & new_qos,
  const ::AVStreams::flowSpec & the_flows)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_new_qos (new_qos);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_flows (the_flows);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_new_qos,
      &_tao_the_flows
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_modify_QoS_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "modify_QoS",
      10,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_modify_QoS_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::StreamEndPoint::set_protocol_restriction (
  const ::AVStreams::protocolSpec & the_pspec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::protocolSpec>::in_arg_val _tao_the_pspec (the_pspec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_pspec
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_protocol_restriction",
      24,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::StreamEndPoint::disconnect (
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_disconnect_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "disconnect",
      10,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_disconnect_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::StreamEndPoint::set_FPStatus (
  const ::AVStreams::flowSpec & the_spec,
  const char * fp_name,
  const ::CORBA::Any & fp_settings)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);
  TAO::Arg_Traits< char *>::in_arg_val _tao_fp_name (fp_name);
  TAO::Arg_Traits< ::CORBA::Any>::in_arg_val _tao_fp_settings (fp_settings);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_spec,
      &_tao_fp_name,
      &_tao_fp_settings
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_set_FPStatus_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/FPError:1.0",
        AVStreams::FPError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_FPError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "set_FPStatus",
      12,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_set_FPStatus_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Object_ptr
AVStreams::StreamEndPoint::get_fep (
  const char * flow_name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_flow_name (flow_name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_flow_name
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_get_fep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_fep",
      7,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_get_fep_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
AVStreams::StreamEndPoint::add_fep (
  ::CORBA::Object_ptr the_fep)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_the_fep (the_fep);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_fep
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_add_fep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "add_fep",
      7,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_add_fep_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::StreamEndPoint::remove_fep (
  const char * fep_name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_fep_name (fep_name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_fep_name
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_remove_fep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_fep",
      10,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_remove_fep_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::StreamEndPoint::set_negotiator (
  ::AVStreams::Negotiator_ptr new_negotiator)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::Negotiator>::in_arg_val _tao_new_negotiator (new_negotiator);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_new_negotiator
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_negotiator",
      14,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::StreamEndPoint::set_key (
  const char * flow_name,
  const ::AVStreams::key & the_key)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_flow_name (flow_name);
  TAO::Arg_Traits< ::AVStreams::key>::in_arg_val _tao_the_key (the_key);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_flow_name,
      &_tao_the_key
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "set_key",
      7,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::StreamEndPoint::set_source_id (
  ::CORBA::Long source_id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_source_id (source_id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_source_id
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_source_id",
      13,
      this->the_TAO_StreamEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

AVStreams::StreamEndPoint::StreamEndPoint (void)
 : the_TAO_StreamEndPoint_Proxy_Broker_ (0)
{
  this->AVStreams_StreamEndPoint_setup_collocation ();
}

void
AVStreams::StreamEndPoint::AVStreams_StreamEndPoint_setup_collocation ()
{
  if (::AVStreams__TAO_StreamEndPoint_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_StreamEndPoint_Proxy_Broker_ =
        ::AVStreams__TAO_StreamEndPoint_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CosPropertyService_PropertySet_setup_collocation ();
}

AVStreams::StreamEndPoint::~StreamEndPoint (void)
{}

void 
AVStreams::StreamEndPoint::_tao_any_destructor (void *_tao_void_pointer)
{
  StreamEndPoint *_tao_tmp_pointer =
    static_cast<StreamEndPoint *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::StreamEndPoint_ptr
AVStreams::StreamEndPoint::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<StreamEndPoint>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/StreamEndPoint:1.0",
        AVStreams__TAO_StreamEndPoint_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::StreamEndPoint_ptr
AVStreams::StreamEndPoint::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<StreamEndPoint>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/StreamEndPoint:1.0",
        AVStreams__TAO_StreamEndPoint_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::StreamEndPoint_ptr
AVStreams::StreamEndPoint::_nil (void)
{
  return 0;
}

AVStreams::StreamEndPoint_ptr
AVStreams::StreamEndPoint::_duplicate (StreamEndPoint_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::StreamEndPoint::_tao_release (StreamEndPoint_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::StreamEndPoint::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/StreamEndPoint:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::StreamEndPoint::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/StreamEndPoint:1.0";
}

::CORBA::Boolean
AVStreams::StreamEndPoint::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_StreamEndPoint (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/StreamEndPoint:1.0",
    "StreamEndPoint");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_StreamEndPoint =
    &_tao_tc_AVStreams_StreamEndPoint;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::StreamEndPoint_A.

AVStreams::StreamEndPoint_A_ptr
TAO::Objref_Traits<AVStreams::StreamEndPoint_A>::duplicate (
    AVStreams::StreamEndPoint_A_ptr p)
{
  return AVStreams::StreamEndPoint_A::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::StreamEndPoint_A>::release (
    AVStreams::StreamEndPoint_A_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::StreamEndPoint_A_ptr
TAO::Objref_Traits<AVStreams::StreamEndPoint_A>::nil (void)
{
  return AVStreams::StreamEndPoint_A::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::StreamEndPoint_A>::marshal (
    const AVStreams::StreamEndPoint_A_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_StreamEndPoint_A_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::StreamEndPoint_A::multiconnect (
  ::AVStreams::streamQoS & the_qos,
  ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_A_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_A_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::inout_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_qos,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_A_multiconnect_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "multiconnect",
      12,
      this->the_TAO_StreamEndPoint_A_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_A_multiconnect_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::StreamEndPoint_A::connect_leaf (
  ::AVStreams::StreamEndPoint_B_ptr the_ep,
  ::AVStreams::streamQoS & the_qos,
  const ::AVStreams::flowSpec & the_flows)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_A_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_A_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::StreamEndPoint_B>::in_arg_val _tao_the_ep (the_ep);
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_flows (the_flows);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_ep,
      &_tao_the_qos,
      &_tao_the_flows
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_A_connect_leaf_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "connect_leaf",
      12,
      this->the_TAO_StreamEndPoint_A_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_A_connect_leaf_exceptiondata,
      4
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::StreamEndPoint_A::disconnect_leaf (
  ::AVStreams::StreamEndPoint_B_ptr the_ep,
  const ::AVStreams::flowSpec & theSpec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_A_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_A_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::StreamEndPoint_B>::in_arg_val _tao_the_ep (the_ep);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_theSpec (theSpec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_ep,
      &_tao_theSpec
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_A_disconnect_leaf_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "disconnect_leaf",
      15,
      this->the_TAO_StreamEndPoint_A_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_A_disconnect_leaf_exceptiondata,
      3
    );
}

AVStreams::StreamEndPoint_A::StreamEndPoint_A (void)
 : the_TAO_StreamEndPoint_A_Proxy_Broker_ (0)
{
  this->AVStreams_StreamEndPoint_A_setup_collocation ();
}

void
AVStreams::StreamEndPoint_A::AVStreams_StreamEndPoint_A_setup_collocation ()
{
  if (::AVStreams__TAO_StreamEndPoint_A_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_StreamEndPoint_A_Proxy_Broker_ =
        ::AVStreams__TAO_StreamEndPoint_A_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->AVStreams_StreamEndPoint_setup_collocation ();
}

AVStreams::StreamEndPoint_A::~StreamEndPoint_A (void)
{}

void 
AVStreams::StreamEndPoint_A::_tao_any_destructor (void *_tao_void_pointer)
{
  StreamEndPoint_A *_tao_tmp_pointer =
    static_cast<StreamEndPoint_A *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::StreamEndPoint_A_ptr
AVStreams::StreamEndPoint_A::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<StreamEndPoint_A>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/StreamEndPoint_A:1.0",
        AVStreams__TAO_StreamEndPoint_A_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::StreamEndPoint_A_ptr
AVStreams::StreamEndPoint_A::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<StreamEndPoint_A>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/StreamEndPoint_A:1.0",
        AVStreams__TAO_StreamEndPoint_A_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::StreamEndPoint_A_ptr
AVStreams::StreamEndPoint_A::_nil (void)
{
  return 0;
}

AVStreams::StreamEndPoint_A_ptr
AVStreams::StreamEndPoint_A::_duplicate (StreamEndPoint_A_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::StreamEndPoint_A::_tao_release (StreamEndPoint_A_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::StreamEndPoint_A::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/StreamEndPoint:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/StreamEndPoint_A:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::StreamEndPoint_A::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/StreamEndPoint_A:1.0";
}

::CORBA::Boolean
AVStreams::StreamEndPoint_A::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_StreamEndPoint_A (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/StreamEndPoint_A:1.0",
    "StreamEndPoint_A");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_StreamEndPoint_A =
    &_tao_tc_AVStreams_StreamEndPoint_A;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::StreamEndPoint_B.

AVStreams::StreamEndPoint_B_ptr
TAO::Objref_Traits<AVStreams::StreamEndPoint_B>::duplicate (
    AVStreams::StreamEndPoint_B_ptr p)
{
  return AVStreams::StreamEndPoint_B::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::StreamEndPoint_B>::release (
    AVStreams::StreamEndPoint_B_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::StreamEndPoint_B_ptr
TAO::Objref_Traits<AVStreams::StreamEndPoint_B>::nil (void)
{
  return AVStreams::StreamEndPoint_B::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::StreamEndPoint_B>::marshal (
    const AVStreams::StreamEndPoint_B_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_StreamEndPoint_B_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::StreamEndPoint_B::multiconnect (
  ::AVStreams::streamQoS & the_qos,
  ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_StreamEndPoint_B_Proxy_Broker_ == 0)
    {
      AVStreams_StreamEndPoint_B_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::inout_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_qos,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_StreamEndPoint_B_multiconnect_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/FPError:1.0",
        AVStreams::FPError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_FPError
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "multiconnect",
      12,
      this->the_TAO_StreamEndPoint_B_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_StreamEndPoint_B_multiconnect_exceptiondata,
      4
    );

  return _tao_retval.retn ();
}

AVStreams::StreamEndPoint_B::StreamEndPoint_B (void)
 : the_TAO_StreamEndPoint_B_Proxy_Broker_ (0)
{
  this->AVStreams_StreamEndPoint_B_setup_collocation ();
}

void
AVStreams::StreamEndPoint_B::AVStreams_StreamEndPoint_B_setup_collocation ()
{
  if (::AVStreams__TAO_StreamEndPoint_B_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_StreamEndPoint_B_Proxy_Broker_ =
        ::AVStreams__TAO_StreamEndPoint_B_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->AVStreams_StreamEndPoint_setup_collocation ();
}

AVStreams::StreamEndPoint_B::~StreamEndPoint_B (void)
{}

void 
AVStreams::StreamEndPoint_B::_tao_any_destructor (void *_tao_void_pointer)
{
  StreamEndPoint_B *_tao_tmp_pointer =
    static_cast<StreamEndPoint_B *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::StreamEndPoint_B_ptr
AVStreams::StreamEndPoint_B::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<StreamEndPoint_B>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/StreamEndPoint_B:1.0",
        AVStreams__TAO_StreamEndPoint_B_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::StreamEndPoint_B_ptr
AVStreams::StreamEndPoint_B::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<StreamEndPoint_B>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/StreamEndPoint_B:1.0",
        AVStreams__TAO_StreamEndPoint_B_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::StreamEndPoint_B_ptr
AVStreams::StreamEndPoint_B::_nil (void)
{
  return 0;
}

AVStreams::StreamEndPoint_B_ptr
AVStreams::StreamEndPoint_B::_duplicate (StreamEndPoint_B_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::StreamEndPoint_B::_tao_release (StreamEndPoint_B_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::StreamEndPoint_B::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/StreamEndPoint:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/StreamEndPoint_B:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::StreamEndPoint_B::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/StreamEndPoint_B:1.0";
}

::CORBA::Boolean
AVStreams::StreamEndPoint_B::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_StreamEndPoint_B (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/StreamEndPoint_B:1.0",
    "StreamEndPoint_B");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_StreamEndPoint_B =
    &_tao_tc_AVStreams_StreamEndPoint_B;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::VDev.

AVStreams::VDev_ptr
TAO::Objref_Traits<AVStreams::VDev>::duplicate (
    AVStreams::VDev_ptr p)
{
  return AVStreams::VDev::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::VDev>::release (
    AVStreams::VDev_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::VDev_ptr
TAO::Objref_Traits<AVStreams::VDev>::nil (void)
{
  return AVStreams::VDev::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::VDev>::marshal (
    const AVStreams::VDev_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_VDev_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::VDev::set_peer (
  ::AVStreams::StreamCtrl_ptr the_ctrl,
  ::AVStreams::VDev_ptr the_peer_dev,
  ::AVStreams::streamQoS & the_qos,
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_VDev_Proxy_Broker_ == 0)
    {
      AVStreams_VDev_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::StreamCtrl>::in_arg_val _tao_the_ctrl (the_ctrl);
  TAO::Arg_Traits< ::AVStreams::VDev>::in_arg_val _tao_the_peer_dev (the_peer_dev);
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_ctrl,
      &_tao_the_peer_dev,
      &_tao_the_qos,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_VDev_set_peer_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "set_peer",
      8,
      this->the_TAO_VDev_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_VDev_set_peer_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::VDev::set_Mcast_peer (
  ::AVStreams::StreamCtrl_ptr the_ctrl,
  ::AVStreams::MCastConfigIf_ptr a_mcastconfigif,
  ::AVStreams::streamQoS & the_qos,
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_VDev_Proxy_Broker_ == 0)
    {
      AVStreams_VDev_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::StreamCtrl>::in_arg_val _tao_the_ctrl (the_ctrl);
  TAO::Arg_Traits< ::AVStreams::MCastConfigIf>::in_arg_val _tao_a_mcastconfigif (a_mcastconfigif);
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_ctrl,
      &_tao_a_mcastconfigif,
      &_tao_the_qos,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_VDev_set_Mcast_peer_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "set_Mcast_peer",
      14,
      this->the_TAO_VDev_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_VDev_set_Mcast_peer_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::VDev::configure (
  const ::CosPropertyService::Property & the_config_mesg)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_VDev_Proxy_Broker_ == 0)
    {
      AVStreams_VDev_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosPropertyService::Property>::in_arg_val _tao_the_config_mesg (the_config_mesg);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_config_mesg
    };

  static TAO::Exception_Data
  _tao_AVStreams_VDev_configure_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/PropertyException:1.0",
        AVStreams::PropertyException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_PropertyException
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "configure",
      9,
      this->the_TAO_VDev_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_VDev_configure_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::VDev::set_format (
  const char * flowName,
  const char * format_name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_VDev_Proxy_Broker_ == 0)
    {
      AVStreams_VDev_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_flowName (flowName);
  TAO::Arg_Traits< char *>::in_arg_val _tao_format_name (format_name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_flowName,
      &_tao_format_name
    };

  static TAO::Exception_Data
  _tao_AVStreams_VDev_set_format_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "set_format",
      10,
      this->the_TAO_VDev_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_VDev_set_format_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::VDev::set_dev_params (
  const char * flowName,
  const ::CosPropertyService::Properties & new_params)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_VDev_Proxy_Broker_ == 0)
    {
      AVStreams_VDev_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_flowName (flowName);
  TAO::Arg_Traits< ::CosPropertyService::Properties>::in_arg_val _tao_new_params (new_params);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_flowName,
      &_tao_new_params
    };

  static TAO::Exception_Data
  _tao_AVStreams_VDev_set_dev_params_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/PropertyException:1.0",
        AVStreams::PropertyException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_PropertyException
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "set_dev_params",
      14,
      this->the_TAO_VDev_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_VDev_set_dev_params_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::VDev::modify_QoS (
  ::AVStreams::streamQoS & the_qos,
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_VDev_Proxy_Broker_ == 0)
    {
      AVStreams_VDev_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_qos,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_VDev_modify_QoS_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "modify_QoS",
      10,
      this->the_TAO_VDev_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_VDev_modify_QoS_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

AVStreams::VDev::VDev (void)
 : the_TAO_VDev_Proxy_Broker_ (0)
{
  this->AVStreams_VDev_setup_collocation ();
}

void
AVStreams::VDev::AVStreams_VDev_setup_collocation ()
{
  if (::AVStreams__TAO_VDev_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_VDev_Proxy_Broker_ =
        ::AVStreams__TAO_VDev_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CosPropertyService_PropertySet_setup_collocation ();
}

AVStreams::VDev::~VDev (void)
{}

void 
AVStreams::VDev::_tao_any_destructor (void *_tao_void_pointer)
{
  VDev *_tao_tmp_pointer =
    static_cast<VDev *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::VDev_ptr
AVStreams::VDev::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<VDev>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/VDev:1.0",
        AVStreams__TAO_VDev_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::VDev_ptr
AVStreams::VDev::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<VDev>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/VDev:1.0",
        AVStreams__TAO_VDev_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::VDev_ptr
AVStreams::VDev::_nil (void)
{
  return 0;
}

AVStreams::VDev_ptr
AVStreams::VDev::_duplicate (VDev_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::VDev::_tao_release (VDev_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::VDev::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/VDev:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::VDev::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/VDev:1.0";
}

::CORBA::Boolean
AVStreams::VDev::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_VDev (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/VDev:1.0",
    "VDev");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_VDev =
    &_tao_tc_AVStreams_VDev;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::MMDevice.

AVStreams::MMDevice_ptr
TAO::Objref_Traits<AVStreams::MMDevice>::duplicate (
    AVStreams::MMDevice_ptr p)
{
  return AVStreams::MMDevice::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::MMDevice>::release (
    AVStreams::MMDevice_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::MMDevice_ptr
TAO::Objref_Traits<AVStreams::MMDevice>::nil (void)
{
  return AVStreams::MMDevice::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::MMDevice>::marshal (
    const AVStreams::MMDevice_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_MMDevice_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::AVStreams::StreamEndPoint_A_ptr
AVStreams::MMDevice::create_A (
  ::AVStreams::StreamCtrl_ptr the_requester,
  ::AVStreams::VDev_out the_vdev,
  ::AVStreams::streamQoS & the_qos,
  ::CORBA::Boolean_out met_qos,
  char *& named_vdev,
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MMDevice_Proxy_Broker_ == 0)
    {
      AVStreams_MMDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::AVStreams::StreamEndPoint_A>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::StreamCtrl>::in_arg_val _tao_the_requester (the_requester);
  TAO::Arg_Traits< ::AVStreams::VDev>::out_arg_val _tao_the_vdev (the_vdev);
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_met_qos (met_qos);
  TAO::Arg_Traits< char *>::inout_arg_val _tao_named_vdev (named_vdev);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_requester,
      &_tao_the_vdev,
      &_tao_the_qos,
      &_tao_met_qos,
      &_tao_named_vdev,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_MMDevice_create_A_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpDenied:1.0",
        AVStreams::streamOpDenied::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpDenied
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      7,
      "create_A",
      8,
      this->the_TAO_MMDevice_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MMDevice_create_A_exceptiondata,
      5
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::AVStreams::StreamEndPoint_B_ptr
AVStreams::MMDevice::create_B (
  ::AVStreams::StreamCtrl_ptr the_requester,
  ::AVStreams::VDev_out the_vdev,
  ::AVStreams::streamQoS & the_qos,
  ::CORBA::Boolean_out met_qos,
  char *& named_vdev,
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MMDevice_Proxy_Broker_ == 0)
    {
      AVStreams_MMDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::AVStreams::StreamEndPoint_B>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::StreamCtrl>::in_arg_val _tao_the_requester (the_requester);
  TAO::Arg_Traits< ::AVStreams::VDev>::out_arg_val _tao_the_vdev (the_vdev);
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_met_qos (met_qos);
  TAO::Arg_Traits< char *>::inout_arg_val _tao_named_vdev (named_vdev);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_requester,
      &_tao_the_vdev,
      &_tao_the_qos,
      &_tao_met_qos,
      &_tao_named_vdev,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_MMDevice_create_B_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpDenied:1.0",
        AVStreams::streamOpDenied::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpDenied
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      7,
      "create_B",
      8,
      this->the_TAO_MMDevice_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MMDevice_create_B_exceptiondata,
      5
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::AVStreams::StreamCtrl_ptr
AVStreams::MMDevice::bind (
  ::AVStreams::MMDevice_ptr peer_device,
  ::AVStreams::streamQoS & the_qos,
  ::CORBA::Boolean_out is_met,
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MMDevice_Proxy_Broker_ == 0)
    {
      AVStreams_MMDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::AVStreams::StreamCtrl>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::MMDevice>::in_arg_val _tao_peer_device (peer_device);
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_is_met (is_met);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_peer_device,
      &_tao_the_qos,
      &_tao_is_met,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_MMDevice_bind_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "bind",
      4,
      this->the_TAO_MMDevice_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MMDevice_bind_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::AVStreams::StreamCtrl_ptr
AVStreams::MMDevice::bind_mcast (
  ::AVStreams::MMDevice_ptr first_peer,
  ::AVStreams::streamQoS & the_qos,
  ::CORBA::Boolean_out is_met,
  const ::AVStreams::flowSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MMDevice_Proxy_Broker_ == 0)
    {
      AVStreams_MMDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::AVStreams::StreamCtrl>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::MMDevice>::in_arg_val _tao_first_peer (first_peer);
  TAO::Arg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_is_met (is_met);
  TAO::Arg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_first_peer,
      &_tao_the_qos,
      &_tao_is_met,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_MMDevice_bind_mcast_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "bind_mcast",
      10,
      this->the_TAO_MMDevice_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MMDevice_bind_mcast_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::MMDevice::destroy (
  ::AVStreams::StreamEndPoint_ptr the_ep,
  const char * vdev_name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MMDevice_Proxy_Broker_ == 0)
    {
      AVStreams_MMDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::StreamEndPoint>::in_arg_val _tao_the_ep (the_ep);
  TAO::Arg_Traits< char *>::in_arg_val _tao_vdev_name (vdev_name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_ep,
      &_tao_vdev_name
    };

  static TAO::Exception_Data
  _tao_AVStreams_MMDevice_destroy_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "destroy",
      7,
      this->the_TAO_MMDevice_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MMDevice_destroy_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
AVStreams::MMDevice::add_fdev (
  ::CORBA::Object_ptr the_fdev)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MMDevice_Proxy_Broker_ == 0)
    {
      AVStreams_MMDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_the_fdev (the_fdev);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_fdev
    };

  static TAO::Exception_Data
  _tao_AVStreams_MMDevice_add_fdev_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "add_fdev",
      8,
      this->the_TAO_MMDevice_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MMDevice_add_fdev_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Object_ptr
AVStreams::MMDevice::get_fdev (
  const char * flow_name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MMDevice_Proxy_Broker_ == 0)
    {
      AVStreams_MMDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_flow_name (flow_name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_flow_name
    };

  static TAO::Exception_Data
  _tao_AVStreams_MMDevice_get_fdev_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_fdev",
      8,
      this->the_TAO_MMDevice_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MMDevice_get_fdev_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::MMDevice::remove_fdev (
  const char * flow_name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MMDevice_Proxy_Broker_ == 0)
    {
      AVStreams_MMDevice_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_flow_name (flow_name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_flow_name
    };

  static TAO::Exception_Data
  _tao_AVStreams_MMDevice_remove_fdev_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/noSuchFlow:1.0",
        AVStreams::noSuchFlow::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_noSuchFlow
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_fdev",
      11,
      this->the_TAO_MMDevice_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MMDevice_remove_fdev_exceptiondata,
      3
    );
}

AVStreams::MMDevice::MMDevice (void)
 : the_TAO_MMDevice_Proxy_Broker_ (0)
{
  this->AVStreams_MMDevice_setup_collocation ();
}

void
AVStreams::MMDevice::AVStreams_MMDevice_setup_collocation ()
{
  if (::AVStreams__TAO_MMDevice_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_MMDevice_Proxy_Broker_ =
        ::AVStreams__TAO_MMDevice_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CosPropertyService_PropertySet_setup_collocation ();
}

AVStreams::MMDevice::~MMDevice (void)
{}

void 
AVStreams::MMDevice::_tao_any_destructor (void *_tao_void_pointer)
{
  MMDevice *_tao_tmp_pointer =
    static_cast<MMDevice *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::MMDevice_ptr
AVStreams::MMDevice::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<MMDevice>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/MMDevice:1.0",
        AVStreams__TAO_MMDevice_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::MMDevice_ptr
AVStreams::MMDevice::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<MMDevice>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/MMDevice:1.0",
        AVStreams__TAO_MMDevice_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::MMDevice_ptr
AVStreams::MMDevice::_nil (void)
{
  return 0;
}

AVStreams::MMDevice_ptr
AVStreams::MMDevice::_duplicate (MMDevice_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::MMDevice::_tao_release (MMDevice_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::MMDevice::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/MMDevice:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::MMDevice::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/MMDevice:1.0";
}

::CORBA::Boolean
AVStreams::MMDevice::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_MMDevice (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/MMDevice:1.0",
    "MMDevice");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_MMDevice =
    &_tao_tc_AVStreams_MMDevice;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::protocolNotSupported::protocolNotSupported (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/protocolNotSupported:1.0",
        "protocolNotSupported"
      )
{
}

AVStreams::protocolNotSupported::~protocolNotSupported (void)
{
}

AVStreams::protocolNotSupported::protocolNotSupported (const ::AVStreams::protocolNotSupported &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

AVStreams::protocolNotSupported&
AVStreams::protocolNotSupported::operator= (const ::AVStreams::protocolNotSupported &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void AVStreams::protocolNotSupported::_tao_any_destructor (void *_tao_void_pointer)
{
  protocolNotSupported *_tao_tmp_pointer =
    static_cast<protocolNotSupported *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::protocolNotSupported *
AVStreams::protocolNotSupported::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<protocolNotSupported *> (_tao_excp);
}

const AVStreams::protocolNotSupported *
AVStreams::protocolNotSupported::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const protocolNotSupported *> (_tao_excp);
}

::CORBA::Exception *AVStreams::protocolNotSupported::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::protocolNotSupported, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::protocolNotSupported::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::protocolNotSupported (*this),
      0
    );
  return result;
}

void AVStreams::protocolNotSupported::_raise (void) const
{
  throw *this;
}

void AVStreams::protocolNotSupported::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::protocolNotSupported::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::protocolNotSupported::_tao_type (void) const
{
  return ::AVStreams::_tc_protocolNotSupported;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_AVStreams_protocolNotSupported = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_protocolNotSupported (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/protocolNotSupported:1.0",
  "protocolNotSupported",
  _tao_fields_AVStreams_protocolNotSupported,
  0);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_protocolNotSupported =
    &_tao_tc_AVStreams_protocolNotSupported;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::formatNotSupported::formatNotSupported (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/formatNotSupported:1.0",
        "formatNotSupported"
      )
{
}

AVStreams::formatNotSupported::~formatNotSupported (void)
{
}

AVStreams::formatNotSupported::formatNotSupported (const ::AVStreams::formatNotSupported &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

AVStreams::formatNotSupported&
AVStreams::formatNotSupported::operator= (const ::AVStreams::formatNotSupported &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void AVStreams::formatNotSupported::_tao_any_destructor (void *_tao_void_pointer)
{
  formatNotSupported *_tao_tmp_pointer =
    static_cast<formatNotSupported *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::formatNotSupported *
AVStreams::formatNotSupported::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<formatNotSupported *> (_tao_excp);
}

const AVStreams::formatNotSupported *
AVStreams::formatNotSupported::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const formatNotSupported *> (_tao_excp);
}

::CORBA::Exception *AVStreams::formatNotSupported::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::formatNotSupported, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::formatNotSupported::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::formatNotSupported (*this),
      0
    );
  return result;
}

void AVStreams::formatNotSupported::_raise (void) const
{
  throw *this;
}

void AVStreams::formatNotSupported::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::formatNotSupported::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::formatNotSupported::_tao_type (void) const
{
  return ::AVStreams::_tc_formatNotSupported;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_AVStreams_formatNotSupported = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_formatNotSupported (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/formatNotSupported:1.0",
  "formatNotSupported",
  _tao_fields_AVStreams_formatNotSupported,
  0);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_formatNotSupported =
    &_tao_tc_AVStreams_formatNotSupported;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::formatMismatch::formatMismatch (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/formatMismatch:1.0",
        "formatMismatch"
      )
{
}

AVStreams::formatMismatch::~formatMismatch (void)
{
}

AVStreams::formatMismatch::formatMismatch (const ::AVStreams::formatMismatch &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

AVStreams::formatMismatch&
AVStreams::formatMismatch::operator= (const ::AVStreams::formatMismatch &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void AVStreams::formatMismatch::_tao_any_destructor (void *_tao_void_pointer)
{
  formatMismatch *_tao_tmp_pointer =
    static_cast<formatMismatch *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::formatMismatch *
AVStreams::formatMismatch::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<formatMismatch *> (_tao_excp);
}

const AVStreams::formatMismatch *
AVStreams::formatMismatch::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const formatMismatch *> (_tao_excp);
}

::CORBA::Exception *AVStreams::formatMismatch::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::formatMismatch, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::formatMismatch::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::formatMismatch (*this),
      0
    );
  return result;
}

void AVStreams::formatMismatch::_raise (void) const
{
  throw *this;
}

void AVStreams::formatMismatch::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::formatMismatch::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::formatMismatch::_tao_type (void) const
{
  return ::AVStreams::_tc_formatMismatch;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_AVStreams_formatMismatch = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_formatMismatch (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/formatMismatch:1.0",
  "formatMismatch",
  _tao_fields_AVStreams_formatMismatch,
  0);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_formatMismatch =
    &_tao_tc_AVStreams_formatMismatch;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::FEPMismatch::FEPMismatch (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/FEPMismatch:1.0",
        "FEPMismatch"
      )
{
}

AVStreams::FEPMismatch::~FEPMismatch (void)
{
}

AVStreams::FEPMismatch::FEPMismatch (const ::AVStreams::FEPMismatch &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

AVStreams::FEPMismatch&
AVStreams::FEPMismatch::operator= (const ::AVStreams::FEPMismatch &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void AVStreams::FEPMismatch::_tao_any_destructor (void *_tao_void_pointer)
{
  FEPMismatch *_tao_tmp_pointer =
    static_cast<FEPMismatch *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::FEPMismatch *
AVStreams::FEPMismatch::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<FEPMismatch *> (_tao_excp);
}

const AVStreams::FEPMismatch *
AVStreams::FEPMismatch::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const FEPMismatch *> (_tao_excp);
}

::CORBA::Exception *AVStreams::FEPMismatch::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::FEPMismatch, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::FEPMismatch::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::FEPMismatch (*this),
      0
    );
  return result;
}

void AVStreams::FEPMismatch::_raise (void) const
{
  throw *this;
}

void AVStreams::FEPMismatch::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::FEPMismatch::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::FEPMismatch::_tao_type (void) const
{
  return ::AVStreams::_tc_FEPMismatch;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_AVStreams_FEPMismatch = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_FEPMismatch (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/FEPMismatch:1.0",
  "FEPMismatch",
  _tao_fields_AVStreams_FEPMismatch,
  0);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_FEPMismatch =
    &_tao_tc_AVStreams_FEPMismatch;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::alreadyConnected::alreadyConnected (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/alreadyConnected:1.0",
        "alreadyConnected"
      )
{
}

AVStreams::alreadyConnected::~alreadyConnected (void)
{
}

AVStreams::alreadyConnected::alreadyConnected (const ::AVStreams::alreadyConnected &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

AVStreams::alreadyConnected&
AVStreams::alreadyConnected::operator= (const ::AVStreams::alreadyConnected &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void AVStreams::alreadyConnected::_tao_any_destructor (void *_tao_void_pointer)
{
  alreadyConnected *_tao_tmp_pointer =
    static_cast<alreadyConnected *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::alreadyConnected *
AVStreams::alreadyConnected::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<alreadyConnected *> (_tao_excp);
}

const AVStreams::alreadyConnected *
AVStreams::alreadyConnected::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const alreadyConnected *> (_tao_excp);
}

::CORBA::Exception *AVStreams::alreadyConnected::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::alreadyConnected, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::alreadyConnected::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::alreadyConnected (*this),
      0
    );
  return result;
}

void AVStreams::alreadyConnected::_raise (void) const
{
  throw *this;
}

void AVStreams::alreadyConnected::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::alreadyConnected::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::alreadyConnected::_tao_type (void) const
{
  return ::AVStreams::_tc_alreadyConnected;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_AVStreams_alreadyConnected = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_alreadyConnected (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/alreadyConnected:1.0",
  "alreadyConnected",
  _tao_fields_AVStreams_alreadyConnected,
  0);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_alreadyConnected =
    &_tao_tc_AVStreams_alreadyConnected;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

AVStreams::invalidSettings::invalidSettings (
    const char * _tao_settings)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/invalidSettings:1.0",
        "invalidSettings"
      )
{
  this->settings = ::CORBA::string_dup (_tao_settings);
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::invalidSettings::invalidSettings (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/invalidSettings:1.0",
        "invalidSettings"
      )
{
}

AVStreams::invalidSettings::~invalidSettings (void)
{
}

AVStreams::invalidSettings::invalidSettings (const ::AVStreams::invalidSettings &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->settings = ::CORBA::string_dup (_tao_excp.settings.in ());
}

AVStreams::invalidSettings&
AVStreams::invalidSettings::operator= (const ::AVStreams::invalidSettings &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->settings = ::CORBA::string_dup (_tao_excp.settings.in ());
  return *this;
}

void AVStreams::invalidSettings::_tao_any_destructor (void *_tao_void_pointer)
{
  invalidSettings *_tao_tmp_pointer =
    static_cast<invalidSettings *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::invalidSettings *
AVStreams::invalidSettings::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<invalidSettings *> (_tao_excp);
}

const AVStreams::invalidSettings *
AVStreams::invalidSettings::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const invalidSettings *> (_tao_excp);
}

::CORBA::Exception *AVStreams::invalidSettings::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::invalidSettings, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::invalidSettings::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::invalidSettings (*this),
      0
    );
  return result;
}

void AVStreams::invalidSettings::_raise (void) const
{
  throw *this;
}

void AVStreams::invalidSettings::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::invalidSettings::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::invalidSettings::_tao_type (void) const
{
  return ::AVStreams::_tc_invalidSettings;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_AVStreams_invalidSettings[] =
      {
        { "settings", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_invalidSettings (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/invalidSettings:1.0",
  "invalidSettings",
  _tao_fields_AVStreams_invalidSettings,
  1);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_invalidSettings =
    &_tao_tc_AVStreams_invalidSettings;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::notConnected::notConnected (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/notConnected:1.0",
        "notConnected"
      )
{
}

AVStreams::notConnected::~notConnected (void)
{
}

AVStreams::notConnected::notConnected (const ::AVStreams::notConnected &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

AVStreams::notConnected&
AVStreams::notConnected::operator= (const ::AVStreams::notConnected &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void AVStreams::notConnected::_tao_any_destructor (void *_tao_void_pointer)
{
  notConnected *_tao_tmp_pointer =
    static_cast<notConnected *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::notConnected *
AVStreams::notConnected::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<notConnected *> (_tao_excp);
}

const AVStreams::notConnected *
AVStreams::notConnected::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const notConnected *> (_tao_excp);
}

::CORBA::Exception *AVStreams::notConnected::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::notConnected, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::notConnected::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::notConnected (*this),
      0
    );
  return result;
}

void AVStreams::notConnected::_raise (void) const
{
  throw *this;
}

void AVStreams::notConnected::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::notConnected::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::notConnected::_tao_type (void) const
{
  return ::AVStreams::_tc_notConnected;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_AVStreams_notConnected = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_notConnected (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/notConnected:1.0",
  "notConnected",
  _tao_fields_AVStreams_notConnected,
  0);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_notConnected =
    &_tao_tc_AVStreams_notConnected;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::deviceQosMismatch::deviceQosMismatch (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/deviceQosMismatch:1.0",
        "deviceQosMismatch"
      )
{
}

AVStreams::deviceQosMismatch::~deviceQosMismatch (void)
{
}

AVStreams::deviceQosMismatch::deviceQosMismatch (const ::AVStreams::deviceQosMismatch &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

AVStreams::deviceQosMismatch&
AVStreams::deviceQosMismatch::operator= (const ::AVStreams::deviceQosMismatch &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void AVStreams::deviceQosMismatch::_tao_any_destructor (void *_tao_void_pointer)
{
  deviceQosMismatch *_tao_tmp_pointer =
    static_cast<deviceQosMismatch *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::deviceQosMismatch *
AVStreams::deviceQosMismatch::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<deviceQosMismatch *> (_tao_excp);
}

const AVStreams::deviceQosMismatch *
AVStreams::deviceQosMismatch::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const deviceQosMismatch *> (_tao_excp);
}

::CORBA::Exception *AVStreams::deviceQosMismatch::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::deviceQosMismatch, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::deviceQosMismatch::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::deviceQosMismatch (*this),
      0
    );
  return result;
}

void AVStreams::deviceQosMismatch::_raise (void) const
{
  throw *this;
}

void AVStreams::deviceQosMismatch::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::deviceQosMismatch::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::deviceQosMismatch::_tao_type (void) const
{
  return ::AVStreams::_tc_deviceQosMismatch;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_AVStreams_deviceQosMismatch = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_deviceQosMismatch (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/deviceQosMismatch:1.0",
  "deviceQosMismatch",
  _tao_fields_AVStreams_deviceQosMismatch,
  0);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_deviceQosMismatch =
    &_tao_tc_AVStreams_deviceQosMismatch;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

AVStreams::failedToConnect::failedToConnect (
    const char * _tao_reason)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/failedToConnect:1.0",
        "failedToConnect"
      )
{
  this->reason = ::CORBA::string_dup (_tao_reason);
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::failedToConnect::failedToConnect (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/failedToConnect:1.0",
        "failedToConnect"
      )
{
}

AVStreams::failedToConnect::~failedToConnect (void)
{
}

AVStreams::failedToConnect::failedToConnect (const ::AVStreams::failedToConnect &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
}

AVStreams::failedToConnect&
AVStreams::failedToConnect::operator= (const ::AVStreams::failedToConnect &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
  return *this;
}

void AVStreams::failedToConnect::_tao_any_destructor (void *_tao_void_pointer)
{
  failedToConnect *_tao_tmp_pointer =
    static_cast<failedToConnect *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::failedToConnect *
AVStreams::failedToConnect::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<failedToConnect *> (_tao_excp);
}

const AVStreams::failedToConnect *
AVStreams::failedToConnect::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const failedToConnect *> (_tao_excp);
}

::CORBA::Exception *AVStreams::failedToConnect::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::failedToConnect, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::failedToConnect::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::failedToConnect (*this),
      0
    );
  return result;
}

void AVStreams::failedToConnect::_raise (void) const
{
  throw *this;
}

void AVStreams::failedToConnect::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::failedToConnect::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::failedToConnect::_tao_type (void) const
{
  return ::AVStreams::_tc_failedToConnect;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_AVStreams_failedToConnect[] =
      {
        { "reason", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_failedToConnect (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/failedToConnect:1.0",
  "failedToConnect",
  _tao_fields_AVStreams_failedToConnect,
  1);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_failedToConnect =
    &_tao_tc_AVStreams_failedToConnect;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

AVStreams::failedToListen::failedToListen (
    const char * _tao_reason)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/failedToListen:1.0",
        "failedToListen"
      )
{
  this->reason = ::CORBA::string_dup (_tao_reason);
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::failedToListen::failedToListen (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/failedToListen:1.0",
        "failedToListen"
      )
{
}

AVStreams::failedToListen::~failedToListen (void)
{
}

AVStreams::failedToListen::failedToListen (const ::AVStreams::failedToListen &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
}

AVStreams::failedToListen&
AVStreams::failedToListen::operator= (const ::AVStreams::failedToListen &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
  return *this;
}

void AVStreams::failedToListen::_tao_any_destructor (void *_tao_void_pointer)
{
  failedToListen *_tao_tmp_pointer =
    static_cast<failedToListen *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::failedToListen *
AVStreams::failedToListen::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<failedToListen *> (_tao_excp);
}

const AVStreams::failedToListen *
AVStreams::failedToListen::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const failedToListen *> (_tao_excp);
}

::CORBA::Exception *AVStreams::failedToListen::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::failedToListen, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::failedToListen::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::failedToListen (*this),
      0
    );
  return result;
}

void AVStreams::failedToListen::_raise (void) const
{
  throw *this;
}

void AVStreams::failedToListen::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::failedToListen::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::failedToListen::_tao_type (void) const
{
  return ::AVStreams::_tc_failedToListen;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_AVStreams_failedToListen[] =
      {
        { "reason", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_failedToListen (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/failedToListen:1.0",
  "failedToListen",
  _tao_fields_AVStreams_failedToListen,
  1);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_failedToListen =
    &_tao_tc_AVStreams_failedToListen;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::FlowConnection.

AVStreams::FlowConnection_ptr
TAO::Objref_Traits<AVStreams::FlowConnection>::duplicate (
    AVStreams::FlowConnection_ptr p)
{
  return AVStreams::FlowConnection::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::FlowConnection>::release (
    AVStreams::FlowConnection_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::FlowConnection_ptr
TAO::Objref_Traits<AVStreams::FlowConnection>::nil (void)
{
  return AVStreams::FlowConnection::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::FlowConnection>::marshal (
    const AVStreams::FlowConnection_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_FlowConnection_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowConnection::stop (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowConnection_Proxy_Broker_ == 0)
    {
      AVStreams_FlowConnection_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "stop",
      4,
      this->the_TAO_FlowConnection_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowConnection::start (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowConnection_Proxy_Broker_ == 0)
    {
      AVStreams_FlowConnection_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "start",
      5,
      this->the_TAO_FlowConnection_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowConnection::destroy (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowConnection_Proxy_Broker_ == 0)
    {
      AVStreams_FlowConnection_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "destroy",
      7,
      this->the_TAO_FlowConnection_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::FlowConnection::modify_QoS (
  ::AVStreams::QoS & new_qos)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowConnection_Proxy_Broker_ == 0)
    {
      AVStreams_FlowConnection_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_new_qos (new_qos);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_new_qos
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowConnection_modify_QoS_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "modify_QoS",
      10,
      this->the_TAO_FlowConnection_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowConnection_modify_QoS_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::FlowConnection::use_flow_protocol (
  const char * fp_name,
  const ::CORBA::Any & fp_settings)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowConnection_Proxy_Broker_ == 0)
    {
      AVStreams_FlowConnection_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_fp_name (fp_name);
  TAO::Arg_Traits< ::CORBA::Any>::in_arg_val _tao_fp_settings (fp_settings);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_fp_name,
      &_tao_fp_settings
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowConnection_use_flow_protocol_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/FPError:1.0",
        AVStreams::FPError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_FPError
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "use_flow_protocol",
      17,
      this->the_TAO_FlowConnection_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowConnection_use_flow_protocol_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowConnection::push_event (
  const ::AVStreams::streamEvent & the_event)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowConnection_Proxy_Broker_ == 0)
    {
      AVStreams_FlowConnection_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosPropertyService::Property>::in_arg_val _tao_the_event (the_event);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_event
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "push_event",
      10,
      this->the_TAO_FlowConnection_Proxy_Broker_,
      TAO::TAO_ONEWAY_INVOCATION
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::FlowConnection::connect_devs (
  ::AVStreams::FDev_ptr a_party,
  ::AVStreams::FDev_ptr b_party,
  ::AVStreams::QoS & the_qos)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowConnection_Proxy_Broker_ == 0)
    {
      AVStreams_FlowConnection_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::FDev>::in_arg_val _tao_a_party (a_party);
  TAO::Arg_Traits< ::AVStreams::FDev>::in_arg_val _tao_b_party (b_party);
  TAO::Arg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos (the_qos);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_a_party,
      &_tao_b_party,
      &_tao_the_qos
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowConnection_connect_devs_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpDenied:1.0",
        AVStreams::streamOpDenied::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpDenied
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "connect_devs",
      12,
      this->the_TAO_FlowConnection_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowConnection_connect_devs_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::FlowConnection::connect (
  ::AVStreams::FlowProducer_ptr flow_producer,
  ::AVStreams::FlowConsumer_ptr flow_consumer,
  ::AVStreams::QoS & the_qos)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowConnection_Proxy_Broker_ == 0)
    {
      AVStreams_FlowConnection_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::FlowProducer>::in_arg_val _tao_flow_producer (flow_producer);
  TAO::Arg_Traits< ::AVStreams::FlowConsumer>::in_arg_val _tao_flow_consumer (flow_consumer);
  TAO::Arg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos (the_qos);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_flow_producer,
      &_tao_flow_consumer,
      &_tao_the_qos
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowConnection_connect_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/formatMismatch:1.0",
        AVStreams::formatMismatch::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_formatMismatch
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/FEPMismatch:1.0",
        AVStreams::FEPMismatch::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_FEPMismatch
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/alreadyConnected:1.0",
        AVStreams::alreadyConnected::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_alreadyConnected
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "connect",
      7,
      this->the_TAO_FlowConnection_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowConnection_connect_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::FlowConnection::disconnect (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowConnection_Proxy_Broker_ == 0)
    {
      AVStreams_FlowConnection_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "disconnect",
      10,
      this->the_TAO_FlowConnection_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::FlowConnection::add_producer (
  ::AVStreams::FlowProducer_ptr flow_producer,
  ::AVStreams::QoS & the_qos)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowConnection_Proxy_Broker_ == 0)
    {
      AVStreams_FlowConnection_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::FlowProducer>::in_arg_val _tao_flow_producer (flow_producer);
  TAO::Arg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos (the_qos);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_flow_producer,
      &_tao_the_qos
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowConnection_add_producer_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/alreadyConnected:1.0",
        AVStreams::alreadyConnected::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_alreadyConnected
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "add_producer",
      12,
      this->the_TAO_FlowConnection_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowConnection_add_producer_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::FlowConnection::add_consumer (
  ::AVStreams::FlowConsumer_ptr flow_consumer,
  ::AVStreams::QoS & the_qos)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowConnection_Proxy_Broker_ == 0)
    {
      AVStreams_FlowConnection_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::FlowConsumer>::in_arg_val _tao_flow_consumer (flow_consumer);
  TAO::Arg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos (the_qos);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_flow_consumer,
      &_tao_the_qos
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowConnection_add_consumer_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/alreadyConnected:1.0",
        AVStreams::alreadyConnected::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_alreadyConnected
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "add_consumer",
      12,
      this->the_TAO_FlowConnection_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowConnection_add_consumer_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::FlowConnection::drop (
  ::AVStreams::FlowEndPoint_ptr target)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowConnection_Proxy_Broker_ == 0)
    {
      AVStreams_FlowConnection_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::FlowEndPoint>::in_arg_val _tao_target (target);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_target
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowConnection_drop_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/notConnected:1.0",
        AVStreams::notConnected::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notConnected
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "drop",
      4,
      this->the_TAO_FlowConnection_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowConnection_drop_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

AVStreams::FlowConnection::FlowConnection (void)
 : the_TAO_FlowConnection_Proxy_Broker_ (0)
{
  this->AVStreams_FlowConnection_setup_collocation ();
}

void
AVStreams::FlowConnection::AVStreams_FlowConnection_setup_collocation ()
{
  if (::AVStreams__TAO_FlowConnection_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_FlowConnection_Proxy_Broker_ =
        ::AVStreams__TAO_FlowConnection_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CosPropertyService_PropertySet_setup_collocation ();
}

AVStreams::FlowConnection::~FlowConnection (void)
{}

void 
AVStreams::FlowConnection::_tao_any_destructor (void *_tao_void_pointer)
{
  FlowConnection *_tao_tmp_pointer =
    static_cast<FlowConnection *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::FlowConnection_ptr
AVStreams::FlowConnection::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FlowConnection>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/FlowConnection:1.0",
        AVStreams__TAO_FlowConnection_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::FlowConnection_ptr
AVStreams::FlowConnection::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FlowConnection>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/FlowConnection:1.0",
        AVStreams__TAO_FlowConnection_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::FlowConnection_ptr
AVStreams::FlowConnection::_nil (void)
{
  return 0;
}

AVStreams::FlowConnection_ptr
AVStreams::FlowConnection::_duplicate (FlowConnection_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::FlowConnection::_tao_release (FlowConnection_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::FlowConnection::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/FlowConnection:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::FlowConnection::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/FlowConnection:1.0";
}

::CORBA::Boolean
AVStreams::FlowConnection::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_FlowConnection (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/FlowConnection:1.0",
    "FlowConnection");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_FlowConnection =
    &_tao_tc_AVStreams_FlowConnection;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::FlowEndPoint.

AVStreams::FlowEndPoint_ptr
TAO::Objref_Traits<AVStreams::FlowEndPoint>::duplicate (
    AVStreams::FlowEndPoint_ptr p)
{
  return AVStreams::FlowEndPoint::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::FlowEndPoint>::release (
    AVStreams::FlowEndPoint_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::FlowEndPoint_ptr
TAO::Objref_Traits<AVStreams::FlowEndPoint>::nil (void)
{
  return AVStreams::FlowEndPoint::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::FlowEndPoint>::marshal (
    const AVStreams::FlowEndPoint_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_FlowEndPoint_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::FlowEndPoint::lock (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "lock",
      4,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowEndPoint::unlock (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "unlock",
      6,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowEndPoint::stop (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "stop",
      4,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowEndPoint::start (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "start",
      5,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowEndPoint::destroy (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "destroy",
      7,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::AVStreams::StreamEndPoint_ptr
AVStreams::FlowEndPoint::related_sep (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::AVStreams::StreamEndPoint>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_related_sep",
      16,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowEndPoint::related_sep (
  ::AVStreams::StreamEndPoint_ptr related_sep)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::StreamEndPoint>::in_arg_val _tao_related_sep (related_sep);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_related_sep
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_related_sep",
      16,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::AVStreams::FlowConnection_ptr
AVStreams::FlowEndPoint::related_flow_connection (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::AVStreams::FlowConnection>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_related_flow_connection",
      28,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowEndPoint::related_flow_connection (
  ::AVStreams::FlowConnection_ptr related_flow_connection)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::FlowConnection>::in_arg_val _tao_related_flow_connection (related_flow_connection);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_related_flow_connection
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_related_flow_connection",
      28,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::AVStreams::FlowEndPoint_ptr
AVStreams::FlowEndPoint::get_connected_fep (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::AVStreams::FlowEndPoint>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowEndPoint_get_connected_fep_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/notConnected:1.0",
        AVStreams::notConnected::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notConnected
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "get_connected_fep",
      17,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowEndPoint_get_connected_fep_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::FlowEndPoint::use_flow_protocol (
  const char * fp_name,
  const ::CORBA::Any & fp_settings)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_fp_name (fp_name);
  TAO::Arg_Traits< ::CORBA::Any>::in_arg_val _tao_fp_settings (fp_settings);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_fp_name,
      &_tao_fp_settings
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowEndPoint_use_flow_protocol_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/FPError:1.0",
        AVStreams::FPError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_FPError
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "use_flow_protocol",
      17,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowEndPoint_use_flow_protocol_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowEndPoint::set_format (
  const char * format)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_format (format);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_format
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowEndPoint_set_format_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_format",
      10,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowEndPoint_set_format_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowEndPoint::set_dev_params (
  const ::CosPropertyService::Properties & new_settings)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CosPropertyService::Properties>::in_arg_val _tao_new_settings (new_settings);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_new_settings
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowEndPoint_set_dev_params_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/PropertyException:1.0",
        AVStreams::PropertyException::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_PropertyException
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_dev_params",
      14,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowEndPoint_set_dev_params_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowEndPoint::set_protocol_restriction (
  const ::AVStreams::protocolSpec & the_spec)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::protocolSpec>::in_arg_val _tao_the_spec (the_spec);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_spec
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowEndPoint_set_protocol_restriction_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_protocol_restriction",
      24,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowEndPoint_set_protocol_restriction_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::FlowEndPoint::is_fep_compatible (
  ::AVStreams::FlowEndPoint_ptr fep)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::FlowEndPoint>::in_arg_val _tao_fep (fep);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_fep
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowEndPoint_is_fep_compatible_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/formatMismatch:1.0",
        AVStreams::formatMismatch::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_formatMismatch
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/deviceQosMismatch:1.0",
        AVStreams::deviceQosMismatch::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_deviceQosMismatch
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "is_fep_compatible",
      17,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowEndPoint_is_fep_compatible_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::FlowEndPoint::set_peer (
  ::AVStreams::FlowConnection_ptr the_fc,
  ::AVStreams::FlowEndPoint_ptr the_peer_fep,
  ::AVStreams::QoS & the_qos)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::FlowConnection>::in_arg_val _tao_the_fc (the_fc);
  TAO::Arg_Traits< ::AVStreams::FlowEndPoint>::in_arg_val _tao_the_peer_fep (the_peer_fep);
  TAO::Arg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos (the_qos);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_fc,
      &_tao_the_peer_fep,
      &_tao_the_qos
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowEndPoint_set_peer_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "set_peer",
      8,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowEndPoint_set_peer_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::FlowEndPoint::set_Mcast_peer (
  ::AVStreams::FlowConnection_ptr the_fc,
  ::AVStreams::MCastConfigIf_ptr a_mcastconfigif,
  ::AVStreams::QoS & the_qos)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::FlowConnection>::in_arg_val _tao_the_fc (the_fc);
  TAO::Arg_Traits< ::AVStreams::MCastConfigIf>::in_arg_val _tao_a_mcastconfigif (a_mcastconfigif);
  TAO::Arg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos (the_qos);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_fc,
      &_tao_a_mcastconfigif,
      &_tao_the_qos
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowEndPoint_set_Mcast_peer_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "set_Mcast_peer",
      14,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowEndPoint_set_Mcast_peer_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::Boolean
AVStreams::FlowEndPoint::connect_to_peer (
  ::AVStreams::QoS & the_qos,
  const char * address,
  const char * use_flow_protocol)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< char *>::in_arg_val _tao_address (address);
  TAO::Arg_Traits< char *>::in_arg_val _tao_use_flow_protocol (use_flow_protocol);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_qos,
      &_tao_address,
      &_tao_use_flow_protocol
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowEndPoint_connect_to_peer_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/failedToConnect:1.0",
        AVStreams::failedToConnect::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_failedToConnect
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/FPError:1.0",
        AVStreams::FPError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_FPError
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "connect_to_peer",
      15,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowEndPoint_connect_to_peer_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
AVStreams::FlowEndPoint::go_to_listen (
  ::AVStreams::QoS & the_qos,
  ::CORBA::Boolean is_mcast,
  ::AVStreams::FlowEndPoint_ptr peer,
  char *& flowProtocol)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowEndPoint_Proxy_Broker_ == 0)
    {
      AVStreams_FlowEndPoint_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_mcast (is_mcast);
  TAO::Arg_Traits< ::AVStreams::FlowEndPoint>::in_arg_val _tao_peer (peer);
  TAO::Arg_Traits< char *>::inout_arg_val _tao_flowProtocol (flowProtocol);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_qos,
      &_tao_is_mcast,
      &_tao_peer,
      &_tao_flowProtocol
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowEndPoint_go_to_listen_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/failedToListen:1.0",
        AVStreams::failedToListen::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_failedToListen
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/FPError:1.0",
        AVStreams::FPError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_FPError
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "go_to_listen",
      12,
      this->the_TAO_FlowEndPoint_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowEndPoint_go_to_listen_exceptiondata,
      3
    );

  return _tao_retval.retn ();
}

AVStreams::FlowEndPoint::FlowEndPoint (void)
 : the_TAO_FlowEndPoint_Proxy_Broker_ (0)
{
  this->AVStreams_FlowEndPoint_setup_collocation ();
}

void
AVStreams::FlowEndPoint::AVStreams_FlowEndPoint_setup_collocation ()
{
  if (::AVStreams__TAO_FlowEndPoint_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_FlowEndPoint_Proxy_Broker_ =
        ::AVStreams__TAO_FlowEndPoint_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CosPropertyService_PropertySet_setup_collocation ();
}

AVStreams::FlowEndPoint::~FlowEndPoint (void)
{}

void 
AVStreams::FlowEndPoint::_tao_any_destructor (void *_tao_void_pointer)
{
  FlowEndPoint *_tao_tmp_pointer =
    static_cast<FlowEndPoint *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::FlowEndPoint_ptr
AVStreams::FlowEndPoint::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FlowEndPoint>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/FlowEndPoint:1.0",
        AVStreams__TAO_FlowEndPoint_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::FlowEndPoint_ptr
AVStreams::FlowEndPoint::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FlowEndPoint>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/FlowEndPoint:1.0",
        AVStreams__TAO_FlowEndPoint_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::FlowEndPoint_ptr
AVStreams::FlowEndPoint::_nil (void)
{
  return 0;
}

AVStreams::FlowEndPoint_ptr
AVStreams::FlowEndPoint::_duplicate (FlowEndPoint_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::FlowEndPoint::_tao_release (FlowEndPoint_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::FlowEndPoint::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/FlowEndPoint:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::FlowEndPoint::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/FlowEndPoint:1.0";
}

::CORBA::Boolean
AVStreams::FlowEndPoint::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_FlowEndPoint (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/FlowEndPoint:1.0",
    "FlowEndPoint");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_FlowEndPoint =
    &_tao_tc_AVStreams_FlowEndPoint;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::FlowProducer.

AVStreams::FlowProducer_ptr
TAO::Objref_Traits<AVStreams::FlowProducer>::duplicate (
    AVStreams::FlowProducer_ptr p)
{
  return AVStreams::FlowProducer::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::FlowProducer>::release (
    AVStreams::FlowProducer_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::FlowProducer_ptr
TAO::Objref_Traits<AVStreams::FlowProducer>::nil (void)
{
  return AVStreams::FlowProducer::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::FlowProducer>::marshal (
    const AVStreams::FlowProducer_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_FlowProducer_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
AVStreams::FlowProducer::connect_mcast (
  ::AVStreams::QoS & the_qos,
  ::CORBA::Boolean_out is_met,
  const char * address,
  const char * use_flow_protocol)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowProducer_Proxy_Broker_ == 0)
    {
      AVStreams_FlowProducer_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_is_met (is_met);
  TAO::Arg_Traits< char *>::in_arg_val _tao_address (address);
  TAO::Arg_Traits< char *>::in_arg_val _tao_use_flow_protocol (use_flow_protocol);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_qos,
      &_tao_is_met,
      &_tao_address,
      &_tao_use_flow_protocol
    };

  static TAO::Exception_Data
  _tao_AVStreams_FlowProducer_connect_mcast_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/failedToConnect:1.0",
        AVStreams::failedToConnect::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_failedToConnect
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/FPError:1.0",
        AVStreams::FPError::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_FPError
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "connect_mcast",
      13,
      this->the_TAO_FlowProducer_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FlowProducer_connect_mcast_exceptiondata,
      4
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char *
AVStreams::FlowProducer::get_rev_channel (
  const char * pcol_name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowProducer_Proxy_Broker_ == 0)
    {
      AVStreams_FlowProducer_setup_collocation ();
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_pcol_name (pcol_name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_pcol_name
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_rev_channel",
      15,
      this->the_TAO_FlowProducer_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowProducer::set_key (
  const ::AVStreams::key & the_key)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowProducer_Proxy_Broker_ == 0)
    {
      AVStreams_FlowProducer_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::key>::in_arg_val _tao_the_key (the_key);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_key
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_key",
      7,
      this->the_TAO_FlowProducer_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FlowProducer::set_source_id (
  ::CORBA::Long source_id)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FlowProducer_Proxy_Broker_ == 0)
    {
      AVStreams_FlowProducer_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_source_id (source_id);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_source_id
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_source_id",
      13,
      this->the_TAO_FlowProducer_Proxy_Broker_
    );

  _tao_call.invoke (0, 0);
}

AVStreams::FlowProducer::FlowProducer (void)
 : the_TAO_FlowProducer_Proxy_Broker_ (0)
{
  this->AVStreams_FlowProducer_setup_collocation ();
}

void
AVStreams::FlowProducer::AVStreams_FlowProducer_setup_collocation ()
{
  if (::AVStreams__TAO_FlowProducer_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_FlowProducer_Proxy_Broker_ =
        ::AVStreams__TAO_FlowProducer_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->AVStreams_FlowEndPoint_setup_collocation ();
}

AVStreams::FlowProducer::~FlowProducer (void)
{}

void 
AVStreams::FlowProducer::_tao_any_destructor (void *_tao_void_pointer)
{
  FlowProducer *_tao_tmp_pointer =
    static_cast<FlowProducer *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::FlowProducer_ptr
AVStreams::FlowProducer::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FlowProducer>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/FlowProducer:1.0",
        AVStreams__TAO_FlowProducer_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::FlowProducer_ptr
AVStreams::FlowProducer::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FlowProducer>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/FlowProducer:1.0",
        AVStreams__TAO_FlowProducer_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::FlowProducer_ptr
AVStreams::FlowProducer::_nil (void)
{
  return 0;
}

AVStreams::FlowProducer_ptr
AVStreams::FlowProducer::_duplicate (FlowProducer_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::FlowProducer::_tao_release (FlowProducer_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::FlowProducer::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/FlowEndPoint:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/FlowProducer:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::FlowProducer::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/FlowProducer:1.0";
}

::CORBA::Boolean
AVStreams::FlowProducer::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_FlowProducer (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/FlowProducer:1.0",
    "FlowProducer");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_FlowProducer =
    &_tao_tc_AVStreams_FlowProducer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::FlowConsumer.

AVStreams::FlowConsumer_ptr
TAO::Objref_Traits<AVStreams::FlowConsumer>::duplicate (
    AVStreams::FlowConsumer_ptr p)
{
  return AVStreams::FlowConsumer::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::FlowConsumer>::release (
    AVStreams::FlowConsumer_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::FlowConsumer_ptr
TAO::Objref_Traits<AVStreams::FlowConsumer>::nil (void)
{
  return AVStreams::FlowConsumer::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::FlowConsumer>::marshal (
    const AVStreams::FlowConsumer_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_FlowConsumer_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

AVStreams::FlowConsumer::FlowConsumer (void)
 : the_TAO_FlowConsumer_Proxy_Broker_ (0)
{
  this->AVStreams_FlowConsumer_setup_collocation ();
}

void
AVStreams::FlowConsumer::AVStreams_FlowConsumer_setup_collocation ()
{
  if (::AVStreams__TAO_FlowConsumer_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_FlowConsumer_Proxy_Broker_ =
        ::AVStreams__TAO_FlowConsumer_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->AVStreams_FlowEndPoint_setup_collocation ();
}

AVStreams::FlowConsumer::~FlowConsumer (void)
{}

void 
AVStreams::FlowConsumer::_tao_any_destructor (void *_tao_void_pointer)
{
  FlowConsumer *_tao_tmp_pointer =
    static_cast<FlowConsumer *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::FlowConsumer_ptr
AVStreams::FlowConsumer::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FlowConsumer>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/FlowConsumer:1.0",
        AVStreams__TAO_FlowConsumer_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::FlowConsumer_ptr
AVStreams::FlowConsumer::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FlowConsumer>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/FlowConsumer:1.0",
        AVStreams__TAO_FlowConsumer_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::FlowConsumer_ptr
AVStreams::FlowConsumer::_nil (void)
{
  return 0;
}

AVStreams::FlowConsumer_ptr
AVStreams::FlowConsumer::_duplicate (FlowConsumer_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::FlowConsumer::_tao_release (FlowConsumer_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::FlowConsumer::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/FlowEndPoint:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/FlowConsumer:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::FlowConsumer::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/FlowConsumer:1.0";
}

::CORBA::Boolean
AVStreams::FlowConsumer::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_FlowConsumer (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/FlowConsumer:1.0",
    "FlowConsumer");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_FlowConsumer =
    &_tao_tc_AVStreams_FlowConsumer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::FDev.

AVStreams::FDev_ptr
TAO::Objref_Traits<AVStreams::FDev>::duplicate (
    AVStreams::FDev_ptr p)
{
  return AVStreams::FDev::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::FDev>::release (
    AVStreams::FDev_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::FDev_ptr
TAO::Objref_Traits<AVStreams::FDev>::nil (void)
{
  return AVStreams::FDev::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::FDev>::marshal (
    const AVStreams::FDev_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_FDev_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::AVStreams::FlowProducer_ptr
AVStreams::FDev::create_producer (
  ::AVStreams::FlowConnection_ptr the_requester,
  ::AVStreams::QoS & the_qos,
  ::CORBA::Boolean_out met_qos,
  char *& named_fdev)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FDev_Proxy_Broker_ == 0)
    {
      AVStreams_FDev_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::AVStreams::FlowProducer>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::FlowConnection>::in_arg_val _tao_the_requester (the_requester);
  TAO::Arg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_met_qos (met_qos);
  TAO::Arg_Traits< char *>::inout_arg_val _tao_named_fdev (named_fdev);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_requester,
      &_tao_the_qos,
      &_tao_met_qos,
      &_tao_named_fdev
    };

  static TAO::Exception_Data
  _tao_AVStreams_FDev_create_producer_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpDenied:1.0",
        AVStreams::streamOpDenied::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpDenied
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "create_producer",
      15,
      this->the_TAO_FDev_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FDev_create_producer_exceptiondata,
      4
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::AVStreams::FlowConsumer_ptr
AVStreams::FDev::create_consumer (
  ::AVStreams::FlowConnection_ptr the_requester,
  ::AVStreams::QoS & the_qos,
  ::CORBA::Boolean_out met_qos,
  char *& named_fdev)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FDev_Proxy_Broker_ == 0)
    {
      AVStreams_FDev_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::AVStreams::FlowConsumer>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::FlowConnection>::in_arg_val _tao_the_requester (the_requester);
  TAO::Arg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_met_qos (met_qos);
  TAO::Arg_Traits< char *>::inout_arg_val _tao_named_fdev (named_fdev);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_requester,
      &_tao_the_qos,
      &_tao_met_qos,
      &_tao_named_fdev
    };

  static TAO::Exception_Data
  _tao_AVStreams_FDev_create_consumer_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/streamOpDenied:1.0",
        AVStreams::streamOpDenied::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpDenied
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "create_consumer",
      15,
      this->the_TAO_FDev_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FDev_create_consumer_exceptiondata,
      4
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::AVStreams::FlowConnection_ptr
AVStreams::FDev::bind (
  ::AVStreams::FDev_ptr peer_device,
  ::AVStreams::QoS & the_qos,
  ::CORBA::Boolean_out is_met)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FDev_Proxy_Broker_ == 0)
    {
      AVStreams_FDev_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::AVStreams::FlowConnection>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::FDev>::in_arg_val _tao_peer_device (peer_device);
  TAO::Arg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_is_met (is_met);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_peer_device,
      &_tao_the_qos,
      &_tao_is_met
    };

  static TAO::Exception_Data
  _tao_AVStreams_FDev_bind_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "bind",
      4,
      this->the_TAO_FDev_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FDev_bind_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::AVStreams::FlowConnection_ptr
AVStreams::FDev::bind_mcast (
  ::AVStreams::FDev_ptr first_peer,
  ::AVStreams::QoS & the_qos,
  ::CORBA::Boolean_out is_met)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FDev_Proxy_Broker_ == 0)
    {
      AVStreams_FDev_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::AVStreams::FlowConnection>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::FDev>::in_arg_val _tao_first_peer (first_peer);
  TAO::Arg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos (the_qos);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_is_met (is_met);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_first_peer,
      &_tao_the_qos,
      &_tao_is_met
    };

  static TAO::Exception_Data
  _tao_AVStreams_FDev_bind_mcast_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/streamOpFailed:1.0",
        AVStreams::streamOpFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_streamOpFailed
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/QoSRequestFailed:1.0",
        AVStreams::QoSRequestFailed::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_QoSRequestFailed
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "bind_mcast",
      10,
      this->the_TAO_FDev_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FDev_bind_mcast_exceptiondata,
      2
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::FDev::destroy (
  ::AVStreams::FlowEndPoint_ptr the_ep,
  const char * fdev_name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_FDev_Proxy_Broker_ == 0)
    {
      AVStreams_FDev_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::FlowEndPoint>::in_arg_val _tao_the_ep (the_ep);
  TAO::Arg_Traits< char *>::in_arg_val _tao_fdev_name (fdev_name);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_ep,
      &_tao_fdev_name
    };

  static TAO::Exception_Data
  _tao_AVStreams_FDev_destroy_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/notSupported:1.0",
        AVStreams::notSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_notSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "destroy",
      7,
      this->the_TAO_FDev_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_FDev_destroy_exceptiondata,
      1
    );
}

AVStreams::FDev::FDev (void)
 : the_TAO_FDev_Proxy_Broker_ (0)
{
  this->AVStreams_FDev_setup_collocation ();
}

void
AVStreams::FDev::AVStreams_FDev_setup_collocation ()
{
  if (::AVStreams__TAO_FDev_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_FDev_Proxy_Broker_ =
        ::AVStreams__TAO_FDev_Proxy_Broker_Factory_function_pointer (this);
    }
  
  this->CosPropertyService_PropertySet_setup_collocation ();
}

AVStreams::FDev::~FDev (void)
{}

void 
AVStreams::FDev::_tao_any_destructor (void *_tao_void_pointer)
{
  FDev *_tao_tmp_pointer =
    static_cast<FDev *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::FDev_ptr
AVStreams::FDev::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FDev>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/FDev:1.0",
        AVStreams__TAO_FDev_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::FDev_ptr
AVStreams::FDev::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<FDev>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/FDev:1.0",
        AVStreams__TAO_FDev_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::FDev_ptr
AVStreams::FDev::_nil (void)
{
  return 0;
}

AVStreams::FDev_ptr
AVStreams::FDev::_duplicate (FDev_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::FDev::_tao_release (FDev_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::FDev::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/FDev:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::FDev::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/FDev:1.0";
}

::CORBA::Boolean
AVStreams::FDev::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_FDev (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/FDev:1.0",
    "FDev");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_FDev =
    &_tao_tc_AVStreams_FDev;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_AVStreams_PositionOrigin[] =
  {
    "AbsolutePosition",
    "RelativePosition",
    "ModuloPosition"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_PositionOrigin (
    "IDL:omg.org/AVStreams/PositionOrigin:1.0",
    "PositionOrigin",
    _tao_enumerators_AVStreams_PositionOrigin,
    3);
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_PositionOrigin =
    &_tao_tc_AVStreams_PositionOrigin;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_AVStreams_PositionKey[] =
  {
    "ByteCount",
    "SampleCount",
    "MediaTime"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_PositionKey (
    "IDL:omg.org/AVStreams/PositionKey:1.0",
    "PositionKey",
    _tao_enumerators_AVStreams_PositionKey,
    3);
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_PositionKey =
    &_tao_tc_AVStreams_PositionKey;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_AVStreams_Position[] =
      {
        { "origin", &AVStreams::_tc_PositionOrigin },
        { "key", &AVStreams::_tc_PositionKey },
        { "value", &CORBA::_tc_long }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_Position (
  ::CORBA::tk_struct,
  "IDL:omg.org/AVStreams/Position:1.0",
  "Position",
  _tao_fields_AVStreams_Position,
  3);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_Position =
    &_tao_tc_AVStreams_Position;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
AVStreams::Position::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Position *_tao_tmp_pointer =
    static_cast<Position *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

AVStreams::PostionKeyNotSupported::PostionKeyNotSupported (
    AVStreams::PositionKey _tao_key)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/PostionKeyNotSupported:1.0",
        "PostionKeyNotSupported"
      )
{
  this->key = _tao_key;
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::PostionKeyNotSupported::PostionKeyNotSupported (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/PostionKeyNotSupported:1.0",
        "PostionKeyNotSupported"
      )
{
}

AVStreams::PostionKeyNotSupported::~PostionKeyNotSupported (void)
{
}

AVStreams::PostionKeyNotSupported::PostionKeyNotSupported (const ::AVStreams::PostionKeyNotSupported &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->key = _tao_excp.key;
}

AVStreams::PostionKeyNotSupported&
AVStreams::PostionKeyNotSupported::operator= (const ::AVStreams::PostionKeyNotSupported &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->key = _tao_excp.key;
  return *this;
}

void AVStreams::PostionKeyNotSupported::_tao_any_destructor (void *_tao_void_pointer)
{
  PostionKeyNotSupported *_tao_tmp_pointer =
    static_cast<PostionKeyNotSupported *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::PostionKeyNotSupported *
AVStreams::PostionKeyNotSupported::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<PostionKeyNotSupported *> (_tao_excp);
}

const AVStreams::PostionKeyNotSupported *
AVStreams::PostionKeyNotSupported::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const PostionKeyNotSupported *> (_tao_excp);
}

::CORBA::Exception *AVStreams::PostionKeyNotSupported::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::PostionKeyNotSupported, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::PostionKeyNotSupported::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::PostionKeyNotSupported (*this),
      0
    );
  return result;
}

void AVStreams::PostionKeyNotSupported::_raise (void) const
{
  throw *this;
}

void AVStreams::PostionKeyNotSupported::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::PostionKeyNotSupported::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::PostionKeyNotSupported::_tao_type (void) const
{
  return ::AVStreams::_tc_PostionKeyNotSupported;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_AVStreams_PostionKeyNotSupported[] =
      {
        { "key", &AVStreams::_tc_PositionKey }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_PostionKeyNotSupported (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/PostionKeyNotSupported:1.0",
  "PostionKeyNotSupported",
  _tao_fields_AVStreams_PostionKeyNotSupported,
  1);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_PostionKeyNotSupported =
    &_tao_tc_AVStreams_PostionKeyNotSupported;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

AVStreams::InvalidPosition::InvalidPosition (
    AVStreams::PositionKey _tao_key)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/InvalidPosition:1.0",
        "InvalidPosition"
      )
{
  this->key = _tao_key;
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::InvalidPosition::InvalidPosition (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/InvalidPosition:1.0",
        "InvalidPosition"
      )
{
}

AVStreams::InvalidPosition::~InvalidPosition (void)
{
}

AVStreams::InvalidPosition::InvalidPosition (const ::AVStreams::InvalidPosition &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->key = _tao_excp.key;
}

AVStreams::InvalidPosition&
AVStreams::InvalidPosition::operator= (const ::AVStreams::InvalidPosition &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->key = _tao_excp.key;
  return *this;
}

void AVStreams::InvalidPosition::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidPosition *_tao_tmp_pointer =
    static_cast<InvalidPosition *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::InvalidPosition *
AVStreams::InvalidPosition::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidPosition *> (_tao_excp);
}

const AVStreams::InvalidPosition *
AVStreams::InvalidPosition::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidPosition *> (_tao_excp);
}

::CORBA::Exception *AVStreams::InvalidPosition::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::InvalidPosition, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::InvalidPosition::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::InvalidPosition (*this),
      0
    );
  return result;
}

void AVStreams::InvalidPosition::_raise (void) const
{
  throw *this;
}

void AVStreams::InvalidPosition::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::InvalidPosition::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::InvalidPosition::_tao_type (void) const
{
  return ::AVStreams::_tc_InvalidPosition;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_AVStreams_InvalidPosition[] =
      {
        { "key", &AVStreams::_tc_PositionKey }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_InvalidPosition (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/InvalidPosition:1.0",
  "InvalidPosition",
  _tao_fields_AVStreams_InvalidPosition,
  1);


namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_InvalidPosition =
    &_tao_tc_AVStreams_InvalidPosition;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for AVStreams::MediaControl.

AVStreams::MediaControl_ptr
TAO::Objref_Traits<AVStreams::MediaControl>::duplicate (
    AVStreams::MediaControl_ptr p)
{
  return AVStreams::MediaControl::_duplicate (p);
}

void
TAO::Objref_Traits<AVStreams::MediaControl>::release (
    AVStreams::MediaControl_ptr p)
{
  ::CORBA::release (p);
}

AVStreams::MediaControl_ptr
TAO::Objref_Traits<AVStreams::MediaControl>::nil (void)
{
  return AVStreams::MediaControl::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AVStreams::MediaControl>::marshal (
    const AVStreams::MediaControl_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*AVStreams__TAO_MediaControl_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:56

AVStreams::MediaControl::PostionKeyNotSupported::PostionKeyNotSupported (
    AVStreams::PositionKey _tao_key)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/MediaControl/PostionKeyNotSupported:1.0",
        "PostionKeyNotSupported"
      )
{
  this->key = _tao_key;
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

AVStreams::MediaControl::PostionKeyNotSupported::PostionKeyNotSupported (void)
  : ::CORBA::UserException (
        "IDL:omg.org/AVStreams/MediaControl/PostionKeyNotSupported:1.0",
        "PostionKeyNotSupported"
      )
{
}

AVStreams::MediaControl::PostionKeyNotSupported::~PostionKeyNotSupported (void)
{
}

AVStreams::MediaControl::PostionKeyNotSupported::PostionKeyNotSupported (const ::AVStreams::MediaControl::PostionKeyNotSupported &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->key = _tao_excp.key;
}

AVStreams::MediaControl::PostionKeyNotSupported&
AVStreams::MediaControl::PostionKeyNotSupported::operator= (const ::AVStreams::MediaControl::PostionKeyNotSupported &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->key = _tao_excp.key;
  return *this;
}

void AVStreams::MediaControl::PostionKeyNotSupported::_tao_any_destructor (void *_tao_void_pointer)
{
  PostionKeyNotSupported *_tao_tmp_pointer =
    static_cast<PostionKeyNotSupported *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

AVStreams::MediaControl::PostionKeyNotSupported *
AVStreams::MediaControl::PostionKeyNotSupported::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<PostionKeyNotSupported *> (_tao_excp);
}

const AVStreams::MediaControl::PostionKeyNotSupported *
AVStreams::MediaControl::PostionKeyNotSupported::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const PostionKeyNotSupported *> (_tao_excp);
}

::CORBA::Exception *AVStreams::MediaControl::PostionKeyNotSupported::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::AVStreams::MediaControl::PostionKeyNotSupported, 0);
  return retval;
}

::CORBA::Exception *
AVStreams::MediaControl::PostionKeyNotSupported::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::AVStreams::MediaControl::PostionKeyNotSupported (*this),
      0
    );
  return result;
}

void AVStreams::MediaControl::PostionKeyNotSupported::_raise (void) const
{
  throw *this;
}

void AVStreams::MediaControl::PostionKeyNotSupported::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void AVStreams::MediaControl::PostionKeyNotSupported::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AVStreams::MediaControl::PostionKeyNotSupported::_tao_type (void) const
{
  return ::AVStreams::MediaControl::_tc_PostionKeyNotSupported;
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_AVStreams_MediaControl_PostionKeyNotSupported[] =
      {
        { "key", &AVStreams::_tc_PositionKey }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_AVStreams_MediaControl_PostionKeyNotSupported (
  ::CORBA::tk_except,
  "IDL:omg.org/AVStreams/MediaControl/PostionKeyNotSupported:1.0",
  "PostionKeyNotSupported",
  _tao_fields_AVStreams_MediaControl_PostionKeyNotSupported,
  1);

::CORBA::TypeCode_ptr const AVStreams::MediaControl::_tc_PostionKeyNotSupported =
  &_tao_tc_AVStreams_MediaControl_PostionKeyNotSupported;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::AVStreams::Position
AVStreams::MediaControl::get_media_position (
  ::AVStreams::PositionOrigin an_origin,
  ::AVStreams::PositionKey a_key)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MediaControl_Proxy_Broker_ == 0)
    {
      AVStreams_MediaControl_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::AVStreams::Position>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::PositionOrigin>::in_arg_val _tao_an_origin (an_origin);
  TAO::Arg_Traits< ::AVStreams::PositionKey>::in_arg_val _tao_a_key (a_key);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_an_origin,
      &_tao_a_key
    };

  static TAO::Exception_Data
  _tao_AVStreams_MediaControl_get_media_position_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/MediaControl/PostionKeyNotSupported:1.0",
        AVStreams::MediaControl::PostionKeyNotSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::MediaControl::_tc_PostionKeyNotSupported
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "get_media_position",
      18,
      this->the_TAO_MediaControl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MediaControl_get_media_position_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::MediaControl::set_media_position (
  const ::AVStreams::Position & a_position)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MediaControl_Proxy_Broker_ == 0)
    {
      AVStreams_MediaControl_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::Position>::in_arg_val _tao_a_position (a_position);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_a_position
    };

  static TAO::Exception_Data
  _tao_AVStreams_MediaControl_set_media_position_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/MediaControl/PostionKeyNotSupported:1.0",
        AVStreams::MediaControl::PostionKeyNotSupported::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::MediaControl::_tc_PostionKeyNotSupported
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:omg.org/AVStreams/InvalidPosition:1.0",
        AVStreams::InvalidPosition::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_InvalidPosition
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_media_position",
      18,
      this->the_TAO_MediaControl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MediaControl_set_media_position_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::MediaControl::start (
  const ::AVStreams::Position & a_position)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MediaControl_Proxy_Broker_ == 0)
    {
      AVStreams_MediaControl_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::Position>::in_arg_val _tao_a_position (a_position);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_a_position
    };

  static TAO::Exception_Data
  _tao_AVStreams_MediaControl_start_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/InvalidPosition:1.0",
        AVStreams::InvalidPosition::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_InvalidPosition
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "start",
      5,
      this->the_TAO_MediaControl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MediaControl_start_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::MediaControl::pause (
  const ::AVStreams::Position & a_position)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MediaControl_Proxy_Broker_ == 0)
    {
      AVStreams_MediaControl_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::Position>::in_arg_val _tao_a_position (a_position);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_a_position
    };

  static TAO::Exception_Data
  _tao_AVStreams_MediaControl_pause_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/InvalidPosition:1.0",
        AVStreams::InvalidPosition::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_InvalidPosition
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "pause",
      5,
      this->the_TAO_MediaControl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MediaControl_pause_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::MediaControl::resume (
  const ::AVStreams::Position & a_position)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MediaControl_Proxy_Broker_ == 0)
    {
      AVStreams_MediaControl_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::Position>::in_arg_val _tao_a_position (a_position);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_a_position
    };

  static TAO::Exception_Data
  _tao_AVStreams_MediaControl_resume_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/InvalidPosition:1.0",
        AVStreams::InvalidPosition::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_InvalidPosition
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "resume",
      6,
      this->the_TAO_MediaControl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MediaControl_resume_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

void
AVStreams::MediaControl::stop (
  const ::AVStreams::Position & a_position)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_MediaControl_Proxy_Broker_ == 0)
    {
      AVStreams_MediaControl_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AVStreams::Position>::in_arg_val _tao_a_position (a_position);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_a_position
    };

  static TAO::Exception_Data
  _tao_AVStreams_MediaControl_stop_exceptiondata [] = 
    {
      {
        "IDL:omg.org/AVStreams/InvalidPosition:1.0",
        AVStreams::InvalidPosition::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , AVStreams::_tc_InvalidPosition
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "stop",
      4,
      this->the_TAO_MediaControl_Proxy_Broker_
    );

  _tao_call.invoke (
      _tao_AVStreams_MediaControl_stop_exceptiondata,
      1
    );
}

AVStreams::MediaControl::MediaControl (void)
 : the_TAO_MediaControl_Proxy_Broker_ (0)
{
  this->AVStreams_MediaControl_setup_collocation ();
}

void
AVStreams::MediaControl::AVStreams_MediaControl_setup_collocation ()
{
  if (::AVStreams__TAO_MediaControl_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_MediaControl_Proxy_Broker_ =
        ::AVStreams__TAO_MediaControl_Proxy_Broker_Factory_function_pointer (this);
    }
}

AVStreams::MediaControl::~MediaControl (void)
{}

void 
AVStreams::MediaControl::_tao_any_destructor (void *_tao_void_pointer)
{
  MediaControl *_tao_tmp_pointer =
    static_cast<MediaControl *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AVStreams::MediaControl_ptr
AVStreams::MediaControl::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<MediaControl>::narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/MediaControl:1.0",
        AVStreams__TAO_MediaControl_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::MediaControl_ptr
AVStreams::MediaControl::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<MediaControl>::unchecked_narrow (
        _tao_objref,
        "IDL:omg.org/AVStreams/MediaControl:1.0",
        AVStreams__TAO_MediaControl_Proxy_Broker_Factory_function_pointer
      );
}

AVStreams::MediaControl_ptr
AVStreams::MediaControl::_nil (void)
{
  return 0;
}

AVStreams::MediaControl_ptr
AVStreams::MediaControl::_duplicate (MediaControl_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
AVStreams::MediaControl::_tao_release (MediaControl_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AVStreams::MediaControl::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/MediaControl:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AVStreams::MediaControl::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/MediaControl:1.0";
}

::CORBA::Boolean
AVStreams::MediaControl::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_MediaControl (
    ::CORBA::tk_objref,
    "IDL:omg.org/AVStreams/MediaControl:1.0",
    "MediaControl");
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_MediaControl =
    &_tao_tc_AVStreams_MediaControl;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_AVSTREAMS_FLOWCONNECTION_SEQ_CS_)
#define _AVSTREAMS_FLOWCONNECTION_SEQ_CS_

AVStreams::FlowConnection_seq::FlowConnection_seq (void)
{}

AVStreams::FlowConnection_seq::FlowConnection_seq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        FlowConnection,
        FlowConnection_var
      > (max)
{}

AVStreams::FlowConnection_seq::FlowConnection_seq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    AVStreams::FlowConnection_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        FlowConnection,
        FlowConnection_var
      >
    (max, length, buffer, release)
{}

AVStreams::FlowConnection_seq::FlowConnection_seq (
    const FlowConnection_seq &seq)
  : ::TAO::unbounded_object_reference_sequence<
        FlowConnection,
        FlowConnection_var
      > (seq)
{}

AVStreams::FlowConnection_seq::~FlowConnection_seq (void)
{}

void AVStreams::FlowConnection_seq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  FlowConnection_seq * _tao_tmp_pointer =
    static_cast<FlowConnection_seq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_AVStreams_FlowConnection_seq_GUARD
#define _TAO_TYPECODE_AVStreams_FlowConnection_seq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        AVStreams_FlowConnection_seq_0 (
          ::CORBA::tk_sequence,
          &AVStreams::_tc_FlowConnection,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_AVStreams_FlowConnection_seq_0 =
        &AVStreams_FlowConnection_seq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_AVStreams_FlowConnection_seq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_FlowConnection_seq (
    ::CORBA::tk_alias,
    "IDL:omg.org/AVStreams/FlowConnection_seq:1.0",
    "FlowConnection_seq",
    &TAO::TypeCode::tc_AVStreams_FlowConnection_seq_0);
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_FlowConnection_seq =
    &_tao_tc_AVStreams_FlowConnection_seq;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_AVSTREAMS_STREAMENDPOINT_A_SEQ_CS_)
#define _AVSTREAMS_STREAMENDPOINT_A_SEQ_CS_

AVStreams::StreamEndPoint_A_seq::StreamEndPoint_A_seq (void)
{}

AVStreams::StreamEndPoint_A_seq::StreamEndPoint_A_seq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        StreamEndPoint_A,
        StreamEndPoint_A_var
      > (max)
{}

AVStreams::StreamEndPoint_A_seq::StreamEndPoint_A_seq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    AVStreams::StreamEndPoint_A_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        StreamEndPoint_A,
        StreamEndPoint_A_var
      >
    (max, length, buffer, release)
{}

AVStreams::StreamEndPoint_A_seq::StreamEndPoint_A_seq (
    const StreamEndPoint_A_seq &seq)
  : ::TAO::unbounded_object_reference_sequence<
        StreamEndPoint_A,
        StreamEndPoint_A_var
      > (seq)
{}

AVStreams::StreamEndPoint_A_seq::~StreamEndPoint_A_seq (void)
{}

void AVStreams::StreamEndPoint_A_seq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  StreamEndPoint_A_seq * _tao_tmp_pointer =
    static_cast<StreamEndPoint_A_seq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_AVStreams_StreamEndPoint_A_seq_GUARD
#define _TAO_TYPECODE_AVStreams_StreamEndPoint_A_seq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        AVStreams_StreamEndPoint_A_seq_0 (
          ::CORBA::tk_sequence,
          &AVStreams::_tc_StreamEndPoint_A,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_AVStreams_StreamEndPoint_A_seq_0 =
        &AVStreams_StreamEndPoint_A_seq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_AVStreams_StreamEndPoint_A_seq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_StreamEndPoint_A_seq (
    ::CORBA::tk_alias,
    "IDL:omg.org/AVStreams/StreamEndPoint_A_seq:1.0",
    "StreamEndPoint_A_seq",
    &TAO::TypeCode::tc_AVStreams_StreamEndPoint_A_seq_0);
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_StreamEndPoint_A_seq =
    &_tao_tc_AVStreams_StreamEndPoint_A_seq;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_AVSTREAMS_STREAMENDPOINT_B_SEQ_CS_)
#define _AVSTREAMS_STREAMENDPOINT_B_SEQ_CS_

AVStreams::StreamEndPoint_B_seq::StreamEndPoint_B_seq (void)
{}

AVStreams::StreamEndPoint_B_seq::StreamEndPoint_B_seq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        StreamEndPoint_B,
        StreamEndPoint_B_var
      > (max)
{}

AVStreams::StreamEndPoint_B_seq::StreamEndPoint_B_seq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    AVStreams::StreamEndPoint_B_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        StreamEndPoint_B,
        StreamEndPoint_B_var
      >
    (max, length, buffer, release)
{}

AVStreams::StreamEndPoint_B_seq::StreamEndPoint_B_seq (
    const StreamEndPoint_B_seq &seq)
  : ::TAO::unbounded_object_reference_sequence<
        StreamEndPoint_B,
        StreamEndPoint_B_var
      > (seq)
{}

AVStreams::StreamEndPoint_B_seq::~StreamEndPoint_B_seq (void)
{}

void AVStreams::StreamEndPoint_B_seq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  StreamEndPoint_B_seq * _tao_tmp_pointer =
    static_cast<StreamEndPoint_B_seq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_AVStreams_StreamEndPoint_B_seq_GUARD
#define _TAO_TYPECODE_AVStreams_StreamEndPoint_B_seq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        AVStreams_StreamEndPoint_B_seq_0 (
          ::CORBA::tk_sequence,
          &AVStreams::_tc_StreamEndPoint_B,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_AVStreams_StreamEndPoint_B_seq_0 =
        &AVStreams_StreamEndPoint_B_seq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_AVStreams_StreamEndPoint_B_seq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_StreamEndPoint_B_seq (
    ::CORBA::tk_alias,
    "IDL:omg.org/AVStreams/StreamEndPoint_B_seq:1.0",
    "StreamEndPoint_B_seq",
    &TAO::TypeCode::tc_AVStreams_StreamEndPoint_B_seq_0);
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_StreamEndPoint_B_seq =
    &_tao_tc_AVStreams_StreamEndPoint_B_seq;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_AVSTREAMS_FLOWENDPOINT_SEQ_CS_)
#define _AVSTREAMS_FLOWENDPOINT_SEQ_CS_

AVStreams::FlowEndPoint_seq::FlowEndPoint_seq (void)
{}

AVStreams::FlowEndPoint_seq::FlowEndPoint_seq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        FlowEndPoint,
        FlowEndPoint_var
      > (max)
{}

AVStreams::FlowEndPoint_seq::FlowEndPoint_seq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    AVStreams::FlowEndPoint_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        FlowEndPoint,
        FlowEndPoint_var
      >
    (max, length, buffer, release)
{}

AVStreams::FlowEndPoint_seq::FlowEndPoint_seq (
    const FlowEndPoint_seq &seq)
  : ::TAO::unbounded_object_reference_sequence<
        FlowEndPoint,
        FlowEndPoint_var
      > (seq)
{}

AVStreams::FlowEndPoint_seq::~FlowEndPoint_seq (void)
{}

void AVStreams::FlowEndPoint_seq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  FlowEndPoint_seq * _tao_tmp_pointer =
    static_cast<FlowEndPoint_seq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_AVStreams_FlowEndPoint_seq_GUARD
#define _TAO_TYPECODE_AVStreams_FlowEndPoint_seq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        AVStreams_FlowEndPoint_seq_0 (
          ::CORBA::tk_sequence,
          &AVStreams::_tc_FlowEndPoint,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_AVStreams_FlowEndPoint_seq_0 =
        &AVStreams_FlowEndPoint_seq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_AVStreams_FlowEndPoint_seq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_FlowEndPoint_seq (
    ::CORBA::tk_alias,
    "IDL:omg.org/AVStreams/FlowEndPoint_seq:1.0",
    "FlowEndPoint_seq",
    &TAO::TypeCode::tc_AVStreams_FlowEndPoint_seq_0);
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_FlowEndPoint_seq =
    &_tao_tc_AVStreams_FlowEndPoint_seq;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_AVSTREAMS_OBJECT_SEQ_CS_)
#define _AVSTREAMS_OBJECT_SEQ_CS_

AVStreams::Object_seq::Object_seq (void)
{}

AVStreams::Object_seq::Object_seq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        ::CORBA::Object,
        ::CORBA::Object_var
      > (max)
{}

AVStreams::Object_seq::Object_seq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Object_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        ::CORBA::Object,
        ::CORBA::Object_var
      >
    (max, length, buffer, release)
{}

AVStreams::Object_seq::Object_seq (
    const Object_seq &seq)
  : ::TAO::unbounded_object_reference_sequence<
        ::CORBA::Object,
        ::CORBA::Object_var
      > (seq)
{}

AVStreams::Object_seq::~Object_seq (void)
{}

void AVStreams::Object_seq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  Object_seq * _tao_tmp_pointer =
    static_cast<Object_seq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_AVStreams_Object_seq_GUARD
#define _TAO_TYPECODE_AVStreams_Object_seq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        AVStreams_Object_seq_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_Object,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_AVStreams_Object_seq_0 =
        &AVStreams_Object_seq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_AVStreams_Object_seq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_AVStreams_Object_seq (
    ::CORBA::tk_alias,
    "IDL:omg.org/AVStreams/Object_seq:1.0",
    "Object_seq",
    &TAO::TypeCode::tc_AVStreams_Object_seq_0);
  

namespace AVStreams
{
  ::CORBA::TypeCode_ptr const _tc_Object_seq =
    &_tao_tc_AVStreams_Object_seq;
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::QoS &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::AVStreams::QoS *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::AVStreams::QoS>::insert_copy (
          _tao_any,
          ::AVStreams::QoS::_tao_any_destructor,
          ::AVStreams::_tc_QoS,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      AVStreams::QoS *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::QoS>::insert (
        _tao_any,
        ::AVStreams::QoS::_tao_any_destructor,
        ::AVStreams::_tc_QoS,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::QoS *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::QoS *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::QoS *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::QoS>::extract (
          _tao_any,
          ::AVStreams::QoS::_tao_any_destructor,
          ::AVStreams::_tc_QoS,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::QoS &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<AVStreams::QoS *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<AVStreams::QoS>::insert_copy (
        _tao_any,
        AVStreams::QoS::_tao_any_destructor,
        AVStreams::_tc_QoS,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::QoS *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::QoS>::insert (
      _tao_any,
      AVStreams::QoS::_tao_any_destructor,
      AVStreams::_tc_QoS,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::QoS *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::QoS *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::QoS *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::QoS>::extract (
        _tao_any,
        AVStreams::QoS::_tao_any_destructor,
        AVStreams::_tc_QoS,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::streamQoS &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::AVStreams::streamQoS *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::AVStreams::streamQoS>::insert_copy (
          _tao_any,
          ::AVStreams::streamQoS::_tao_any_destructor,
          ::AVStreams::_tc_streamQoS,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::streamQoS *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::streamQoS>::insert (
        _tao_any,
        ::AVStreams::streamQoS::_tao_any_destructor,
        ::AVStreams::_tc_streamQoS,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::streamQoS *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::streamQoS *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::streamQoS *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::streamQoS>::extract (
          _tao_any,
          ::AVStreams::streamQoS::_tao_any_destructor,
          ::AVStreams::_tc_streamQoS,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::streamQoS &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<AVStreams::streamQoS *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<AVStreams::streamQoS>::insert_copy (
        _tao_any,
        AVStreams::streamQoS::_tao_any_destructor,
        AVStreams::_tc_streamQoS,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::streamQoS *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::streamQoS>::insert (
      _tao_any,
      AVStreams::streamQoS::_tao_any_destructor,
      AVStreams::_tc_streamQoS,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::streamQoS *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::streamQoS *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::streamQoS *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::streamQoS>::extract (
        _tao_any,
        AVStreams::streamQoS::_tao_any_destructor,
        AVStreams::_tc_streamQoS,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::flowSpec &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::AVStreams::flowSpec *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::AVStreams::flowSpec>::insert_copy (
          _tao_any,
          ::AVStreams::flowSpec::_tao_any_destructor,
          ::AVStreams::_tc_flowSpec,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::flowSpec *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::flowSpec>::insert (
        _tao_any,
        ::AVStreams::flowSpec::_tao_any_destructor,
        ::AVStreams::_tc_flowSpec,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::flowSpec *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::flowSpec *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::flowSpec *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::flowSpec>::extract (
          _tao_any,
          ::AVStreams::flowSpec::_tao_any_destructor,
          ::AVStreams::_tc_flowSpec,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::flowSpec &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<AVStreams::flowSpec *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<AVStreams::flowSpec>::insert_copy (
        _tao_any,
        AVStreams::flowSpec::_tao_any_destructor,
        AVStreams::_tc_flowSpec,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::flowSpec *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::flowSpec>::insert (
      _tao_any,
      AVStreams::flowSpec::_tao_any_destructor,
      AVStreams::_tc_flowSpec,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::flowSpec *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::flowSpec *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::flowSpec *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::flowSpec>::extract (
        _tao_any,
        AVStreams::flowSpec::_tao_any_destructor,
        AVStreams::_tc_flowSpec,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::protocolSpec &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::AVStreams::protocolSpec *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::AVStreams::protocolSpec>::insert_copy (
          _tao_any,
          ::AVStreams::protocolSpec::_tao_any_destructor,
          ::AVStreams::_tc_protocolSpec,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::protocolSpec *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::protocolSpec>::insert (
        _tao_any,
        ::AVStreams::protocolSpec::_tao_any_destructor,
        ::AVStreams::_tc_protocolSpec,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::protocolSpec *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::protocolSpec *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::protocolSpec *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::protocolSpec>::extract (
          _tao_any,
          ::AVStreams::protocolSpec::_tao_any_destructor,
          ::AVStreams::_tc_protocolSpec,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::protocolSpec &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<AVStreams::protocolSpec *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<AVStreams::protocolSpec>::insert_copy (
        _tao_any,
        AVStreams::protocolSpec::_tao_any_destructor,
        AVStreams::_tc_protocolSpec,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::protocolSpec *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::protocolSpec>::insert (
      _tao_any,
      AVStreams::protocolSpec::_tao_any_destructor,
      AVStreams::_tc_protocolSpec,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::protocolSpec *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::protocolSpec *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::protocolSpec *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::protocolSpec>::extract (
        _tao_any,
        AVStreams::protocolSpec::_tao_any_destructor,
        AVStreams::_tc_protocolSpec,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::key &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::AVStreams::key *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::AVStreams::key>::insert_copy (
          _tao_any,
          ::AVStreams::key::_tao_any_destructor,
          ::AVStreams::_tc_key,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::key *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::key>::insert (
        _tao_any,
        ::AVStreams::key::_tao_any_destructor,
        ::AVStreams::_tc_key,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::key *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::key *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::key *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::key>::extract (
          _tao_any,
          ::AVStreams::key::_tao_any_destructor,
          ::AVStreams::_tc_key,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::key &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<AVStreams::key *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<AVStreams::key>::insert_copy (
        _tao_any,
        AVStreams::key::_tao_any_destructor,
        AVStreams::_tc_key,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::key *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::key>::insert (
      _tao_any,
      AVStreams::key::_tao_any_destructor,
      AVStreams::_tc_key,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::key *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::key *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::key *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::key>::extract (
        _tao_any,
        AVStreams::key::_tao_any_destructor,
        AVStreams::_tc_key,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::SFPStatus &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::AVStreams::SFPStatus *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::AVStreams::SFPStatus>::insert_copy (
          _tao_any,
          ::AVStreams::SFPStatus::_tao_any_destructor,
          ::AVStreams::_tc_SFPStatus,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      AVStreams::SFPStatus *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::SFPStatus>::insert (
        _tao_any,
        ::AVStreams::SFPStatus::_tao_any_destructor,
        ::AVStreams::_tc_SFPStatus,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::SFPStatus *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::SFPStatus *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::SFPStatus *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::SFPStatus>::extract (
          _tao_any,
          ::AVStreams::SFPStatus::_tao_any_destructor,
          ::AVStreams::_tc_SFPStatus,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::SFPStatus &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<AVStreams::SFPStatus *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<AVStreams::SFPStatus>::insert_copy (
        _tao_any,
        AVStreams::SFPStatus::_tao_any_destructor,
        AVStreams::_tc_SFPStatus,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::SFPStatus *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::SFPStatus>::insert (
      _tao_any,
      AVStreams::SFPStatus::_tao_any_destructor,
      AVStreams::_tc_SFPStatus,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::SFPStatus *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::SFPStatus *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::SFPStatus *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::SFPStatus>::extract (
        _tao_any,
        AVStreams::SFPStatus::_tao_any_destructor,
        AVStreams::_tc_SFPStatus,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::flowState _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::AVStreams::flowState>::insert (
        _tao_any,
        ::AVStreams::_tc_flowState,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::flowState &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::AVStreams::flowState>::extract (
          _tao_any,
          ::AVStreams::_tc_flowState,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::flowState _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<AVStreams::flowState>::insert (
      _tao_any,
      AVStreams::_tc_flowState,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::flowState &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<AVStreams::flowState>::extract (
        _tao_any,
        AVStreams::_tc_flowState,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::dirType _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::AVStreams::dirType>::insert (
        _tao_any,
        ::AVStreams::_tc_dirType,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::dirType &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::AVStreams::dirType>::extract (
          _tao_any,
          ::AVStreams::_tc_dirType,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::dirType _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<AVStreams::dirType>::insert (
      _tao_any,
      AVStreams::_tc_dirType,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::dirType &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<AVStreams::dirType>::extract (
        _tao_any,
        AVStreams::_tc_dirType,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::flowStatus &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::AVStreams::flowStatus *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::AVStreams::flowStatus>::insert_copy (
          _tao_any,
          ::AVStreams::flowStatus::_tao_any_destructor,
          ::AVStreams::_tc_flowStatus,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      AVStreams::flowStatus *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::flowStatus>::insert (
        _tao_any,
        ::AVStreams::flowStatus::_tao_any_destructor,
        ::AVStreams::_tc_flowStatus,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::flowStatus *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::flowStatus *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::flowStatus *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::flowStatus>::extract (
          _tao_any,
          ::AVStreams::flowStatus::_tao_any_destructor,
          ::AVStreams::_tc_flowStatus,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::flowStatus &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<AVStreams::flowStatus *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<AVStreams::flowStatus>::insert_copy (
        _tao_any,
        AVStreams::flowStatus::_tao_any_destructor,
        AVStreams::_tc_flowStatus,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::flowStatus *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::flowStatus>::insert (
      _tao_any,
      AVStreams::flowStatus::_tao_any_destructor,
      AVStreams::_tc_flowStatus,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::flowStatus *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::flowStatus *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::flowStatus *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::flowStatus>::extract (
        _tao_any,
        AVStreams::flowStatus::_tao_any_destructor,
        AVStreams::_tc_flowStatus,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::notSupported>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::notSupported &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::notSupported>::insert_copy (
        _tao_any,
        ::AVStreams::notSupported::_tao_any_destructor,
        ::AVStreams::_tc_notSupported,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::notSupported *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::notSupported>::insert (
        _tao_any,
        ::AVStreams::notSupported::_tao_any_destructor,
        ::AVStreams::_tc_notSupported,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::notSupported *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::notSupported *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::notSupported *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::notSupported>::extract (
          _tao_any,
          ::AVStreams::notSupported::_tao_any_destructor,
          ::AVStreams::_tc_notSupported,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::notSupported &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::notSupported>::insert_copy (
      _tao_any,
      AVStreams::notSupported::_tao_any_destructor,
      AVStreams::_tc_notSupported,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::notSupported *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::notSupported>::insert (
      _tao_any,
      AVStreams::notSupported::_tao_any_destructor,
      AVStreams::_tc_notSupported,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::notSupported *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::notSupported *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::notSupported *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::notSupported>::extract (
        _tao_any,
        AVStreams::notSupported::_tao_any_destructor,
        AVStreams::_tc_notSupported,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::PropertyException>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::PropertyException &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::PropertyException>::insert_copy (
        _tao_any,
        ::AVStreams::PropertyException::_tao_any_destructor,
        ::AVStreams::_tc_PropertyException,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::PropertyException *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::PropertyException>::insert (
        _tao_any,
        ::AVStreams::PropertyException::_tao_any_destructor,
        ::AVStreams::_tc_PropertyException,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::PropertyException *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::PropertyException *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::PropertyException *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::PropertyException>::extract (
          _tao_any,
          ::AVStreams::PropertyException::_tao_any_destructor,
          ::AVStreams::_tc_PropertyException,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::PropertyException &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::PropertyException>::insert_copy (
      _tao_any,
      AVStreams::PropertyException::_tao_any_destructor,
      AVStreams::_tc_PropertyException,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::PropertyException *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::PropertyException>::insert (
      _tao_any,
      AVStreams::PropertyException::_tao_any_destructor,
      AVStreams::_tc_PropertyException,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::PropertyException *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::PropertyException *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::PropertyException *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::PropertyException>::extract (
        _tao_any,
        AVStreams::PropertyException::_tao_any_destructor,
        AVStreams::_tc_PropertyException,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::FPError>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::FPError &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::FPError>::insert_copy (
        _tao_any,
        ::AVStreams::FPError::_tao_any_destructor,
        ::AVStreams::_tc_FPError,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::FPError *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::FPError>::insert (
        _tao_any,
        ::AVStreams::FPError::_tao_any_destructor,
        ::AVStreams::_tc_FPError,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::FPError *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::FPError *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::FPError *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::FPError>::extract (
          _tao_any,
          ::AVStreams::FPError::_tao_any_destructor,
          ::AVStreams::_tc_FPError,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::FPError &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::FPError>::insert_copy (
      _tao_any,
      AVStreams::FPError::_tao_any_destructor,
      AVStreams::_tc_FPError,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::FPError *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::FPError>::insert (
      _tao_any,
      AVStreams::FPError::_tao_any_destructor,
      AVStreams::_tc_FPError,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::FPError *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::FPError *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::FPError *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::FPError>::extract (
        _tao_any,
        AVStreams::FPError::_tao_any_destructor,
        AVStreams::_tc_FPError,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::streamOpFailed>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::streamOpFailed &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::streamOpFailed>::insert_copy (
        _tao_any,
        ::AVStreams::streamOpFailed::_tao_any_destructor,
        ::AVStreams::_tc_streamOpFailed,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::streamOpFailed *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::streamOpFailed>::insert (
        _tao_any,
        ::AVStreams::streamOpFailed::_tao_any_destructor,
        ::AVStreams::_tc_streamOpFailed,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::streamOpFailed *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::streamOpFailed *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::streamOpFailed *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::streamOpFailed>::extract (
          _tao_any,
          ::AVStreams::streamOpFailed::_tao_any_destructor,
          ::AVStreams::_tc_streamOpFailed,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::streamOpFailed &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::streamOpFailed>::insert_copy (
      _tao_any,
      AVStreams::streamOpFailed::_tao_any_destructor,
      AVStreams::_tc_streamOpFailed,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::streamOpFailed *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::streamOpFailed>::insert (
      _tao_any,
      AVStreams::streamOpFailed::_tao_any_destructor,
      AVStreams::_tc_streamOpFailed,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::streamOpFailed *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::streamOpFailed *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::streamOpFailed *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::streamOpFailed>::extract (
        _tao_any,
        AVStreams::streamOpFailed::_tao_any_destructor,
        AVStreams::_tc_streamOpFailed,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::streamOpDenied>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::streamOpDenied &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::streamOpDenied>::insert_copy (
        _tao_any,
        ::AVStreams::streamOpDenied::_tao_any_destructor,
        ::AVStreams::_tc_streamOpDenied,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::streamOpDenied *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::streamOpDenied>::insert (
        _tao_any,
        ::AVStreams::streamOpDenied::_tao_any_destructor,
        ::AVStreams::_tc_streamOpDenied,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::streamOpDenied *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::streamOpDenied *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::streamOpDenied *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::streamOpDenied>::extract (
          _tao_any,
          ::AVStreams::streamOpDenied::_tao_any_destructor,
          ::AVStreams::_tc_streamOpDenied,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::streamOpDenied &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::streamOpDenied>::insert_copy (
      _tao_any,
      AVStreams::streamOpDenied::_tao_any_destructor,
      AVStreams::_tc_streamOpDenied,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::streamOpDenied *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::streamOpDenied>::insert (
      _tao_any,
      AVStreams::streamOpDenied::_tao_any_destructor,
      AVStreams::_tc_streamOpDenied,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::streamOpDenied *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::streamOpDenied *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::streamOpDenied *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::streamOpDenied>::extract (
        _tao_any,
        AVStreams::streamOpDenied::_tao_any_destructor,
        AVStreams::_tc_streamOpDenied,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::noSuchFlow>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::noSuchFlow &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::noSuchFlow>::insert_copy (
        _tao_any,
        ::AVStreams::noSuchFlow::_tao_any_destructor,
        ::AVStreams::_tc_noSuchFlow,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::noSuchFlow *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::noSuchFlow>::insert (
        _tao_any,
        ::AVStreams::noSuchFlow::_tao_any_destructor,
        ::AVStreams::_tc_noSuchFlow,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::noSuchFlow *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::noSuchFlow *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::noSuchFlow *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::noSuchFlow>::extract (
          _tao_any,
          ::AVStreams::noSuchFlow::_tao_any_destructor,
          ::AVStreams::_tc_noSuchFlow,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::noSuchFlow &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::noSuchFlow>::insert_copy (
      _tao_any,
      AVStreams::noSuchFlow::_tao_any_destructor,
      AVStreams::_tc_noSuchFlow,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::noSuchFlow *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::noSuchFlow>::insert (
      _tao_any,
      AVStreams::noSuchFlow::_tao_any_destructor,
      AVStreams::_tc_noSuchFlow,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::noSuchFlow *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::noSuchFlow *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::noSuchFlow *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::noSuchFlow>::extract (
        _tao_any,
        AVStreams::noSuchFlow::_tao_any_destructor,
        AVStreams::_tc_noSuchFlow,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::QoSRequestFailed>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::QoSRequestFailed &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::QoSRequestFailed>::insert_copy (
        _tao_any,
        ::AVStreams::QoSRequestFailed::_tao_any_destructor,
        ::AVStreams::_tc_QoSRequestFailed,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::QoSRequestFailed *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::QoSRequestFailed>::insert (
        _tao_any,
        ::AVStreams::QoSRequestFailed::_tao_any_destructor,
        ::AVStreams::_tc_QoSRequestFailed,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::QoSRequestFailed *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::QoSRequestFailed *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::QoSRequestFailed *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::QoSRequestFailed>::extract (
          _tao_any,
          ::AVStreams::QoSRequestFailed::_tao_any_destructor,
          ::AVStreams::_tc_QoSRequestFailed,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::QoSRequestFailed &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::QoSRequestFailed>::insert_copy (
      _tao_any,
      AVStreams::QoSRequestFailed::_tao_any_destructor,
      AVStreams::_tc_QoSRequestFailed,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::QoSRequestFailed *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::QoSRequestFailed>::insert (
      _tao_any,
      AVStreams::QoSRequestFailed::_tao_any_destructor,
      AVStreams::_tc_QoSRequestFailed,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::QoSRequestFailed *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::QoSRequestFailed *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::QoSRequestFailed *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::QoSRequestFailed>::extract (
        _tao_any,
        AVStreams::QoSRequestFailed::_tao_any_destructor,
        AVStreams::_tc_QoSRequestFailed,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::Basic_StreamCtrl>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Basic_StreamCtrl_ptr _tao_elem)
  {
    Basic_StreamCtrl_ptr _tao_objptr =
      Basic_StreamCtrl::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Basic_StreamCtrl_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Basic_StreamCtrl>::insert (
        _tao_any,
        Basic_StreamCtrl::_tao_any_destructor,
        _tc_Basic_StreamCtrl,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Basic_StreamCtrl_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Basic_StreamCtrl>::extract (
          _tao_any,
          Basic_StreamCtrl::_tao_any_destructor,
          _tc_Basic_StreamCtrl,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::Basic_StreamCtrl_ptr _tao_elem)
{
  AVStreams::Basic_StreamCtrl_ptr _tao_objptr =
    AVStreams::Basic_StreamCtrl::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::Basic_StreamCtrl_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::Basic_StreamCtrl>::insert (
      _tao_any,
      AVStreams::Basic_StreamCtrl::_tao_any_destructor,
      AVStreams::_tc_Basic_StreamCtrl,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::Basic_StreamCtrl_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::Basic_StreamCtrl>::extract (
        _tao_any,
        AVStreams::Basic_StreamCtrl::_tao_any_destructor,
        AVStreams::_tc_Basic_StreamCtrl,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::Negotiator>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Negotiator_ptr _tao_elem)
  {
    Negotiator_ptr _tao_objptr =
      Negotiator::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Negotiator_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Negotiator>::insert (
        _tao_any,
        Negotiator::_tao_any_destructor,
        _tc_Negotiator,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Negotiator_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Negotiator>::extract (
          _tao_any,
          Negotiator::_tao_any_destructor,
          _tc_Negotiator,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::Negotiator_ptr _tao_elem)
{
  AVStreams::Negotiator_ptr _tao_objptr =
    AVStreams::Negotiator::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::Negotiator_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::Negotiator>::insert (
      _tao_any,
      AVStreams::Negotiator::_tao_any_destructor,
      AVStreams::_tc_Negotiator,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::Negotiator_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::Negotiator>::extract (
        _tao_any,
        AVStreams::Negotiator::_tao_any_destructor,
        AVStreams::_tc_Negotiator,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::StreamCtrl>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      StreamCtrl_ptr _tao_elem)
  {
    StreamCtrl_ptr _tao_objptr =
      StreamCtrl::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      StreamCtrl_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<StreamCtrl>::insert (
        _tao_any,
        StreamCtrl::_tao_any_destructor,
        _tc_StreamCtrl,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      StreamCtrl_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<StreamCtrl>::extract (
          _tao_any,
          StreamCtrl::_tao_any_destructor,
          _tc_StreamCtrl,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::StreamCtrl_ptr _tao_elem)
{
  AVStreams::StreamCtrl_ptr _tao_objptr =
    AVStreams::StreamCtrl::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::StreamCtrl_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::StreamCtrl>::insert (
      _tao_any,
      AVStreams::StreamCtrl::_tao_any_destructor,
      AVStreams::_tc_StreamCtrl,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::StreamCtrl_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::StreamCtrl>::extract (
        _tao_any,
        AVStreams::StreamCtrl::_tao_any_destructor,
        AVStreams::_tc_StreamCtrl,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::MCastConfigIf>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      MCastConfigIf_ptr _tao_elem)
  {
    MCastConfigIf_ptr _tao_objptr =
      MCastConfigIf::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      MCastConfigIf_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<MCastConfigIf>::insert (
        _tao_any,
        MCastConfigIf::_tao_any_destructor,
        _tc_MCastConfigIf,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      MCastConfigIf_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<MCastConfigIf>::extract (
          _tao_any,
          MCastConfigIf::_tao_any_destructor,
          _tc_MCastConfigIf,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::MCastConfigIf_ptr _tao_elem)
{
  AVStreams::MCastConfigIf_ptr _tao_objptr =
    AVStreams::MCastConfigIf::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::MCastConfigIf_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::MCastConfigIf>::insert (
      _tao_any,
      AVStreams::MCastConfigIf::_tao_any_destructor,
      AVStreams::_tc_MCastConfigIf,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::MCastConfigIf_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::MCastConfigIf>::extract (
        _tao_any,
        AVStreams::MCastConfigIf::_tao_any_destructor,
        AVStreams::_tc_MCastConfigIf,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::StreamEndPoint>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      StreamEndPoint_ptr _tao_elem)
  {
    StreamEndPoint_ptr _tao_objptr =
      StreamEndPoint::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      StreamEndPoint_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<StreamEndPoint>::insert (
        _tao_any,
        StreamEndPoint::_tao_any_destructor,
        _tc_StreamEndPoint,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      StreamEndPoint_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<StreamEndPoint>::extract (
          _tao_any,
          StreamEndPoint::_tao_any_destructor,
          _tc_StreamEndPoint,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::StreamEndPoint_ptr _tao_elem)
{
  AVStreams::StreamEndPoint_ptr _tao_objptr =
    AVStreams::StreamEndPoint::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::StreamEndPoint_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::StreamEndPoint>::insert (
      _tao_any,
      AVStreams::StreamEndPoint::_tao_any_destructor,
      AVStreams::_tc_StreamEndPoint,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::StreamEndPoint_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::StreamEndPoint>::extract (
        _tao_any,
        AVStreams::StreamEndPoint::_tao_any_destructor,
        AVStreams::_tc_StreamEndPoint,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::StreamEndPoint_A>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      StreamEndPoint_A_ptr _tao_elem)
  {
    StreamEndPoint_A_ptr _tao_objptr =
      StreamEndPoint_A::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      StreamEndPoint_A_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<StreamEndPoint_A>::insert (
        _tao_any,
        StreamEndPoint_A::_tao_any_destructor,
        _tc_StreamEndPoint_A,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      StreamEndPoint_A_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<StreamEndPoint_A>::extract (
          _tao_any,
          StreamEndPoint_A::_tao_any_destructor,
          _tc_StreamEndPoint_A,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::StreamEndPoint_A_ptr _tao_elem)
{
  AVStreams::StreamEndPoint_A_ptr _tao_objptr =
    AVStreams::StreamEndPoint_A::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::StreamEndPoint_A_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::StreamEndPoint_A>::insert (
      _tao_any,
      AVStreams::StreamEndPoint_A::_tao_any_destructor,
      AVStreams::_tc_StreamEndPoint_A,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::StreamEndPoint_A_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::StreamEndPoint_A>::extract (
        _tao_any,
        AVStreams::StreamEndPoint_A::_tao_any_destructor,
        AVStreams::_tc_StreamEndPoint_A,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::StreamEndPoint_B>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      StreamEndPoint_B_ptr _tao_elem)
  {
    StreamEndPoint_B_ptr _tao_objptr =
      StreamEndPoint_B::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      StreamEndPoint_B_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<StreamEndPoint_B>::insert (
        _tao_any,
        StreamEndPoint_B::_tao_any_destructor,
        _tc_StreamEndPoint_B,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      StreamEndPoint_B_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<StreamEndPoint_B>::extract (
          _tao_any,
          StreamEndPoint_B::_tao_any_destructor,
          _tc_StreamEndPoint_B,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::StreamEndPoint_B_ptr _tao_elem)
{
  AVStreams::StreamEndPoint_B_ptr _tao_objptr =
    AVStreams::StreamEndPoint_B::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::StreamEndPoint_B_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::StreamEndPoint_B>::insert (
      _tao_any,
      AVStreams::StreamEndPoint_B::_tao_any_destructor,
      AVStreams::_tc_StreamEndPoint_B,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::StreamEndPoint_B_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::StreamEndPoint_B>::extract (
        _tao_any,
        AVStreams::StreamEndPoint_B::_tao_any_destructor,
        AVStreams::_tc_StreamEndPoint_B,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::VDev>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      VDev_ptr _tao_elem)
  {
    VDev_ptr _tao_objptr =
      VDev::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      VDev_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<VDev>::insert (
        _tao_any,
        VDev::_tao_any_destructor,
        _tc_VDev,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      VDev_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<VDev>::extract (
          _tao_any,
          VDev::_tao_any_destructor,
          _tc_VDev,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::VDev_ptr _tao_elem)
{
  AVStreams::VDev_ptr _tao_objptr =
    AVStreams::VDev::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::VDev_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::VDev>::insert (
      _tao_any,
      AVStreams::VDev::_tao_any_destructor,
      AVStreams::_tc_VDev,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::VDev_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::VDev>::extract (
        _tao_any,
        AVStreams::VDev::_tao_any_destructor,
        AVStreams::_tc_VDev,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::MMDevice>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      MMDevice_ptr _tao_elem)
  {
    MMDevice_ptr _tao_objptr =
      MMDevice::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      MMDevice_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<MMDevice>::insert (
        _tao_any,
        MMDevice::_tao_any_destructor,
        _tc_MMDevice,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      MMDevice_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<MMDevice>::extract (
          _tao_any,
          MMDevice::_tao_any_destructor,
          _tc_MMDevice,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::MMDevice_ptr _tao_elem)
{
  AVStreams::MMDevice_ptr _tao_objptr =
    AVStreams::MMDevice::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::MMDevice_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::MMDevice>::insert (
      _tao_any,
      AVStreams::MMDevice::_tao_any_destructor,
      AVStreams::_tc_MMDevice,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::MMDevice_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::MMDevice>::extract (
        _tao_any,
        AVStreams::MMDevice::_tao_any_destructor,
        AVStreams::_tc_MMDevice,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::protocolNotSupported>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::protocolNotSupported &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::protocolNotSupported>::insert_copy (
        _tao_any,
        ::AVStreams::protocolNotSupported::_tao_any_destructor,
        ::AVStreams::_tc_protocolNotSupported,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::protocolNotSupported *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::protocolNotSupported>::insert (
        _tao_any,
        ::AVStreams::protocolNotSupported::_tao_any_destructor,
        ::AVStreams::_tc_protocolNotSupported,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::protocolNotSupported *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::protocolNotSupported *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::protocolNotSupported *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::protocolNotSupported>::extract (
          _tao_any,
          ::AVStreams::protocolNotSupported::_tao_any_destructor,
          ::AVStreams::_tc_protocolNotSupported,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::protocolNotSupported &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::protocolNotSupported>::insert_copy (
      _tao_any,
      AVStreams::protocolNotSupported::_tao_any_destructor,
      AVStreams::_tc_protocolNotSupported,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::protocolNotSupported *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::protocolNotSupported>::insert (
      _tao_any,
      AVStreams::protocolNotSupported::_tao_any_destructor,
      AVStreams::_tc_protocolNotSupported,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::protocolNotSupported *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::protocolNotSupported *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::protocolNotSupported *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::protocolNotSupported>::extract (
        _tao_any,
        AVStreams::protocolNotSupported::_tao_any_destructor,
        AVStreams::_tc_protocolNotSupported,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::formatNotSupported>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::formatNotSupported &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::formatNotSupported>::insert_copy (
        _tao_any,
        ::AVStreams::formatNotSupported::_tao_any_destructor,
        ::AVStreams::_tc_formatNotSupported,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::formatNotSupported *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::formatNotSupported>::insert (
        _tao_any,
        ::AVStreams::formatNotSupported::_tao_any_destructor,
        ::AVStreams::_tc_formatNotSupported,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::formatNotSupported *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::formatNotSupported *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::formatNotSupported *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::formatNotSupported>::extract (
          _tao_any,
          ::AVStreams::formatNotSupported::_tao_any_destructor,
          ::AVStreams::_tc_formatNotSupported,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::formatNotSupported &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::formatNotSupported>::insert_copy (
      _tao_any,
      AVStreams::formatNotSupported::_tao_any_destructor,
      AVStreams::_tc_formatNotSupported,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::formatNotSupported *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::formatNotSupported>::insert (
      _tao_any,
      AVStreams::formatNotSupported::_tao_any_destructor,
      AVStreams::_tc_formatNotSupported,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::formatNotSupported *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::formatNotSupported *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::formatNotSupported *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::formatNotSupported>::extract (
        _tao_any,
        AVStreams::formatNotSupported::_tao_any_destructor,
        AVStreams::_tc_formatNotSupported,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::formatMismatch>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::formatMismatch &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::formatMismatch>::insert_copy (
        _tao_any,
        ::AVStreams::formatMismatch::_tao_any_destructor,
        ::AVStreams::_tc_formatMismatch,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::formatMismatch *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::formatMismatch>::insert (
        _tao_any,
        ::AVStreams::formatMismatch::_tao_any_destructor,
        ::AVStreams::_tc_formatMismatch,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::formatMismatch *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::formatMismatch *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::formatMismatch *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::formatMismatch>::extract (
          _tao_any,
          ::AVStreams::formatMismatch::_tao_any_destructor,
          ::AVStreams::_tc_formatMismatch,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::formatMismatch &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::formatMismatch>::insert_copy (
      _tao_any,
      AVStreams::formatMismatch::_tao_any_destructor,
      AVStreams::_tc_formatMismatch,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::formatMismatch *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::formatMismatch>::insert (
      _tao_any,
      AVStreams::formatMismatch::_tao_any_destructor,
      AVStreams::_tc_formatMismatch,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::formatMismatch *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::formatMismatch *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::formatMismatch *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::formatMismatch>::extract (
        _tao_any,
        AVStreams::formatMismatch::_tao_any_destructor,
        AVStreams::_tc_formatMismatch,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::FEPMismatch>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::FEPMismatch &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::FEPMismatch>::insert_copy (
        _tao_any,
        ::AVStreams::FEPMismatch::_tao_any_destructor,
        ::AVStreams::_tc_FEPMismatch,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::FEPMismatch *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::FEPMismatch>::insert (
        _tao_any,
        ::AVStreams::FEPMismatch::_tao_any_destructor,
        ::AVStreams::_tc_FEPMismatch,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::FEPMismatch *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::FEPMismatch *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::FEPMismatch *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::FEPMismatch>::extract (
          _tao_any,
          ::AVStreams::FEPMismatch::_tao_any_destructor,
          ::AVStreams::_tc_FEPMismatch,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::FEPMismatch &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::FEPMismatch>::insert_copy (
      _tao_any,
      AVStreams::FEPMismatch::_tao_any_destructor,
      AVStreams::_tc_FEPMismatch,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::FEPMismatch *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::FEPMismatch>::insert (
      _tao_any,
      AVStreams::FEPMismatch::_tao_any_destructor,
      AVStreams::_tc_FEPMismatch,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::FEPMismatch *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::FEPMismatch *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::FEPMismatch *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::FEPMismatch>::extract (
        _tao_any,
        AVStreams::FEPMismatch::_tao_any_destructor,
        AVStreams::_tc_FEPMismatch,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::alreadyConnected>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::alreadyConnected &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::alreadyConnected>::insert_copy (
        _tao_any,
        ::AVStreams::alreadyConnected::_tao_any_destructor,
        ::AVStreams::_tc_alreadyConnected,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::alreadyConnected *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::alreadyConnected>::insert (
        _tao_any,
        ::AVStreams::alreadyConnected::_tao_any_destructor,
        ::AVStreams::_tc_alreadyConnected,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::alreadyConnected *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::alreadyConnected *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::alreadyConnected *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::alreadyConnected>::extract (
          _tao_any,
          ::AVStreams::alreadyConnected::_tao_any_destructor,
          ::AVStreams::_tc_alreadyConnected,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::alreadyConnected &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::alreadyConnected>::insert_copy (
      _tao_any,
      AVStreams::alreadyConnected::_tao_any_destructor,
      AVStreams::_tc_alreadyConnected,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::alreadyConnected *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::alreadyConnected>::insert (
      _tao_any,
      AVStreams::alreadyConnected::_tao_any_destructor,
      AVStreams::_tc_alreadyConnected,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::alreadyConnected *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::alreadyConnected *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::alreadyConnected *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::alreadyConnected>::extract (
        _tao_any,
        AVStreams::alreadyConnected::_tao_any_destructor,
        AVStreams::_tc_alreadyConnected,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::invalidSettings>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::invalidSettings &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::invalidSettings>::insert_copy (
        _tao_any,
        ::AVStreams::invalidSettings::_tao_any_destructor,
        ::AVStreams::_tc_invalidSettings,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::invalidSettings *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::invalidSettings>::insert (
        _tao_any,
        ::AVStreams::invalidSettings::_tao_any_destructor,
        ::AVStreams::_tc_invalidSettings,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::invalidSettings *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::invalidSettings *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::invalidSettings *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::invalidSettings>::extract (
          _tao_any,
          ::AVStreams::invalidSettings::_tao_any_destructor,
          ::AVStreams::_tc_invalidSettings,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::invalidSettings &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::invalidSettings>::insert_copy (
      _tao_any,
      AVStreams::invalidSettings::_tao_any_destructor,
      AVStreams::_tc_invalidSettings,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::invalidSettings *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::invalidSettings>::insert (
      _tao_any,
      AVStreams::invalidSettings::_tao_any_destructor,
      AVStreams::_tc_invalidSettings,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::invalidSettings *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::invalidSettings *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::invalidSettings *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::invalidSettings>::extract (
        _tao_any,
        AVStreams::invalidSettings::_tao_any_destructor,
        AVStreams::_tc_invalidSettings,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::notConnected>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::notConnected &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::notConnected>::insert_copy (
        _tao_any,
        ::AVStreams::notConnected::_tao_any_destructor,
        ::AVStreams::_tc_notConnected,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::notConnected *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::notConnected>::insert (
        _tao_any,
        ::AVStreams::notConnected::_tao_any_destructor,
        ::AVStreams::_tc_notConnected,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::notConnected *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::notConnected *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::notConnected *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::notConnected>::extract (
          _tao_any,
          ::AVStreams::notConnected::_tao_any_destructor,
          ::AVStreams::_tc_notConnected,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::notConnected &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::notConnected>::insert_copy (
      _tao_any,
      AVStreams::notConnected::_tao_any_destructor,
      AVStreams::_tc_notConnected,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::notConnected *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::notConnected>::insert (
      _tao_any,
      AVStreams::notConnected::_tao_any_destructor,
      AVStreams::_tc_notConnected,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::notConnected *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::notConnected *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::notConnected *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::notConnected>::extract (
        _tao_any,
        AVStreams::notConnected::_tao_any_destructor,
        AVStreams::_tc_notConnected,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::deviceQosMismatch>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::deviceQosMismatch &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::deviceQosMismatch>::insert_copy (
        _tao_any,
        ::AVStreams::deviceQosMismatch::_tao_any_destructor,
        ::AVStreams::_tc_deviceQosMismatch,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::deviceQosMismatch *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::deviceQosMismatch>::insert (
        _tao_any,
        ::AVStreams::deviceQosMismatch::_tao_any_destructor,
        ::AVStreams::_tc_deviceQosMismatch,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::deviceQosMismatch *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::deviceQosMismatch *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::deviceQosMismatch *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::deviceQosMismatch>::extract (
          _tao_any,
          ::AVStreams::deviceQosMismatch::_tao_any_destructor,
          ::AVStreams::_tc_deviceQosMismatch,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::deviceQosMismatch &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::deviceQosMismatch>::insert_copy (
      _tao_any,
      AVStreams::deviceQosMismatch::_tao_any_destructor,
      AVStreams::_tc_deviceQosMismatch,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::deviceQosMismatch *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::deviceQosMismatch>::insert (
      _tao_any,
      AVStreams::deviceQosMismatch::_tao_any_destructor,
      AVStreams::_tc_deviceQosMismatch,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::deviceQosMismatch *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::deviceQosMismatch *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::deviceQosMismatch *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::deviceQosMismatch>::extract (
        _tao_any,
        AVStreams::deviceQosMismatch::_tao_any_destructor,
        AVStreams::_tc_deviceQosMismatch,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::failedToConnect>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::failedToConnect &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::failedToConnect>::insert_copy (
        _tao_any,
        ::AVStreams::failedToConnect::_tao_any_destructor,
        ::AVStreams::_tc_failedToConnect,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::failedToConnect *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::failedToConnect>::insert (
        _tao_any,
        ::AVStreams::failedToConnect::_tao_any_destructor,
        ::AVStreams::_tc_failedToConnect,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::failedToConnect *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::failedToConnect *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::failedToConnect *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::failedToConnect>::extract (
          _tao_any,
          ::AVStreams::failedToConnect::_tao_any_destructor,
          ::AVStreams::_tc_failedToConnect,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::failedToConnect &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::failedToConnect>::insert_copy (
      _tao_any,
      AVStreams::failedToConnect::_tao_any_destructor,
      AVStreams::_tc_failedToConnect,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::failedToConnect *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::failedToConnect>::insert (
      _tao_any,
      AVStreams::failedToConnect::_tao_any_destructor,
      AVStreams::_tc_failedToConnect,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::failedToConnect *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::failedToConnect *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::failedToConnect *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::failedToConnect>::extract (
        _tao_any,
        AVStreams::failedToConnect::_tao_any_destructor,
        AVStreams::_tc_failedToConnect,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::failedToListen>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::failedToListen &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::failedToListen>::insert_copy (
        _tao_any,
        ::AVStreams::failedToListen::_tao_any_destructor,
        ::AVStreams::_tc_failedToListen,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::failedToListen *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::failedToListen>::insert (
        _tao_any,
        ::AVStreams::failedToListen::_tao_any_destructor,
        ::AVStreams::_tc_failedToListen,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::failedToListen *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::failedToListen *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::failedToListen *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::failedToListen>::extract (
          _tao_any,
          ::AVStreams::failedToListen::_tao_any_destructor,
          ::AVStreams::_tc_failedToListen,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::failedToListen &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::failedToListen>::insert_copy (
      _tao_any,
      AVStreams::failedToListen::_tao_any_destructor,
      AVStreams::_tc_failedToListen,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::failedToListen *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::failedToListen>::insert (
      _tao_any,
      AVStreams::failedToListen::_tao_any_destructor,
      AVStreams::_tc_failedToListen,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::failedToListen *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::failedToListen *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::failedToListen *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::failedToListen>::extract (
        _tao_any,
        AVStreams::failedToListen::_tao_any_destructor,
        AVStreams::_tc_failedToListen,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::FlowConnection>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FlowConnection_ptr _tao_elem)
  {
    FlowConnection_ptr _tao_objptr =
      FlowConnection::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FlowConnection_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<FlowConnection>::insert (
        _tao_any,
        FlowConnection::_tao_any_destructor,
        _tc_FlowConnection,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      FlowConnection_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<FlowConnection>::extract (
          _tao_any,
          FlowConnection::_tao_any_destructor,
          _tc_FlowConnection,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::FlowConnection_ptr _tao_elem)
{
  AVStreams::FlowConnection_ptr _tao_objptr =
    AVStreams::FlowConnection::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::FlowConnection_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::FlowConnection>::insert (
      _tao_any,
      AVStreams::FlowConnection::_tao_any_destructor,
      AVStreams::_tc_FlowConnection,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::FlowConnection_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::FlowConnection>::extract (
        _tao_any,
        AVStreams::FlowConnection::_tao_any_destructor,
        AVStreams::_tc_FlowConnection,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::FlowEndPoint>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FlowEndPoint_ptr _tao_elem)
  {
    FlowEndPoint_ptr _tao_objptr =
      FlowEndPoint::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FlowEndPoint_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<FlowEndPoint>::insert (
        _tao_any,
        FlowEndPoint::_tao_any_destructor,
        _tc_FlowEndPoint,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      FlowEndPoint_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<FlowEndPoint>::extract (
          _tao_any,
          FlowEndPoint::_tao_any_destructor,
          _tc_FlowEndPoint,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::FlowEndPoint_ptr _tao_elem)
{
  AVStreams::FlowEndPoint_ptr _tao_objptr =
    AVStreams::FlowEndPoint::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::FlowEndPoint_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::FlowEndPoint>::insert (
      _tao_any,
      AVStreams::FlowEndPoint::_tao_any_destructor,
      AVStreams::_tc_FlowEndPoint,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::FlowEndPoint_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::FlowEndPoint>::extract (
        _tao_any,
        AVStreams::FlowEndPoint::_tao_any_destructor,
        AVStreams::_tc_FlowEndPoint,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::FlowProducer>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FlowProducer_ptr _tao_elem)
  {
    FlowProducer_ptr _tao_objptr =
      FlowProducer::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FlowProducer_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<FlowProducer>::insert (
        _tao_any,
        FlowProducer::_tao_any_destructor,
        _tc_FlowProducer,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      FlowProducer_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<FlowProducer>::extract (
          _tao_any,
          FlowProducer::_tao_any_destructor,
          _tc_FlowProducer,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::FlowProducer_ptr _tao_elem)
{
  AVStreams::FlowProducer_ptr _tao_objptr =
    AVStreams::FlowProducer::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::FlowProducer_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::FlowProducer>::insert (
      _tao_any,
      AVStreams::FlowProducer::_tao_any_destructor,
      AVStreams::_tc_FlowProducer,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::FlowProducer_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::FlowProducer>::extract (
        _tao_any,
        AVStreams::FlowProducer::_tao_any_destructor,
        AVStreams::_tc_FlowProducer,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::FlowConsumer>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FlowConsumer_ptr _tao_elem)
  {
    FlowConsumer_ptr _tao_objptr =
      FlowConsumer::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FlowConsumer_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<FlowConsumer>::insert (
        _tao_any,
        FlowConsumer::_tao_any_destructor,
        _tc_FlowConsumer,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      FlowConsumer_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<FlowConsumer>::extract (
          _tao_any,
          FlowConsumer::_tao_any_destructor,
          _tc_FlowConsumer,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::FlowConsumer_ptr _tao_elem)
{
  AVStreams::FlowConsumer_ptr _tao_objptr =
    AVStreams::FlowConsumer::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::FlowConsumer_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::FlowConsumer>::insert (
      _tao_any,
      AVStreams::FlowConsumer::_tao_any_destructor,
      AVStreams::_tc_FlowConsumer,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::FlowConsumer_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::FlowConsumer>::extract (
        _tao_any,
        AVStreams::FlowConsumer::_tao_any_destructor,
        AVStreams::_tc_FlowConsumer,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::FDev>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FDev_ptr _tao_elem)
  {
    FDev_ptr _tao_objptr =
      FDev::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      FDev_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<FDev>::insert (
        _tao_any,
        FDev::_tao_any_destructor,
        _tc_FDev,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      FDev_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<FDev>::extract (
          _tao_any,
          FDev::_tao_any_destructor,
          _tc_FDev,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::FDev_ptr _tao_elem)
{
  AVStreams::FDev_ptr _tao_objptr =
    AVStreams::FDev::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::FDev_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::FDev>::insert (
      _tao_any,
      AVStreams::FDev::_tao_any_destructor,
      AVStreams::_tc_FDev,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::FDev_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::FDev>::extract (
        _tao_any,
        AVStreams::FDev::_tao_any_destructor,
        AVStreams::_tc_FDev,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::PositionOrigin _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::AVStreams::PositionOrigin>::insert (
        _tao_any,
        ::AVStreams::_tc_PositionOrigin,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::PositionOrigin &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::AVStreams::PositionOrigin>::extract (
          _tao_any,
          ::AVStreams::_tc_PositionOrigin,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::PositionOrigin _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<AVStreams::PositionOrigin>::insert (
      _tao_any,
      AVStreams::_tc_PositionOrigin,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::PositionOrigin &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<AVStreams::PositionOrigin>::extract (
        _tao_any,
        AVStreams::_tc_PositionOrigin,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:43


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::PositionKey _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::AVStreams::PositionKey>::insert (
        _tao_any,
        ::AVStreams::_tc_PositionKey,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::PositionKey &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::AVStreams::PositionKey>::extract (
          _tao_any,
          ::AVStreams::_tc_PositionKey,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::PositionKey _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<AVStreams::PositionKey>::insert (
      _tao_any,
      AVStreams::_tc_PositionKey,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::PositionKey &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<AVStreams::PositionKey>::extract (
        _tao_any,
        AVStreams::_tc_PositionKey,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::Position &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::AVStreams::Position *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::AVStreams::Position>::insert_copy (
          _tao_any,
          ::AVStreams::Position::_tao_any_destructor,
          ::AVStreams::_tc_Position,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      AVStreams::Position *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::Position>::insert (
        _tao_any,
        ::AVStreams::Position::_tao_any_destructor,
        ::AVStreams::_tc_Position,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::Position *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::Position *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::Position *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::Position>::extract (
          _tao_any,
          ::AVStreams::Position::_tao_any_destructor,
          ::AVStreams::_tc_Position,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::Position &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<AVStreams::Position *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<AVStreams::Position>::insert_copy (
        _tao_any,
        AVStreams::Position::_tao_any_destructor,
        AVStreams::_tc_Position,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::Position *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::Position>::insert (
      _tao_any,
      AVStreams::Position::_tao_any_destructor,
      AVStreams::_tc_Position,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::Position *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::Position *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::Position *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::Position>::extract (
        _tao_any,
        AVStreams::Position::_tao_any_destructor,
        AVStreams::_tc_Position,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::PostionKeyNotSupported>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::PostionKeyNotSupported &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::PostionKeyNotSupported>::insert_copy (
        _tao_any,
        ::AVStreams::PostionKeyNotSupported::_tao_any_destructor,
        ::AVStreams::_tc_PostionKeyNotSupported,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::PostionKeyNotSupported *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::PostionKeyNotSupported>::insert (
        _tao_any,
        ::AVStreams::PostionKeyNotSupported::_tao_any_destructor,
        ::AVStreams::_tc_PostionKeyNotSupported,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::PostionKeyNotSupported *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::PostionKeyNotSupported *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::PostionKeyNotSupported *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::PostionKeyNotSupported>::extract (
          _tao_any,
          ::AVStreams::PostionKeyNotSupported::_tao_any_destructor,
          ::AVStreams::_tc_PostionKeyNotSupported,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::PostionKeyNotSupported &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::PostionKeyNotSupported>::insert_copy (
      _tao_any,
      AVStreams::PostionKeyNotSupported::_tao_any_destructor,
      AVStreams::_tc_PostionKeyNotSupported,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::PostionKeyNotSupported *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::PostionKeyNotSupported>::insert (
      _tao_any,
      AVStreams::PostionKeyNotSupported::_tao_any_destructor,
      AVStreams::_tc_PostionKeyNotSupported,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::PostionKeyNotSupported *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::PostionKeyNotSupported *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::PostionKeyNotSupported *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::PostionKeyNotSupported>::extract (
        _tao_any,
        AVStreams::PostionKeyNotSupported::_tao_any_destructor,
        AVStreams::_tc_PostionKeyNotSupported,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::InvalidPosition>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::InvalidPosition &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::InvalidPosition>::insert_copy (
        _tao_any,
        ::AVStreams::InvalidPosition::_tao_any_destructor,
        ::AVStreams::_tc_InvalidPosition,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::InvalidPosition *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::InvalidPosition>::insert (
        _tao_any,
        ::AVStreams::InvalidPosition::_tao_any_destructor,
        ::AVStreams::_tc_InvalidPosition,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::InvalidPosition *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::InvalidPosition *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::InvalidPosition *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::InvalidPosition>::extract (
          _tao_any,
          ::AVStreams::InvalidPosition::_tao_any_destructor,
          ::AVStreams::_tc_InvalidPosition,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::InvalidPosition &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::InvalidPosition>::insert_copy (
      _tao_any,
      AVStreams::InvalidPosition::_tao_any_destructor,
      AVStreams::_tc_InvalidPosition,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::InvalidPosition *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::InvalidPosition>::insert (
      _tao_any,
      AVStreams::InvalidPosition::_tao_any_destructor,
      AVStreams::_tc_InvalidPosition,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::InvalidPosition *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::InvalidPosition *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::InvalidPosition *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::InvalidPosition>::extract (
        _tao_any,
        AVStreams::InvalidPosition::_tao_any_destructor,
        AVStreams::_tc_InvalidPosition,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AVStreams::MediaControl>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      MediaControl_ptr _tao_elem)
  {
    MediaControl_ptr _tao_objptr =
      MediaControl::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      MediaControl_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<MediaControl>::insert (
        _tao_any,
        MediaControl::_tao_any_destructor,
        _tc_MediaControl,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      MediaControl_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<MediaControl>::extract (
          _tao_any,
          MediaControl::_tao_any_destructor,
          _tc_MediaControl,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::MediaControl_ptr _tao_elem)
{
  AVStreams::MediaControl_ptr _tao_objptr =
    AVStreams::MediaControl::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::MediaControl_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AVStreams::MediaControl>::insert (
      _tao_any,
      AVStreams::MediaControl::_tao_any_destructor,
      AVStreams::_tc_MediaControl,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::MediaControl_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AVStreams::MediaControl>::extract (
        _tao_any,
        AVStreams::MediaControl::_tao_any_destructor,
        AVStreams::_tc_MediaControl,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<AVStreams::MediaControl::PostionKeyNotSupported>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::MediaControl::PostionKeyNotSupported &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::MediaControl::PostionKeyNotSupported>::insert_copy (
        _tao_any,
        ::AVStreams::MediaControl::PostionKeyNotSupported::_tao_any_destructor,
        ::AVStreams::MediaControl::_tc_PostionKeyNotSupported,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::MediaControl::PostionKeyNotSupported *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::MediaControl::PostionKeyNotSupported>::insert (
        _tao_any,
        ::AVStreams::MediaControl::PostionKeyNotSupported::_tao_any_destructor,
        ::AVStreams::MediaControl::_tc_PostionKeyNotSupported,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::MediaControl::PostionKeyNotSupported *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::MediaControl::PostionKeyNotSupported *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::MediaControl::PostionKeyNotSupported *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::MediaControl::PostionKeyNotSupported>::extract (
          _tao_any,
          ::AVStreams::MediaControl::PostionKeyNotSupported::_tao_any_destructor,
          ::AVStreams::MediaControl::_tc_PostionKeyNotSupported,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::MediaControl::PostionKeyNotSupported &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::MediaControl::PostionKeyNotSupported>::insert_copy (
      _tao_any,
      AVStreams::MediaControl::PostionKeyNotSupported::_tao_any_destructor,
      AVStreams::MediaControl::_tc_PostionKeyNotSupported,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::MediaControl::PostionKeyNotSupported *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::MediaControl::PostionKeyNotSupported>::insert (
      _tao_any,
      AVStreams::MediaControl::PostionKeyNotSupported::_tao_any_destructor,
      AVStreams::MediaControl::_tc_PostionKeyNotSupported,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::MediaControl::PostionKeyNotSupported *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::MediaControl::PostionKeyNotSupported *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::MediaControl::PostionKeyNotSupported *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::MediaControl::PostionKeyNotSupported>::extract (
        _tao_any,
        AVStreams::MediaControl::PostionKeyNotSupported::_tao_any_destructor,
        AVStreams::MediaControl::_tc_PostionKeyNotSupported,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::FlowConnection_seq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::AVStreams::FlowConnection_seq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::AVStreams::FlowConnection_seq>::insert_copy (
          _tao_any,
          ::AVStreams::FlowConnection_seq::_tao_any_destructor,
          ::AVStreams::_tc_FlowConnection_seq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::FlowConnection_seq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::FlowConnection_seq>::insert (
        _tao_any,
        ::AVStreams::FlowConnection_seq::_tao_any_destructor,
        ::AVStreams::_tc_FlowConnection_seq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::FlowConnection_seq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::FlowConnection_seq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::FlowConnection_seq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::FlowConnection_seq>::extract (
          _tao_any,
          ::AVStreams::FlowConnection_seq::_tao_any_destructor,
          ::AVStreams::_tc_FlowConnection_seq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::FlowConnection_seq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<AVStreams::FlowConnection_seq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<AVStreams::FlowConnection_seq>::insert_copy (
        _tao_any,
        AVStreams::FlowConnection_seq::_tao_any_destructor,
        AVStreams::_tc_FlowConnection_seq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::FlowConnection_seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::FlowConnection_seq>::insert (
      _tao_any,
      AVStreams::FlowConnection_seq::_tao_any_destructor,
      AVStreams::_tc_FlowConnection_seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::FlowConnection_seq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::FlowConnection_seq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::FlowConnection_seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::FlowConnection_seq>::extract (
        _tao_any,
        AVStreams::FlowConnection_seq::_tao_any_destructor,
        AVStreams::_tc_FlowConnection_seq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::StreamEndPoint_A_seq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::AVStreams::StreamEndPoint_A_seq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::AVStreams::StreamEndPoint_A_seq>::insert_copy (
          _tao_any,
          ::AVStreams::StreamEndPoint_A_seq::_tao_any_destructor,
          ::AVStreams::_tc_StreamEndPoint_A_seq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::StreamEndPoint_A_seq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::StreamEndPoint_A_seq>::insert (
        _tao_any,
        ::AVStreams::StreamEndPoint_A_seq::_tao_any_destructor,
        ::AVStreams::_tc_StreamEndPoint_A_seq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::StreamEndPoint_A_seq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::StreamEndPoint_A_seq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::StreamEndPoint_A_seq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::StreamEndPoint_A_seq>::extract (
          _tao_any,
          ::AVStreams::StreamEndPoint_A_seq::_tao_any_destructor,
          ::AVStreams::_tc_StreamEndPoint_A_seq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::StreamEndPoint_A_seq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<AVStreams::StreamEndPoint_A_seq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<AVStreams::StreamEndPoint_A_seq>::insert_copy (
        _tao_any,
        AVStreams::StreamEndPoint_A_seq::_tao_any_destructor,
        AVStreams::_tc_StreamEndPoint_A_seq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::StreamEndPoint_A_seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::StreamEndPoint_A_seq>::insert (
      _tao_any,
      AVStreams::StreamEndPoint_A_seq::_tao_any_destructor,
      AVStreams::_tc_StreamEndPoint_A_seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::StreamEndPoint_A_seq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::StreamEndPoint_A_seq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::StreamEndPoint_A_seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::StreamEndPoint_A_seq>::extract (
        _tao_any,
        AVStreams::StreamEndPoint_A_seq::_tao_any_destructor,
        AVStreams::_tc_StreamEndPoint_A_seq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::StreamEndPoint_B_seq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::AVStreams::StreamEndPoint_B_seq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::AVStreams::StreamEndPoint_B_seq>::insert_copy (
          _tao_any,
          ::AVStreams::StreamEndPoint_B_seq::_tao_any_destructor,
          ::AVStreams::_tc_StreamEndPoint_B_seq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::StreamEndPoint_B_seq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::StreamEndPoint_B_seq>::insert (
        _tao_any,
        ::AVStreams::StreamEndPoint_B_seq::_tao_any_destructor,
        ::AVStreams::_tc_StreamEndPoint_B_seq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::StreamEndPoint_B_seq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::StreamEndPoint_B_seq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::StreamEndPoint_B_seq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::StreamEndPoint_B_seq>::extract (
          _tao_any,
          ::AVStreams::StreamEndPoint_B_seq::_tao_any_destructor,
          ::AVStreams::_tc_StreamEndPoint_B_seq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::StreamEndPoint_B_seq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<AVStreams::StreamEndPoint_B_seq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<AVStreams::StreamEndPoint_B_seq>::insert_copy (
        _tao_any,
        AVStreams::StreamEndPoint_B_seq::_tao_any_destructor,
        AVStreams::_tc_StreamEndPoint_B_seq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::StreamEndPoint_B_seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::StreamEndPoint_B_seq>::insert (
      _tao_any,
      AVStreams::StreamEndPoint_B_seq::_tao_any_destructor,
      AVStreams::_tc_StreamEndPoint_B_seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::StreamEndPoint_B_seq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::StreamEndPoint_B_seq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::StreamEndPoint_B_seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::StreamEndPoint_B_seq>::extract (
        _tao_any,
        AVStreams::StreamEndPoint_B_seq::_tao_any_destructor,
        AVStreams::_tc_StreamEndPoint_B_seq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::FlowEndPoint_seq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::AVStreams::FlowEndPoint_seq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::AVStreams::FlowEndPoint_seq>::insert_copy (
          _tao_any,
          ::AVStreams::FlowEndPoint_seq::_tao_any_destructor,
          ::AVStreams::_tc_FlowEndPoint_seq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::FlowEndPoint_seq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::FlowEndPoint_seq>::insert (
        _tao_any,
        ::AVStreams::FlowEndPoint_seq::_tao_any_destructor,
        ::AVStreams::_tc_FlowEndPoint_seq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::FlowEndPoint_seq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::FlowEndPoint_seq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::FlowEndPoint_seq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::FlowEndPoint_seq>::extract (
          _tao_any,
          ::AVStreams::FlowEndPoint_seq::_tao_any_destructor,
          ::AVStreams::_tc_FlowEndPoint_seq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::FlowEndPoint_seq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<AVStreams::FlowEndPoint_seq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<AVStreams::FlowEndPoint_seq>::insert_copy (
        _tao_any,
        AVStreams::FlowEndPoint_seq::_tao_any_destructor,
        AVStreams::_tc_FlowEndPoint_seq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::FlowEndPoint_seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::FlowEndPoint_seq>::insert (
      _tao_any,
      AVStreams::FlowEndPoint_seq::_tao_any_destructor,
      AVStreams::_tc_FlowEndPoint_seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::FlowEndPoint_seq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::FlowEndPoint_seq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::FlowEndPoint_seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::FlowEndPoint_seq>::extract (
        _tao_any,
        AVStreams::FlowEndPoint_seq::_tao_any_destructor,
        AVStreams::_tc_FlowEndPoint_seq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace AVStreams
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::AVStreams::Object_seq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::AVStreams::Object_seq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::AVStreams::Object_seq>::insert_copy (
          _tao_any,
          ::AVStreams::Object_seq::_tao_any_destructor,
          ::AVStreams::_tc_Object_seq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::AVStreams::Object_seq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::AVStreams::Object_seq>::insert (
        _tao_any,
        ::AVStreams::Object_seq::_tao_any_destructor,
        ::AVStreams::_tc_Object_seq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::AVStreams::Object_seq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::AVStreams::Object_seq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::AVStreams::Object_seq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::AVStreams::Object_seq>::extract (
          _tao_any,
          ::AVStreams::Object_seq::_tao_any_destructor,
          ::AVStreams::_tc_Object_seq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const AVStreams::Object_seq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<AVStreams::Object_seq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<AVStreams::Object_seq>::insert_copy (
        _tao_any,
        AVStreams::Object_seq::_tao_any_destructor,
        AVStreams::_tc_Object_seq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    AVStreams::Object_seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<AVStreams::Object_seq>::insert (
      _tao_any,
      AVStreams::Object_seq::_tao_any_destructor,
      AVStreams::_tc_Object_seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AVStreams::Object_seq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const AVStreams::Object_seq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const AVStreams::Object_seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<AVStreams::Object_seq>::extract (
        _tao_any,
        AVStreams::Object_seq::_tao_any_destructor,
        AVStreams::_tc_Object_seq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::QoS &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.QoSType.in ()) &&
    (strm << _tao_aggregate.QoSParams);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::QoS &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.QoSType.out ()) &&
    (strm >> _tao_aggregate.QoSParams);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_AVStreams_streamQoS_CPP_
#define _TAO_CDR_OP_AVStreams_streamQoS_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::streamQoS &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::streamQoS &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_AVStreams_streamQoS_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_AVStreams_flowSpec_CPP_
#define _TAO_CDR_OP_AVStreams_flowSpec_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::flowSpec &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::flowSpec &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_AVStreams_flowSpec_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_AVStreams_protocolSpec_CPP_
#define _TAO_CDR_OP_AVStreams_protocolSpec_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::protocolSpec &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::protocolSpec &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_AVStreams_protocolSpec_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_AVStreams_key_CPP_
#define _TAO_CDR_OP_AVStreams_key_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::key &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::key &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_AVStreams_key_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::SFPStatus &_tao_aggregate)
{
  return
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.isFormatted)) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.isSpecialFormat)) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.seqNums)) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.timestamps)) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.sourceIndicators));
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::SFPStatus &_tao_aggregate)
{
  return
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.isFormatted)) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.isSpecialFormat)) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.seqNums)) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.timestamps)) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.sourceIndicators));
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, AVStreams::flowState _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, AVStreams::flowState & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<AVStreams::flowState> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, AVStreams::dirType _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, AVStreams::dirType & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<AVStreams::dirType> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::flowStatus &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.flowName.in ()) &&
    (strm << _tao_aggregate.directionality) &&
    (strm << _tao_aggregate.status) &&
    (strm << _tao_aggregate.theFormat) &&
    (strm << _tao_aggregate.theQoS);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::flowStatus &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.flowName.out ()) &&
    (strm >> _tao_aggregate.directionality) &&
    (strm >> _tao_aggregate.status) &&
    (strm >> _tao_aggregate.theFormat) &&
    (strm >> _tao_aggregate.theQoS);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::notSupported &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    AVStreams::notSupported&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::PropertyException &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    AVStreams::PropertyException&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::FPError &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.flow_name.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::FPError &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.flow_name.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::streamOpFailed &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.reason.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::streamOpFailed &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.reason.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::streamOpDenied &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.reason.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::streamOpDenied &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.reason.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::noSuchFlow &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    AVStreams::noSuchFlow&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::QoSRequestFailed &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.reason.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::QoSRequestFailed &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.reason.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::Basic_StreamCtrl_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::Basic_StreamCtrl_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::Basic_StreamCtrl RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_Basic_StreamCtrl_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::Negotiator_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::Negotiator_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::Negotiator RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_Negotiator_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::StreamCtrl_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::StreamCtrl_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::StreamCtrl RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_StreamCtrl_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::MCastConfigIf_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::MCastConfigIf_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::MCastConfigIf RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_MCastConfigIf_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::StreamEndPoint_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::StreamEndPoint_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::StreamEndPoint RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_StreamEndPoint_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::StreamEndPoint_A_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::StreamEndPoint_A_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::StreamEndPoint_A RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_StreamEndPoint_A_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::StreamEndPoint_B_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::StreamEndPoint_B_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::StreamEndPoint_B RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_StreamEndPoint_B_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::VDev_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::VDev_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::VDev RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_VDev_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::MMDevice_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::MMDevice_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::MMDevice RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_MMDevice_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::protocolNotSupported &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    AVStreams::protocolNotSupported&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::formatNotSupported &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    AVStreams::formatNotSupported&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::formatMismatch &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    AVStreams::formatMismatch&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::FEPMismatch &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    AVStreams::FEPMismatch&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::alreadyConnected &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    AVStreams::alreadyConnected&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::invalidSettings &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.settings.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::invalidSettings &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.settings.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::notConnected &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    AVStreams::notConnected&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::deviceQosMismatch &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    AVStreams::deviceQosMismatch&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::failedToConnect &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.reason.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::failedToConnect &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.reason.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::failedToListen &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.reason.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::failedToListen &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.reason.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::FlowConnection_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::FlowConnection_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::FlowConnection RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_FlowConnection_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::FlowEndPoint_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::FlowEndPoint_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::FlowEndPoint RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_FlowEndPoint_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::FlowProducer_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::FlowProducer_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::FlowProducer RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_FlowProducer_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::FlowConsumer_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::FlowConsumer_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::FlowConsumer RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_FlowConsumer_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::FDev_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::FDev_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::FDev RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_FDev_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, AVStreams::PositionOrigin _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, AVStreams::PositionOrigin & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<AVStreams::PositionOrigin> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:41



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, AVStreams::PositionKey _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, AVStreams::PositionKey & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<AVStreams::PositionKey> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::Position &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.origin) &&
    (strm << _tao_aggregate.key) &&
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::Position &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.origin) &&
    (strm >> _tao_aggregate.key) &&
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::PostionKeyNotSupported &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.key)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::PostionKeyNotSupported &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.key)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::InvalidPosition &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.key)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::InvalidPosition &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.key)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::MediaControl::PostionKeyNotSupported &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.key)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::MediaControl::PostionKeyNotSupported &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.key)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:53


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::MediaControl_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::MediaControl_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::AVStreams::MediaControl RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_MediaControl_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_AVStreams_FlowConnection_seq_CPP_
#define _TAO_CDR_OP_AVStreams_FlowConnection_seq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::FlowConnection_seq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::FlowConnection_seq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_AVStreams_FlowConnection_seq_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_AVStreams_StreamEndPoint_A_seq_CPP_
#define _TAO_CDR_OP_AVStreams_StreamEndPoint_A_seq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::StreamEndPoint_A_seq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::StreamEndPoint_A_seq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_AVStreams_StreamEndPoint_A_seq_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_AVStreams_StreamEndPoint_B_seq_CPP_
#define _TAO_CDR_OP_AVStreams_StreamEndPoint_B_seq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::StreamEndPoint_B_seq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::StreamEndPoint_B_seq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_AVStreams_StreamEndPoint_B_seq_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_AVStreams_FlowEndPoint_seq_CPP_
#define _TAO_CDR_OP_AVStreams_FlowEndPoint_seq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::FlowEndPoint_seq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::FlowEndPoint_seq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_AVStreams_FlowEndPoint_seq_CPP_ */

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_AVStreams_Object_seq_CPP_
#define _TAO_CDR_OP_AVStreams_Object_seq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AVStreams::Object_seq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AVStreams::Object_seq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_AVStreams_Object_seq_CPP_ */


TAO_END_VERSIONED_NAMESPACE_DECL


