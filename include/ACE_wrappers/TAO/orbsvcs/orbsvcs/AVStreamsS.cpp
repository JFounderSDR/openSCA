// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/


// TAO_IDL - Generated from 
// .\be\be_codegen.cpp:651

#ifndef _TAO_IDL_AVSTREAMSS_B5V2PX_CPP_
#define _TAO_IDL_AVSTREAMSS_B5V2PX_CPP_


#include "AVStreamsS.h"
#include "tao/PortableServer/Operation_Table_Perfect_Hash.h"
#include "tao/PortableServer/Upcall_Command.h"
#include "tao/PortableServer/Upcall_Wrapper.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Profile.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/Object_T.h"
#include "tao/AnyTypeCode/TypeCode.h"
#include "tao/AnyTypeCode/DynamicC.h"
#include "tao/CDR.h"
#include "tao/operation_details.h"
#include "tao/PortableInterceptor.h"
#include "ace/Dynamic_Service.h"
#include "ace/Malloc_Allocator.h"

#if !defined (__ACE_INLINE__)
#include "AVStreamsS.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_Basic_StreamCtrl_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_Basic_StreamCtrl_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_Basic_StreamCtrl_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
     40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
     40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
     40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
     40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
     40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
     40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
     40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
     40, 40, 40, 20, 40, 40, 40, 40, 40, 40,
     40, 40, 40, 40, 40,  0, 40, 20, 40, 40,
      0, 10, 40, 10, 40, 20, 40, 40, 40,  0,
      0, 40, 23, 40, 40,  0,  0, 40, 40, 40,
     40,  0, 40, 40, 40, 40, 40, 40,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_Basic_StreamCtrl_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 24,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 24,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 39,
      HASH_VALUE_RANGE = 35,
      DUPLICATES = 3,
      WORDLIST_SIZE = 29
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"start", &POA_AVStreams::Basic_StreamCtrl::start_skel, 0},
      {"destroy", &POA_AVStreams::Basic_StreamCtrl::destroy_skel, 0},
      {"_component", &POA_AVStreams::Basic_StreamCtrl::_component_skel, 0},
      {"set_FPStatus", &POA_AVStreams::Basic_StreamCtrl::set_FPStatus_skel, 0},
      {"_non_existent", &POA_AVStreams::Basic_StreamCtrl::_non_existent_skel, 0},
      {"_repository_id", &POA_AVStreams::Basic_StreamCtrl::_repository_id_skel, 0},
      {"define_property", &POA_AVStreams::Basic_StreamCtrl::define_property_skel, 0},
      {"delete_property", &POA_AVStreams::Basic_StreamCtrl::delete_property_skel, 0},
      {"define_properties", &POA_AVStreams::Basic_StreamCtrl::define_properties_skel, 0},
      {"delete_properties", &POA_AVStreams::Basic_StreamCtrl::delete_properties_skel, 0},
      {"set_flow_connection", &POA_AVStreams::Basic_StreamCtrl::set_flow_connection_skel, 0},
      {"_interface", &POA_AVStreams::Basic_StreamCtrl::_interface_skel, 0},
      {"delete_all_properties", &POA_AVStreams::Basic_StreamCtrl::delete_all_properties_skel, 0},
      {"get_properties", &POA_AVStreams::Basic_StreamCtrl::get_properties_skel, 0},
      {"_is_a", &POA_AVStreams::Basic_StreamCtrl::_is_a_skel, 0},
      {"stop", &POA_AVStreams::Basic_StreamCtrl::stop_skel, 0},
      {"get_all_properties", &POA_AVStreams::Basic_StreamCtrl::get_all_properties_skel, 0},
      {"get_flow_connection", &POA_AVStreams::Basic_StreamCtrl::get_flow_connection_skel, 0},
      {"modify_QoS", &POA_AVStreams::Basic_StreamCtrl::modify_QoS_skel, 0},
      {"get_all_property_names", &POA_AVStreams::Basic_StreamCtrl::get_all_property_names_skel, 0},
      {"push_event", &POA_AVStreams::Basic_StreamCtrl::push_event_skel, 0},
      {"get_number_of_properties", &POA_AVStreams::Basic_StreamCtrl::get_number_of_properties_skel, 0},
      {"get_property_value", &POA_AVStreams::Basic_StreamCtrl::get_property_value_skel, 0},
      {"is_property_defined", &POA_AVStreams::Basic_StreamCtrl::is_property_defined_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1, -11,  -2,   5,  -1,   6, -13,  -2,   7,  -1,   8,   9, 
       10, -51,  -1, -48,  -1,  15,  16,  17,  -1,  -1,  18,  19,  -1,  20, 
       21,  22,  23,  -1,  24,  25,  26,  -1,  -1,  -1,  27,  28, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_AVStreams_Basic_StreamCtrl_Perfect_Hash_OpTable tao_AVStreams_Basic_StreamCtrl_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_Basic_StreamCtrl_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_Basic_StreamCtrl_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_Basic_StreamCtrl_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_Basic_StreamCtrl_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_Basic_StreamCtrl_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_Basic_StreamCtrl_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_Basic_StreamCtrl_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::Basic_StreamCtrl::Basic_StreamCtrl (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_Basic_StreamCtrl_optable;
}

POA_AVStreams::Basic_StreamCtrl::Basic_StreamCtrl (const Basic_StreamCtrl& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CosPropertyService::PropertySet (rhs)
{
}

POA_AVStreams::Basic_StreamCtrl::~Basic_StreamCtrl (void)
{
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class stop_Basic_StreamCtrl
    : public TAO::Upcall_Command
  {
  public:
    inline stop_Basic_StreamCtrl (
      POA_AVStreams::Basic_StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->stop (
        arg_1);
    }
  
  private:
    POA_AVStreams::Basic_StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::Basic_StreamCtrl::stop_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_spec
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::Basic_StreamCtrl * const impl =
    static_cast<POA_AVStreams::Basic_StreamCtrl *> (servant);

  stop_Basic_StreamCtrl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class start_Basic_StreamCtrl
    : public TAO::Upcall_Command
  {
  public:
    inline start_Basic_StreamCtrl (
      POA_AVStreams::Basic_StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->start (
        arg_1);
    }
  
  private:
    POA_AVStreams::Basic_StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::Basic_StreamCtrl::start_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_spec
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::Basic_StreamCtrl * const impl =
    static_cast<POA_AVStreams::Basic_StreamCtrl *> (servant);

  start_Basic_StreamCtrl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class destroy_Basic_StreamCtrl
    : public TAO::Upcall_Command
  {
  public:
    inline destroy_Basic_StreamCtrl (
      POA_AVStreams::Basic_StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->destroy (
        arg_1);
    }
  
  private:
    POA_AVStreams::Basic_StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::Basic_StreamCtrl::destroy_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_spec
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::Basic_StreamCtrl * const impl =
    static_cast<POA_AVStreams::Basic_StreamCtrl *> (servant);

  destroy_Basic_StreamCtrl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class modify_QoS_Basic_StreamCtrl
    : public TAO::Upcall_Command
  {
  public:
    inline modify_QoS_Basic_StreamCtrl (
      POA_AVStreams::Basic_StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_1 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->modify_QoS (
          arg_1
          , arg_2);
    }
  
  private:
    POA_AVStreams::Basic_StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::Basic_StreamCtrl::modify_QoS_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_new_qos;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_new_qos,
      &_tao_the_spec
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::Basic_StreamCtrl * const impl =
    static_cast<POA_AVStreams::Basic_StreamCtrl *> (servant);

  modify_QoS_Basic_StreamCtrl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class push_event_Basic_StreamCtrl
    : public TAO::Upcall_Command
  {
  public:
    inline push_event_Basic_StreamCtrl (
      POA_AVStreams::Basic_StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosPropertyService::Property>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CosPropertyService::Property> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->push_event (
        arg_1);
    }
  
  private:
    POA_AVStreams::Basic_StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::Basic_StreamCtrl::push_event_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CosPropertyService::Property>::in_arg_val _tao_the_event;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_event
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::Basic_StreamCtrl * const impl =
    static_cast<POA_AVStreams::Basic_StreamCtrl *> (servant);

  push_event_Basic_StreamCtrl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_FPStatus_Basic_StreamCtrl
    : public TAO::Upcall_Command
  {
  public:
    inline set_FPStatus_Basic_StreamCtrl (
      POA_AVStreams::Basic_StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Any>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Any> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->set_FPStatus (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_AVStreams::Basic_StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::Basic_StreamCtrl::set_FPStatus_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_FPError
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;
  TAO::SArg_Traits< char *>::in_arg_val _tao_fp_name;
  TAO::SArg_Traits< ::CORBA::Any>::in_arg_val _tao_fp_settings;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_spec,
      &_tao_fp_name,
      &_tao_fp_settings
    };
  
  static size_t const nargs = 4;

  POA_AVStreams::Basic_StreamCtrl * const impl =
    static_cast<POA_AVStreams::Basic_StreamCtrl *> (servant);

  set_FPStatus_Basic_StreamCtrl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_flow_connection_Basic_StreamCtrl
    : public TAO::Upcall_Command
  {
  public:
    inline get_flow_connection_Basic_StreamCtrl (
      POA_AVStreams::Basic_StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->get_flow_connection (
          arg_1);
    }
  
  private:
    POA_AVStreams::Basic_StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::Basic_StreamCtrl::get_flow_connection_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_notSupported
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_flow_name;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flow_name
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::Basic_StreamCtrl * const impl =
    static_cast<POA_AVStreams::Basic_StreamCtrl *> (servant);

  get_flow_connection_Basic_StreamCtrl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_flow_connection_Basic_StreamCtrl
    : public TAO::Upcall_Command
  {
  public:
    inline set_flow_connection_Basic_StreamCtrl (
      POA_AVStreams::Basic_StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Object>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->set_flow_connection (
        arg_1
        , arg_2);
    }
  
  private:
    POA_AVStreams::Basic_StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::Basic_StreamCtrl::set_flow_connection_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_notSupported
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_flow_name;
  TAO::SArg_Traits< ::CORBA::Object>::in_arg_val _tao_flow_connection;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flow_name,
      &_tao_flow_connection
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::Basic_StreamCtrl * const impl =
    static_cast<POA_AVStreams::Basic_StreamCtrl *> (servant);

  set_flow_connection_Basic_StreamCtrl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_Basic_StreamCtrl_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_Basic_StreamCtrl_Upcall_Command (
      POA_AVStreams::Basic_StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::Basic_StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::Basic_StreamCtrl::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::Basic_StreamCtrl * const impl =
    static_cast<POA_AVStreams::Basic_StreamCtrl *> (servant);
  
  _is_a_Basic_StreamCtrl_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_Basic_StreamCtrl_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_Basic_StreamCtrl_Upcall_Command (
      POA_AVStreams::Basic_StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::Basic_StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::Basic_StreamCtrl::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::Basic_StreamCtrl * const impl =
    static_cast<POA_AVStreams::Basic_StreamCtrl *> (servant);
  
  _non_existent_Basic_StreamCtrl_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_Basic_StreamCtrl_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_Basic_StreamCtrl_Upcall_Command (
      POA_AVStreams::Basic_StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::Basic_StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::Basic_StreamCtrl::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::Basic_StreamCtrl * const impl =
    static_cast<POA_AVStreams::Basic_StreamCtrl *> (servant);
  
  _repository_id_Basic_StreamCtrl_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::Basic_StreamCtrl::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::Basic_StreamCtrl * const impl =
    static_cast<POA_AVStreams::Basic_StreamCtrl *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_Basic_StreamCtrl_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_Basic_StreamCtrl_Upcall_Command (
      POA_AVStreams::Basic_StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::Basic_StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::Basic_StreamCtrl::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::Basic_StreamCtrl * const impl =
    static_cast<POA_AVStreams::Basic_StreamCtrl *> (servant);
  
  _get_component_Basic_StreamCtrl_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::Basic_StreamCtrl::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/Basic_StreamCtrl:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::Basic_StreamCtrl::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/Basic_StreamCtrl:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::Basic_StreamCtrl::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::Basic_StreamCtrl *
POA_AVStreams::Basic_StreamCtrl::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::Basic_StreamCtrl STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_Basic_StreamCtrl_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_Negotiator_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_Negotiator_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_Negotiator_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20,  0, 20,  0, 20, 20,
      5,  5, 20, 20, 20, 20, 20, 20, 20, 20,
      0, 20, 20, 20, 20, 20,  0, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_Negotiator_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 19,
      HASH_VALUE_RANGE = 15,
      DUPLICATES = 0,
      WORDLIST_SIZE = 11
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_AVStreams::Negotiator::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_component", &POA_AVStreams::Negotiator::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_AVStreams::Negotiator::_non_existent_skel, 0},
      {"negotiate", &POA_AVStreams::Negotiator::negotiate_skel, 0},
      {"_interface", &POA_AVStreams::Negotiator::_interface_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_repository_id", &POA_AVStreams::Negotiator::_repository_id_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_AVStreams_Negotiator_Perfect_Hash_OpTable tao_AVStreams_Negotiator_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_Negotiator_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_Negotiator_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_Negotiator_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_Negotiator_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_Negotiator_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_Negotiator_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_Negotiator_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::Negotiator::Negotiator (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_Negotiator_optable;
}

POA_AVStreams::Negotiator::Negotiator (const Negotiator& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_AVStreams::Negotiator::~Negotiator (void)
{
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class negotiate_Negotiator
    : public TAO::Upcall_Command
  {
  public:
    inline negotiate_Negotiator (
      POA_AVStreams::Negotiator * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::Negotiator>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::Negotiator> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::streamQoS>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->negotiate (
          arg_1
          , arg_2);
    }
  
  private:
    POA_AVStreams::Negotiator * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::Negotiator::negotiate_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::Negotiator>::in_arg_val _tao_remote_negotiator;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::in_arg_val _tao_qos_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_remote_negotiator,
      &_tao_qos_spec
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::Negotiator * const impl =
    static_cast<POA_AVStreams::Negotiator *> (servant);

  negotiate_Negotiator command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_Negotiator_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_Negotiator_Upcall_Command (
      POA_AVStreams::Negotiator * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::Negotiator * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::Negotiator::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::Negotiator * const impl =
    static_cast<POA_AVStreams::Negotiator *> (servant);
  
  _is_a_Negotiator_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_Negotiator_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_Negotiator_Upcall_Command (
      POA_AVStreams::Negotiator * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::Negotiator * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::Negotiator::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::Negotiator * const impl =
    static_cast<POA_AVStreams::Negotiator *> (servant);
  
  _non_existent_Negotiator_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_Negotiator_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_Negotiator_Upcall_Command (
      POA_AVStreams::Negotiator * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::Negotiator * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::Negotiator::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::Negotiator * const impl =
    static_cast<POA_AVStreams::Negotiator *> (servant);
  
  _repository_id_Negotiator_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::Negotiator::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::Negotiator * const impl =
    static_cast<POA_AVStreams::Negotiator *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_Negotiator_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_Negotiator_Upcall_Command (
      POA_AVStreams::Negotiator * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::Negotiator * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::Negotiator::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::Negotiator * const impl =
    static_cast<POA_AVStreams::Negotiator *> (servant);
  
  _get_component_Negotiator_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::Negotiator::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/Negotiator:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::Negotiator::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/Negotiator:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::Negotiator::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::Negotiator *
POA_AVStreams::Negotiator::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::Negotiator STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_Negotiator_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_StreamCtrl_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_StreamCtrl_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_StreamCtrl_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 30, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44,  0, 44, 15, 18, 44,
      0, 15, 44, 10, 44, 20, 44, 44, 44,  0,
      0, 44, 26, 44, 44,  0,  0, 25,  0, 44,
     44,  0, 44, 44, 44, 44, 44, 44,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_StreamCtrl_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 30,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 24,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 43,
      HASH_VALUE_RANGE = 39,
      DUPLICATES = 3,
      WORDLIST_SIZE = 35
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"start", &POA_AVStreams::StreamCtrl::start_skel, 0},
      {"destroy", &POA_AVStreams::StreamCtrl::destroy_skel, 0},
      {"_component", &POA_AVStreams::StreamCtrl::_component_skel, 0},
      {"set_FPStatus", &POA_AVStreams::StreamCtrl::set_FPStatus_skel, 0},
      {"_non_existent", &POA_AVStreams::StreamCtrl::_non_existent_skel, 0},
      {"_repository_id", &POA_AVStreams::StreamCtrl::_repository_id_skel, 0},
      {"define_property", &POA_AVStreams::StreamCtrl::define_property_skel, 0},
      {"delete_property", &POA_AVStreams::StreamCtrl::delete_property_skel, 0},
      {"define_properties", &POA_AVStreams::StreamCtrl::define_properties_skel, 0},
      {"delete_properties", &POA_AVStreams::StreamCtrl::delete_properties_skel, 0},
      {"set_flow_connection", &POA_AVStreams::StreamCtrl::set_flow_connection_skel, 0},
      {"_is_a", &POA_AVStreams::StreamCtrl::_is_a_skel, 0},
      {"delete_all_properties", &POA_AVStreams::StreamCtrl::delete_all_properties_skel, 0},
      {"bind", &POA_AVStreams::StreamCtrl::bind_skel, 0},
      {"get_properties", &POA_AVStreams::StreamCtrl::get_properties_skel, 0},
      {"_interface", &POA_AVStreams::StreamCtrl::_interface_skel, 0},
      {"get_related_vdev", &POA_AVStreams::StreamCtrl::get_related_vdev_skel, 0},
      {"bind_devs", &POA_AVStreams::StreamCtrl::bind_devs_skel, 0},
      {"get_all_properties", &POA_AVStreams::StreamCtrl::get_all_properties_skel, 0},
      {"get_flow_connection", &POA_AVStreams::StreamCtrl::get_flow_connection_skel, 0},
      {"stop", &POA_AVStreams::StreamCtrl::stop_skel, 0},
      {"unbind", &POA_AVStreams::StreamCtrl::unbind_skel, 0},
      {"get_all_property_names", &POA_AVStreams::StreamCtrl::get_all_property_names_skel, 0},
      {"get_number_of_properties", &POA_AVStreams::StreamCtrl::get_number_of_properties_skel, 0},
      {"unbind_dev", &POA_AVStreams::StreamCtrl::unbind_dev_skel, 0},
      {"push_event", &POA_AVStreams::StreamCtrl::push_event_skel, 0},
      {"unbind_party", &POA_AVStreams::StreamCtrl::unbind_party_skel, 0},
      {"is_property_defined", &POA_AVStreams::StreamCtrl::is_property_defined_skel, 0},
      {"modify_QoS", &POA_AVStreams::StreamCtrl::modify_QoS_skel, 0},
      {"get_property_value", &POA_AVStreams::StreamCtrl::get_property_value_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1, -11,  -2,   5,  -1,   6, -13,  -2,   7,  -1,   8,   9, 
       10, -55,  -1, -52,  -1,  15,  16,  17,  18,  -1,  19,  20,  21,  22, 
       23,  24,  25,  26,  27,  -1,  28,  29,  30,  31,  -1,  32,  33,  -1, 
       -1,  34, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_AVStreams_StreamCtrl_Perfect_Hash_OpTable tao_AVStreams_StreamCtrl_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_StreamCtrl_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_StreamCtrl_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_StreamCtrl_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_StreamCtrl_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_StreamCtrl_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_StreamCtrl_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_StreamCtrl_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::StreamCtrl::StreamCtrl (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_StreamCtrl_optable;
}

POA_AVStreams::StreamCtrl::StreamCtrl (const StreamCtrl& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CosPropertyService::PropertySet (rhs),
    POA_AVStreams::Basic_StreamCtrl (rhs)
{
}

POA_AVStreams::StreamCtrl::~StreamCtrl (void)
{
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class bind_devs_StreamCtrl
    : public TAO::Upcall_Command
  {
  public:
    inline bind_devs_StreamCtrl (
      POA_AVStreams::StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::MMDevice>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::MMDevice> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::MMDevice>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::MMDevice> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_3 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          4);
        
      retval =
        this->servant_->bind_devs (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }
  
  private:
    POA_AVStreams::StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamCtrl::bind_devs_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 3;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::MMDevice>::in_arg_val _tao_a_party;
  TAO::SArg_Traits< ::AVStreams::MMDevice>::in_arg_val _tao_b_party;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_flows;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_a_party,
      &_tao_b_party,
      &_tao_the_qos,
      &_tao_the_flows
    };
  
  static size_t const nargs = 5;

  POA_AVStreams::StreamCtrl * const impl =
    static_cast<POA_AVStreams::StreamCtrl *> (servant);

  bind_devs_StreamCtrl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class bind_StreamCtrl
    : public TAO::Upcall_Command
  {
  public:
    inline bind_StreamCtrl (
      POA_AVStreams::StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::StreamEndPoint_A>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::StreamEndPoint_A> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::StreamEndPoint_B>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::StreamEndPoint_B> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_3 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          4);
        
      retval =
        this->servant_->bind (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }
  
  private:
    POA_AVStreams::StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamCtrl::bind_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 3;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::StreamEndPoint_A>::in_arg_val _tao_a_party;
  TAO::SArg_Traits< ::AVStreams::StreamEndPoint_B>::in_arg_val _tao_b_party;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_flows;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_a_party,
      &_tao_b_party,
      &_tao_the_qos,
      &_tao_the_flows
    };
  
  static size_t const nargs = 5;

  POA_AVStreams::StreamCtrl * const impl =
    static_cast<POA_AVStreams::StreamCtrl *> (servant);

  bind_StreamCtrl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class unbind_dev_StreamCtrl
    : public TAO::Upcall_Command
  {
  public:
    inline unbind_dev_StreamCtrl (
      POA_AVStreams::StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::MMDevice>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::MMDevice> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->unbind_dev (
        arg_1
        , arg_2);
    }
  
  private:
    POA_AVStreams::StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamCtrl::unbind_dev_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_noSuchFlow
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::MMDevice>::in_arg_val _tao_dev;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_dev,
      &_tao_the_spec
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::StreamCtrl * const impl =
    static_cast<POA_AVStreams::StreamCtrl *> (servant);

  unbind_dev_StreamCtrl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class unbind_party_StreamCtrl
    : public TAO::Upcall_Command
  {
  public:
    inline unbind_party_StreamCtrl (
      POA_AVStreams::StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::StreamEndPoint>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::StreamEndPoint> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->unbind_party (
        arg_1
        , arg_2);
    }
  
  private:
    POA_AVStreams::StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamCtrl::unbind_party_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_noSuchFlow
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::StreamEndPoint>::in_arg_val _tao_the_ep;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_ep,
      &_tao_the_spec
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::StreamCtrl * const impl =
    static_cast<POA_AVStreams::StreamCtrl *> (servant);

  unbind_party_StreamCtrl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class unbind_StreamCtrl
    : public TAO::Upcall_Command
  {
  public:
    inline unbind_StreamCtrl (
      POA_AVStreams::StreamCtrl * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->unbind ();
    }
  
  private:
    POA_AVStreams::StreamCtrl * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamCtrl::unbind_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::StreamCtrl * const impl =
    static_cast<POA_AVStreams::StreamCtrl *> (servant);

  unbind_StreamCtrl command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_related_vdev_StreamCtrl
    : public TAO::Upcall_Command
  {
  public:
    inline get_related_vdev_StreamCtrl (
      POA_AVStreams::StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::VDev>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::AVStreams::VDev> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::MMDevice>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::MMDevice> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::StreamEndPoint>::out_arg_type arg_2 =
        TAO::Portable_Server::get_out_arg< ::AVStreams::StreamEndPoint> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->get_related_vdev (
          arg_1
          , arg_2);
    }
  
  private:
    POA_AVStreams::StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamCtrl::get_related_vdev_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::AVStreams::VDev>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::MMDevice>::in_arg_val _tao_adev;
  TAO::SArg_Traits< ::AVStreams::StreamEndPoint>::out_arg_val _tao_sep;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_adev,
      &_tao_sep
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::StreamCtrl * const impl =
    static_cast<POA_AVStreams::StreamCtrl *> (servant);

  get_related_vdev_StreamCtrl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_StreamCtrl_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_StreamCtrl_Upcall_Command (
      POA_AVStreams::StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamCtrl::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::StreamCtrl * const impl =
    static_cast<POA_AVStreams::StreamCtrl *> (servant);
  
  _is_a_StreamCtrl_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_StreamCtrl_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_StreamCtrl_Upcall_Command (
      POA_AVStreams::StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamCtrl::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::StreamCtrl * const impl =
    static_cast<POA_AVStreams::StreamCtrl *> (servant);
  
  _non_existent_StreamCtrl_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_StreamCtrl_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_StreamCtrl_Upcall_Command (
      POA_AVStreams::StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamCtrl::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::StreamCtrl * const impl =
    static_cast<POA_AVStreams::StreamCtrl *> (servant);
  
  _repository_id_StreamCtrl_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::StreamCtrl::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::StreamCtrl * const impl =
    static_cast<POA_AVStreams::StreamCtrl *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_StreamCtrl_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_StreamCtrl_Upcall_Command (
      POA_AVStreams::StreamCtrl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::StreamCtrl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamCtrl::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::StreamCtrl * const impl =
    static_cast<POA_AVStreams::StreamCtrl *> (servant);
  
  _get_component_StreamCtrl_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::StreamCtrl::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/Basic_StreamCtrl:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/StreamCtrl:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::StreamCtrl::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/StreamCtrl:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::StreamCtrl::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::StreamCtrl *
POA_AVStreams::StreamCtrl::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::StreamCtrl STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_StreamCtrl_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_MCastConfigIf_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_MCastConfigIf_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_MCastConfigIf_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 10, 41, 25, 41, 20,
      0, 10, 41,  5, 41, 15, 41, 41, 41, 41,
     10, 41, 41, 41,  0,  0,  5, 41, 41, 41,
     41,  5, 41, 41, 41, 41, 41, 41,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_MCastConfigIf_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 21,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 25,
      MIN_HASH_VALUE = 8,
      MAX_HASH_VALUE = 40,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 3,
      WORDLIST_SIZE = 29
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"set_peer", &POA_AVStreams::MCastConfigIf::set_peer_skel, 0},
      {"set_dev_params", &POA_AVStreams::MCastConfigIf::set_dev_params_skel, 0},
      {"set_format", &POA_AVStreams::MCastConfigIf::set_format_skel, 0},
      {"define_properties", &POA_AVStreams::MCastConfigIf::define_properties_skel, 0},
      {"delete_properties", &POA_AVStreams::MCastConfigIf::delete_properties_skel, 0},
      {"get_properties", &POA_AVStreams::MCastConfigIf::get_properties_skel, 0},
      {"define_property", &POA_AVStreams::MCastConfigIf::define_property_skel, 0},
      {"delete_property", &POA_AVStreams::MCastConfigIf::delete_property_skel, 0},
      {"delete_all_properties", &POA_AVStreams::MCastConfigIf::delete_all_properties_skel, 0},
      {"get_all_properties", &POA_AVStreams::MCastConfigIf::get_all_properties_skel, 0},
      {"_repository_id", &POA_AVStreams::MCastConfigIf::_repository_id_skel, 0},
      {"_component", &POA_AVStreams::MCastConfigIf::_component_skel, 0},
      {"get_all_property_names", &POA_AVStreams::MCastConfigIf::get_all_property_names_skel, 0},
      {"_non_existent", &POA_AVStreams::MCastConfigIf::_non_existent_skel, 0},
      {"get_number_of_properties", &POA_AVStreams::MCastConfigIf::get_number_of_properties_skel, 0},
      {"_interface", &POA_AVStreams::MCastConfigIf::_interface_skel, 0},
      {"get_property_value", &POA_AVStreams::MCastConfigIf::get_property_value_skel, 0},
      {"is_property_defined", &POA_AVStreams::MCastConfigIf::is_property_defined_skel, 0},
      {"set_initial_configuration", &POA_AVStreams::MCastConfigIf::set_initial_configuration_skel, 0},
      {"configure", &POA_AVStreams::MCastConfigIf::configure_skel, 0},
      {"_is_a", &POA_AVStreams::MCastConfigIf::_is_a_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,   8,  -1, -11,  -2, -14,  -2, 
        9,  10,  -1, -47,  -1,  13, -48,  16,  -1,  17,  18,  19,  -1,  20, 
       21,  22,  23,  -1,  -1,  24,  25,  26,  -1,  -1,  -1,  27,  28, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_AVStreams_MCastConfigIf_Perfect_Hash_OpTable tao_AVStreams_MCastConfigIf_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_MCastConfigIf_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_MCastConfigIf_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_MCastConfigIf_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_MCastConfigIf_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_MCastConfigIf_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_MCastConfigIf_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_MCastConfigIf_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::MCastConfigIf::MCastConfigIf (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_MCastConfigIf_optable;
}

POA_AVStreams::MCastConfigIf::MCastConfigIf (const MCastConfigIf& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CosPropertyService::PropertySet (rhs)
{
}

POA_AVStreams::MCastConfigIf::~MCastConfigIf (void)
{
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_peer_MCastConfigIf
    : public TAO::Upcall_Command
  {
  public:
    inline set_peer_MCastConfigIf (
      POA_AVStreams::MCastConfigIf * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Object>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_2 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          3);
        
      retval =
        this->servant_->set_peer (
          arg_1
          , arg_2
          , arg_3);
    }
  
  private:
    POA_AVStreams::MCastConfigIf * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MCastConfigIf::set_peer_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_QoSRequestFailed,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Object>::in_arg_val _tao_peer;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_peer,
      &_tao_the_qos,
      &_tao_the_spec
    };
  
  static size_t const nargs = 4;

  POA_AVStreams::MCastConfigIf * const impl =
    static_cast<POA_AVStreams::MCastConfigIf *> (servant);

  set_peer_MCastConfigIf command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class configure_MCastConfigIf
    : public TAO::Upcall_Command
  {
  public:
    inline configure_MCastConfigIf (
      POA_AVStreams::MCastConfigIf * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosPropertyService::Property>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CosPropertyService::Property> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->configure (
        arg_1);
    }
  
  private:
    POA_AVStreams::MCastConfigIf * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MCastConfigIf::configure_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CosPropertyService::Property>::in_arg_val _tao_a_configuration;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_a_configuration
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::MCastConfigIf * const impl =
    static_cast<POA_AVStreams::MCastConfigIf *> (servant);

  configure_MCastConfigIf command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_initial_configuration_MCastConfigIf
    : public TAO::Upcall_Command
  {
  public:
    inline set_initial_configuration_MCastConfigIf (
      POA_AVStreams::MCastConfigIf * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosPropertyService::Properties>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CosPropertyService::Properties> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->set_initial_configuration (
        arg_1);
    }
  
  private:
    POA_AVStreams::MCastConfigIf * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MCastConfigIf::set_initial_configuration_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CosPropertyService::Properties>::in_arg_val _tao_initial;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_initial
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::MCastConfigIf * const impl =
    static_cast<POA_AVStreams::MCastConfigIf *> (servant);

  set_initial_configuration_MCastConfigIf command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_format_MCastConfigIf
    : public TAO::Upcall_Command
  {
  public:
    inline set_format_MCastConfigIf (
      POA_AVStreams::MCastConfigIf * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->set_format (
        arg_1
        , arg_2);
    }
  
  private:
    POA_AVStreams::MCastConfigIf * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MCastConfigIf::set_format_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_notSupported
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_flowName;
  TAO::SArg_Traits< char *>::in_arg_val _tao_format_name;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flowName,
      &_tao_format_name
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::MCastConfigIf * const impl =
    static_cast<POA_AVStreams::MCastConfigIf *> (servant);

  set_format_MCastConfigIf command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_dev_params_MCastConfigIf
    : public TAO::Upcall_Command
  {
  public:
    inline set_dev_params_MCastConfigIf (
      POA_AVStreams::MCastConfigIf * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CosPropertyService::Properties>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CosPropertyService::Properties> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->set_dev_params (
        arg_1
        , arg_2);
    }
  
  private:
    POA_AVStreams::MCastConfigIf * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MCastConfigIf::set_dev_params_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_PropertyException,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_flowName;
  TAO::SArg_Traits< ::CosPropertyService::Properties>::in_arg_val _tao_new_params;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flowName,
      &_tao_new_params
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::MCastConfigIf * const impl =
    static_cast<POA_AVStreams::MCastConfigIf *> (servant);

  set_dev_params_MCastConfigIf command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_MCastConfigIf_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_MCastConfigIf_Upcall_Command (
      POA_AVStreams::MCastConfigIf * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::MCastConfigIf * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::MCastConfigIf::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::MCastConfigIf * const impl =
    static_cast<POA_AVStreams::MCastConfigIf *> (servant);
  
  _is_a_MCastConfigIf_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_MCastConfigIf_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_MCastConfigIf_Upcall_Command (
      POA_AVStreams::MCastConfigIf * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::MCastConfigIf * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::MCastConfigIf::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::MCastConfigIf * const impl =
    static_cast<POA_AVStreams::MCastConfigIf *> (servant);
  
  _non_existent_MCastConfigIf_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_MCastConfigIf_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_MCastConfigIf_Upcall_Command (
      POA_AVStreams::MCastConfigIf * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::MCastConfigIf * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::MCastConfigIf::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::MCastConfigIf * const impl =
    static_cast<POA_AVStreams::MCastConfigIf *> (servant);
  
  _repository_id_MCastConfigIf_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::MCastConfigIf::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::MCastConfigIf * const impl =
    static_cast<POA_AVStreams::MCastConfigIf *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_MCastConfigIf_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_MCastConfigIf_Upcall_Command (
      POA_AVStreams::MCastConfigIf * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::MCastConfigIf * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::MCastConfigIf::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::MCastConfigIf * const impl =
    static_cast<POA_AVStreams::MCastConfigIf *> (servant);
  
  _get_component_MCastConfigIf_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::MCastConfigIf::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/MCastConfigIf:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::MCastConfigIf::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/MCastConfigIf:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::MCastConfigIf::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::MCastConfigIf *
POA_AVStreams::MCastConfigIf::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::MCastConfigIf STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_MCastConfigIf_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_StreamEndPoint_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_StreamEndPoint_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_StreamEndPoint_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56,  0, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 15, 56, 10, 56,  0,
     10, 20, 56,  0, 56, 15, 56, 56, 56,  0,
     10, 56, 25, 56,  5,  0,  0, 56, 56, 56,
     56, 30, 56, 56, 56, 56, 56, 56,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_StreamEndPoint_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 31,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 24,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 55,
      HASH_VALUE_RANGE = 51,
      DUPLICATES = 3,
      WORDLIST_SIZE = 36
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"start", &POA_AVStreams::StreamEndPoint::start_skel, 0},
      {"connect", &POA_AVStreams::StreamEndPoint::connect_skel, 0},
      {"modify_QoS", &POA_AVStreams::StreamEndPoint::modify_QoS_skel, 0},
      {"set_FPStatus", &POA_AVStreams::StreamEndPoint::set_FPStatus_skel, 0},
      {"get_properties", &POA_AVStreams::StreamEndPoint::get_properties_skel, 0},
      {"get_all_properties", &POA_AVStreams::StreamEndPoint::get_all_properties_skel, 0},
      {"set_negotiator", &POA_AVStreams::StreamEndPoint::set_negotiator_skel, 0},
      {"disconnect", &POA_AVStreams::StreamEndPoint::disconnect_skel, 0},
      {"get_all_property_names", &POA_AVStreams::StreamEndPoint::get_all_property_names_skel, 0},
      {"set_source_id", &POA_AVStreams::StreamEndPoint::set_source_id_skel, 0},
      {"get_number_of_properties", &POA_AVStreams::StreamEndPoint::get_number_of_properties_skel, 0},
      {"_component", &POA_AVStreams::StreamEndPoint::_component_skel, 0},
      {"define_properties", &POA_AVStreams::StreamEndPoint::define_properties_skel, 0},
      {"delete_properties", &POA_AVStreams::StreamEndPoint::delete_properties_skel, 0},
      {"_non_existent", &POA_AVStreams::StreamEndPoint::_non_existent_skel, 0},
      {"stop", &POA_AVStreams::StreamEndPoint::stop_skel, 0},
      {"_is_a", &POA_AVStreams::StreamEndPoint::_is_a_skel, 0},
      {"delete_all_properties", &POA_AVStreams::StreamEndPoint::delete_all_properties_skel, 0},
      {"get_fep", &POA_AVStreams::StreamEndPoint::get_fep_skel, 0},
      {"request_connection", &POA_AVStreams::StreamEndPoint::request_connection_skel, 0},
      {"set_protocol_restriction", &POA_AVStreams::StreamEndPoint::set_protocol_restriction_skel, 0},
      {"set_key", &POA_AVStreams::StreamEndPoint::set_key_skel, 0},
      {"get_property_value", &POA_AVStreams::StreamEndPoint::get_property_value_skel, 0},
      {"_repository_id", &POA_AVStreams::StreamEndPoint::_repository_id_skel, 0},
      {"remove_fep", &POA_AVStreams::StreamEndPoint::remove_fep_skel, 0},
      {"add_fep", &POA_AVStreams::StreamEndPoint::add_fep_skel, 0},
      {"is_property_defined", &POA_AVStreams::StreamEndPoint::is_property_defined_skel, 0},
      {"_interface", &POA_AVStreams::StreamEndPoint::_interface_skel, 0},
      {"destroy", &POA_AVStreams::StreamEndPoint::destroy_skel, 0},
      {"define_property", &POA_AVStreams::StreamEndPoint::define_property_skel, 0},
      {"delete_property", &POA_AVStreams::StreamEndPoint::delete_property_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -1,  -1,   7,  -1,   8,  -1, 
        9,  -1, -17,  -2,  10,  11,  12,  -1,  13,  14,  15,  16,  -1, -66, 
       19,  20,  21,  22,  23,  24,  25,  -1,  -1,  26,  27,  28,  29,  -1, 
       30,  -1,  31,  32,  -1,  33,  -1,  -1,  -1,  -1,  -1, -34,  -2, -57, 
      
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_AVStreams_StreamEndPoint_Perfect_Hash_OpTable tao_AVStreams_StreamEndPoint_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_StreamEndPoint_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_StreamEndPoint_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_StreamEndPoint_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_StreamEndPoint_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_StreamEndPoint_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_StreamEndPoint_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_StreamEndPoint_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::StreamEndPoint::StreamEndPoint (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_StreamEndPoint_optable;
}

POA_AVStreams::StreamEndPoint::StreamEndPoint (const StreamEndPoint& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CosPropertyService::PropertySet (rhs)
{
}

POA_AVStreams::StreamEndPoint::~StreamEndPoint (void)
{
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class stop_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline stop_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->stop (
        arg_1);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::stop_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_spec
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  stop_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class start_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline start_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->start (
        arg_1);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::start_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_spec
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  start_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class destroy_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline destroy_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->destroy (
        arg_1);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::destroy_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_spec
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  destroy_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class connect_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline connect_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::StreamEndPoint>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::StreamEndPoint> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_2 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          3);
        
      retval =
        this->servant_->connect (
          arg_1
          , arg_2
          , arg_3);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::connect_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_QoSRequestFailed,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 3;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::StreamEndPoint>::in_arg_val _tao_responder;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_qos_spec;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_responder,
      &_tao_qos_spec,
      &_tao_the_spec
    };
  
  static size_t const nargs = 4;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  connect_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class request_connection_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline request_connection_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::StreamEndPoint>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::StreamEndPoint> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_3 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::inout_arg_type arg_4 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          4);
        
      retval =
        this->servant_->request_connection (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::request_connection_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpDenied,
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_QoSRequestFailed,
      AVStreams::_tc_FPError
    };
  static ::CORBA::ULong const nexceptions = 4;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::StreamEndPoint>::in_arg_val _tao_initiator;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_mcast;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_qos;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::inout_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_initiator,
      &_tao_is_mcast,
      &_tao_qos,
      &_tao_the_spec
    };
  
  static size_t const nargs = 5;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  request_connection_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class modify_QoS_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline modify_QoS_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_1 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->modify_QoS (
          arg_1
          , arg_2);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::modify_QoS_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_new_qos;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_flows;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_new_qos,
      &_tao_the_flows
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  modify_QoS_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_protocol_restriction_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline set_protocol_restriction_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::protocolSpec>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::protocolSpec> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->set_protocol_restriction (
          arg_1);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::set_protocol_restriction_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::protocolSpec>::in_arg_val _tao_the_pspec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_pspec
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  set_protocol_restriction_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class disconnect_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline disconnect_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->disconnect (
        arg_1);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::disconnect_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_spec
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  disconnect_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_FPStatus_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline set_FPStatus_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Any>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Any> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->set_FPStatus (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::set_FPStatus_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_FPError
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;
  TAO::SArg_Traits< char *>::in_arg_val _tao_fp_name;
  TAO::SArg_Traits< ::CORBA::Any>::in_arg_val _tao_fp_settings;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_spec,
      &_tao_fp_name,
      &_tao_fp_settings
    };
  
  static size_t const nargs = 4;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  set_FPStatus_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_fep_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline get_fep_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->get_fep (
          arg_1);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::get_fep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_notSupported,
      AVStreams::_tc_noSuchFlow
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_flow_name;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flow_name
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  get_fep_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class add_fep_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline add_fep_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Object>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->add_fep (
          arg_1);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::add_fep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_notSupported,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Object>::in_arg_val _tao_the_fep;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_fep
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  add_fep_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class remove_fep_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline remove_fep_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->remove_fep (
        arg_1);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::remove_fep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_notSupported,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_fep_name;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_fep_name
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  remove_fep_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_negotiator_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline set_negotiator_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::Negotiator>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::Negotiator> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->set_negotiator (
        arg_1);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::set_negotiator_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::Negotiator>::in_arg_val _tao_new_negotiator;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_new_negotiator
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  set_negotiator_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_key_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline set_key_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::key>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::key> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->set_key (
        arg_1
        , arg_2);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::set_key_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_flow_name;
  TAO::SArg_Traits< ::AVStreams::key>::in_arg_val _tao_the_key;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flow_name,
      &_tao_the_key
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  set_key_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_source_id_StreamEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline set_source_id_StreamEndPoint (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->set_source_id (
        arg_1);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint::set_source_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_source_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_source_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);

  set_source_id_StreamEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_StreamEndPoint_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_StreamEndPoint_Upcall_Command (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamEndPoint::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);
  
  _is_a_StreamEndPoint_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_StreamEndPoint_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_StreamEndPoint_Upcall_Command (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamEndPoint::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);
  
  _non_existent_StreamEndPoint_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_StreamEndPoint_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_StreamEndPoint_Upcall_Command (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamEndPoint::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);
  
  _repository_id_StreamEndPoint_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::StreamEndPoint::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_StreamEndPoint_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_StreamEndPoint_Upcall_Command (
      POA_AVStreams::StreamEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::StreamEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamEndPoint::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::StreamEndPoint * const impl =
    static_cast<POA_AVStreams::StreamEndPoint *> (servant);
  
  _get_component_StreamEndPoint_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::StreamEndPoint::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/StreamEndPoint:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::StreamEndPoint::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/StreamEndPoint:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::StreamEndPoint::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::StreamEndPoint *
POA_AVStreams::StreamEndPoint::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::StreamEndPoint STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_StreamEndPoint_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_StreamEndPoint_A_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_StreamEndPoint_A_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_StreamEndPoint_A_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
     63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
     63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
     63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
     63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
     63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
     63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
     63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
     63, 63, 63,  0, 63, 63, 63, 63, 63, 63,
     63, 63, 63, 63, 63, 15, 63, 30, 63,  4,
     10, 20,  5,  0, 63, 15, 63, 63, 63,  5,
     10, 63, 25, 63,  5,  0,  0, 63, 63, 63,
     63, 30, 63, 63, 63, 63, 63, 63,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_StreamEndPoint_A_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 34,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 24,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 62,
      HASH_VALUE_RANGE = 58,
      DUPLICATES = 3,
      WORDLIST_SIZE = 39
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"start", &POA_AVStreams::StreamEndPoint_A::start_skel, 0},
      {"connect", &POA_AVStreams::StreamEndPoint_A::connect_skel, 0},
      {"set_FPStatus", &POA_AVStreams::StreamEndPoint_A::set_FPStatus_skel, 0},
      {"get_properties", &POA_AVStreams::StreamEndPoint_A::get_properties_skel, 0},
      {"modify_QoS", &POA_AVStreams::StreamEndPoint_A::modify_QoS_skel, 0},
      {"multiconnect", &POA_AVStreams::StreamEndPoint_A::multiconnect_skel, 0},
      {"get_all_properties", &POA_AVStreams::StreamEndPoint_A::get_all_properties_skel, 0},
      {"set_negotiator", &POA_AVStreams::StreamEndPoint_A::set_negotiator_skel, 0},
      {"disconnect", &POA_AVStreams::StreamEndPoint_A::disconnect_skel, 0},
      {"connect_leaf", &POA_AVStreams::StreamEndPoint_A::connect_leaf_skel, 0},
      {"get_all_property_names", &POA_AVStreams::StreamEndPoint_A::get_all_property_names_skel, 0},
      {"set_source_id", &POA_AVStreams::StreamEndPoint_A::set_source_id_skel, 0},
      {"get_number_of_properties", &POA_AVStreams::StreamEndPoint_A::get_number_of_properties_skel, 0},
      {"_component", &POA_AVStreams::StreamEndPoint_A::_component_skel, 0},
      {"define_properties", &POA_AVStreams::StreamEndPoint_A::define_properties_skel, 0},
      {"delete_properties", &POA_AVStreams::StreamEndPoint_A::delete_properties_skel, 0},
      {"_non_existent", &POA_AVStreams::StreamEndPoint_A::_non_existent_skel, 0},
      {"stop", &POA_AVStreams::StreamEndPoint_A::stop_skel, 0},
      {"disconnect_leaf", &POA_AVStreams::StreamEndPoint_A::disconnect_leaf_skel, 0},
      {"delete_all_properties", &POA_AVStreams::StreamEndPoint_A::delete_all_properties_skel, 0},
      {"get_fep", &POA_AVStreams::StreamEndPoint_A::get_fep_skel, 0},
      {"request_connection", &POA_AVStreams::StreamEndPoint_A::request_connection_skel, 0},
      {"set_protocol_restriction", &POA_AVStreams::StreamEndPoint_A::set_protocol_restriction_skel, 0},
      {"set_key", &POA_AVStreams::StreamEndPoint_A::set_key_skel, 0},
      {"get_property_value", &POA_AVStreams::StreamEndPoint_A::get_property_value_skel, 0},
      {"_repository_id", &POA_AVStreams::StreamEndPoint_A::_repository_id_skel, 0},
      {"remove_fep", &POA_AVStreams::StreamEndPoint_A::remove_fep_skel, 0},
      {"is_property_defined", &POA_AVStreams::StreamEndPoint_A::is_property_defined_skel, 0},
      {"_interface", &POA_AVStreams::StreamEndPoint_A::_interface_skel, 0},
      {"destroy", &POA_AVStreams::StreamEndPoint_A::destroy_skel, 0},
      {"_is_a", &POA_AVStreams::StreamEndPoint_A::_is_a_skel, 0},
      {"define_property", &POA_AVStreams::StreamEndPoint_A::define_property_skel, 0},
      {"delete_property", &POA_AVStreams::StreamEndPoint_A::delete_property_skel, 0},
      {"add_fep", &POA_AVStreams::StreamEndPoint_A::add_fep_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,  -1,  -1, -19,  -2,   6,   7,  -1, 
        8,   9,  -1,  10,  11,  12,  13,  14,  15,  16,  17,  18,  -1, -80, 
       21,  22,  23,  24,  25,  26,  27,  -1,  -1,  28,  29,  30,  31,  -1, 
       -1,  -1,  32,  33,  -1,  34,  -1,  -1,  35,  -1,  -1, -36,  -2, -64, 
       -1,  -1,  -1,  -1,  -1,  -1,  38, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_AVStreams_StreamEndPoint_A_Perfect_Hash_OpTable tao_AVStreams_StreamEndPoint_A_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_StreamEndPoint_A_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_StreamEndPoint_A_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_StreamEndPoint_A_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_StreamEndPoint_A_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_StreamEndPoint_A_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_StreamEndPoint_A_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_StreamEndPoint_A_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::StreamEndPoint_A::StreamEndPoint_A (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_StreamEndPoint_A_optable;
}

POA_AVStreams::StreamEndPoint_A::StreamEndPoint_A (const StreamEndPoint_A& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CosPropertyService::PropertySet (rhs),
    POA_AVStreams::StreamEndPoint (rhs)
{
}

POA_AVStreams::StreamEndPoint_A::~StreamEndPoint_A (void)
{
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class multiconnect_StreamEndPoint_A
    : public TAO::Upcall_Command
  {
  public:
    inline multiconnect_StreamEndPoint_A (
      POA_AVStreams::StreamEndPoint_A * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_1 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::inout_arg_type arg_2 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->multiconnect (
          arg_1
          , arg_2);
    }
  
  private:
    POA_AVStreams::StreamEndPoint_A * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint_A::multiconnect_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_QoSRequestFailed,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 3;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::inout_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_qos,
      &_tao_the_spec
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::StreamEndPoint_A * const impl =
    static_cast<POA_AVStreams::StreamEndPoint_A *> (servant);

  multiconnect_StreamEndPoint_A command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class connect_leaf_StreamEndPoint_A
    : public TAO::Upcall_Command
  {
  public:
    inline connect_leaf_StreamEndPoint_A (
      POA_AVStreams::StreamEndPoint_A * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::StreamEndPoint_B>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::StreamEndPoint_B> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_2 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          3);
        
      retval =
        this->servant_->connect_leaf (
          arg_1
          , arg_2
          , arg_3);
    }
  
  private:
    POA_AVStreams::StreamEndPoint_A * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint_A::connect_leaf_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_QoSRequestFailed,
      AVStreams::_tc_notSupported
    };
  static ::CORBA::ULong const nexceptions = 4;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::StreamEndPoint_B>::in_arg_val _tao_the_ep;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_flows;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_ep,
      &_tao_the_qos,
      &_tao_the_flows
    };
  
  static size_t const nargs = 4;

  POA_AVStreams::StreamEndPoint_A * const impl =
    static_cast<POA_AVStreams::StreamEndPoint_A *> (servant);

  connect_leaf_StreamEndPoint_A command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class disconnect_leaf_StreamEndPoint_A
    : public TAO::Upcall_Command
  {
  public:
    inline disconnect_leaf_StreamEndPoint_A (
      POA_AVStreams::StreamEndPoint_A * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::StreamEndPoint_B>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::StreamEndPoint_B> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->disconnect_leaf (
        arg_1
        , arg_2);
    }
  
  private:
    POA_AVStreams::StreamEndPoint_A * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint_A::disconnect_leaf_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_notSupported
    };
  static ::CORBA::ULong const nexceptions = 3;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::StreamEndPoint_B>::in_arg_val _tao_the_ep;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_theSpec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_ep,
      &_tao_theSpec
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::StreamEndPoint_A * const impl =
    static_cast<POA_AVStreams::StreamEndPoint_A *> (servant);

  disconnect_leaf_StreamEndPoint_A command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_StreamEndPoint_A_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_StreamEndPoint_A_Upcall_Command (
      POA_AVStreams::StreamEndPoint_A * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::StreamEndPoint_A * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamEndPoint_A::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::StreamEndPoint_A * const impl =
    static_cast<POA_AVStreams::StreamEndPoint_A *> (servant);
  
  _is_a_StreamEndPoint_A_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_StreamEndPoint_A_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_StreamEndPoint_A_Upcall_Command (
      POA_AVStreams::StreamEndPoint_A * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::StreamEndPoint_A * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamEndPoint_A::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::StreamEndPoint_A * const impl =
    static_cast<POA_AVStreams::StreamEndPoint_A *> (servant);
  
  _non_existent_StreamEndPoint_A_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_StreamEndPoint_A_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_StreamEndPoint_A_Upcall_Command (
      POA_AVStreams::StreamEndPoint_A * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::StreamEndPoint_A * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamEndPoint_A::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::StreamEndPoint_A * const impl =
    static_cast<POA_AVStreams::StreamEndPoint_A *> (servant);
  
  _repository_id_StreamEndPoint_A_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::StreamEndPoint_A::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::StreamEndPoint_A * const impl =
    static_cast<POA_AVStreams::StreamEndPoint_A *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_StreamEndPoint_A_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_StreamEndPoint_A_Upcall_Command (
      POA_AVStreams::StreamEndPoint_A * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::StreamEndPoint_A * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamEndPoint_A::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::StreamEndPoint_A * const impl =
    static_cast<POA_AVStreams::StreamEndPoint_A *> (servant);
  
  _get_component_StreamEndPoint_A_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::StreamEndPoint_A::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/StreamEndPoint:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/StreamEndPoint_A:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::StreamEndPoint_A::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/StreamEndPoint_A:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::StreamEndPoint_A::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::StreamEndPoint_A *
POA_AVStreams::StreamEndPoint_A::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::StreamEndPoint_A STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_StreamEndPoint_A_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_StreamEndPoint_B_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_StreamEndPoint_B_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_StreamEndPoint_B_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
     56, 56, 56,  0, 56, 56, 56, 56, 56, 56,
     56, 56, 56, 56, 56, 15, 56, 10, 56,  0,
     10, 20, 56,  0, 56, 15, 56, 56, 56,  5,
     10, 56, 25, 56,  5,  0,  0, 56, 56, 56,
     56, 30, 56, 56, 56, 56, 56, 56,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_StreamEndPoint_B_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 32,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 24,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 55,
      HASH_VALUE_RANGE = 51,
      DUPLICATES = 3,
      WORDLIST_SIZE = 37
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"start", &POA_AVStreams::StreamEndPoint_B::start_skel, 0},
      {"connect", &POA_AVStreams::StreamEndPoint_B::connect_skel, 0},
      {"set_FPStatus", &POA_AVStreams::StreamEndPoint_B::set_FPStatus_skel, 0},
      {"get_properties", &POA_AVStreams::StreamEndPoint_B::get_properties_skel, 0},
      {"modify_QoS", &POA_AVStreams::StreamEndPoint_B::modify_QoS_skel, 0},
      {"multiconnect", &POA_AVStreams::StreamEndPoint_B::multiconnect_skel, 0},
      {"get_all_properties", &POA_AVStreams::StreamEndPoint_B::get_all_properties_skel, 0},
      {"set_negotiator", &POA_AVStreams::StreamEndPoint_B::set_negotiator_skel, 0},
      {"disconnect", &POA_AVStreams::StreamEndPoint_B::disconnect_skel, 0},
      {"get_all_property_names", &POA_AVStreams::StreamEndPoint_B::get_all_property_names_skel, 0},
      {"set_source_id", &POA_AVStreams::StreamEndPoint_B::set_source_id_skel, 0},
      {"get_number_of_properties", &POA_AVStreams::StreamEndPoint_B::get_number_of_properties_skel, 0},
      {"_component", &POA_AVStreams::StreamEndPoint_B::_component_skel, 0},
      {"define_properties", &POA_AVStreams::StreamEndPoint_B::define_properties_skel, 0},
      {"delete_properties", &POA_AVStreams::StreamEndPoint_B::delete_properties_skel, 0},
      {"_non_existent", &POA_AVStreams::StreamEndPoint_B::_non_existent_skel, 0},
      {"stop", &POA_AVStreams::StreamEndPoint_B::stop_skel, 0},
      {"_is_a", &POA_AVStreams::StreamEndPoint_B::_is_a_skel, 0},
      {"delete_all_properties", &POA_AVStreams::StreamEndPoint_B::delete_all_properties_skel, 0},
      {"get_fep", &POA_AVStreams::StreamEndPoint_B::get_fep_skel, 0},
      {"request_connection", &POA_AVStreams::StreamEndPoint_B::request_connection_skel, 0},
      {"set_protocol_restriction", &POA_AVStreams::StreamEndPoint_B::set_protocol_restriction_skel, 0},
      {"set_key", &POA_AVStreams::StreamEndPoint_B::set_key_skel, 0},
      {"get_property_value", &POA_AVStreams::StreamEndPoint_B::get_property_value_skel, 0},
      {"_repository_id", &POA_AVStreams::StreamEndPoint_B::_repository_id_skel, 0},
      {"remove_fep", &POA_AVStreams::StreamEndPoint_B::remove_fep_skel, 0},
      {"add_fep", &POA_AVStreams::StreamEndPoint_B::add_fep_skel, 0},
      {"is_property_defined", &POA_AVStreams::StreamEndPoint_B::is_property_defined_skel, 0},
      {"_interface", &POA_AVStreams::StreamEndPoint_B::_interface_skel, 0},
      {"destroy", &POA_AVStreams::StreamEndPoint_B::destroy_skel, 0},
      {"define_property", &POA_AVStreams::StreamEndPoint_B::define_property_skel, 0},
      {"delete_property", &POA_AVStreams::StreamEndPoint_B::delete_property_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -1,  -1, -18,  -2,   7,  -1, 
        8,   9,  -1,  10,  11,  12,  13,  -1,  14,  15,  16,  17,  -1, -72, 
       20,  21,  22,  23,  24,  25,  26,  -1,  -1,  27,  28,  29,  30,  -1, 
       31,  -1,  32,  33,  -1,  34,  -1,  -1,  -1,  -1,  -1, -35,  -2, -57, 
      
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_AVStreams_StreamEndPoint_B_Perfect_Hash_OpTable tao_AVStreams_StreamEndPoint_B_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_StreamEndPoint_B_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_StreamEndPoint_B_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_StreamEndPoint_B_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_StreamEndPoint_B_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_StreamEndPoint_B_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_StreamEndPoint_B_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_StreamEndPoint_B_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::StreamEndPoint_B::StreamEndPoint_B (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_StreamEndPoint_B_optable;
}

POA_AVStreams::StreamEndPoint_B::StreamEndPoint_B (const StreamEndPoint_B& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CosPropertyService::PropertySet (rhs),
    POA_AVStreams::StreamEndPoint (rhs)
{
}

POA_AVStreams::StreamEndPoint_B::~StreamEndPoint_B (void)
{
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class multiconnect_StreamEndPoint_B
    : public TAO::Upcall_Command
  {
  public:
    inline multiconnect_StreamEndPoint_B (
      POA_AVStreams::StreamEndPoint_B * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_1 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::inout_arg_type arg_2 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->multiconnect (
          arg_1
          , arg_2);
    }
  
  private:
    POA_AVStreams::StreamEndPoint_B * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::StreamEndPoint_B::multiconnect_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_QoSRequestFailed,
      AVStreams::_tc_FPError
    };
  static ::CORBA::ULong const nexceptions = 4;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::inout_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_qos,
      &_tao_the_spec
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::StreamEndPoint_B * const impl =
    static_cast<POA_AVStreams::StreamEndPoint_B *> (servant);

  multiconnect_StreamEndPoint_B command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_StreamEndPoint_B_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_StreamEndPoint_B_Upcall_Command (
      POA_AVStreams::StreamEndPoint_B * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::StreamEndPoint_B * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamEndPoint_B::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::StreamEndPoint_B * const impl =
    static_cast<POA_AVStreams::StreamEndPoint_B *> (servant);
  
  _is_a_StreamEndPoint_B_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_StreamEndPoint_B_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_StreamEndPoint_B_Upcall_Command (
      POA_AVStreams::StreamEndPoint_B * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::StreamEndPoint_B * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamEndPoint_B::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::StreamEndPoint_B * const impl =
    static_cast<POA_AVStreams::StreamEndPoint_B *> (servant);
  
  _non_existent_StreamEndPoint_B_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_StreamEndPoint_B_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_StreamEndPoint_B_Upcall_Command (
      POA_AVStreams::StreamEndPoint_B * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::StreamEndPoint_B * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamEndPoint_B::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::StreamEndPoint_B * const impl =
    static_cast<POA_AVStreams::StreamEndPoint_B *> (servant);
  
  _repository_id_StreamEndPoint_B_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::StreamEndPoint_B::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::StreamEndPoint_B * const impl =
    static_cast<POA_AVStreams::StreamEndPoint_B *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_StreamEndPoint_B_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_StreamEndPoint_B_Upcall_Command (
      POA_AVStreams::StreamEndPoint_B * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::StreamEndPoint_B * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::StreamEndPoint_B::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::StreamEndPoint_B * const impl =
    static_cast<POA_AVStreams::StreamEndPoint_B *> (servant);
  
  _get_component_StreamEndPoint_B_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::StreamEndPoint_B::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/StreamEndPoint:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/StreamEndPoint_B:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::StreamEndPoint_B::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/StreamEndPoint_B:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::StreamEndPoint_B::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::StreamEndPoint_B *
POA_AVStreams::StreamEndPoint_B::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::StreamEndPoint_B STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_StreamEndPoint_B_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_VDev_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_VDev_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_VDev_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
     45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
     45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
     45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
     45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
     45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
     45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
     45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
     45, 45, 45, 10, 45, 45, 45, 45, 45, 45,
     45, 45, 45, 45, 45, 20, 45,  0, 45, 30,
      0,  5, 45,  5, 45, 20, 45, 45, 45,  0,
     45, 45, 45, 45, 10,  0,  0, 45, 45, 45,
     45,  0, 45, 45, 45, 45, 45, 45,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_VDev_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 22,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 24,
      MIN_HASH_VALUE = 10,
      MAX_HASH_VALUE = 44,
      HASH_VALUE_RANGE = 35,
      DUPLICATES = 3,
      WORDLIST_SIZE = 32
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"",0,0},
      {"set_format", &POA_AVStreams::VDev::set_format_skel, 0},
      {"set_dev_params", &POA_AVStreams::VDev::set_dev_params_skel, 0},
      {"define_property", &POA_AVStreams::VDev::define_property_skel, 0},
      {"delete_property", &POA_AVStreams::VDev::delete_property_skel, 0},
      {"define_properties", &POA_AVStreams::VDev::define_properties_skel, 0},
      {"delete_properties", &POA_AVStreams::VDev::delete_properties_skel, 0},
      {"set_peer", &POA_AVStreams::VDev::set_peer_skel, 0},
      {"get_properties", &POA_AVStreams::VDev::get_properties_skel, 0},
      {"modify_QoS", &POA_AVStreams::VDev::modify_QoS_skel, 0},
      {"delete_all_properties", &POA_AVStreams::VDev::delete_all_properties_skel, 0},
      {"get_all_properties", &POA_AVStreams::VDev::get_all_properties_skel, 0},
      {"set_Mcast_peer", &POA_AVStreams::VDev::set_Mcast_peer_skel, 0},
      {"_is_a", &POA_AVStreams::VDev::_is_a_skel, 0},
      {"get_all_property_names", &POA_AVStreams::VDev::get_all_property_names_skel, 0},
      {"get_property_value", &POA_AVStreams::VDev::get_property_value_skel, 0},
      {"get_number_of_properties", &POA_AVStreams::VDev::get_number_of_properties_skel, 0},
      {"_component", &POA_AVStreams::VDev::_component_skel, 0},
      {"_non_existent", &POA_AVStreams::VDev::_non_existent_skel, 0},
      {"_repository_id", &POA_AVStreams::VDev::_repository_id_skel, 0},
      {"_interface", &POA_AVStreams::VDev::_interface_skel, 0},
      {"is_property_defined", &POA_AVStreams::VDev::is_property_defined_skel, 0},
      {"configure", &POA_AVStreams::VDev::configure_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -12,  -2,  10,  -1, -14,  -2, 
       11, -51,  -1, -49,  16,  17,  18,  19,  -1,  20,  21,  22,  -1,  23, 
       24,  25,  26,  -1,  -1,  27,  28,  29,  -1,  -1,  -1,  30,  -1,  -1, 
       -1,  -1,  31, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_AVStreams_VDev_Perfect_Hash_OpTable tao_AVStreams_VDev_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_VDev_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_VDev_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_VDev_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_VDev_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_VDev_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_VDev_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_VDev_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::VDev::VDev (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_VDev_optable;
}

POA_AVStreams::VDev::VDev (const VDev& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CosPropertyService::PropertySet (rhs)
{
}

POA_AVStreams::VDev::~VDev (void)
{
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_peer_VDev
    : public TAO::Upcall_Command
  {
  public:
    inline set_peer_VDev (
      POA_AVStreams::VDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::StreamCtrl>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::StreamCtrl> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::VDev>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::VDev> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_3 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          4);
        
      retval =
        this->servant_->set_peer (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }
  
  private:
    POA_AVStreams::VDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::VDev::set_peer_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_QoSRequestFailed,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 3;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::StreamCtrl>::in_arg_val _tao_the_ctrl;
  TAO::SArg_Traits< ::AVStreams::VDev>::in_arg_val _tao_the_peer_dev;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_ctrl,
      &_tao_the_peer_dev,
      &_tao_the_qos,
      &_tao_the_spec
    };
  
  static size_t const nargs = 5;

  POA_AVStreams::VDev * const impl =
    static_cast<POA_AVStreams::VDev *> (servant);

  set_peer_VDev command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_Mcast_peer_VDev
    : public TAO::Upcall_Command
  {
  public:
    inline set_Mcast_peer_VDev (
      POA_AVStreams::VDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::StreamCtrl>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::StreamCtrl> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::MCastConfigIf>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::MCastConfigIf> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_3 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          4);
        
      retval =
        this->servant_->set_Mcast_peer (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }
  
  private:
    POA_AVStreams::VDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::VDev::set_Mcast_peer_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_QoSRequestFailed,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 3;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::StreamCtrl>::in_arg_val _tao_the_ctrl;
  TAO::SArg_Traits< ::AVStreams::MCastConfigIf>::in_arg_val _tao_a_mcastconfigif;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_ctrl,
      &_tao_a_mcastconfigif,
      &_tao_the_qos,
      &_tao_the_spec
    };
  
  static size_t const nargs = 5;

  POA_AVStreams::VDev * const impl =
    static_cast<POA_AVStreams::VDev *> (servant);

  set_Mcast_peer_VDev command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class configure_VDev
    : public TAO::Upcall_Command
  {
  public:
    inline configure_VDev (
      POA_AVStreams::VDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosPropertyService::Property>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CosPropertyService::Property> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->configure (
        arg_1);
    }
  
  private:
    POA_AVStreams::VDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::VDev::configure_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_PropertyException,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CosPropertyService::Property>::in_arg_val _tao_the_config_mesg;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_config_mesg
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::VDev * const impl =
    static_cast<POA_AVStreams::VDev *> (servant);

  configure_VDev command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_format_VDev
    : public TAO::Upcall_Command
  {
  public:
    inline set_format_VDev (
      POA_AVStreams::VDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->set_format (
        arg_1
        , arg_2);
    }
  
  private:
    POA_AVStreams::VDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::VDev::set_format_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_notSupported
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_flowName;
  TAO::SArg_Traits< char *>::in_arg_val _tao_format_name;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flowName,
      &_tao_format_name
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::VDev * const impl =
    static_cast<POA_AVStreams::VDev *> (servant);

  set_format_VDev command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_dev_params_VDev
    : public TAO::Upcall_Command
  {
  public:
    inline set_dev_params_VDev (
      POA_AVStreams::VDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CosPropertyService::Properties>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CosPropertyService::Properties> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->set_dev_params (
        arg_1
        , arg_2);
    }
  
  private:
    POA_AVStreams::VDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::VDev::set_dev_params_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_PropertyException,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_flowName;
  TAO::SArg_Traits< ::CosPropertyService::Properties>::in_arg_val _tao_new_params;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flowName,
      &_tao_new_params
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::VDev * const impl =
    static_cast<POA_AVStreams::VDev *> (servant);

  set_dev_params_VDev command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class modify_QoS_VDev
    : public TAO::Upcall_Command
  {
  public:
    inline modify_QoS_VDev (
      POA_AVStreams::VDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_1 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->modify_QoS (
          arg_1
          , arg_2);
    }
  
  private:
    POA_AVStreams::VDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::VDev::modify_QoS_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_qos,
      &_tao_the_spec
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::VDev * const impl =
    static_cast<POA_AVStreams::VDev *> (servant);

  modify_QoS_VDev command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_VDev_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_VDev_Upcall_Command (
      POA_AVStreams::VDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::VDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::VDev::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::VDev * const impl =
    static_cast<POA_AVStreams::VDev *> (servant);
  
  _is_a_VDev_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_VDev_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_VDev_Upcall_Command (
      POA_AVStreams::VDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::VDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::VDev::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::VDev * const impl =
    static_cast<POA_AVStreams::VDev *> (servant);
  
  _non_existent_VDev_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_VDev_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_VDev_Upcall_Command (
      POA_AVStreams::VDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::VDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::VDev::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::VDev * const impl =
    static_cast<POA_AVStreams::VDev *> (servant);
  
  _repository_id_VDev_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::VDev::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::VDev * const impl =
    static_cast<POA_AVStreams::VDev *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_VDev_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_VDev_Upcall_Command (
      POA_AVStreams::VDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::VDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::VDev::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::VDev * const impl =
    static_cast<POA_AVStreams::VDev *> (servant);
  
  _get_component_VDev_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::VDev::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/VDev:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::VDev::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/VDev:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::VDev::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::VDev *
POA_AVStreams::VDev::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::VDev STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_VDev_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_MMDevice_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_MMDevice_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_MMDevice_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46,  5, 30, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46,  5, 46, 25, 30,  0,
      0, 10, 46,  0, 46, 10, 46, 46, 46, 46,
     46, 46, 46, 46,  0,  0,  5, 46,  0, 46,
     46,  0, 46, 46, 46, 46, 46, 46,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_MMDevice_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 24,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 24,
      MIN_HASH_VALUE = 7,
      MAX_HASH_VALUE = 45,
      HASH_VALUE_RANGE = 39,
      DUPLICATES = 3,
      WORDLIST_SIZE = 31
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"destroy", &POA_AVStreams::MMDevice::destroy_skel, 0},
      {"get_fdev", &POA_AVStreams::MMDevice::get_fdev_skel, 0},
      {"remove_fdev", &POA_AVStreams::MMDevice::remove_fdev_skel, 0},
      {"create_A", &POA_AVStreams::MMDevice::create_A_skel, 0},
      {"get_properties", &POA_AVStreams::MMDevice::get_properties_skel, 0},
      {"define_property", &POA_AVStreams::MMDevice::define_property_skel, 0},
      {"delete_property", &POA_AVStreams::MMDevice::delete_property_skel, 0},
      {"define_properties", &POA_AVStreams::MMDevice::define_properties_skel, 0},
      {"delete_properties", &POA_AVStreams::MMDevice::delete_properties_skel, 0},
      {"get_all_properties", &POA_AVStreams::MMDevice::get_all_properties_skel, 0},
      {"_repository_id", &POA_AVStreams::MMDevice::_repository_id_skel, 0},
      {"_component", &POA_AVStreams::MMDevice::_component_skel, 0},
      {"delete_all_properties", &POA_AVStreams::MMDevice::delete_all_properties_skel, 0},
      {"get_all_property_names", &POA_AVStreams::MMDevice::get_all_property_names_skel, 0},
      {"_non_existent", &POA_AVStreams::MMDevice::_non_existent_skel, 0},
      {"get_number_of_properties", &POA_AVStreams::MMDevice::get_number_of_properties_skel, 0},
      {"_interface", &POA_AVStreams::MMDevice::_interface_skel, 0},
      {"get_property_value", &POA_AVStreams::MMDevice::get_property_value_skel, 0},
      {"is_property_defined", &POA_AVStreams::MMDevice::is_property_defined_skel, 0},
      {"add_fdev", &POA_AVStreams::MMDevice::add_fdev_skel, 0},
      {"bind", &POA_AVStreams::MMDevice::bind_skel, 0},
      {"_is_a", &POA_AVStreams::MMDevice::_is_a_skel, 0},
      {"create_B", &POA_AVStreams::MMDevice::create_B_skel, 0},
      {"bind_mcast", &POA_AVStreams::MMDevice::bind_mcast_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1, -12,  -2,   7,   8, -14,  -2,   9,  -1,  10, 
       11, -55,  -1, -53,  16,  17,  18,  19,  20,  21,  22,  23,  -1,  -1, 
       24,  25,  -1,  -1,  -1,  26,  27,  28,  -1,  -1,  29,  -1,  -1,  -1, 
       -1,  -1,  -1,  30, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_AVStreams_MMDevice_Perfect_Hash_OpTable tao_AVStreams_MMDevice_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_MMDevice_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_MMDevice_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_MMDevice_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_MMDevice_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_MMDevice_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_MMDevice_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_MMDevice_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::MMDevice::MMDevice (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_MMDevice_optable;
}

POA_AVStreams::MMDevice::MMDevice (const MMDevice& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CosPropertyService::PropertySet (rhs)
{
}

POA_AVStreams::MMDevice::~MMDevice (void)
{
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class create_A_MMDevice
    : public TAO::Upcall_Command
  {
  public:
    inline create_A_MMDevice (
      POA_AVStreams::MMDevice * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::StreamEndPoint_A>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::AVStreams::StreamEndPoint_A> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::StreamCtrl>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::StreamCtrl> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::VDev>::out_arg_type arg_2 =
        TAO::Portable_Server::get_out_arg< ::AVStreams::VDev> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_3 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_type arg_4 =
        TAO::Portable_Server::get_out_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          4);
        
      TAO::SArg_Traits< char *>::inout_arg_type arg_5 =
        TAO::Portable_Server::get_inout_arg< char *> (
          this->operation_details_,
          this->args_,
          5);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_6 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          6);
        
      retval =
        this->servant_->create_A (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5
          , arg_6);
    }
  
  private:
    POA_AVStreams::MMDevice * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MMDevice::create_A_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_streamOpDenied,
      AVStreams::_tc_notSupported,
      AVStreams::_tc_QoSRequestFailed,
      AVStreams::_tc_noSuchFlow
    };
  static ::CORBA::ULong const nexceptions = 5;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::AVStreams::StreamEndPoint_A>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::StreamCtrl>::in_arg_val _tao_the_requester;
  TAO::SArg_Traits< ::AVStreams::VDev>::out_arg_val _tao_the_vdev;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_met_qos;
  TAO::SArg_Traits< char *>::inout_arg_val _tao_named_vdev;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_requester,
      &_tao_the_vdev,
      &_tao_the_qos,
      &_tao_met_qos,
      &_tao_named_vdev,
      &_tao_the_spec
    };
  
  static size_t const nargs = 7;

  POA_AVStreams::MMDevice * const impl =
    static_cast<POA_AVStreams::MMDevice *> (servant);

  create_A_MMDevice command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class create_B_MMDevice
    : public TAO::Upcall_Command
  {
  public:
    inline create_B_MMDevice (
      POA_AVStreams::MMDevice * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::StreamEndPoint_B>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::AVStreams::StreamEndPoint_B> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::StreamCtrl>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::StreamCtrl> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::VDev>::out_arg_type arg_2 =
        TAO::Portable_Server::get_out_arg< ::AVStreams::VDev> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_3 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_type arg_4 =
        TAO::Portable_Server::get_out_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          4);
        
      TAO::SArg_Traits< char *>::inout_arg_type arg_5 =
        TAO::Portable_Server::get_inout_arg< char *> (
          this->operation_details_,
          this->args_,
          5);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_6 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          6);
        
      retval =
        this->servant_->create_B (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5
          , arg_6);
    }
  
  private:
    POA_AVStreams::MMDevice * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MMDevice::create_B_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_streamOpDenied,
      AVStreams::_tc_notSupported,
      AVStreams::_tc_QoSRequestFailed,
      AVStreams::_tc_noSuchFlow
    };
  static ::CORBA::ULong const nexceptions = 5;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::AVStreams::StreamEndPoint_B>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::StreamCtrl>::in_arg_val _tao_the_requester;
  TAO::SArg_Traits< ::AVStreams::VDev>::out_arg_val _tao_the_vdev;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_met_qos;
  TAO::SArg_Traits< char *>::inout_arg_val _tao_named_vdev;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_requester,
      &_tao_the_vdev,
      &_tao_the_qos,
      &_tao_met_qos,
      &_tao_named_vdev,
      &_tao_the_spec
    };
  
  static size_t const nargs = 7;

  POA_AVStreams::MMDevice * const impl =
    static_cast<POA_AVStreams::MMDevice *> (servant);

  create_B_MMDevice command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class bind_MMDevice
    : public TAO::Upcall_Command
  {
  public:
    inline bind_MMDevice (
      POA_AVStreams::MMDevice * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::StreamCtrl>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::AVStreams::StreamCtrl> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::MMDevice>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::MMDevice> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_2 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_type arg_3 =
        TAO::Portable_Server::get_out_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          4);
        
      retval =
        this->servant_->bind (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }
  
  private:
    POA_AVStreams::MMDevice * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MMDevice::bind_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 3;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::AVStreams::StreamCtrl>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::MMDevice>::in_arg_val _tao_peer_device;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_is_met;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_peer_device,
      &_tao_the_qos,
      &_tao_is_met,
      &_tao_the_spec
    };
  
  static size_t const nargs = 5;

  POA_AVStreams::MMDevice * const impl =
    static_cast<POA_AVStreams::MMDevice *> (servant);

  bind_MMDevice command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class bind_mcast_MMDevice
    : public TAO::Upcall_Command
  {
  public:
    inline bind_mcast_MMDevice (
      POA_AVStreams::MMDevice * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::StreamCtrl>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::AVStreams::StreamCtrl> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::MMDevice>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::MMDevice> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_type arg_2 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::streamQoS> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_type arg_3 =
        TAO::Portable_Server::get_out_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::flowSpec> (
          this->operation_details_,
          this->args_,
          4);
        
      retval =
        this->servant_->bind_mcast (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }
  
  private:
    POA_AVStreams::MMDevice * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MMDevice::bind_mcast_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 3;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::AVStreams::StreamCtrl>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::MMDevice>::in_arg_val _tao_first_peer;
  TAO::SArg_Traits< ::AVStreams::streamQoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_is_met;
  TAO::SArg_Traits< ::AVStreams::flowSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_first_peer,
      &_tao_the_qos,
      &_tao_is_met,
      &_tao_the_spec
    };
  
  static size_t const nargs = 5;

  POA_AVStreams::MMDevice * const impl =
    static_cast<POA_AVStreams::MMDevice *> (servant);

  bind_mcast_MMDevice command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class destroy_MMDevice
    : public TAO::Upcall_Command
  {
  public:
    inline destroy_MMDevice (
      POA_AVStreams::MMDevice * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::StreamEndPoint>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::StreamEndPoint> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->destroy (
        arg_1
        , arg_2);
    }
  
  private:
    POA_AVStreams::MMDevice * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MMDevice::destroy_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_notSupported
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::StreamEndPoint>::in_arg_val _tao_the_ep;
  TAO::SArg_Traits< char *>::in_arg_val _tao_vdev_name;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_ep,
      &_tao_vdev_name
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::MMDevice * const impl =
    static_cast<POA_AVStreams::MMDevice *> (servant);

  destroy_MMDevice command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class add_fdev_MMDevice
    : public TAO::Upcall_Command
  {
  public:
    inline add_fdev_MMDevice (
      POA_AVStreams::MMDevice * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Object>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->add_fdev (
          arg_1);
    }
  
  private:
    POA_AVStreams::MMDevice * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MMDevice::add_fdev_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_notSupported,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Object>::in_arg_val _tao_the_fdev;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_fdev
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::MMDevice * const impl =
    static_cast<POA_AVStreams::MMDevice *> (servant);

  add_fdev_MMDevice command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_fdev_MMDevice
    : public TAO::Upcall_Command
  {
  public:
    inline get_fdev_MMDevice (
      POA_AVStreams::MMDevice * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->get_fdev (
          arg_1);
    }
  
  private:
    POA_AVStreams::MMDevice * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MMDevice::get_fdev_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_notSupported,
      AVStreams::_tc_noSuchFlow
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_flow_name;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flow_name
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::MMDevice * const impl =
    static_cast<POA_AVStreams::MMDevice *> (servant);

  get_fdev_MMDevice command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class remove_fdev_MMDevice
    : public TAO::Upcall_Command
  {
  public:
    inline remove_fdev_MMDevice (
      POA_AVStreams::MMDevice * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->remove_fdev (
        arg_1);
    }
  
  private:
    POA_AVStreams::MMDevice * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MMDevice::remove_fdev_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_notSupported,
      AVStreams::_tc_noSuchFlow,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 3;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_flow_name;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flow_name
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::MMDevice * const impl =
    static_cast<POA_AVStreams::MMDevice *> (servant);

  remove_fdev_MMDevice command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_MMDevice_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_MMDevice_Upcall_Command (
      POA_AVStreams::MMDevice * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::MMDevice * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::MMDevice::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::MMDevice * const impl =
    static_cast<POA_AVStreams::MMDevice *> (servant);
  
  _is_a_MMDevice_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_MMDevice_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_MMDevice_Upcall_Command (
      POA_AVStreams::MMDevice * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::MMDevice * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::MMDevice::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::MMDevice * const impl =
    static_cast<POA_AVStreams::MMDevice *> (servant);
  
  _non_existent_MMDevice_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_MMDevice_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_MMDevice_Upcall_Command (
      POA_AVStreams::MMDevice * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::MMDevice * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::MMDevice::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::MMDevice * const impl =
    static_cast<POA_AVStreams::MMDevice *> (servant);
  
  _repository_id_MMDevice_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::MMDevice::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::MMDevice * const impl =
    static_cast<POA_AVStreams::MMDevice *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_MMDevice_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_MMDevice_Upcall_Command (
      POA_AVStreams::MMDevice * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::MMDevice * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::MMDevice::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::MMDevice * const impl =
    static_cast<POA_AVStreams::MMDevice *> (servant);
  
  _get_component_MMDevice_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::MMDevice::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/MMDevice:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::MMDevice::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/MMDevice:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::MMDevice::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::MMDevice *
POA_AVStreams::MMDevice::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::MMDevice STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_MMDevice_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_FlowConnection_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_FlowConnection_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_FlowConnection_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     55, 55, 55, 55, 55, 55, 55, 55, 55, 55,
     55, 55, 55, 55, 55, 55, 55, 55, 55, 55,
     55, 55, 55, 55, 55, 55, 55, 55, 55, 55,
     55, 55, 55, 55, 55, 55, 55, 55, 55, 55,
     55, 55, 55, 55, 55, 55, 55, 55, 55, 55,
     55, 55, 55, 55, 55, 55, 55, 55, 55, 55,
     55, 55, 55, 55, 55, 55, 55, 55, 55, 55,
     55, 55, 55, 55, 55, 55, 55, 55, 55, 55,
     55, 55, 55,  5, 55, 55, 55, 55, 55, 55,
     55, 55, 55, 55, 55, 15, 55,  0, 55,  1,
     25,  5, 55,  0, 55,  0, 55, 55,  0,  0,
     55, 55,  0, 55,  0,  0,  0,  0, 55, 55,
     55,  0, 55, 55, 55, 55, 55, 55,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_FlowConnection_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 28,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 24,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 54,
      HASH_VALUE_RANGE = 51,
      DUPLICATES = 4,
      WORDLIST_SIZE = 32
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"stop", &POA_AVStreams::FlowConnection::stop_skel, 0},
      {"start", &POA_AVStreams::FlowConnection::start_skel, 0},
      {"connect", &POA_AVStreams::FlowConnection::connect_skel, 0},
      {"push_event", &POA_AVStreams::FlowConnection::push_event_skel, 0},
      {"add_producer", &POA_AVStreams::FlowConnection::add_producer_skel, 0},
      {"add_consumer", &POA_AVStreams::FlowConnection::add_consumer_skel, 0},
      {"connect_devs", &POA_AVStreams::FlowConnection::connect_devs_skel, 0},
      {"get_properties", &POA_AVStreams::FlowConnection::get_properties_skel, 0},
      {"modify_QoS", &POA_AVStreams::FlowConnection::modify_QoS_skel, 0},
      {"use_flow_protocol", &POA_AVStreams::FlowConnection::use_flow_protocol_skel, 0},
      {"get_all_properties", &POA_AVStreams::FlowConnection::get_all_properties_skel, 0},
      {"_is_a", &POA_AVStreams::FlowConnection::_is_a_skel, 0},
      {"get_all_property_names", &POA_AVStreams::FlowConnection::get_all_property_names_skel, 0},
      {"get_property_value", &POA_AVStreams::FlowConnection::get_property_value_skel, 0},
      {"get_number_of_properties", &POA_AVStreams::FlowConnection::get_number_of_properties_skel, 0},
      {"_component", &POA_AVStreams::FlowConnection::_component_skel, 0},
      {"_non_existent", &POA_AVStreams::FlowConnection::_non_existent_skel, 0},
      {"drop", &POA_AVStreams::FlowConnection::drop_skel, 0},
      {"_interface", &POA_AVStreams::FlowConnection::_interface_skel, 0},
      {"destroy", &POA_AVStreams::FlowConnection::destroy_skel, 0},
      {"disconnect", &POA_AVStreams::FlowConnection::disconnect_skel, 0},
      {"define_property", &POA_AVStreams::FlowConnection::define_property_skel, 0},
      {"delete_property", &POA_AVStreams::FlowConnection::delete_property_skel, 0},
      {"define_properties", &POA_AVStreams::FlowConnection::define_properties_skel, 0},
      {"delete_properties", &POA_AVStreams::FlowConnection::delete_properties_skel, 0},
      {"is_property_defined", &POA_AVStreams::FlowConnection::is_property_defined_skel, 0},
      {"delete_all_properties", &POA_AVStreams::FlowConnection::delete_all_properties_skel, 0},
      {"_repository_id", &POA_AVStreams::FlowConnection::_repository_id_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,   5,  -8,  -2,   6,  -1,   7,  -1, -60,  10, 
       11,  12,  -1,  13,  14,  -1,  15,  -1,  16,  17,  18,  19,  -1,  -1, 
       20,  21,  22,  -1,  23,  -1,  -1,  24, -25,  -2, -27,  -2, -58,  -1, 
      -58,  -1,  29,  -1,  30,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  31, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_AVStreams_FlowConnection_Perfect_Hash_OpTable tao_AVStreams_FlowConnection_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_FlowConnection_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_FlowConnection_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_FlowConnection_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_FlowConnection_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_FlowConnection_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_FlowConnection_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_FlowConnection_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::FlowConnection::FlowConnection (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_FlowConnection_optable;
}

POA_AVStreams::FlowConnection::FlowConnection (const FlowConnection& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CosPropertyService::PropertySet (rhs)
{
}

POA_AVStreams::FlowConnection::~FlowConnection (void)
{
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class stop_FlowConnection
    : public TAO::Upcall_Command
  {
  public:
    inline stop_FlowConnection (
      POA_AVStreams::FlowConnection * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->stop ();
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowConnection::stop_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);

  stop_FlowConnection command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class start_FlowConnection
    : public TAO::Upcall_Command
  {
  public:
    inline start_FlowConnection (
      POA_AVStreams::FlowConnection * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->start ();
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowConnection::start_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);

  start_FlowConnection command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class destroy_FlowConnection
    : public TAO::Upcall_Command
  {
  public:
    inline destroy_FlowConnection (
      POA_AVStreams::FlowConnection * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->destroy ();
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowConnection::destroy_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);

  destroy_FlowConnection command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class modify_QoS_FlowConnection
    : public TAO::Upcall_Command
  {
  public:
    inline modify_QoS_FlowConnection (
      POA_AVStreams::FlowConnection * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_type arg_1 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::QoS> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->modify_QoS (
          arg_1);
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowConnection::modify_QoS_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_new_qos;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_new_qos
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);

  modify_QoS_FlowConnection command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class use_flow_protocol_FlowConnection
    : public TAO::Upcall_Command
  {
  public:
    inline use_flow_protocol_FlowConnection (
      POA_AVStreams::FlowConnection * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Any>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Any> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->use_flow_protocol (
          arg_1
          , arg_2);
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowConnection::use_flow_protocol_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_FPError,
      AVStreams::_tc_notSupported
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_fp_name;
  TAO::SArg_Traits< ::CORBA::Any>::in_arg_val _tao_fp_settings;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_fp_name,
      &_tao_fp_settings
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);

  use_flow_protocol_FlowConnection command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class push_event_FlowConnection
    : public TAO::Upcall_Command
  {
  public:
    inline push_event_FlowConnection (
      POA_AVStreams::FlowConnection * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosPropertyService::Property>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CosPropertyService::Property> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->push_event (
        arg_1);
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowConnection::push_event_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CosPropertyService::Property>::in_arg_val _tao_the_event;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_event
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);

  push_event_FlowConnection command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class connect_devs_FlowConnection
    : public TAO::Upcall_Command
  {
  public:
    inline connect_devs_FlowConnection (
      POA_AVStreams::FlowConnection * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::FDev>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FDev> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::FDev>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FDev> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_type arg_3 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::QoS> (
          this->operation_details_,
          this->args_,
          3);
        
      retval =
        this->servant_->connect_devs (
          arg_1
          , arg_2
          , arg_3);
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowConnection::connect_devs_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_streamOpDenied,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 3;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::FDev>::in_arg_val _tao_a_party;
  TAO::SArg_Traits< ::AVStreams::FDev>::in_arg_val _tao_b_party;
  TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_a_party,
      &_tao_b_party,
      &_tao_the_qos
    };
  
  static size_t const nargs = 4;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);

  connect_devs_FlowConnection command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class connect_FlowConnection
    : public TAO::Upcall_Command
  {
  public:
    inline connect_FlowConnection (
      POA_AVStreams::FlowConnection * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::FlowProducer>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FlowProducer> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::FlowConsumer>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FlowConsumer> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_type arg_3 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::QoS> (
          this->operation_details_,
          this->args_,
          3);
        
      retval =
        this->servant_->connect (
          arg_1
          , arg_2
          , arg_3);
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowConnection::connect_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_formatMismatch,
      AVStreams::_tc_FEPMismatch,
      AVStreams::_tc_alreadyConnected
    };
  static ::CORBA::ULong const nexceptions = 3;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::FlowProducer>::in_arg_val _tao_flow_producer;
  TAO::SArg_Traits< ::AVStreams::FlowConsumer>::in_arg_val _tao_flow_consumer;
  TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flow_producer,
      &_tao_flow_consumer,
      &_tao_the_qos
    };
  
  static size_t const nargs = 4;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);

  connect_FlowConnection command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class disconnect_FlowConnection
    : public TAO::Upcall_Command
  {
  public:
    inline disconnect_FlowConnection (
      POA_AVStreams::FlowConnection * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->disconnect ();
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowConnection::disconnect_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);

  disconnect_FlowConnection command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class add_producer_FlowConnection
    : public TAO::Upcall_Command
  {
  public:
    inline add_producer_FlowConnection (
      POA_AVStreams::FlowConnection * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::FlowProducer>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FlowProducer> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_type arg_2 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::QoS> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->add_producer (
          arg_1
          , arg_2);
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowConnection::add_producer_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_alreadyConnected,
      AVStreams::_tc_notSupported
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::FlowProducer>::in_arg_val _tao_flow_producer;
  TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flow_producer,
      &_tao_the_qos
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);

  add_producer_FlowConnection command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class add_consumer_FlowConnection
    : public TAO::Upcall_Command
  {
  public:
    inline add_consumer_FlowConnection (
      POA_AVStreams::FlowConnection * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::FlowConsumer>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FlowConsumer> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_type arg_2 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::QoS> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->add_consumer (
          arg_1
          , arg_2);
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowConnection::add_consumer_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_alreadyConnected
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::FlowConsumer>::in_arg_val _tao_flow_consumer;
  TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flow_consumer,
      &_tao_the_qos
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);

  add_consumer_FlowConnection command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class drop_FlowConnection
    : public TAO::Upcall_Command
  {
  public:
    inline drop_FlowConnection (
      POA_AVStreams::FlowConnection * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::FlowEndPoint>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FlowEndPoint> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->drop (
          arg_1);
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowConnection::drop_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_notConnected
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::FlowEndPoint>::in_arg_val _tao_target;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_target
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);

  drop_FlowConnection command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_FlowConnection_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_FlowConnection_Upcall_Command (
      POA_AVStreams::FlowConnection * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowConnection::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);
  
  _is_a_FlowConnection_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_FlowConnection_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_FlowConnection_Upcall_Command (
      POA_AVStreams::FlowConnection * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowConnection::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);
  
  _non_existent_FlowConnection_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_FlowConnection_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_FlowConnection_Upcall_Command (
      POA_AVStreams::FlowConnection * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowConnection::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);
  
  _repository_id_FlowConnection_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::FlowConnection::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_FlowConnection_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_FlowConnection_Upcall_Command (
      POA_AVStreams::FlowConnection * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::FlowConnection * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowConnection::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowConnection * const impl =
    static_cast<POA_AVStreams::FlowConnection *> (servant);
  
  _get_component_FlowConnection_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::FlowConnection::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/FlowConnection:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::FlowConnection::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/FlowConnection:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::FlowConnection::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::FlowConnection *
POA_AVStreams::FlowConnection::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::FlowConnection STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_FlowConnection_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_FlowEndPoint_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_FlowEndPoint_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_FlowEndPoint_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 10, 60,  5, 60, 10,
     20, 10, 60,  5, 60, 20, 60,  5,  0, 60,
     15, 60,  0, 60, 10,  0,  5,  0, 60, 60,
     60, 15, 60, 60, 60, 60, 60, 60,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_FlowEndPoint_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 35,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 28,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 59,
      HASH_VALUE_RANGE = 56,
      DUPLICATES = 5,
      WORDLIST_SIZE = 39
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"stop", &POA_AVStreams::FlowEndPoint::stop_skel, 0},
      {"lock", &POA_AVStreams::FlowEndPoint::lock_skel, 0},
      {"start", &POA_AVStreams::FlowEndPoint::start_skel, 0},
      {"unlock", &POA_AVStreams::FlowEndPoint::unlock_skel, 0},
      {"set_dev_params", &POA_AVStreams::FlowEndPoint::set_dev_params_skel, 0},
      {"set_format", &POA_AVStreams::FlowEndPoint::set_format_skel, 0},
      {"use_flow_protocol", &POA_AVStreams::FlowEndPoint::use_flow_protocol_skel, 0},
      {"set_peer", &POA_AVStreams::FlowEndPoint::set_peer_skel, 0},
      {"get_properties", &POA_AVStreams::FlowEndPoint::get_properties_skel, 0},
      {"_is_a", &POA_AVStreams::FlowEndPoint::_is_a_skel, 0},
      {"get_connected_fep", &POA_AVStreams::FlowEndPoint::get_connected_fep_skel, 0},
      {"get_all_properties", &POA_AVStreams::FlowEndPoint::get_all_properties_skel, 0},
      {"set_Mcast_peer", &POA_AVStreams::FlowEndPoint::set_Mcast_peer_skel, 0},
      {"_component", &POA_AVStreams::FlowEndPoint::_component_skel, 0},
      {"_get_related_sep", &POA_AVStreams::FlowEndPoint::_get_related_sep_skel, 0},
      {"_set_related_sep", &POA_AVStreams::FlowEndPoint::_set_related_sep_skel, 0},
      {"get_all_property_names", &POA_AVStreams::FlowEndPoint::get_all_property_names_skel, 0},
      {"_non_existent", &POA_AVStreams::FlowEndPoint::_non_existent_skel, 0},
      {"get_number_of_properties", &POA_AVStreams::FlowEndPoint::get_number_of_properties_skel, 0},
      {"_interface", &POA_AVStreams::FlowEndPoint::_interface_skel, 0},
      {"go_to_listen", &POA_AVStreams::FlowEndPoint::go_to_listen_skel, 0},
      {"get_property_value", &POA_AVStreams::FlowEndPoint::get_property_value_skel, 0},
      {"connect_to_peer", &POA_AVStreams::FlowEndPoint::connect_to_peer_skel, 0},
      {"define_properties", &POA_AVStreams::FlowEndPoint::define_properties_skel, 0},
      {"delete_properties", &POA_AVStreams::FlowEndPoint::delete_properties_skel, 0},
      {"set_protocol_restriction", &POA_AVStreams::FlowEndPoint::set_protocol_restriction_skel, 0},
      {"delete_all_properties", &POA_AVStreams::FlowEndPoint::delete_all_properties_skel, 0},
      {"destroy", &POA_AVStreams::FlowEndPoint::destroy_skel, 0},
      {"_repository_id", &POA_AVStreams::FlowEndPoint::_repository_id_skel, 0},
      {"is_fep_compatible", &POA_AVStreams::FlowEndPoint::is_fep_compatible_skel, 0},
      {"define_property", &POA_AVStreams::FlowEndPoint::define_property_skel, 0},
      {"delete_property", &POA_AVStreams::FlowEndPoint::delete_property_skel, 0},
      {"_get_related_flow_connection", &POA_AVStreams::FlowEndPoint::_get_related_flow_connection_skel, 0},
      {"_set_related_flow_connection", &POA_AVStreams::FlowEndPoint::_set_related_flow_connection_skel, 0},
      {"is_property_defined", &POA_AVStreams::FlowEndPoint::is_property_defined_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1, -18,  -2,   5,   6,   7, -27,  -2, 
        8,   9,  -1,  10,  11,  12,  13,  -1,  14,  15,  16,  17, -78,  20, 
       21,  22,  23,  -1,  24,  25,  -1,  26,  -1, -84,  -1,  29,  -1,  30, 
       31,  -1,  32,  -1,  -1,  33, -34,  -2, -61, -36,  -2, -61,  -1,  -1, 
       -1,  -1,  -1,  38, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_AVStreams_FlowEndPoint_Perfect_Hash_OpTable tao_AVStreams_FlowEndPoint_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_FlowEndPoint_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_FlowEndPoint_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_FlowEndPoint_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_FlowEndPoint_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_FlowEndPoint_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_FlowEndPoint_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_FlowEndPoint_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::FlowEndPoint::FlowEndPoint (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_FlowEndPoint_optable;
}

POA_AVStreams::FlowEndPoint::FlowEndPoint (const FlowEndPoint& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CosPropertyService::PropertySet (rhs)
{
}

POA_AVStreams::FlowEndPoint::~FlowEndPoint (void)
{
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class lock_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline lock_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->lock ();
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::lock_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  lock_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class unlock_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline unlock_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->unlock ();
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::unlock_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  unlock_FlowEndPoint command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class stop_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline stop_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->stop ();
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::stop_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  stop_FlowEndPoint command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class start_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline start_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->start ();
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::start_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  start_FlowEndPoint command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class destroy_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline destroy_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->destroy ();
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::destroy_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  destroy_FlowEndPoint command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_related_sep_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline _get_related_sep_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::StreamEndPoint>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::AVStreams::StreamEndPoint> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->related_sep ();
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::_get_related_sep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::AVStreams::StreamEndPoint>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  _get_related_sep_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _set_related_sep_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline _set_related_sep_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::StreamEndPoint>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::StreamEndPoint> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->related_sep (
        arg_1);
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::_set_related_sep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::StreamEndPoint>::in_arg_val _tao_related_sep;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_related_sep
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  _set_related_sep_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_related_flow_connection_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline _get_related_flow_connection_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::FlowConnection>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::AVStreams::FlowConnection> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->related_flow_connection ();
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::_get_related_flow_connection_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::AVStreams::FlowConnection>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  _get_related_flow_connection_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _set_related_flow_connection_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline _set_related_flow_connection_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::FlowConnection>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FlowConnection> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->related_flow_connection (
        arg_1);
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::_set_related_flow_connection_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::FlowConnection>::in_arg_val _tao_related_flow_connection;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_related_flow_connection
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  _set_related_flow_connection_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_connected_fep_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline get_connected_fep_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::FlowEndPoint>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::AVStreams::FlowEndPoint> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->get_connected_fep ();
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::get_connected_fep_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_notConnected,
      AVStreams::_tc_notSupported
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::AVStreams::FlowEndPoint>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  get_connected_fep_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class use_flow_protocol_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline use_flow_protocol_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Any>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Any> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->use_flow_protocol (
          arg_1
          , arg_2);
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::use_flow_protocol_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_FPError,
      AVStreams::_tc_notSupported
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_fp_name;
  TAO::SArg_Traits< ::CORBA::Any>::in_arg_val _tao_fp_settings;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_fp_name,
      &_tao_fp_settings
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  use_flow_protocol_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_format_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline set_format_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->set_format (
        arg_1);
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::set_format_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_notSupported
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_format;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_format
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  set_format_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_dev_params_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline set_dev_params_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CosPropertyService::Properties>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CosPropertyService::Properties> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->set_dev_params (
        arg_1);
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::set_dev_params_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_PropertyException,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CosPropertyService::Properties>::in_arg_val _tao_new_settings;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_new_settings
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  set_dev_params_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_protocol_restriction_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline set_protocol_restriction_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::protocolSpec>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::protocolSpec> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->set_protocol_restriction (
        arg_1);
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::set_protocol_restriction_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_notSupported
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::protocolSpec>::in_arg_val _tao_the_spec;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_spec
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  set_protocol_restriction_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class is_fep_compatible_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline is_fep_compatible_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::FlowEndPoint>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FlowEndPoint> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->is_fep_compatible (
          arg_1);
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::is_fep_compatible_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_formatMismatch,
      AVStreams::_tc_deviceQosMismatch
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::FlowEndPoint>::in_arg_val _tao_fep;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_fep
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  is_fep_compatible_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_peer_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline set_peer_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::FlowConnection>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FlowConnection> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::FlowEndPoint>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FlowEndPoint> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_type arg_3 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::QoS> (
          this->operation_details_,
          this->args_,
          3);
        
      retval =
        this->servant_->set_peer (
          arg_1
          , arg_2
          , arg_3);
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::set_peer_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_QoSRequestFailed,
      AVStreams::_tc_streamOpFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::FlowConnection>::in_arg_val _tao_the_fc;
  TAO::SArg_Traits< ::AVStreams::FlowEndPoint>::in_arg_val _tao_the_peer_fep;
  TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_fc,
      &_tao_the_peer_fep,
      &_tao_the_qos
    };
  
  static size_t const nargs = 4;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  set_peer_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_Mcast_peer_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline set_Mcast_peer_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::FlowConnection>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FlowConnection> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::MCastConfigIf>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::MCastConfigIf> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_type arg_3 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::QoS> (
          this->operation_details_,
          this->args_,
          3);
        
      retval =
        this->servant_->set_Mcast_peer (
          arg_1
          , arg_2
          , arg_3);
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::set_Mcast_peer_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::FlowConnection>::in_arg_val _tao_the_fc;
  TAO::SArg_Traits< ::AVStreams::MCastConfigIf>::in_arg_val _tao_a_mcastconfigif;
  TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_fc,
      &_tao_a_mcastconfigif,
      &_tao_the_qos
    };
  
  static size_t const nargs = 4;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  set_Mcast_peer_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class connect_to_peer_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline connect_to_peer_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_type arg_1 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::QoS> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          3);
        
      retval =
        this->servant_->connect_to_peer (
          arg_1
          , arg_2
          , arg_3);
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::connect_to_peer_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_failedToConnect,
      AVStreams::_tc_FPError,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 3;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< char *>::in_arg_val _tao_address;
  TAO::SArg_Traits< char *>::in_arg_val _tao_use_flow_protocol;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_qos,
      &_tao_address,
      &_tao_use_flow_protocol
    };
  
  static size_t const nargs = 4;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  connect_to_peer_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class go_to_listen_FlowEndPoint
    : public TAO::Upcall_Command
  {
  public:
    inline go_to_listen_FlowEndPoint (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_type arg_1 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::QoS> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::AVStreams::FlowEndPoint>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FlowEndPoint> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< char *>::inout_arg_type arg_4 =
        TAO::Portable_Server::get_inout_arg< char *> (
          this->operation_details_,
          this->args_,
          4);
        
      retval =
        this->servant_->go_to_listen (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowEndPoint::go_to_listen_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_failedToListen,
      AVStreams::_tc_FPError,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 3;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_mcast;
  TAO::SArg_Traits< ::AVStreams::FlowEndPoint>::in_arg_val _tao_peer;
  TAO::SArg_Traits< char *>::inout_arg_val _tao_flowProtocol;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_qos,
      &_tao_is_mcast,
      &_tao_peer,
      &_tao_flowProtocol
    };
  
  static size_t const nargs = 5;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);

  go_to_listen_FlowEndPoint command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_FlowEndPoint_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_FlowEndPoint_Upcall_Command (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowEndPoint::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);
  
  _is_a_FlowEndPoint_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_FlowEndPoint_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_FlowEndPoint_Upcall_Command (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowEndPoint::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);
  
  _non_existent_FlowEndPoint_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_FlowEndPoint_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_FlowEndPoint_Upcall_Command (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowEndPoint::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);
  
  _repository_id_FlowEndPoint_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::FlowEndPoint::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_FlowEndPoint_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_FlowEndPoint_Upcall_Command (
      POA_AVStreams::FlowEndPoint * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::FlowEndPoint * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowEndPoint::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowEndPoint * const impl =
    static_cast<POA_AVStreams::FlowEndPoint *> (servant);
  
  _get_component_FlowEndPoint_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::FlowEndPoint::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/FlowEndPoint:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::FlowEndPoint::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/FlowEndPoint:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::FlowEndPoint::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::FlowEndPoint *
POA_AVStreams::FlowEndPoint::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::FlowEndPoint STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_FlowEndPoint_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_FlowProducer_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_FlowProducer_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_FlowProducer_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 30, 74, 20, 74,  0,
      5, 10, 74, 30, 74,  5, 74,  0,  0, 74,
     15, 74, 20, 74, 20,  0,  0,  0, 74, 74,
     74,  0, 74, 74, 74, 74, 74, 74,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_FlowProducer_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 39,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 28,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 73,
      HASH_VALUE_RANGE = 70,
      DUPLICATES = 5,
      WORDLIST_SIZE = 43
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"lock", &POA_AVStreams::FlowProducer::lock_skel, 0},
      {"start", &POA_AVStreams::FlowProducer::start_skel, 0},
      {"unlock", &POA_AVStreams::FlowProducer::unlock_skel, 0},
      {"set_key", &POA_AVStreams::FlowProducer::set_key_skel, 0},
      {"set_format", &POA_AVStreams::FlowProducer::set_format_skel, 0},
      {"destroy", &POA_AVStreams::FlowProducer::destroy_skel, 0},
      {"connect_mcast", &POA_AVStreams::FlowProducer::connect_mcast_skel, 0},
      {"set_dev_params", &POA_AVStreams::FlowProducer::set_dev_params_skel, 0},
      {"use_flow_protocol", &POA_AVStreams::FlowProducer::use_flow_protocol_skel, 0},
      {"set_source_id", &POA_AVStreams::FlowProducer::set_source_id_skel, 0},
      {"define_property", &POA_AVStreams::FlowProducer::define_property_skel, 0},
      {"delete_property", &POA_AVStreams::FlowProducer::delete_property_skel, 0},
      {"define_properties", &POA_AVStreams::FlowProducer::define_properties_skel, 0},
      {"delete_properties", &POA_AVStreams::FlowProducer::delete_properties_skel, 0},
      {"stop", &POA_AVStreams::FlowProducer::stop_skel, 0},
      {"delete_all_properties", &POA_AVStreams::FlowProducer::delete_all_properties_skel, 0},
      {"set_peer", &POA_AVStreams::FlowProducer::set_peer_skel, 0},
      {"is_property_defined", &POA_AVStreams::FlowProducer::is_property_defined_skel, 0},
      {"is_fep_compatible", &POA_AVStreams::FlowProducer::is_fep_compatible_skel, 0},
      {"set_Mcast_peer", &POA_AVStreams::FlowProducer::set_Mcast_peer_skel, 0},
      {"connect_to_peer", &POA_AVStreams::FlowProducer::connect_to_peer_skel, 0},
      {"set_protocol_restriction", &POA_AVStreams::FlowProducer::set_protocol_restriction_skel, 0},
      {"_component", &POA_AVStreams::FlowProducer::_component_skel, 0},
      {"_non_existent", &POA_AVStreams::FlowProducer::_non_existent_skel, 0},
      {"get_properties", &POA_AVStreams::FlowProducer::get_properties_skel, 0},
      {"get_rev_channel", &POA_AVStreams::FlowProducer::get_rev_channel_skel, 0},
      {"get_all_properties", &POA_AVStreams::FlowProducer::get_all_properties_skel, 0},
      {"_repository_id", &POA_AVStreams::FlowProducer::_repository_id_skel, 0},
      {"_interface", &POA_AVStreams::FlowProducer::_interface_skel, 0},
      {"get_all_property_names", &POA_AVStreams::FlowProducer::get_all_property_names_skel, 0},
      {"get_number_of_properties", &POA_AVStreams::FlowProducer::get_number_of_properties_skel, 0},
      {"_is_a", &POA_AVStreams::FlowProducer::_is_a_skel, 0},
      {"go_to_listen", &POA_AVStreams::FlowProducer::go_to_listen_skel, 0},
      {"get_property_value", &POA_AVStreams::FlowProducer::get_property_value_skel, 0},
      {"_get_related_sep", &POA_AVStreams::FlowProducer::_get_related_sep_skel, 0},
      {"_set_related_sep", &POA_AVStreams::FlowProducer::_set_related_sep_skel, 0},
      {"get_connected_fep", &POA_AVStreams::FlowProducer::get_connected_fep_skel, 0},
      {"_get_related_flow_connection", &POA_AVStreams::FlowProducer::_get_related_flow_connection_skel, 0},
      {"_set_related_flow_connection", &POA_AVStreams::FlowProducer::_set_related_flow_connection_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,   5,   6,   7, -14,  -2,   8,  -1,   9,  10, 
       11, -16,  -2,  12,  13,  -1, -85,  -1, -80,  -1,  18,  -1,  19,  -1, 
       20,  21,  -1,  -1,  22,  -1,  23,  24,  -1,  -1,  -1,  25,  26,  -1, 
       -1,  27,  28,  29,  -1,  -1,  30,  31,  32,  -1,  33,  -1,  34,  35, 
       -1,  36,  37,  -1,  -1,  -1,  -1,  -1, -38,  -2, -75,  40,  -1,  -1, 
       -1, -41,  -2, -75, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_AVStreams_FlowProducer_Perfect_Hash_OpTable tao_AVStreams_FlowProducer_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_FlowProducer_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_FlowProducer_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_FlowProducer_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_FlowProducer_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_FlowProducer_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_FlowProducer_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_FlowProducer_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::FlowProducer::FlowProducer (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_FlowProducer_optable;
}

POA_AVStreams::FlowProducer::FlowProducer (const FlowProducer& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CosPropertyService::PropertySet (rhs),
    POA_AVStreams::FlowEndPoint (rhs)
{
}

POA_AVStreams::FlowProducer::~FlowProducer (void)
{
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class connect_mcast_FlowProducer
    : public TAO::Upcall_Command
  {
  public:
    inline connect_mcast_FlowProducer (
      POA_AVStreams::FlowProducer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_type arg_1 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::QoS> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_type arg_2 =
        TAO::Portable_Server::get_out_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          4);
        
      retval =
        this->servant_->connect_mcast (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }
  
  private:
    POA_AVStreams::FlowProducer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowProducer::connect_mcast_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_failedToConnect,
      AVStreams::_tc_notSupported,
      AVStreams::_tc_FPError,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 4;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_is_met;
  TAO::SArg_Traits< char *>::in_arg_val _tao_address;
  TAO::SArg_Traits< char *>::in_arg_val _tao_use_flow_protocol;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_qos,
      &_tao_is_met,
      &_tao_address,
      &_tao_use_flow_protocol
    };
  
  static size_t const nargs = 5;

  POA_AVStreams::FlowProducer * const impl =
    static_cast<POA_AVStreams::FlowProducer *> (servant);

  connect_mcast_FlowProducer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_rev_channel_FlowProducer
    : public TAO::Upcall_Command
  {
  public:
    inline get_rev_channel_FlowProducer (
      POA_AVStreams::FlowProducer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->get_rev_channel (
          arg_1);
    }
  
  private:
    POA_AVStreams::FlowProducer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowProducer::get_rev_channel_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_pcol_name;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_pcol_name
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowProducer * const impl =
    static_cast<POA_AVStreams::FlowProducer *> (servant);

  get_rev_channel_FlowProducer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_key_FlowProducer
    : public TAO::Upcall_Command
  {
  public:
    inline set_key_FlowProducer (
      POA_AVStreams::FlowProducer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::key>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::key> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->set_key (
        arg_1);
    }
  
  private:
    POA_AVStreams::FlowProducer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowProducer::set_key_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::key>::in_arg_val _tao_the_key;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_key
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowProducer * const impl =
    static_cast<POA_AVStreams::FlowProducer *> (servant);

  set_key_FlowProducer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_source_id_FlowProducer
    : public TAO::Upcall_Command
  {
  public:
    inline set_source_id_FlowProducer (
      POA_AVStreams::FlowProducer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->set_source_id (
        arg_1);
    }
  
  private:
    POA_AVStreams::FlowProducer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FlowProducer::set_source_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_source_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_source_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowProducer * const impl =
    static_cast<POA_AVStreams::FlowProducer *> (servant);

  set_source_id_FlowProducer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_FlowProducer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_FlowProducer_Upcall_Command (
      POA_AVStreams::FlowProducer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::FlowProducer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowProducer::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowProducer * const impl =
    static_cast<POA_AVStreams::FlowProducer *> (servant);
  
  _is_a_FlowProducer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_FlowProducer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_FlowProducer_Upcall_Command (
      POA_AVStreams::FlowProducer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::FlowProducer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowProducer::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowProducer * const impl =
    static_cast<POA_AVStreams::FlowProducer *> (servant);
  
  _non_existent_FlowProducer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_FlowProducer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_FlowProducer_Upcall_Command (
      POA_AVStreams::FlowProducer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::FlowProducer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowProducer::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowProducer * const impl =
    static_cast<POA_AVStreams::FlowProducer *> (servant);
  
  _repository_id_FlowProducer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::FlowProducer::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::FlowProducer * const impl =
    static_cast<POA_AVStreams::FlowProducer *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_FlowProducer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_FlowProducer_Upcall_Command (
      POA_AVStreams::FlowProducer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::FlowProducer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowProducer::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowProducer * const impl =
    static_cast<POA_AVStreams::FlowProducer *> (servant);
  
  _get_component_FlowProducer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::FlowProducer::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/FlowEndPoint:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/FlowProducer:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::FlowProducer::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/FlowProducer:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::FlowProducer::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::FlowProducer *
POA_AVStreams::FlowProducer::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::FlowProducer STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_FlowProducer_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_FlowConsumer_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_FlowConsumer_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_FlowConsumer_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 10, 60,  5, 60, 10,
     20, 10, 60,  5, 60, 20, 60,  5,  0, 60,
     15, 60,  0, 60, 10,  0,  5,  0, 60, 60,
     60, 15, 60, 60, 60, 60, 60, 60,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_FlowConsumer_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 35,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 28,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 59,
      HASH_VALUE_RANGE = 56,
      DUPLICATES = 5,
      WORDLIST_SIZE = 39
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"stop", &POA_AVStreams::FlowConsumer::stop_skel, 0},
      {"lock", &POA_AVStreams::FlowConsumer::lock_skel, 0},
      {"start", &POA_AVStreams::FlowConsumer::start_skel, 0},
      {"unlock", &POA_AVStreams::FlowConsumer::unlock_skel, 0},
      {"set_dev_params", &POA_AVStreams::FlowConsumer::set_dev_params_skel, 0},
      {"set_format", &POA_AVStreams::FlowConsumer::set_format_skel, 0},
      {"use_flow_protocol", &POA_AVStreams::FlowConsumer::use_flow_protocol_skel, 0},
      {"set_peer", &POA_AVStreams::FlowConsumer::set_peer_skel, 0},
      {"get_properties", &POA_AVStreams::FlowConsumer::get_properties_skel, 0},
      {"_is_a", &POA_AVStreams::FlowConsumer::_is_a_skel, 0},
      {"get_connected_fep", &POA_AVStreams::FlowConsumer::get_connected_fep_skel, 0},
      {"get_all_properties", &POA_AVStreams::FlowConsumer::get_all_properties_skel, 0},
      {"set_Mcast_peer", &POA_AVStreams::FlowConsumer::set_Mcast_peer_skel, 0},
      {"_component", &POA_AVStreams::FlowConsumer::_component_skel, 0},
      {"_get_related_sep", &POA_AVStreams::FlowConsumer::_get_related_sep_skel, 0},
      {"_set_related_sep", &POA_AVStreams::FlowConsumer::_set_related_sep_skel, 0},
      {"get_all_property_names", &POA_AVStreams::FlowConsumer::get_all_property_names_skel, 0},
      {"_non_existent", &POA_AVStreams::FlowConsumer::_non_existent_skel, 0},
      {"get_number_of_properties", &POA_AVStreams::FlowConsumer::get_number_of_properties_skel, 0},
      {"_interface", &POA_AVStreams::FlowConsumer::_interface_skel, 0},
      {"go_to_listen", &POA_AVStreams::FlowConsumer::go_to_listen_skel, 0},
      {"get_property_value", &POA_AVStreams::FlowConsumer::get_property_value_skel, 0},
      {"connect_to_peer", &POA_AVStreams::FlowConsumer::connect_to_peer_skel, 0},
      {"define_properties", &POA_AVStreams::FlowConsumer::define_properties_skel, 0},
      {"delete_properties", &POA_AVStreams::FlowConsumer::delete_properties_skel, 0},
      {"set_protocol_restriction", &POA_AVStreams::FlowConsumer::set_protocol_restriction_skel, 0},
      {"delete_all_properties", &POA_AVStreams::FlowConsumer::delete_all_properties_skel, 0},
      {"destroy", &POA_AVStreams::FlowConsumer::destroy_skel, 0},
      {"_repository_id", &POA_AVStreams::FlowConsumer::_repository_id_skel, 0},
      {"is_fep_compatible", &POA_AVStreams::FlowConsumer::is_fep_compatible_skel, 0},
      {"define_property", &POA_AVStreams::FlowConsumer::define_property_skel, 0},
      {"delete_property", &POA_AVStreams::FlowConsumer::delete_property_skel, 0},
      {"_get_related_flow_connection", &POA_AVStreams::FlowConsumer::_get_related_flow_connection_skel, 0},
      {"_set_related_flow_connection", &POA_AVStreams::FlowConsumer::_set_related_flow_connection_skel, 0},
      {"is_property_defined", &POA_AVStreams::FlowConsumer::is_property_defined_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1, -18,  -2,   5,   6,   7, -27,  -2, 
        8,   9,  -1,  10,  11,  12,  13,  -1,  14,  15,  16,  17, -78,  20, 
       21,  22,  23,  -1,  24,  25,  -1,  26,  -1, -84,  -1,  29,  -1,  30, 
       31,  -1,  32,  -1,  -1,  33, -34,  -2, -61, -36,  -2, -61,  -1,  -1, 
       -1,  -1,  -1,  38, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_AVStreams_FlowConsumer_Perfect_Hash_OpTable tao_AVStreams_FlowConsumer_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_FlowConsumer_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_FlowConsumer_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_FlowConsumer_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_FlowConsumer_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_FlowConsumer_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_FlowConsumer_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_FlowConsumer_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::FlowConsumer::FlowConsumer (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_FlowConsumer_optable;
}

POA_AVStreams::FlowConsumer::FlowConsumer (const FlowConsumer& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CosPropertyService::PropertySet (rhs),
    POA_AVStreams::FlowEndPoint (rhs)
{
}

POA_AVStreams::FlowConsumer::~FlowConsumer (void)
{
}


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_FlowConsumer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_FlowConsumer_Upcall_Command (
      POA_AVStreams::FlowConsumer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::FlowConsumer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowConsumer::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FlowConsumer * const impl =
    static_cast<POA_AVStreams::FlowConsumer *> (servant);
  
  _is_a_FlowConsumer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_FlowConsumer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_FlowConsumer_Upcall_Command (
      POA_AVStreams::FlowConsumer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::FlowConsumer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowConsumer::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowConsumer * const impl =
    static_cast<POA_AVStreams::FlowConsumer *> (servant);
  
  _non_existent_FlowConsumer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_FlowConsumer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_FlowConsumer_Upcall_Command (
      POA_AVStreams::FlowConsumer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::FlowConsumer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowConsumer::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowConsumer * const impl =
    static_cast<POA_AVStreams::FlowConsumer *> (servant);
  
  _repository_id_FlowConsumer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::FlowConsumer::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::FlowConsumer * const impl =
    static_cast<POA_AVStreams::FlowConsumer *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_FlowConsumer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_FlowConsumer_Upcall_Command (
      POA_AVStreams::FlowConsumer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::FlowConsumer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FlowConsumer::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FlowConsumer * const impl =
    static_cast<POA_AVStreams::FlowConsumer *> (servant);
  
  _get_component_FlowConsumer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::FlowConsumer::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/FlowEndPoint:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/FlowConsumer:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::FlowConsumer::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/FlowConsumer:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::FlowConsumer::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::FlowConsumer *
POA_AVStreams::FlowConsumer::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::FlowConsumer STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_FlowConsumer_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_FDev_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_FDev_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_FDev_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46,  5, 46,  0, 30, 15,
      0, 10, 46,  0, 46, 10, 46, 46, 46, 46,
     46, 46, 46, 46,  0,  0,  5, 46, 46, 46,
     46,  0, 46, 46, 46, 46, 46, 46,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_FDev_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 21,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 24,
      MIN_HASH_VALUE = 7,
      MAX_HASH_VALUE = 45,
      HASH_VALUE_RANGE = 39,
      DUPLICATES = 4,
      WORDLIST_SIZE = 28
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"destroy", &POA_AVStreams::FDev::destroy_skel, 0},
      {"_is_a", &POA_AVStreams::FDev::_is_a_skel, 0},
      {"get_properties", &POA_AVStreams::FDev::get_properties_skel, 0},
      {"define_property", &POA_AVStreams::FDev::define_property_skel, 0},
      {"delete_property", &POA_AVStreams::FDev::delete_property_skel, 0},
      {"define_properties", &POA_AVStreams::FDev::define_properties_skel, 0},
      {"delete_properties", &POA_AVStreams::FDev::delete_properties_skel, 0},
      {"get_all_properties", &POA_AVStreams::FDev::get_all_properties_skel, 0},
      {"_repository_id", &POA_AVStreams::FDev::_repository_id_skel, 0},
      {"_component", &POA_AVStreams::FDev::_component_skel, 0},
      {"delete_all_properties", &POA_AVStreams::FDev::delete_all_properties_skel, 0},
      {"get_all_property_names", &POA_AVStreams::FDev::get_all_property_names_skel, 0},
      {"_non_existent", &POA_AVStreams::FDev::_non_existent_skel, 0},
      {"get_number_of_properties", &POA_AVStreams::FDev::get_number_of_properties_skel, 0},
      {"_interface", &POA_AVStreams::FDev::_interface_skel, 0},
      {"get_property_value", &POA_AVStreams::FDev::get_property_value_skel, 0},
      {"is_property_defined", &POA_AVStreams::FDev::is_property_defined_skel, 0},
      {"create_producer", &POA_AVStreams::FDev::create_producer_skel, 0},
      {"create_consumer", &POA_AVStreams::FDev::create_consumer_skel, 0},
      {"bind", &POA_AVStreams::FDev::bind_skel, 0},
      {"bind_mcast", &POA_AVStreams::FDev::bind_mcast_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1,   7, -10,  -2,   8,  -1, -12,  -2, 
        9, -52,  -1, -50,  14,  15,  16,  17,  18,  19,  20,  21, -24,  -2, 
       22,  23, -49,  -1,  -1,  -1,  26,  -1,  -1,  -1,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  27, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_AVStreams_FDev_Perfect_Hash_OpTable tao_AVStreams_FDev_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_FDev_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_FDev_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_FDev_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_FDev_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_FDev_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_FDev_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_FDev_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::FDev::FDev (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_FDev_optable;
}

POA_AVStreams::FDev::FDev (const FDev& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CosPropertyService::PropertySet (rhs)
{
}

POA_AVStreams::FDev::~FDev (void)
{
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class create_producer_FDev
    : public TAO::Upcall_Command
  {
  public:
    inline create_producer_FDev (
      POA_AVStreams::FDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::FlowProducer>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::AVStreams::FlowProducer> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::FlowConnection>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FlowConnection> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_type arg_2 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::QoS> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_type arg_3 =
        TAO::Portable_Server::get_out_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< char *>::inout_arg_type arg_4 =
        TAO::Portable_Server::get_inout_arg< char *> (
          this->operation_details_,
          this->args_,
          4);
        
      retval =
        this->servant_->create_producer (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }
  
  private:
    POA_AVStreams::FDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FDev::create_producer_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_streamOpDenied,
      AVStreams::_tc_notSupported,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 4;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::AVStreams::FlowProducer>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::FlowConnection>::in_arg_val _tao_the_requester;
  TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_met_qos;
  TAO::SArg_Traits< char *>::inout_arg_val _tao_named_fdev;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_requester,
      &_tao_the_qos,
      &_tao_met_qos,
      &_tao_named_fdev
    };
  
  static size_t const nargs = 5;

  POA_AVStreams::FDev * const impl =
    static_cast<POA_AVStreams::FDev *> (servant);

  create_producer_FDev command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class create_consumer_FDev
    : public TAO::Upcall_Command
  {
  public:
    inline create_consumer_FDev (
      POA_AVStreams::FDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::FlowConsumer>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::AVStreams::FlowConsumer> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::FlowConnection>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FlowConnection> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_type arg_2 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::QoS> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_type arg_3 =
        TAO::Portable_Server::get_out_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< char *>::inout_arg_type arg_4 =
        TAO::Portable_Server::get_inout_arg< char *> (
          this->operation_details_,
          this->args_,
          4);
        
      retval =
        this->servant_->create_consumer (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }
  
  private:
    POA_AVStreams::FDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FDev::create_consumer_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_streamOpDenied,
      AVStreams::_tc_notSupported,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 4;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::AVStreams::FlowConsumer>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::FlowConnection>::in_arg_val _tao_the_requester;
  TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_met_qos;
  TAO::SArg_Traits< char *>::inout_arg_val _tao_named_fdev;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_requester,
      &_tao_the_qos,
      &_tao_met_qos,
      &_tao_named_fdev
    };
  
  static size_t const nargs = 5;

  POA_AVStreams::FDev * const impl =
    static_cast<POA_AVStreams::FDev *> (servant);

  create_consumer_FDev command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class bind_FDev
    : public TAO::Upcall_Command
  {
  public:
    inline bind_FDev (
      POA_AVStreams::FDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::FlowConnection>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::AVStreams::FlowConnection> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::FDev>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FDev> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_type arg_2 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::QoS> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_type arg_3 =
        TAO::Portable_Server::get_out_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          3);
        
      retval =
        this->servant_->bind (
          arg_1
          , arg_2
          , arg_3);
    }
  
  private:
    POA_AVStreams::FDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FDev::bind_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::AVStreams::FlowConnection>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::FDev>::in_arg_val _tao_peer_device;
  TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_is_met;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_peer_device,
      &_tao_the_qos,
      &_tao_is_met
    };
  
  static size_t const nargs = 4;

  POA_AVStreams::FDev * const impl =
    static_cast<POA_AVStreams::FDev *> (servant);

  bind_FDev command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class bind_mcast_FDev
    : public TAO::Upcall_Command
  {
  public:
    inline bind_mcast_FDev (
      POA_AVStreams::FDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::FlowConnection>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::AVStreams::FlowConnection> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::FDev>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FDev> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_type arg_2 =
        TAO::Portable_Server::get_inout_arg< ::AVStreams::QoS> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_type arg_3 =
        TAO::Portable_Server::get_out_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          3);
        
      retval =
        this->servant_->bind_mcast (
          arg_1
          , arg_2
          , arg_3);
    }
  
  private:
    POA_AVStreams::FDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FDev::bind_mcast_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_streamOpFailed,
      AVStreams::_tc_QoSRequestFailed
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::AVStreams::FlowConnection>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::FDev>::in_arg_val _tao_first_peer;
  TAO::SArg_Traits< ::AVStreams::QoS>::inout_arg_val _tao_the_qos;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::out_arg_val _tao_is_met;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_first_peer,
      &_tao_the_qos,
      &_tao_is_met
    };
  
  static size_t const nargs = 4;

  POA_AVStreams::FDev * const impl =
    static_cast<POA_AVStreams::FDev *> (servant);

  bind_mcast_FDev command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class destroy_FDev
    : public TAO::Upcall_Command
  {
  public:
    inline destroy_FDev (
      POA_AVStreams::FDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::FlowEndPoint>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::FlowEndPoint> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->destroy (
        arg_1
        , arg_2);
    }
  
  private:
    POA_AVStreams::FDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::FDev::destroy_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_notSupported
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::FlowEndPoint>::in_arg_val _tao_the_ep;
  TAO::SArg_Traits< char *>::in_arg_val _tao_fdev_name;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_the_ep,
      &_tao_fdev_name
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::FDev * const impl =
    static_cast<POA_AVStreams::FDev *> (servant);

  destroy_FDev command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_FDev_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_FDev_Upcall_Command (
      POA_AVStreams::FDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::FDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FDev::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::FDev * const impl =
    static_cast<POA_AVStreams::FDev *> (servant);
  
  _is_a_FDev_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_FDev_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_FDev_Upcall_Command (
      POA_AVStreams::FDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::FDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FDev::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FDev * const impl =
    static_cast<POA_AVStreams::FDev *> (servant);
  
  _non_existent_FDev_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_FDev_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_FDev_Upcall_Command (
      POA_AVStreams::FDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::FDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FDev::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FDev * const impl =
    static_cast<POA_AVStreams::FDev *> (servant);
  
  _repository_id_FDev_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::FDev::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::FDev * const impl =
    static_cast<POA_AVStreams::FDev *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_FDev_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_FDev_Upcall_Command (
      POA_AVStreams::FDev * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::FDev * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::FDev::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::FDev * const impl =
    static_cast<POA_AVStreams::FDev *> (servant);
  
  _get_component_FDev_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::FDev::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CosPropertyService/PropertySet:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/FDev:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::FDev::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/FDev:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::FDev::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::FDev *
POA_AVStreams::FDev::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::FDev STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_FDev_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1714

class TAO_AVStreams_MediaControl_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_AVStreams_MediaControl_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_AVStreams_MediaControl_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
     26, 26, 26, 26, 26,  0, 26, 15, 26, 26,
      0,  5, 26,  5, 26, 26, 26, 26, 26, 26,
      0, 26, 15, 26,  0,  0,  0, 26, 26, 26,
     26, 26, 26, 26, 26, 26, 26, 26,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_AVStreams_MediaControl_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 11,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 18,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 25,
      HASH_VALUE_RANGE = 21,
      DUPLICATES = 0,
      WORDLIST_SIZE = 16
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"start", &POA_AVStreams::MediaControl::start_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_component", &POA_AVStreams::MediaControl::_component_skel, 0},
      {"resume", &POA_AVStreams::MediaControl::resume_skel, 0},
      {"",0,0},
      {"_non_existent", &POA_AVStreams::MediaControl::_non_existent_skel, 0},
      {"_repository_id", &POA_AVStreams::MediaControl::_repository_id_skel, 0},
      {"_interface", &POA_AVStreams::MediaControl::_interface_skel, 0},
      {"",0,0},{"",0,0},
      {"set_media_position", &POA_AVStreams::MediaControl::set_media_position_skel, 0},
      {"stop", &POA_AVStreams::MediaControl::stop_skel, 0},
      {"_is_a", &POA_AVStreams::MediaControl::_is_a_skel, 0},
      {"",0,0},{"",0,0},
      {"get_media_position", &POA_AVStreams::MediaControl::get_media_position_skel, 0},
      {"",0,0},
      {"pause", &POA_AVStreams::MediaControl::pause_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_AVStreams_MediaControl_Perfect_Hash_OpTable tao_AVStreams_MediaControl_optable;

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:1029

TAO::Collocation_Proxy_Broker *
AVStreams__TAO_MediaControl_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
AVStreams__TAO_MediaControl_Proxy_Broker_Factory_Initializer (size_t)
{
  AVStreams__TAO_MediaControl_Proxy_Broker_Factory_function_pointer = 
    AVStreams__TAO_MediaControl_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
AVStreams__TAO_MediaControl_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  AVStreams__TAO_MediaControl_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (AVStreams__TAO_MediaControl_Proxy_Broker_Factory_Initializer));


// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:97

POA_AVStreams::MediaControl::MediaControl (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_AVStreams_MediaControl_optable;
}

POA_AVStreams::MediaControl::MediaControl (const MediaControl& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_AVStreams::MediaControl::~MediaControl (void)
{
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class get_media_position_MediaControl
    : public TAO::Upcall_Command
  {
  public:
    inline get_media_position_MediaControl (
      POA_AVStreams::MediaControl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::Position>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::AVStreams::Position> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::AVStreams::PositionOrigin>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::PositionOrigin> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::AVStreams::PositionKey>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::PositionKey> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->get_media_position (
          arg_1
          , arg_2);
    }
  
  private:
    POA_AVStreams::MediaControl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MediaControl::get_media_position_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::MediaControl::_tc_PostionKeyNotSupported
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::AVStreams::Position>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::PositionOrigin>::in_arg_val _tao_an_origin;
  TAO::SArg_Traits< ::AVStreams::PositionKey>::in_arg_val _tao_a_key;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_an_origin,
      &_tao_a_key
    };
  
  static size_t const nargs = 3;

  POA_AVStreams::MediaControl * const impl =
    static_cast<POA_AVStreams::MediaControl *> (servant);

  get_media_position_MediaControl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class set_media_position_MediaControl
    : public TAO::Upcall_Command
  {
  public:
    inline set_media_position_MediaControl (
      POA_AVStreams::MediaControl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::Position>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::Position> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->set_media_position (
        arg_1);
    }
  
  private:
    POA_AVStreams::MediaControl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MediaControl::set_media_position_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::MediaControl::_tc_PostionKeyNotSupported,
      AVStreams::_tc_InvalidPosition
    };
  static ::CORBA::ULong const nexceptions = 2;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::Position>::in_arg_val _tao_a_position;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_a_position
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::MediaControl * const impl =
    static_cast<POA_AVStreams::MediaControl *> (servant);

  set_media_position_MediaControl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class start_MediaControl
    : public TAO::Upcall_Command
  {
  public:
    inline start_MediaControl (
      POA_AVStreams::MediaControl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::Position>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::Position> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->start (
        arg_1);
    }
  
  private:
    POA_AVStreams::MediaControl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MediaControl::start_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_InvalidPosition
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::Position>::in_arg_val _tao_a_position;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_a_position
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::MediaControl * const impl =
    static_cast<POA_AVStreams::MediaControl *> (servant);

  start_MediaControl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class pause_MediaControl
    : public TAO::Upcall_Command
  {
  public:
    inline pause_MediaControl (
      POA_AVStreams::MediaControl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::Position>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::Position> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->pause (
        arg_1);
    }
  
  private:
    POA_AVStreams::MediaControl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MediaControl::pause_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_InvalidPosition
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::Position>::in_arg_val _tao_a_position;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_a_position
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::MediaControl * const impl =
    static_cast<POA_AVStreams::MediaControl *> (servant);

  pause_MediaControl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class resume_MediaControl
    : public TAO::Upcall_Command
  {
  public:
    inline resume_MediaControl (
      POA_AVStreams::MediaControl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::Position>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::Position> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->resume (
        arg_1);
    }
  
  private:
    POA_AVStreams::MediaControl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MediaControl::resume_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_InvalidPosition
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::Position>::in_arg_val _tao_a_position;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_a_position
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::MediaControl * const impl =
    static_cast<POA_AVStreams::MediaControl *> (servant);

  resume_MediaControl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class stop_MediaControl
    : public TAO::Upcall_Command
  {
  public:
    inline stop_MediaControl (
      POA_AVStreams::MediaControl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::AVStreams::Position>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::AVStreams::Position> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->stop (
        arg_1);
    }
  
  private:
    POA_AVStreams::MediaControl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:173

void POA_AVStreams::MediaControl::stop_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      AVStreams::_tc_InvalidPosition
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::AVStreams::Position>::in_arg_val _tao_a_position;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_a_position
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::MediaControl * const impl =
    static_cast<POA_AVStreams::MediaControl *> (servant);

  stop_MediaControl command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:170


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _is_a_MediaControl_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_MediaControl_Upcall_Command (
      POA_AVStreams::MediaControl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_AVStreams::MediaControl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::MediaControl::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;

  POA_AVStreams::MediaControl * const impl =
    static_cast<POA_AVStreams::MediaControl *> (servant);
  
  _is_a_MediaControl_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _non_existent_MediaControl_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_MediaControl_Upcall_Command (
      POA_AVStreams::MediaControl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_AVStreams::MediaControl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::MediaControl::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::MediaControl * const impl =
    static_cast<POA_AVStreams::MediaControl *> (servant);
  
  _non_existent_MediaControl_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _repository_id_MediaControl_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_MediaControl_Upcall_Command (
      POA_AVStreams::MediaControl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_AVStreams::MediaControl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::MediaControl::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::MediaControl * const impl =
    static_cast<POA_AVStreams::MediaControl *> (servant);
  
  _repository_id_MediaControl_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:525

void POA_AVStreams::MediaControl::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (!_tao_adapter)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_AVStreams::MediaControl * const impl =
    static_cast<POA_AVStreams::MediaControl *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);

  if (!_tao_result)
    {
      throw ::CORBA::MARSHAL ();
    }
}


namespace POA_AVStreams
{
  

  // TAO_IDL - Generated from
  // e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:81

  class _get_component_MediaControl_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_MediaControl_Upcall_Command (
      POA_AVStreams::MediaControl * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_AVStreams::MediaControl * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

void POA_AVStreams::MediaControl::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_AVStreams::MediaControl * const impl =
    static_cast<POA_AVStreams::MediaControl *> (servant);
  
  _get_component_MediaControl_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_AVStreams::MediaControl::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/AVStreams/MediaControl:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_AVStreams::MediaControl::_interface_repository_id (void) const
{
  return "IDL:omg.org/AVStreams/MediaControl:1.0";
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:966

void POA_AVStreams::MediaControl::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// e:\sca\ace_diab\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:884

AVStreams::MediaControl *
POA_AVStreams::MediaControl::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::AVStreams::MediaControl STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        AVStreams__TAO_MediaControl_Proxy_Broker_Factory_function_pointer
      );
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* ifndef */

