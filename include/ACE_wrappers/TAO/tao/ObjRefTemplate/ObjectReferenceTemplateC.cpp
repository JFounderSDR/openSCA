// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "tao/ObjRefTemplate/ObjectReferenceTemplate.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Value_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Value_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Valuetype/ValueFactory.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"

#if !defined (__ACE_INLINE__)
#include "ObjectReferenceTemplateC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/value_typecode.cpp:65

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_PortableInterceptor_ObjectReferenceFactory = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_PortableInterceptor_ObjectReferenceFactory (
    ::CORBA::tk_value,
    "IDL:omg.org/PortableInterceptor/ObjectReferenceFactory:1.0",
    "ObjectReferenceFactory",
    ::CORBA::VM_ABSTRACT,
    &::CORBA::_tc_null,
    _tao_fields_PortableInterceptor_ObjectReferenceFactory,
    0);
  

namespace PortableInterceptor
{
  ::CORBA::TypeCode_ptr const _tc_ObjectReferenceFactory =
    &_tao_tc_PortableInterceptor_ObjectReferenceFactory;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_valuetype/valuetype_cs.cpp:55

void
TAO::Value_Traits<PortableInterceptor::ObjectReferenceFactory>::add_ref (
    PortableInterceptor::ObjectReferenceFactory * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<PortableInterceptor::ObjectReferenceFactory>::remove_ref (
    PortableInterceptor::ObjectReferenceFactory * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<PortableInterceptor::ObjectReferenceFactory>::release (
    PortableInterceptor::ObjectReferenceFactory * p)
{
  ::CORBA::remove_ref (p);
}

PortableInterceptor::ObjectReferenceFactory *
PortableInterceptor::ObjectReferenceFactory::_downcast ( ::CORBA::ValueBase *v)
{
  return dynamic_cast< ::PortableInterceptor::ObjectReferenceFactory * > (v);
}

const char *
PortableInterceptor::ObjectReferenceFactory::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void
PortableInterceptor::ObjectReferenceFactory::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
PortableInterceptor::ObjectReferenceFactory::_tao_any_destructor (void *_tao_void_pointer)
{
  ObjectReferenceFactory *_tao_tmp_pointer =
    static_cast<ObjectReferenceFactory *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableInterceptor::ObjectReferenceFactory::_tao_type (void) const
{
  return ::PortableInterceptor::_tc_ObjectReferenceFactory;
}

PortableInterceptor::ObjectReferenceFactory::~ObjectReferenceFactory (void)
{}

::CORBA::Boolean 
PortableInterceptor::ObjectReferenceFactory::_tao_unmarshal (
    TAO_InputCDR &strm,
    ObjectReferenceFactory *&new_object
  )
{
  ::CORBA::ValueBase *base = 0;
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        ObjectReferenceFactory::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = ObjectReferenceFactory::_downcast (base);
  if (0 == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/value_typecode.cpp:65

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_PortableInterceptor_ObjectReferenceTemplate = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_PortableInterceptor_ObjectReferenceTemplate (
    ::CORBA::tk_value,
    "IDL:omg.org/PortableInterceptor/ObjectReferenceTemplate:1.0",
    "ObjectReferenceTemplate",
    ::CORBA::VM_ABSTRACT,
    &::CORBA::_tc_null,
    _tao_fields_PortableInterceptor_ObjectReferenceTemplate,
    0);
  

namespace PortableInterceptor
{
  ::CORBA::TypeCode_ptr const _tc_ObjectReferenceTemplate =
    &_tao_tc_PortableInterceptor_ObjectReferenceTemplate;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_valuetype/valuetype_cs.cpp:55

void
TAO::Value_Traits<PortableInterceptor::ObjectReferenceTemplate>::add_ref (
    PortableInterceptor::ObjectReferenceTemplate * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<PortableInterceptor::ObjectReferenceTemplate>::remove_ref (
    PortableInterceptor::ObjectReferenceTemplate * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<PortableInterceptor::ObjectReferenceTemplate>::release (
    PortableInterceptor::ObjectReferenceTemplate * p)
{
  ::CORBA::remove_ref (p);
}

PortableInterceptor::ObjectReferenceTemplate *
PortableInterceptor::ObjectReferenceTemplate::_downcast ( ::CORBA::ValueBase *v)
{
  return dynamic_cast< ::PortableInterceptor::ObjectReferenceTemplate * > (v);
}

const char *
PortableInterceptor::ObjectReferenceTemplate::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void
PortableInterceptor::ObjectReferenceTemplate::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
PortableInterceptor::ObjectReferenceTemplate::_tao_any_destructor (void *_tao_void_pointer)
{
  ObjectReferenceTemplate *_tao_tmp_pointer =
    static_cast<ObjectReferenceTemplate *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr PortableInterceptor::ObjectReferenceTemplate::_tao_type (void) const
{
  return ::PortableInterceptor::_tc_ObjectReferenceTemplate;
}

PortableInterceptor::ObjectReferenceTemplate::~ObjectReferenceTemplate (void)
{}

::CORBA::Boolean 
PortableInterceptor::ObjectReferenceTemplate::_tao_unmarshal (
    TAO_InputCDR &strm,
    ObjectReferenceTemplate *&new_object
  )
{
  ::CORBA::ValueBase *base = 0;
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        ObjectReferenceTemplate::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = ObjectReferenceTemplate::_downcast (base);
  if (0 == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PORTABLEINTERCEPTOR_OBJECTREFERENCETEMPLATESEQ_CS_)
#define _PORTABLEINTERCEPTOR_OBJECTREFERENCETEMPLATESEQ_CS_

PortableInterceptor::ObjectReferenceTemplateSeq::ObjectReferenceTemplateSeq (void)
{}

PortableInterceptor::ObjectReferenceTemplateSeq::ObjectReferenceTemplateSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_valuetype_sequence<
        ObjectReferenceTemplate,
        ObjectReferenceTemplate_var
      > (max)
{}

PortableInterceptor::ObjectReferenceTemplateSeq::ObjectReferenceTemplateSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    PortableInterceptor::ObjectReferenceTemplate * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_valuetype_sequence<
        ObjectReferenceTemplate,
        ObjectReferenceTemplate_var
      >
    (max, length, buffer, release)
{}

PortableInterceptor::ObjectReferenceTemplateSeq::ObjectReferenceTemplateSeq (
    const ObjectReferenceTemplateSeq &seq)
  : ::TAO::unbounded_valuetype_sequence<
        ObjectReferenceTemplate,
        ObjectReferenceTemplate_var
      > (seq)
{}

PortableInterceptor::ObjectReferenceTemplateSeq::~ObjectReferenceTemplateSeq (void)
{}

void PortableInterceptor::ObjectReferenceTemplateSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ObjectReferenceTemplateSeq * _tao_tmp_pointer =
    static_cast<ObjectReferenceTemplateSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_PortableInterceptor_ObjectReferenceTemplateSeq_GUARD
#define _TAO_TYPECODE_PortableInterceptor_ObjectReferenceTemplateSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        PortableInterceptor_ObjectReferenceTemplateSeq_0 (
          ::CORBA::tk_sequence,
          &PortableInterceptor::_tc_ObjectReferenceTemplate,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_PortableInterceptor_ObjectReferenceTemplateSeq_0 =
        &PortableInterceptor_ObjectReferenceTemplateSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_PortableInterceptor_ObjectReferenceTemplateSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_PortableInterceptor_ObjectReferenceTemplateSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/PortableInterceptor/ObjectReferenceTemplateSeq:1.0",
    "ObjectReferenceTemplateSeq",
    &TAO::TypeCode::tc_PortableInterceptor_ObjectReferenceTemplateSeq_0);
  

namespace PortableInterceptor
{
  ::CORBA::TypeCode_ptr const _tc_ObjectReferenceTemplateSeq =
    &_tao_tc_PortableInterceptor_ObjectReferenceTemplateSeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_valuetype/any_op_cs.cpp:48

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableInterceptor::ObjectReferenceFactory>::to_value (
      ::CORBA::ValueBase *&_tao_elem
    ) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableInterceptor
{
  // Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ObjectReferenceFactory *_tao_elem
    )
  {
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= &_tao_elem;
  }

  // Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ObjectReferenceFactory **_tao_elem
    )
  {
    TAO::Any_Impl_T<ObjectReferenceFactory>::insert (
        _tao_any,
        ObjectReferenceFactory::_tao_any_destructor,
        (*_tao_elem)->_tao_type (),
        *_tao_elem
      );
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      ObjectReferenceFactory *&_tao_elem
    )
  {
    return
      TAO::Any_Impl_T<ObjectReferenceFactory>::extract (
          _tao_any,
          ObjectReferenceFactory::_tao_any_destructor,
          _tc_ObjectReferenceFactory,
          _tao_elem
        );
  }

  
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableInterceptor::ObjectReferenceFactory *_tao_elem
  )
{
  ::CORBA::add_ref (_tao_elem);
  _tao_any <<= &_tao_elem;
}

// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableInterceptor::ObjectReferenceFactory **_tao_elem
  )
{
  TAO::Any_Impl_T<PortableInterceptor::ObjectReferenceFactory>::insert (
      _tao_any,
      PortableInterceptor::ObjectReferenceFactory::_tao_any_destructor,
      (*_tao_elem)->_tao_type (),
      *_tao_elem
    );
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableInterceptor::ObjectReferenceFactory *&_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableInterceptor::ObjectReferenceFactory>::extract (
        _tao_any,
        PortableInterceptor::ObjectReferenceFactory::_tao_any_destructor,
        PortableInterceptor::_tc_ObjectReferenceFactory,
        _tao_elem
      );
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_valuetype/any_op_cs.cpp:48

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<PortableInterceptor::ObjectReferenceTemplate>::to_value (
      ::CORBA::ValueBase *&_tao_elem
    ) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableInterceptor
{
  // Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ObjectReferenceTemplate *_tao_elem
    )
  {
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= &_tao_elem;
  }

  // Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ObjectReferenceTemplate **_tao_elem
    )
  {
    TAO::Any_Impl_T<ObjectReferenceTemplate>::insert (
        _tao_any,
        ObjectReferenceTemplate::_tao_any_destructor,
        (*_tao_elem)->_tao_type (),
        *_tao_elem
      );
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      ObjectReferenceTemplate *&_tao_elem
    )
  {
    return
      TAO::Any_Impl_T<ObjectReferenceTemplate>::extract (
          _tao_any,
          ObjectReferenceTemplate::_tao_any_destructor,
          _tc_ObjectReferenceTemplate,
          _tao_elem
        );
  }

  
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableInterceptor::ObjectReferenceTemplate *_tao_elem
  )
{
  ::CORBA::add_ref (_tao_elem);
  _tao_any <<= &_tao_elem;
}

// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    PortableInterceptor::ObjectReferenceTemplate **_tao_elem
  )
{
  TAO::Any_Impl_T<PortableInterceptor::ObjectReferenceTemplate>::insert (
      _tao_any,
      PortableInterceptor::ObjectReferenceTemplate::_tao_any_destructor,
      (*_tao_elem)->_tao_type (),
      *_tao_elem
    );
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableInterceptor::ObjectReferenceTemplate *&_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableInterceptor::ObjectReferenceTemplate>::extract (
        _tao_any,
        PortableInterceptor::ObjectReferenceTemplate::_tao_any_destructor,
        PortableInterceptor::_tc_ObjectReferenceTemplate,
        _tao_elem
      );
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace PortableInterceptor
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::PortableInterceptor::ObjectReferenceTemplateSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::PortableInterceptor::ObjectReferenceTemplateSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::PortableInterceptor::ObjectReferenceTemplateSeq>::insert_copy (
          _tao_any,
          ::PortableInterceptor::ObjectReferenceTemplateSeq::_tao_any_destructor,
          ::PortableInterceptor::_tc_ObjectReferenceTemplateSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::PortableInterceptor::ObjectReferenceTemplateSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::PortableInterceptor::ObjectReferenceTemplateSeq>::insert (
        _tao_any,
        ::PortableInterceptor::ObjectReferenceTemplateSeq::_tao_any_destructor,
        ::PortableInterceptor::_tc_ObjectReferenceTemplateSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::PortableInterceptor::ObjectReferenceTemplateSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::PortableInterceptor::ObjectReferenceTemplateSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::PortableInterceptor::ObjectReferenceTemplateSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::PortableInterceptor::ObjectReferenceTemplateSeq>::extract (
          _tao_any,
          ::PortableInterceptor::ObjectReferenceTemplateSeq::_tao_any_destructor,
          ::PortableInterceptor::_tc_ObjectReferenceTemplateSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const PortableInterceptor::ObjectReferenceTemplateSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<PortableInterceptor::ObjectReferenceTemplateSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<PortableInterceptor::ObjectReferenceTemplateSeq>::insert_copy (
        _tao_any,
        PortableInterceptor::ObjectReferenceTemplateSeq::_tao_any_destructor,
        PortableInterceptor::_tc_ObjectReferenceTemplateSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    PortableInterceptor::ObjectReferenceTemplateSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableInterceptor::ObjectReferenceTemplateSeq>::insert (
      _tao_any,
      PortableInterceptor::ObjectReferenceTemplateSeq::_tao_any_destructor,
      PortableInterceptor::_tc_ObjectReferenceTemplateSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    PortableInterceptor::ObjectReferenceTemplateSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const PortableInterceptor::ObjectReferenceTemplateSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const PortableInterceptor::ObjectReferenceTemplateSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableInterceptor::ObjectReferenceTemplateSeq>::extract (
        _tao_any,
        PortableInterceptor::ObjectReferenceTemplateSeq::_tao_any_destructor,
        PortableInterceptor::_tc_ObjectReferenceTemplateSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// .\be\be_valuetype.cpp:508

void
CORBA::add_ref (PortableInterceptor::ObjectReferenceFactory * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (PortableInterceptor::ObjectReferenceFactory * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_valuetype/cdr_op_cs.cpp:62



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm, 
    const PortableInterceptor::ObjectReferenceFactory *_tao_valuetype
  )
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&PortableInterceptor::ObjectReferenceFactory::_downcast)
      );
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::ObjectReferenceFactory *&_tao_valuetype
  )
{
  return PortableInterceptor::ObjectReferenceFactory::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// .\be\be_valuetype.cpp:508

void
CORBA::add_ref (PortableInterceptor::ObjectReferenceTemplate * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (PortableInterceptor::ObjectReferenceTemplate * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_valuetype/cdr_op_cs.cpp:62



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm, 
    const PortableInterceptor::ObjectReferenceTemplate *_tao_valuetype
  )
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&PortableInterceptor::ObjectReferenceTemplate::_downcast)
      );
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::ObjectReferenceTemplate *&_tao_valuetype
  )
{
  return PortableInterceptor::ObjectReferenceTemplate::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_PortableInterceptor_ObjectReferenceTemplateSeq_CPP_
#define _TAO_CDR_OP_PortableInterceptor_ObjectReferenceTemplateSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::ObjectReferenceTemplateSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::ObjectReferenceTemplateSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_PortableInterceptor_ObjectReferenceTemplateSeq_CPP_ */


TAO_END_VERSIONED_NAMESPACE_DECL


