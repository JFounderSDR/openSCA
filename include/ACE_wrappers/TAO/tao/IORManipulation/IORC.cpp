// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "tao/IORManipulation/IORManip_Loader.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/CDR.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "ace/OS_NS_string.h"

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

TAO_IOP::EmptyProfileList::EmptyProfileList (void)
  : ::CORBA::UserException (
        "IDL:TAO_IOP/EmptyProfileList:1.0",
        "EmptyProfileList"
      )
{
}

TAO_IOP::EmptyProfileList::~EmptyProfileList (void)
{
}

TAO_IOP::EmptyProfileList::EmptyProfileList (const ::TAO_IOP::EmptyProfileList &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

TAO_IOP::EmptyProfileList&
TAO_IOP::EmptyProfileList::operator= (const ::TAO_IOP::EmptyProfileList &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void TAO_IOP::EmptyProfileList::_tao_any_destructor (void *_tao_void_pointer)
{
  EmptyProfileList *_tao_tmp_pointer =
    static_cast<EmptyProfileList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

TAO_IOP::EmptyProfileList *
TAO_IOP::EmptyProfileList::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<EmptyProfileList *> (_tao_excp);
}

const TAO_IOP::EmptyProfileList *
TAO_IOP::EmptyProfileList::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const EmptyProfileList *> (_tao_excp);
}

::CORBA::Exception *TAO_IOP::EmptyProfileList::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::TAO_IOP::EmptyProfileList, 0);
  return retval;
}

::CORBA::Exception *
TAO_IOP::EmptyProfileList::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::TAO_IOP::EmptyProfileList (*this),
      0
    );
  return result;
}

void TAO_IOP::EmptyProfileList::_raise (void) const
{
  throw *this;
}

void TAO_IOP::EmptyProfileList::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void TAO_IOP::EmptyProfileList::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr TAO_IOP::EmptyProfileList::_tao_type (void) const
{
  return ::TAO_IOP::_tc_EmptyProfileList;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_TAO_IOP_EmptyProfileList = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TAO_IOP_EmptyProfileList (
  ::CORBA::tk_except,
  "IDL:TAO_IOP/EmptyProfileList:1.0",
  "EmptyProfileList",
  _tao_fields_TAO_IOP_EmptyProfileList,
  0);


namespace TAO_IOP
{
  ::CORBA::TypeCode_ptr const _tc_EmptyProfileList =
    &_tao_tc_TAO_IOP_EmptyProfileList;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

TAO_IOP::NotFound::NotFound (void)
  : ::CORBA::UserException (
        "IDL:TAO_IOP/NotFound:1.0",
        "NotFound"
      )
{
}

TAO_IOP::NotFound::~NotFound (void)
{
}

TAO_IOP::NotFound::NotFound (const ::TAO_IOP::NotFound &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

TAO_IOP::NotFound&
TAO_IOP::NotFound::operator= (const ::TAO_IOP::NotFound &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void TAO_IOP::NotFound::_tao_any_destructor (void *_tao_void_pointer)
{
  NotFound *_tao_tmp_pointer =
    static_cast<NotFound *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

TAO_IOP::NotFound *
TAO_IOP::NotFound::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NotFound *> (_tao_excp);
}

const TAO_IOP::NotFound *
TAO_IOP::NotFound::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NotFound *> (_tao_excp);
}

::CORBA::Exception *TAO_IOP::NotFound::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::TAO_IOP::NotFound, 0);
  return retval;
}

::CORBA::Exception *
TAO_IOP::NotFound::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::TAO_IOP::NotFound (*this),
      0
    );
  return result;
}

void TAO_IOP::NotFound::_raise (void) const
{
  throw *this;
}

void TAO_IOP::NotFound::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void TAO_IOP::NotFound::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr TAO_IOP::NotFound::_tao_type (void) const
{
  return ::TAO_IOP::_tc_NotFound;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_TAO_IOP_NotFound = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TAO_IOP_NotFound (
  ::CORBA::tk_except,
  "IDL:TAO_IOP/NotFound:1.0",
  "NotFound",
  _tao_fields_TAO_IOP_NotFound,
  0);


namespace TAO_IOP
{
  ::CORBA::TypeCode_ptr const _tc_NotFound =
    &_tao_tc_TAO_IOP_NotFound;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

TAO_IOP::Duplicate::Duplicate (void)
  : ::CORBA::UserException (
        "IDL:TAO_IOP/Duplicate:1.0",
        "Duplicate"
      )
{
}

TAO_IOP::Duplicate::~Duplicate (void)
{
}

TAO_IOP::Duplicate::Duplicate (const ::TAO_IOP::Duplicate &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

TAO_IOP::Duplicate&
TAO_IOP::Duplicate::operator= (const ::TAO_IOP::Duplicate &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void TAO_IOP::Duplicate::_tao_any_destructor (void *_tao_void_pointer)
{
  Duplicate *_tao_tmp_pointer =
    static_cast<Duplicate *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

TAO_IOP::Duplicate *
TAO_IOP::Duplicate::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<Duplicate *> (_tao_excp);
}

const TAO_IOP::Duplicate *
TAO_IOP::Duplicate::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const Duplicate *> (_tao_excp);
}

::CORBA::Exception *TAO_IOP::Duplicate::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::TAO_IOP::Duplicate, 0);
  return retval;
}

::CORBA::Exception *
TAO_IOP::Duplicate::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::TAO_IOP::Duplicate (*this),
      0
    );
  return result;
}

void TAO_IOP::Duplicate::_raise (void) const
{
  throw *this;
}

void TAO_IOP::Duplicate::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void TAO_IOP::Duplicate::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr TAO_IOP::Duplicate::_tao_type (void) const
{
  return ::TAO_IOP::_tc_Duplicate;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_TAO_IOP_Duplicate = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TAO_IOP_Duplicate (
  ::CORBA::tk_except,
  "IDL:TAO_IOP/Duplicate:1.0",
  "Duplicate",
  _tao_fields_TAO_IOP_Duplicate,
  0);


namespace TAO_IOP
{
  ::CORBA::TypeCode_ptr const _tc_Duplicate =
    &_tao_tc_TAO_IOP_Duplicate;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

TAO_IOP::Invalid_IOR::Invalid_IOR (void)
  : ::CORBA::UserException (
        "IDL:TAO_IOP/Invalid_IOR:1.0",
        "Invalid_IOR"
      )
{
}

TAO_IOP::Invalid_IOR::~Invalid_IOR (void)
{
}

TAO_IOP::Invalid_IOR::Invalid_IOR (const ::TAO_IOP::Invalid_IOR &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

TAO_IOP::Invalid_IOR&
TAO_IOP::Invalid_IOR::operator= (const ::TAO_IOP::Invalid_IOR &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void TAO_IOP::Invalid_IOR::_tao_any_destructor (void *_tao_void_pointer)
{
  Invalid_IOR *_tao_tmp_pointer =
    static_cast<Invalid_IOR *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

TAO_IOP::Invalid_IOR *
TAO_IOP::Invalid_IOR::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<Invalid_IOR *> (_tao_excp);
}

const TAO_IOP::Invalid_IOR *
TAO_IOP::Invalid_IOR::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const Invalid_IOR *> (_tao_excp);
}

::CORBA::Exception *TAO_IOP::Invalid_IOR::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::TAO_IOP::Invalid_IOR, 0);
  return retval;
}

::CORBA::Exception *
TAO_IOP::Invalid_IOR::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::TAO_IOP::Invalid_IOR (*this),
      0
    );
  return result;
}

void TAO_IOP::Invalid_IOR::_raise (void) const
{
  throw *this;
}

void TAO_IOP::Invalid_IOR::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void TAO_IOP::Invalid_IOR::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr TAO_IOP::Invalid_IOR::_tao_type (void) const
{
  return ::TAO_IOP::_tc_Invalid_IOR;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_TAO_IOP_Invalid_IOR = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TAO_IOP_Invalid_IOR (
  ::CORBA::tk_except,
  "IDL:TAO_IOP/Invalid_IOR:1.0",
  "Invalid_IOR",
  _tao_fields_TAO_IOP_Invalid_IOR,
  0);


namespace TAO_IOP
{
  ::CORBA::TypeCode_ptr const _tc_Invalid_IOR =
    &_tao_tc_TAO_IOP_Invalid_IOR;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

TAO_IOP::MultiProfileList::MultiProfileList (void)
  : ::CORBA::UserException (
        "IDL:TAO_IOP/MultiProfileList:1.0",
        "MultiProfileList"
      )
{
}

TAO_IOP::MultiProfileList::~MultiProfileList (void)
{
}

TAO_IOP::MultiProfileList::MultiProfileList (const ::TAO_IOP::MultiProfileList &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

TAO_IOP::MultiProfileList&
TAO_IOP::MultiProfileList::operator= (const ::TAO_IOP::MultiProfileList &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void TAO_IOP::MultiProfileList::_tao_any_destructor (void *_tao_void_pointer)
{
  MultiProfileList *_tao_tmp_pointer =
    static_cast<MultiProfileList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

TAO_IOP::MultiProfileList *
TAO_IOP::MultiProfileList::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<MultiProfileList *> (_tao_excp);
}

const TAO_IOP::MultiProfileList *
TAO_IOP::MultiProfileList::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const MultiProfileList *> (_tao_excp);
}

::CORBA::Exception *TAO_IOP::MultiProfileList::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::TAO_IOP::MultiProfileList, 0);
  return retval;
}

::CORBA::Exception *
TAO_IOP::MultiProfileList::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::TAO_IOP::MultiProfileList (*this),
      0
    );
  return result;
}

void TAO_IOP::MultiProfileList::_raise (void) const
{
  throw *this;
}

void TAO_IOP::MultiProfileList::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void TAO_IOP::MultiProfileList::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr TAO_IOP::MultiProfileList::_tao_type (void) const
{
  return ::TAO_IOP::_tc_MultiProfileList;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_TAO_IOP_MultiProfileList = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TAO_IOP_MultiProfileList (
  ::CORBA::tk_except,
  "IDL:TAO_IOP/MultiProfileList:1.0",
  "MultiProfileList",
  _tao_fields_TAO_IOP_MultiProfileList,
  0);


namespace TAO_IOP
{
  ::CORBA::TypeCode_ptr const _tc_MultiProfileList =
    &_tao_tc_TAO_IOP_MultiProfileList;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for TAO_IOP::TAO_IOR_Property.

TAO_IOP::TAO_IOR_Property_ptr
TAO::Objref_Traits<TAO_IOP::TAO_IOR_Property>::duplicate (
    TAO_IOP::TAO_IOR_Property_ptr p)
{
  return TAO_IOP::TAO_IOR_Property::_duplicate (p);
}

void
TAO::Objref_Traits<TAO_IOP::TAO_IOR_Property>::release (
    TAO_IOP::TAO_IOR_Property_ptr p)
{
  ::CORBA::release (p);
}

TAO_IOP::TAO_IOR_Property_ptr
TAO::Objref_Traits<TAO_IOP::TAO_IOR_Property>::nil (void)
{
  return TAO_IOP::TAO_IOR_Property::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<TAO_IOP::TAO_IOR_Property>::marshal (
    const TAO_IOP::TAO_IOR_Property_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_IOP::TAO_IOR_Property::TAO_IOR_Property (void)
{}

TAO_IOP::TAO_IOR_Property::~TAO_IOR_Property (void)
{}

void 
TAO_IOP::TAO_IOR_Property::_tao_any_destructor (void *_tao_void_pointer)
{
  TAO_IOR_Property *_tao_tmp_pointer =
    static_cast<TAO_IOR_Property *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

TAO_IOP::TAO_IOR_Property_ptr
TAO_IOP::TAO_IOR_Property::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return TAO_IOR_Property::_duplicate (
      dynamic_cast<TAO_IOR_Property_ptr> (_tao_objref)
    );
}

TAO_IOP::TAO_IOR_Property_ptr
TAO_IOP::TAO_IOR_Property::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return TAO_IOR_Property::_duplicate (
      dynamic_cast<TAO_IOR_Property_ptr> (_tao_objref)
    );
}

TAO_IOP::TAO_IOR_Property_ptr
TAO_IOP::TAO_IOR_Property::_nil (void)
{
  return 0;
}

TAO_IOP::TAO_IOR_Property_ptr
TAO_IOP::TAO_IOR_Property::_duplicate (TAO_IOR_Property_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
TAO_IOP::TAO_IOR_Property::_tao_release (TAO_IOR_Property_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
TAO_IOP::TAO_IOR_Property::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:TAO_IOP/TAO_IOR_Property:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* TAO_IOP::TAO_IOR_Property::_interface_repository_id (void) const
{
  return "IDL:TAO_IOP/TAO_IOR_Property:1.0";
}

::CORBA::Boolean
TAO_IOP::TAO_IOR_Property::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_TAO_IOP_TAO_IOR_Property (
    ::CORBA::tk_local_interface,
    "IDL:TAO_IOP/TAO_IOR_Property:1.0",
    "TAO_IOR_Property");
  

namespace TAO_IOP
{
  ::CORBA::TypeCode_ptr const _tc_TAO_IOR_Property =
    &_tao_tc_TAO_IOP_TAO_IOR_Property;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for TAO_IOP::TAO_IOR_Manipulation.

TAO_IOP::TAO_IOR_Manipulation_ptr
TAO::Objref_Traits<TAO_IOP::TAO_IOR_Manipulation>::duplicate (
    TAO_IOP::TAO_IOR_Manipulation_ptr p)
{
  return TAO_IOP::TAO_IOR_Manipulation::_duplicate (p);
}

void
TAO::Objref_Traits<TAO_IOP::TAO_IOR_Manipulation>::release (
    TAO_IOP::TAO_IOR_Manipulation_ptr p)
{
  ::CORBA::release (p);
}

TAO_IOP::TAO_IOR_Manipulation_ptr
TAO::Objref_Traits<TAO_IOP::TAO_IOR_Manipulation>::nil (void)
{
  return TAO_IOP::TAO_IOR_Manipulation::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<TAO_IOP::TAO_IOR_Manipulation>::marshal (
    const TAO_IOP::TAO_IOR_Manipulation_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TAO_IOP_TAO_IOR_MANIPULATION_IORLIST_CS_)
#define _TAO_IOP_TAO_IOR_MANIPULATION_IORLIST_CS_

TAO_IOP::TAO_IOR_Manipulation::IORList::IORList (void)
{}

TAO_IOP::TAO_IOR_Manipulation::IORList::IORList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        ::CORBA::Object,
        ::CORBA::Object_var
      > (max)
{}

TAO_IOP::TAO_IOR_Manipulation::IORList::IORList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Object_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        ::CORBA::Object,
        ::CORBA::Object_var
      >
    (max, length, buffer, release)
{}

TAO_IOP::TAO_IOR_Manipulation::IORList::IORList (
    const IORList &seq)
  : ::TAO::unbounded_object_reference_sequence<
        ::CORBA::Object,
        ::CORBA::Object_var
      > (seq)
{}

TAO_IOP::TAO_IOR_Manipulation::IORList::~IORList (void)
{}

void TAO_IOP::TAO_IOR_Manipulation::IORList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  IORList * _tao_tmp_pointer =
    static_cast<IORList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_TAO_IOP_TAO_IOR_Manipulation_IORList_GUARD
#define _TAO_TYPECODE_TAO_IOP_TAO_IOR_Manipulation_IORList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        TAO_IOP_TAO_IOR_Manipulation_IORList_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_Object,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_TAO_IOP_TAO_IOR_Manipulation_IORList_0 =
        &TAO_IOP_TAO_IOR_Manipulation_IORList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_TAO_IOP_TAO_IOR_Manipulation_IORList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_TAO_IOP_TAO_IOR_Manipulation_IORList (
    ::CORBA::tk_alias,
    "IDL:TAO_IOP/TAO_IOR_Manipulation/IORList:1.0",
    "IORList",
    &TAO::TypeCode::tc_TAO_IOP_TAO_IOR_Manipulation_IORList_0);
  
::CORBA::TypeCode_ptr const TAO_IOP::TAO_IOR_Manipulation::_tc_IORList =
  &_tao_tc_TAO_IOP_TAO_IOR_Manipulation_IORList;

TAO_IOP::TAO_IOR_Manipulation::TAO_IOR_Manipulation (void)
{}

TAO_IOP::TAO_IOR_Manipulation::~TAO_IOR_Manipulation (void)
{}

void 
TAO_IOP::TAO_IOR_Manipulation::_tao_any_destructor (void *_tao_void_pointer)
{
  TAO_IOR_Manipulation *_tao_tmp_pointer =
    static_cast<TAO_IOR_Manipulation *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

TAO_IOP::TAO_IOR_Manipulation_ptr
TAO_IOP::TAO_IOR_Manipulation::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return TAO_IOR_Manipulation::_duplicate (
      dynamic_cast<TAO_IOR_Manipulation_ptr> (_tao_objref)
    );
}

TAO_IOP::TAO_IOR_Manipulation_ptr
TAO_IOP::TAO_IOR_Manipulation::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return TAO_IOR_Manipulation::_duplicate (
      dynamic_cast<TAO_IOR_Manipulation_ptr> (_tao_objref)
    );
}

TAO_IOP::TAO_IOR_Manipulation_ptr
TAO_IOP::TAO_IOR_Manipulation::_nil (void)
{
  return 0;
}

TAO_IOP::TAO_IOR_Manipulation_ptr
TAO_IOP::TAO_IOR_Manipulation::_duplicate (TAO_IOR_Manipulation_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
TAO_IOP::TAO_IOR_Manipulation::_tao_release (TAO_IOR_Manipulation_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
TAO_IOP::TAO_IOR_Manipulation::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:TAO_IOP/TAO_IOR_Manipulation:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* TAO_IOP::TAO_IOR_Manipulation::_interface_repository_id (void) const
{
  return "IDL:TAO_IOP/TAO_IOR_Manipulation:1.0";
}

::CORBA::Boolean
TAO_IOP::TAO_IOR_Manipulation::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_TAO_IOP_TAO_IOR_Manipulation (
    ::CORBA::tk_local_interface,
    "IDL:TAO_IOP/TAO_IOR_Manipulation:1.0",
    "TAO_IOR_Manipulation");
  

namespace TAO_IOP
{
  ::CORBA::TypeCode_ptr const _tc_TAO_IOR_Manipulation =
    &_tao_tc_TAO_IOP_TAO_IOR_Manipulation;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<TAO_IOP::EmptyProfileList>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TAO_IOP
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TAO_IOP::EmptyProfileList &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::TAO_IOP::EmptyProfileList>::insert_copy (
        _tao_any,
        ::TAO_IOP::EmptyProfileList::_tao_any_destructor,
        ::TAO_IOP::_tc_EmptyProfileList,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::TAO_IOP::EmptyProfileList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::TAO_IOP::EmptyProfileList>::insert (
        _tao_any,
        ::TAO_IOP::EmptyProfileList::_tao_any_destructor,
        ::TAO_IOP::_tc_EmptyProfileList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TAO_IOP::EmptyProfileList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::TAO_IOP::EmptyProfileList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TAO_IOP::EmptyProfileList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::TAO_IOP::EmptyProfileList>::extract (
          _tao_any,
          ::TAO_IOP::EmptyProfileList::_tao_any_destructor,
          ::TAO_IOP::_tc_EmptyProfileList,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const TAO_IOP::EmptyProfileList &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TAO_IOP::EmptyProfileList>::insert_copy (
      _tao_any,
      TAO_IOP::EmptyProfileList::_tao_any_destructor,
      TAO_IOP::_tc_EmptyProfileList,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    TAO_IOP::EmptyProfileList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TAO_IOP::EmptyProfileList>::insert (
      _tao_any,
      TAO_IOP::EmptyProfileList::_tao_any_destructor,
      TAO_IOP::_tc_EmptyProfileList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    TAO_IOP::EmptyProfileList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const TAO_IOP::EmptyProfileList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const TAO_IOP::EmptyProfileList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TAO_IOP::EmptyProfileList>::extract (
        _tao_any,
        TAO_IOP::EmptyProfileList::_tao_any_destructor,
        TAO_IOP::_tc_EmptyProfileList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<TAO_IOP::NotFound>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TAO_IOP
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TAO_IOP::NotFound &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::TAO_IOP::NotFound>::insert_copy (
        _tao_any,
        ::TAO_IOP::NotFound::_tao_any_destructor,
        ::TAO_IOP::_tc_NotFound,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::TAO_IOP::NotFound *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::TAO_IOP::NotFound>::insert (
        _tao_any,
        ::TAO_IOP::NotFound::_tao_any_destructor,
        ::TAO_IOP::_tc_NotFound,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TAO_IOP::NotFound *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::TAO_IOP::NotFound *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TAO_IOP::NotFound *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::TAO_IOP::NotFound>::extract (
          _tao_any,
          ::TAO_IOP::NotFound::_tao_any_destructor,
          ::TAO_IOP::_tc_NotFound,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const TAO_IOP::NotFound &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TAO_IOP::NotFound>::insert_copy (
      _tao_any,
      TAO_IOP::NotFound::_tao_any_destructor,
      TAO_IOP::_tc_NotFound,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    TAO_IOP::NotFound *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TAO_IOP::NotFound>::insert (
      _tao_any,
      TAO_IOP::NotFound::_tao_any_destructor,
      TAO_IOP::_tc_NotFound,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    TAO_IOP::NotFound *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const TAO_IOP::NotFound *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const TAO_IOP::NotFound *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TAO_IOP::NotFound>::extract (
        _tao_any,
        TAO_IOP::NotFound::_tao_any_destructor,
        TAO_IOP::_tc_NotFound,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<TAO_IOP::Duplicate>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TAO_IOP
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TAO_IOP::Duplicate &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::TAO_IOP::Duplicate>::insert_copy (
        _tao_any,
        ::TAO_IOP::Duplicate::_tao_any_destructor,
        ::TAO_IOP::_tc_Duplicate,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::TAO_IOP::Duplicate *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::TAO_IOP::Duplicate>::insert (
        _tao_any,
        ::TAO_IOP::Duplicate::_tao_any_destructor,
        ::TAO_IOP::_tc_Duplicate,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TAO_IOP::Duplicate *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::TAO_IOP::Duplicate *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TAO_IOP::Duplicate *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::TAO_IOP::Duplicate>::extract (
          _tao_any,
          ::TAO_IOP::Duplicate::_tao_any_destructor,
          ::TAO_IOP::_tc_Duplicate,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const TAO_IOP::Duplicate &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TAO_IOP::Duplicate>::insert_copy (
      _tao_any,
      TAO_IOP::Duplicate::_tao_any_destructor,
      TAO_IOP::_tc_Duplicate,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    TAO_IOP::Duplicate *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TAO_IOP::Duplicate>::insert (
      _tao_any,
      TAO_IOP::Duplicate::_tao_any_destructor,
      TAO_IOP::_tc_Duplicate,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    TAO_IOP::Duplicate *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const TAO_IOP::Duplicate *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const TAO_IOP::Duplicate *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TAO_IOP::Duplicate>::extract (
        _tao_any,
        TAO_IOP::Duplicate::_tao_any_destructor,
        TAO_IOP::_tc_Duplicate,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<TAO_IOP::Invalid_IOR>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TAO_IOP
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TAO_IOP::Invalid_IOR &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::TAO_IOP::Invalid_IOR>::insert_copy (
        _tao_any,
        ::TAO_IOP::Invalid_IOR::_tao_any_destructor,
        ::TAO_IOP::_tc_Invalid_IOR,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::TAO_IOP::Invalid_IOR *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::TAO_IOP::Invalid_IOR>::insert (
        _tao_any,
        ::TAO_IOP::Invalid_IOR::_tao_any_destructor,
        ::TAO_IOP::_tc_Invalid_IOR,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TAO_IOP::Invalid_IOR *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::TAO_IOP::Invalid_IOR *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TAO_IOP::Invalid_IOR *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::TAO_IOP::Invalid_IOR>::extract (
          _tao_any,
          ::TAO_IOP::Invalid_IOR::_tao_any_destructor,
          ::TAO_IOP::_tc_Invalid_IOR,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const TAO_IOP::Invalid_IOR &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TAO_IOP::Invalid_IOR>::insert_copy (
      _tao_any,
      TAO_IOP::Invalid_IOR::_tao_any_destructor,
      TAO_IOP::_tc_Invalid_IOR,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    TAO_IOP::Invalid_IOR *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TAO_IOP::Invalid_IOR>::insert (
      _tao_any,
      TAO_IOP::Invalid_IOR::_tao_any_destructor,
      TAO_IOP::_tc_Invalid_IOR,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    TAO_IOP::Invalid_IOR *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const TAO_IOP::Invalid_IOR *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const TAO_IOP::Invalid_IOR *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TAO_IOP::Invalid_IOR>::extract (
        _tao_any,
        TAO_IOP::Invalid_IOR::_tao_any_destructor,
        TAO_IOP::_tc_Invalid_IOR,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<TAO_IOP::MultiProfileList>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TAO_IOP
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TAO_IOP::MultiProfileList &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::TAO_IOP::MultiProfileList>::insert_copy (
        _tao_any,
        ::TAO_IOP::MultiProfileList::_tao_any_destructor,
        ::TAO_IOP::_tc_MultiProfileList,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::TAO_IOP::MultiProfileList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::TAO_IOP::MultiProfileList>::insert (
        _tao_any,
        ::TAO_IOP::MultiProfileList::_tao_any_destructor,
        ::TAO_IOP::_tc_MultiProfileList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TAO_IOP::MultiProfileList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::TAO_IOP::MultiProfileList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TAO_IOP::MultiProfileList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::TAO_IOP::MultiProfileList>::extract (
          _tao_any,
          ::TAO_IOP::MultiProfileList::_tao_any_destructor,
          ::TAO_IOP::_tc_MultiProfileList,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const TAO_IOP::MultiProfileList &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TAO_IOP::MultiProfileList>::insert_copy (
      _tao_any,
      TAO_IOP::MultiProfileList::_tao_any_destructor,
      TAO_IOP::_tc_MultiProfileList,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    TAO_IOP::MultiProfileList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TAO_IOP::MultiProfileList>::insert (
      _tao_any,
      TAO_IOP::MultiProfileList::_tao_any_destructor,
      TAO_IOP::_tc_MultiProfileList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    TAO_IOP::MultiProfileList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const TAO_IOP::MultiProfileList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const TAO_IOP::MultiProfileList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TAO_IOP::MultiProfileList>::extract (
        _tao_any,
        TAO_IOP::MultiProfileList::_tao_any_destructor,
        TAO_IOP::_tc_MultiProfileList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<TAO_IOP::TAO_IOR_Property>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<TAO_IOP::TAO_IOR_Property>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<TAO_IOP::TAO_IOR_Property>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TAO_IOP
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      TAO_IOR_Property_ptr _tao_elem)
  {
    TAO_IOR_Property_ptr _tao_objptr =
      TAO_IOR_Property::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      TAO_IOR_Property_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<TAO_IOR_Property>::insert (
        _tao_any,
        TAO_IOR_Property::_tao_any_destructor,
        _tc_TAO_IOR_Property,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      TAO_IOR_Property_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<TAO_IOR_Property>::extract (
          _tao_any,
          TAO_IOR_Property::_tao_any_destructor,
          _tc_TAO_IOR_Property,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    TAO_IOP::TAO_IOR_Property_ptr _tao_elem)
{
  TAO_IOP::TAO_IOR_Property_ptr _tao_objptr =
    TAO_IOP::TAO_IOR_Property::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    TAO_IOP::TAO_IOR_Property_ptr *_tao_elem)
{
  TAO::Any_Impl_T<TAO_IOP::TAO_IOR_Property>::insert (
      _tao_any,
      TAO_IOP::TAO_IOR_Property::_tao_any_destructor,
      TAO_IOP::_tc_TAO_IOR_Property,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    TAO_IOP::TAO_IOR_Property_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<TAO_IOP::TAO_IOR_Property>::extract (
        _tao_any,
        TAO_IOP::TAO_IOR_Property::_tao_any_destructor,
        TAO_IOP::_tc_TAO_IOR_Property,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<TAO_IOP::TAO_IOR_Manipulation>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<TAO_IOP::TAO_IOR_Manipulation>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<TAO_IOP::TAO_IOR_Manipulation>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TAO_IOP
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      TAO_IOR_Manipulation_ptr _tao_elem)
  {
    TAO_IOR_Manipulation_ptr _tao_objptr =
      TAO_IOR_Manipulation::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      TAO_IOR_Manipulation_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<TAO_IOR_Manipulation>::insert (
        _tao_any,
        TAO_IOR_Manipulation::_tao_any_destructor,
        _tc_TAO_IOR_Manipulation,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      TAO_IOR_Manipulation_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<TAO_IOR_Manipulation>::extract (
          _tao_any,
          TAO_IOR_Manipulation::_tao_any_destructor,
          _tc_TAO_IOR_Manipulation,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    TAO_IOP::TAO_IOR_Manipulation_ptr _tao_elem)
{
  TAO_IOP::TAO_IOR_Manipulation_ptr _tao_objptr =
    TAO_IOP::TAO_IOR_Manipulation::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    TAO_IOP::TAO_IOR_Manipulation_ptr *_tao_elem)
{
  TAO::Any_Impl_T<TAO_IOP::TAO_IOR_Manipulation>::insert (
      _tao_any,
      TAO_IOP::TAO_IOR_Manipulation::_tao_any_destructor,
      TAO_IOP::_tc_TAO_IOR_Manipulation,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    TAO_IOP::TAO_IOR_Manipulation_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<TAO_IOP::TAO_IOR_Manipulation>::extract (
        _tao_any,
        TAO_IOP::TAO_IOR_Manipulation::_tao_any_destructor,
        TAO_IOP::_tc_TAO_IOR_Manipulation,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<TAO_IOP::TAO_IOR_Manipulation::IORList>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<TAO_IOP::TAO_IOR_Manipulation::IORList>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TAO_IOP
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TAO_IOP::TAO_IOR_Manipulation::IORList &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::TAO_IOP::TAO_IOR_Manipulation::IORList *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::TAO_IOP::TAO_IOR_Manipulation::IORList>::insert_copy (
          _tao_any,
          ::TAO_IOP::TAO_IOR_Manipulation::IORList::_tao_any_destructor,
          ::TAO_IOP::TAO_IOR_Manipulation::_tc_IORList,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::TAO_IOP::TAO_IOR_Manipulation::IORList *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::TAO_IOP::TAO_IOR_Manipulation::IORList>::insert (
        _tao_any,
        ::TAO_IOP::TAO_IOR_Manipulation::IORList::_tao_any_destructor,
        ::TAO_IOP::TAO_IOR_Manipulation::_tc_IORList,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TAO_IOP::TAO_IOR_Manipulation::IORList *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::TAO_IOP::TAO_IOR_Manipulation::IORList *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TAO_IOP::TAO_IOR_Manipulation::IORList *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::TAO_IOP::TAO_IOR_Manipulation::IORList>::extract (
          _tao_any,
          ::TAO_IOP::TAO_IOR_Manipulation::IORList::_tao_any_destructor,
          ::TAO_IOP::TAO_IOR_Manipulation::_tc_IORList,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const TAO_IOP::TAO_IOR_Manipulation::IORList &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<TAO_IOP::TAO_IOR_Manipulation::IORList *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<TAO_IOP::TAO_IOR_Manipulation::IORList>::insert_copy (
        _tao_any,
        TAO_IOP::TAO_IOR_Manipulation::IORList::_tao_any_destructor,
        TAO_IOP::TAO_IOR_Manipulation::_tc_IORList,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    TAO_IOP::TAO_IOR_Manipulation::IORList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TAO_IOP::TAO_IOR_Manipulation::IORList>::insert (
      _tao_any,
      TAO_IOP::TAO_IOR_Manipulation::IORList::_tao_any_destructor,
      TAO_IOP::TAO_IOR_Manipulation::_tc_IORList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    TAO_IOP::TAO_IOR_Manipulation::IORList *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const TAO_IOP::TAO_IOR_Manipulation::IORList *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const TAO_IOP::TAO_IOR_Manipulation::IORList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TAO_IOP::TAO_IOR_Manipulation::IORList>::extract (
        _tao_any,
        TAO_IOP::TAO_IOR_Manipulation::IORList::_tao_any_destructor,
        TAO_IOP::TAO_IOR_Manipulation::_tc_IORList,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TAO_IOP::EmptyProfileList &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    TAO_IOP::EmptyProfileList&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TAO_IOP::NotFound &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    TAO_IOP::NotFound&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TAO_IOP::Duplicate &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    TAO_IOP::Duplicate&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TAO_IOP::Invalid_IOR &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    TAO_IOP::Invalid_IOR&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TAO_IOP::MultiProfileList &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    TAO_IOP::MultiProfileList&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL





TAO_END_VERSIONED_NAMESPACE_DECL


