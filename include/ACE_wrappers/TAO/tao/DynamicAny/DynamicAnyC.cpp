// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:375


#include "tao/DynamicAny/DynamicAny.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/CDR.h"
#include "tao/ORB_Core.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "ace/OS_NS_string.h"

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DynamicAny::DynAny.

DynamicAny::DynAny_ptr
TAO::Objref_Traits<DynamicAny::DynAny>::duplicate (
    DynamicAny::DynAny_ptr p)
{
  return DynamicAny::DynAny::_duplicate (p);
}

void
TAO::Objref_Traits<DynamicAny::DynAny>::release (
    DynamicAny::DynAny_ptr p)
{
  ::CORBA::release (p);
}

DynamicAny::DynAny_ptr
TAO::Objref_Traits<DynamicAny::DynAny>::nil (void)
{
  return DynamicAny::DynAny::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DynamicAny::DynAny>::marshal (
    const DynamicAny::DynAny_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DynamicAny::DynAny::InvalidValue::InvalidValue (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DynamicAny/DynAny/InvalidValue:1.0",
        "InvalidValue"
      )
{
}

DynamicAny::DynAny::InvalidValue::~InvalidValue (void)
{
}

DynamicAny::DynAny::InvalidValue::InvalidValue (const ::DynamicAny::DynAny::InvalidValue &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DynamicAny::DynAny::InvalidValue&
DynamicAny::DynAny::InvalidValue::operator= (const ::DynamicAny::DynAny::InvalidValue &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DynamicAny::DynAny::InvalidValue::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidValue *_tao_tmp_pointer =
    static_cast<InvalidValue *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DynamicAny::DynAny::InvalidValue *
DynamicAny::DynAny::InvalidValue::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidValue *> (_tao_excp);
}

const DynamicAny::DynAny::InvalidValue *
DynamicAny::DynAny::InvalidValue::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidValue *> (_tao_excp);
}

::CORBA::Exception *DynamicAny::DynAny::InvalidValue::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DynamicAny::DynAny::InvalidValue, 0);
  return retval;
}

::CORBA::Exception *
DynamicAny::DynAny::InvalidValue::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DynamicAny::DynAny::InvalidValue (*this),
      0
    );
  return result;
}

void DynamicAny::DynAny::InvalidValue::_raise (void) const
{
  throw *this;
}

void DynamicAny::DynAny::InvalidValue::_tao_encode (TAO_OutputCDR &) const
{
  throw ::CORBA::MARSHAL ();
}

void DynamicAny::DynAny::InvalidValue::_tao_decode (TAO_InputCDR &)
{
  throw ::CORBA::MARSHAL ();
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DynamicAny::DynAny::InvalidValue::_tao_type (void) const
{
  return ::DynamicAny::DynAny::_tc_InvalidValue;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DynamicAny_DynAny_InvalidValue = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DynamicAny_DynAny_InvalidValue (
  ::CORBA::tk_except,
  "IDL:omg.org/DynamicAny/DynAny/InvalidValue:1.0",
  "InvalidValue",
  _tao_fields_DynamicAny_DynAny_InvalidValue,
  0);

::CORBA::TypeCode_ptr const DynamicAny::DynAny::_tc_InvalidValue =
  &_tao_tc_DynamicAny_DynAny_InvalidValue;

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DynamicAny::DynAny::TypeMismatch::TypeMismatch (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DynamicAny/DynAny/TypeMismatch:1.0",
        "TypeMismatch"
      )
{
}

DynamicAny::DynAny::TypeMismatch::~TypeMismatch (void)
{
}

DynamicAny::DynAny::TypeMismatch::TypeMismatch (const ::DynamicAny::DynAny::TypeMismatch &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DynamicAny::DynAny::TypeMismatch&
DynamicAny::DynAny::TypeMismatch::operator= (const ::DynamicAny::DynAny::TypeMismatch &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DynamicAny::DynAny::TypeMismatch::_tao_any_destructor (void *_tao_void_pointer)
{
  TypeMismatch *_tao_tmp_pointer =
    static_cast<TypeMismatch *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DynamicAny::DynAny::TypeMismatch *
DynamicAny::DynAny::TypeMismatch::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<TypeMismatch *> (_tao_excp);
}

const DynamicAny::DynAny::TypeMismatch *
DynamicAny::DynAny::TypeMismatch::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const TypeMismatch *> (_tao_excp);
}

::CORBA::Exception *DynamicAny::DynAny::TypeMismatch::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DynamicAny::DynAny::TypeMismatch, 0);
  return retval;
}

::CORBA::Exception *
DynamicAny::DynAny::TypeMismatch::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DynamicAny::DynAny::TypeMismatch (*this),
      0
    );
  return result;
}

void DynamicAny::DynAny::TypeMismatch::_raise (void) const
{
  throw *this;
}

void DynamicAny::DynAny::TypeMismatch::_tao_encode (TAO_OutputCDR &) const
{
  throw ::CORBA::MARSHAL ();
}

void DynamicAny::DynAny::TypeMismatch::_tao_decode (TAO_InputCDR &)
{
  throw ::CORBA::MARSHAL ();
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DynamicAny::DynAny::TypeMismatch::_tao_type (void) const
{
  return ::DynamicAny::DynAny::_tc_TypeMismatch;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DynamicAny_DynAny_TypeMismatch = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DynamicAny_DynAny_TypeMismatch (
  ::CORBA::tk_except,
  "IDL:omg.org/DynamicAny/DynAny/TypeMismatch:1.0",
  "TypeMismatch",
  _tao_fields_DynamicAny_DynAny_TypeMismatch,
  0);

::CORBA::TypeCode_ptr const DynamicAny::DynAny::_tc_TypeMismatch =
  &_tao_tc_DynamicAny_DynAny_TypeMismatch;

DynamicAny::DynAny::DynAny (void)
{}

DynamicAny::DynAny::~DynAny (void)
{}

void 
DynamicAny::DynAny::_tao_any_destructor (void *_tao_void_pointer)
{
  DynAny *_tao_tmp_pointer =
    static_cast<DynAny *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DynamicAny::DynAny_ptr
DynamicAny::DynAny::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynAny::_duplicate (
      dynamic_cast<DynAny_ptr> (_tao_objref)
    );
}

DynamicAny::DynAny_ptr
DynamicAny::DynAny::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynAny::_duplicate (
      dynamic_cast<DynAny_ptr> (_tao_objref)
    );
}

DynamicAny::DynAny_ptr
DynamicAny::DynAny::_nil (void)
{
  return 0;
}

DynamicAny::DynAny_ptr
DynamicAny::DynAny::_duplicate (DynAny_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DynamicAny::DynAny::_tao_release (DynAny_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DynamicAny::DynAny::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynAny:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* DynamicAny::DynAny::_interface_repository_id (void) const
{
  return "IDL:omg.org/DynamicAny/DynAny:1.0";
}

::CORBA::Boolean
DynamicAny::DynAny::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_DynAny (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/DynamicAny/DynAny:1.0",
    "DynAny");
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_DynAny =
    &_tao_tc_DynamicAny_DynAny;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DynamicAny::DynFixed.

DynamicAny::DynFixed_ptr
TAO::Objref_Traits<DynamicAny::DynFixed>::duplicate (
    DynamicAny::DynFixed_ptr p)
{
  return DynamicAny::DynFixed::_duplicate (p);
}

void
TAO::Objref_Traits<DynamicAny::DynFixed>::release (
    DynamicAny::DynFixed_ptr p)
{
  ::CORBA::release (p);
}

DynamicAny::DynFixed_ptr
TAO::Objref_Traits<DynamicAny::DynFixed>::nil (void)
{
  return DynamicAny::DynFixed::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DynamicAny::DynFixed>::marshal (
    const DynamicAny::DynFixed_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

DynamicAny::DynFixed::DynFixed (void)
{}

DynamicAny::DynFixed::~DynFixed (void)
{}

void 
DynamicAny::DynFixed::_tao_any_destructor (void *_tao_void_pointer)
{
  DynFixed *_tao_tmp_pointer =
    static_cast<DynFixed *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DynamicAny::DynFixed_ptr
DynamicAny::DynFixed::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynFixed::_duplicate (
      dynamic_cast<DynFixed_ptr> (_tao_objref)
    );
}

DynamicAny::DynFixed_ptr
DynamicAny::DynFixed::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynFixed::_duplicate (
      dynamic_cast<DynFixed_ptr> (_tao_objref)
    );
}

DynamicAny::DynFixed_ptr
DynamicAny::DynFixed::_nil (void)
{
  return 0;
}

DynamicAny::DynFixed_ptr
DynamicAny::DynFixed::_duplicate (DynFixed_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DynamicAny::DynFixed::_tao_release (DynFixed_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DynamicAny::DynFixed::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynAny:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynFixed:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* DynamicAny::DynFixed::_interface_repository_id (void) const
{
  return "IDL:omg.org/DynamicAny/DynFixed:1.0";
}

::CORBA::Boolean
DynamicAny::DynFixed::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_DynFixed (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/DynamicAny/DynFixed:1.0",
    "DynFixed");
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_DynFixed =
    &_tao_tc_DynamicAny_DynFixed;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DynamicAny::DynEnum.

DynamicAny::DynEnum_ptr
TAO::Objref_Traits<DynamicAny::DynEnum>::duplicate (
    DynamicAny::DynEnum_ptr p)
{
  return DynamicAny::DynEnum::_duplicate (p);
}

void
TAO::Objref_Traits<DynamicAny::DynEnum>::release (
    DynamicAny::DynEnum_ptr p)
{
  ::CORBA::release (p);
}

DynamicAny::DynEnum_ptr
TAO::Objref_Traits<DynamicAny::DynEnum>::nil (void)
{
  return DynamicAny::DynEnum::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DynamicAny::DynEnum>::marshal (
    const DynamicAny::DynEnum_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

DynamicAny::DynEnum::DynEnum (void)
{}

DynamicAny::DynEnum::~DynEnum (void)
{}

void 
DynamicAny::DynEnum::_tao_any_destructor (void *_tao_void_pointer)
{
  DynEnum *_tao_tmp_pointer =
    static_cast<DynEnum *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DynamicAny::DynEnum_ptr
DynamicAny::DynEnum::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynEnum::_duplicate (
      dynamic_cast<DynEnum_ptr> (_tao_objref)
    );
}

DynamicAny::DynEnum_ptr
DynamicAny::DynEnum::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynEnum::_duplicate (
      dynamic_cast<DynEnum_ptr> (_tao_objref)
    );
}

DynamicAny::DynEnum_ptr
DynamicAny::DynEnum::_nil (void)
{
  return 0;
}

DynamicAny::DynEnum_ptr
DynamicAny::DynEnum::_duplicate (DynEnum_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DynamicAny::DynEnum::_tao_release (DynEnum_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DynamicAny::DynEnum::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynAny:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynEnum:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* DynamicAny::DynEnum::_interface_repository_id (void) const
{
  return "IDL:omg.org/DynamicAny/DynEnum:1.0";
}

::CORBA::Boolean
DynamicAny::DynEnum::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_DynEnum (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/DynamicAny/DynEnum:1.0",
    "DynEnum");
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_DynEnum =
    &_tao_tc_DynamicAny_DynEnum;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_FieldName (
    ::CORBA::tk_alias,
    "IDL:omg.org/DynamicAny/FieldName:1.0",
    "FieldName",
    &CORBA::_tc_string);
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_FieldName =
    &_tao_tc_DynamicAny_FieldName;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_DynamicAny_NameValuePair[] =
      {
        { "id", &DynamicAny::_tc_FieldName },
        { "value", &CORBA::_tc_any }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DynamicAny_NameValuePair (
  ::CORBA::tk_struct,
  "IDL:omg.org/DynamicAny/NameValuePair:1.0",
  "NameValuePair",
  _tao_fields_DynamicAny_NameValuePair,
  2);


namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_NameValuePair =
    &_tao_tc_DynamicAny_NameValuePair;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
DynamicAny::NameValuePair::_tao_any_destructor (
    void *_tao_void_pointer)
{
  NameValuePair *_tao_tmp_pointer =
    static_cast<NameValuePair *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DYNAMICANY_NAMEVALUEPAIRSEQ_CS_)
#define _DYNAMICANY_NAMEVALUEPAIRSEQ_CS_

DynamicAny::NameValuePairSeq::NameValuePairSeq (void)
{}

DynamicAny::NameValuePairSeq::NameValuePairSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        NameValuePair
      > (max)
{}

DynamicAny::NameValuePairSeq::NameValuePairSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    DynamicAny::NameValuePair * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        NameValuePair
      >
    (max, length, buffer, release)
{}

DynamicAny::NameValuePairSeq::NameValuePairSeq (
    const NameValuePairSeq &seq)
  : ::TAO::unbounded_value_sequence<
        NameValuePair
      > (seq)
{}

DynamicAny::NameValuePairSeq::~NameValuePairSeq (void)
{}

void DynamicAny::NameValuePairSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  NameValuePairSeq * _tao_tmp_pointer =
    static_cast<NameValuePairSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DynamicAny_NameValuePairSeq_GUARD
#define _TAO_TYPECODE_DynamicAny_NameValuePairSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DynamicAny_NameValuePairSeq_0 (
          ::CORBA::tk_sequence,
          &DynamicAny::_tc_NameValuePair,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DynamicAny_NameValuePairSeq_0 =
        &DynamicAny_NameValuePairSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DynamicAny_NameValuePairSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_NameValuePairSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/DynamicAny/NameValuePairSeq:1.0",
    "NameValuePairSeq",
    &TAO::TypeCode::tc_DynamicAny_NameValuePairSeq_0);
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_NameValuePairSeq =
    &_tao_tc_DynamicAny_NameValuePairSeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_DynamicAny_NameDynAnyPair[] =
      {
        { "id", &DynamicAny::_tc_FieldName },
        { "value", &DynamicAny::_tc_DynAny }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DynamicAny_NameDynAnyPair (
  ::CORBA::tk_struct,
  "IDL:omg.org/DynamicAny/NameDynAnyPair:1.0",
  "NameDynAnyPair",
  _tao_fields_DynamicAny_NameDynAnyPair,
  2);


namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_NameDynAnyPair =
    &_tao_tc_DynamicAny_NameDynAnyPair;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:58

void 
DynamicAny::NameDynAnyPair::_tao_any_destructor (
    void *_tao_void_pointer)
{
  NameDynAnyPair *_tao_tmp_pointer =
    static_cast<NameDynAnyPair *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DYNAMICANY_NAMEDYNANYPAIRSEQ_CS_)
#define _DYNAMICANY_NAMEDYNANYPAIRSEQ_CS_

DynamicAny::NameDynAnyPairSeq::NameDynAnyPairSeq (void)
{}

DynamicAny::NameDynAnyPairSeq::NameDynAnyPairSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        NameDynAnyPair
      > (max)
{}

DynamicAny::NameDynAnyPairSeq::NameDynAnyPairSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    DynamicAny::NameDynAnyPair * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        NameDynAnyPair
      >
    (max, length, buffer, release)
{}

DynamicAny::NameDynAnyPairSeq::NameDynAnyPairSeq (
    const NameDynAnyPairSeq &seq)
  : ::TAO::unbounded_value_sequence<
        NameDynAnyPair
      > (seq)
{}

DynamicAny::NameDynAnyPairSeq::~NameDynAnyPairSeq (void)
{}

void DynamicAny::NameDynAnyPairSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  NameDynAnyPairSeq * _tao_tmp_pointer =
    static_cast<NameDynAnyPairSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DynamicAny_NameDynAnyPairSeq_GUARD
#define _TAO_TYPECODE_DynamicAny_NameDynAnyPairSeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DynamicAny_NameDynAnyPairSeq_0 (
          ::CORBA::tk_sequence,
          &DynamicAny::_tc_NameDynAnyPair,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DynamicAny_NameDynAnyPairSeq_0 =
        &DynamicAny_NameDynAnyPairSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DynamicAny_NameDynAnyPairSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_NameDynAnyPairSeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/DynamicAny/NameDynAnyPairSeq:1.0",
    "NameDynAnyPairSeq",
    &TAO::TypeCode::tc_DynamicAny_NameDynAnyPairSeq_0);
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_NameDynAnyPairSeq =
    &_tao_tc_DynamicAny_NameDynAnyPairSeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DynamicAny::DynStruct.

DynamicAny::DynStruct_ptr
TAO::Objref_Traits<DynamicAny::DynStruct>::duplicate (
    DynamicAny::DynStruct_ptr p)
{
  return DynamicAny::DynStruct::_duplicate (p);
}

void
TAO::Objref_Traits<DynamicAny::DynStruct>::release (
    DynamicAny::DynStruct_ptr p)
{
  ::CORBA::release (p);
}

DynamicAny::DynStruct_ptr
TAO::Objref_Traits<DynamicAny::DynStruct>::nil (void)
{
  return DynamicAny::DynStruct::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DynamicAny::DynStruct>::marshal (
    const DynamicAny::DynStruct_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

DynamicAny::DynStruct::DynStruct (void)
{}

DynamicAny::DynStruct::~DynStruct (void)
{}

void 
DynamicAny::DynStruct::_tao_any_destructor (void *_tao_void_pointer)
{
  DynStruct *_tao_tmp_pointer =
    static_cast<DynStruct *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DynamicAny::DynStruct_ptr
DynamicAny::DynStruct::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynStruct::_duplicate (
      dynamic_cast<DynStruct_ptr> (_tao_objref)
    );
}

DynamicAny::DynStruct_ptr
DynamicAny::DynStruct::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynStruct::_duplicate (
      dynamic_cast<DynStruct_ptr> (_tao_objref)
    );
}

DynamicAny::DynStruct_ptr
DynamicAny::DynStruct::_nil (void)
{
  return 0;
}

DynamicAny::DynStruct_ptr
DynamicAny::DynStruct::_duplicate (DynStruct_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DynamicAny::DynStruct::_tao_release (DynStruct_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DynamicAny::DynStruct::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynAny:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynStruct:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* DynamicAny::DynStruct::_interface_repository_id (void) const
{
  return "IDL:omg.org/DynamicAny/DynStruct:1.0";
}

::CORBA::Boolean
DynamicAny::DynStruct::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_DynStruct (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/DynamicAny/DynStruct:1.0",
    "DynStruct");
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_DynStruct =
    &_tao_tc_DynamicAny_DynStruct;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DynamicAny::DynUnion.

DynamicAny::DynUnion_ptr
TAO::Objref_Traits<DynamicAny::DynUnion>::duplicate (
    DynamicAny::DynUnion_ptr p)
{
  return DynamicAny::DynUnion::_duplicate (p);
}

void
TAO::Objref_Traits<DynamicAny::DynUnion>::release (
    DynamicAny::DynUnion_ptr p)
{
  ::CORBA::release (p);
}

DynamicAny::DynUnion_ptr
TAO::Objref_Traits<DynamicAny::DynUnion>::nil (void)
{
  return DynamicAny::DynUnion::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DynamicAny::DynUnion>::marshal (
    const DynamicAny::DynUnion_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

DynamicAny::DynUnion::DynUnion (void)
{}

DynamicAny::DynUnion::~DynUnion (void)
{}

void 
DynamicAny::DynUnion::_tao_any_destructor (void *_tao_void_pointer)
{
  DynUnion *_tao_tmp_pointer =
    static_cast<DynUnion *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DynamicAny::DynUnion_ptr
DynamicAny::DynUnion::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynUnion::_duplicate (
      dynamic_cast<DynUnion_ptr> (_tao_objref)
    );
}

DynamicAny::DynUnion_ptr
DynamicAny::DynUnion::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynUnion::_duplicate (
      dynamic_cast<DynUnion_ptr> (_tao_objref)
    );
}

DynamicAny::DynUnion_ptr
DynamicAny::DynUnion::_nil (void)
{
  return 0;
}

DynamicAny::DynUnion_ptr
DynamicAny::DynUnion::_duplicate (DynUnion_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DynamicAny::DynUnion::_tao_release (DynUnion_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DynamicAny::DynUnion::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynAny:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynUnion:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* DynamicAny::DynUnion::_interface_repository_id (void) const
{
  return "IDL:omg.org/DynamicAny/DynUnion:1.0";
}

::CORBA::Boolean
DynamicAny::DynUnion::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_DynUnion (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/DynamicAny/DynUnion:1.0",
    "DynUnion");
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_DynUnion =
    &_tao_tc_DynamicAny_DynUnion;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DYNAMICANY_ANYSEQ_CS_)
#define _DYNAMICANY_ANYSEQ_CS_

DynamicAny::AnySeq::AnySeq (void)
{}

DynamicAny::AnySeq::AnySeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Any
      > (max)
{}

DynamicAny::AnySeq::AnySeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Any * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Any
      >
    (max, length, buffer, release)
{}

DynamicAny::AnySeq::AnySeq (
    const AnySeq &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Any
      > (seq)
{}

DynamicAny::AnySeq::~AnySeq (void)
{}

void DynamicAny::AnySeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  AnySeq * _tao_tmp_pointer =
    static_cast<AnySeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DynamicAny_AnySeq_GUARD
#define _TAO_TYPECODE_DynamicAny_AnySeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DynamicAny_AnySeq_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_any,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DynamicAny_AnySeq_0 =
        &DynamicAny_AnySeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DynamicAny_AnySeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_AnySeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/DynamicAny/AnySeq:1.0",
    "AnySeq",
    &TAO::TypeCode::tc_DynamicAny_AnySeq_0);
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_AnySeq =
    &_tao_tc_DynamicAny_AnySeq;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DYNAMICANY_DYNANYSEQ_CS_)
#define _DYNAMICANY_DYNANYSEQ_CS_

DynamicAny::DynAnySeq::DynAnySeq (void)
{}

DynamicAny::DynAnySeq::DynAnySeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        DynAny,
        DynAny_var
      > (max)
{}

DynamicAny::DynAnySeq::DynAnySeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    DynamicAny::DynAny_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        DynAny,
        DynAny_var
      >
    (max, length, buffer, release)
{}

DynamicAny::DynAnySeq::DynAnySeq (
    const DynAnySeq &seq)
  : ::TAO::unbounded_object_reference_sequence<
        DynAny,
        DynAny_var
      > (seq)
{}

DynamicAny::DynAnySeq::~DynAnySeq (void)
{}

void DynamicAny::DynAnySeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  DynAnySeq * _tao_tmp_pointer =
    static_cast<DynAnySeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:460


#ifndef _TAO_TYPECODE_DynamicAny_DynAnySeq_GUARD
#define _TAO_TYPECODE_DynamicAny_DynAnySeq_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DynamicAny_DynAnySeq_0 (
          ::CORBA::tk_sequence,
          &DynamicAny::_tc_DynAny,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DynamicAny_DynAnySeq_0 =
        &DynamicAny_DynAnySeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_DynamicAny_DynAnySeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_DynAnySeq (
    ::CORBA::tk_alias,
    "IDL:omg.org/DynamicAny/DynAnySeq:1.0",
    "DynAnySeq",
    &TAO::TypeCode::tc_DynamicAny_DynAnySeq_0);
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_DynAnySeq =
    &_tao_tc_DynamicAny_DynAnySeq;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DynamicAny::DynSequence.

DynamicAny::DynSequence_ptr
TAO::Objref_Traits<DynamicAny::DynSequence>::duplicate (
    DynamicAny::DynSequence_ptr p)
{
  return DynamicAny::DynSequence::_duplicate (p);
}

void
TAO::Objref_Traits<DynamicAny::DynSequence>::release (
    DynamicAny::DynSequence_ptr p)
{
  ::CORBA::release (p);
}

DynamicAny::DynSequence_ptr
TAO::Objref_Traits<DynamicAny::DynSequence>::nil (void)
{
  return DynamicAny::DynSequence::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DynamicAny::DynSequence>::marshal (
    const DynamicAny::DynSequence_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

DynamicAny::DynSequence::DynSequence (void)
{}

DynamicAny::DynSequence::~DynSequence (void)
{}

void 
DynamicAny::DynSequence::_tao_any_destructor (void *_tao_void_pointer)
{
  DynSequence *_tao_tmp_pointer =
    static_cast<DynSequence *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DynamicAny::DynSequence_ptr
DynamicAny::DynSequence::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynSequence::_duplicate (
      dynamic_cast<DynSequence_ptr> (_tao_objref)
    );
}

DynamicAny::DynSequence_ptr
DynamicAny::DynSequence::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynSequence::_duplicate (
      dynamic_cast<DynSequence_ptr> (_tao_objref)
    );
}

DynamicAny::DynSequence_ptr
DynamicAny::DynSequence::_nil (void)
{
  return 0;
}

DynamicAny::DynSequence_ptr
DynamicAny::DynSequence::_duplicate (DynSequence_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DynamicAny::DynSequence::_tao_release (DynSequence_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DynamicAny::DynSequence::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynAny:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynSequence:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* DynamicAny::DynSequence::_interface_repository_id (void) const
{
  return "IDL:omg.org/DynamicAny/DynSequence:1.0";
}

::CORBA::Boolean
DynamicAny::DynSequence::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_DynSequence (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/DynamicAny/DynSequence:1.0",
    "DynSequence");
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_DynSequence =
    &_tao_tc_DynamicAny_DynSequence;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DynamicAny::DynArray.

DynamicAny::DynArray_ptr
TAO::Objref_Traits<DynamicAny::DynArray>::duplicate (
    DynamicAny::DynArray_ptr p)
{
  return DynamicAny::DynArray::_duplicate (p);
}

void
TAO::Objref_Traits<DynamicAny::DynArray>::release (
    DynamicAny::DynArray_ptr p)
{
  ::CORBA::release (p);
}

DynamicAny::DynArray_ptr
TAO::Objref_Traits<DynamicAny::DynArray>::nil (void)
{
  return DynamicAny::DynArray::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DynamicAny::DynArray>::marshal (
    const DynamicAny::DynArray_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

DynamicAny::DynArray::DynArray (void)
{}

DynamicAny::DynArray::~DynArray (void)
{}

void 
DynamicAny::DynArray::_tao_any_destructor (void *_tao_void_pointer)
{
  DynArray *_tao_tmp_pointer =
    static_cast<DynArray *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DynamicAny::DynArray_ptr
DynamicAny::DynArray::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynArray::_duplicate (
      dynamic_cast<DynArray_ptr> (_tao_objref)
    );
}

DynamicAny::DynArray_ptr
DynamicAny::DynArray::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynArray::_duplicate (
      dynamic_cast<DynArray_ptr> (_tao_objref)
    );
}

DynamicAny::DynArray_ptr
DynamicAny::DynArray::_nil (void)
{
  return 0;
}

DynamicAny::DynArray_ptr
DynamicAny::DynArray::_duplicate (DynArray_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DynamicAny::DynArray::_tao_release (DynArray_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DynamicAny::DynArray::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynAny:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynArray:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* DynamicAny::DynArray::_interface_repository_id (void) const
{
  return "IDL:omg.org/DynamicAny/DynArray:1.0";
}

::CORBA::Boolean
DynamicAny::DynArray::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_DynArray (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/DynamicAny/DynArray:1.0",
    "DynArray");
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_DynArray =
    &_tao_tc_DynamicAny_DynArray;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DynamicAny::DynValueCommon.

DynamicAny::DynValueCommon_ptr
TAO::Objref_Traits<DynamicAny::DynValueCommon>::duplicate (
    DynamicAny::DynValueCommon_ptr p)
{
  return DynamicAny::DynValueCommon::_duplicate (p);
}

void
TAO::Objref_Traits<DynamicAny::DynValueCommon>::release (
    DynamicAny::DynValueCommon_ptr p)
{
  ::CORBA::release (p);
}

DynamicAny::DynValueCommon_ptr
TAO::Objref_Traits<DynamicAny::DynValueCommon>::nil (void)
{
  return DynamicAny::DynValueCommon::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DynamicAny::DynValueCommon>::marshal (
    const DynamicAny::DynValueCommon_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

DynamicAny::DynValueCommon::DynValueCommon (void)
{}

DynamicAny::DynValueCommon::~DynValueCommon (void)
{}

void 
DynamicAny::DynValueCommon::_tao_any_destructor (void *_tao_void_pointer)
{
  DynValueCommon *_tao_tmp_pointer =
    static_cast<DynValueCommon *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DynamicAny::DynValueCommon_ptr
DynamicAny::DynValueCommon::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynValueCommon::_duplicate (
      dynamic_cast<DynValueCommon_ptr> (_tao_objref)
    );
}

DynamicAny::DynValueCommon_ptr
DynamicAny::DynValueCommon::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynValueCommon::_duplicate (
      dynamic_cast<DynValueCommon_ptr> (_tao_objref)
    );
}

DynamicAny::DynValueCommon_ptr
DynamicAny::DynValueCommon::_nil (void)
{
  return 0;
}

DynamicAny::DynValueCommon_ptr
DynamicAny::DynValueCommon::_duplicate (DynValueCommon_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DynamicAny::DynValueCommon::_tao_release (DynValueCommon_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DynamicAny::DynValueCommon::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynAny:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynValueCommon:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* DynamicAny::DynValueCommon::_interface_repository_id (void) const
{
  return "IDL:omg.org/DynamicAny/DynValueCommon:1.0";
}

::CORBA::Boolean
DynamicAny::DynValueCommon::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_DynValueCommon (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/DynamicAny/DynValueCommon:1.0",
    "DynValueCommon");
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_DynValueCommon =
    &_tao_tc_DynamicAny_DynValueCommon;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DynamicAny::DynValue.

DynamicAny::DynValue_ptr
TAO::Objref_Traits<DynamicAny::DynValue>::duplicate (
    DynamicAny::DynValue_ptr p)
{
  return DynamicAny::DynValue::_duplicate (p);
}

void
TAO::Objref_Traits<DynamicAny::DynValue>::release (
    DynamicAny::DynValue_ptr p)
{
  ::CORBA::release (p);
}

DynamicAny::DynValue_ptr
TAO::Objref_Traits<DynamicAny::DynValue>::nil (void)
{
  return DynamicAny::DynValue::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DynamicAny::DynValue>::marshal (
    const DynamicAny::DynValue_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

DynamicAny::DynValue::DynValue (void)
{}

DynamicAny::DynValue::~DynValue (void)
{}

void 
DynamicAny::DynValue::_tao_any_destructor (void *_tao_void_pointer)
{
  DynValue *_tao_tmp_pointer =
    static_cast<DynValue *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DynamicAny::DynValue_ptr
DynamicAny::DynValue::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynValue::_duplicate (
      dynamic_cast<DynValue_ptr> (_tao_objref)
    );
}

DynamicAny::DynValue_ptr
DynamicAny::DynValue::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynValue::_duplicate (
      dynamic_cast<DynValue_ptr> (_tao_objref)
    );
}

DynamicAny::DynValue_ptr
DynamicAny::DynValue::_nil (void)
{
  return 0;
}

DynamicAny::DynValue_ptr
DynamicAny::DynValue::_duplicate (DynValue_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DynamicAny::DynValue::_tao_release (DynValue_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DynamicAny::DynValue::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynAny:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynValueCommon:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynValue:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* DynamicAny::DynValue::_interface_repository_id (void) const
{
  return "IDL:omg.org/DynamicAny/DynValue:1.0";
}

::CORBA::Boolean
DynamicAny::DynValue::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_DynValue (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/DynamicAny/DynValue:1.0",
    "DynValue");
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_DynValue =
    &_tao_tc_DynamicAny_DynValue;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DynamicAny::DynValueBox.

DynamicAny::DynValueBox_ptr
TAO::Objref_Traits<DynamicAny::DynValueBox>::duplicate (
    DynamicAny::DynValueBox_ptr p)
{
  return DynamicAny::DynValueBox::_duplicate (p);
}

void
TAO::Objref_Traits<DynamicAny::DynValueBox>::release (
    DynamicAny::DynValueBox_ptr p)
{
  ::CORBA::release (p);
}

DynamicAny::DynValueBox_ptr
TAO::Objref_Traits<DynamicAny::DynValueBox>::nil (void)
{
  return DynamicAny::DynValueBox::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DynamicAny::DynValueBox>::marshal (
    const DynamicAny::DynValueBox_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

DynamicAny::DynValueBox::DynValueBox (void)
{}

DynamicAny::DynValueBox::~DynValueBox (void)
{}

void 
DynamicAny::DynValueBox::_tao_any_destructor (void *_tao_void_pointer)
{
  DynValueBox *_tao_tmp_pointer =
    static_cast<DynValueBox *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DynamicAny::DynValueBox_ptr
DynamicAny::DynValueBox::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynValueBox::_duplicate (
      dynamic_cast<DynValueBox_ptr> (_tao_objref)
    );
}

DynamicAny::DynValueBox_ptr
DynamicAny::DynValueBox::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynValueBox::_duplicate (
      dynamic_cast<DynValueBox_ptr> (_tao_objref)
    );
}

DynamicAny::DynValueBox_ptr
DynamicAny::DynValueBox::_nil (void)
{
  return 0;
}

DynamicAny::DynValueBox_ptr
DynamicAny::DynValueBox::_duplicate (DynValueBox_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DynamicAny::DynValueBox::_tao_release (DynValueBox_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DynamicAny::DynValueBox::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynAny:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynValueCommon:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynValueBox:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* DynamicAny::DynValueBox::_interface_repository_id (void) const
{
  return "IDL:omg.org/DynamicAny/DynValueBox:1.0";
}

::CORBA::Boolean
DynamicAny::DynValueBox::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_DynValueBox (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/DynamicAny/DynValueBox:1.0",
    "DynValueBox");
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_DynValueBox =
    &_tao_tc_DynamicAny_DynValueBox;
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DynamicAny::MustTruncate::MustTruncate (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DynamicAny/MustTruncate:1.0",
        "MustTruncate"
      )
{
}

DynamicAny::MustTruncate::~MustTruncate (void)
{
}

DynamicAny::MustTruncate::MustTruncate (const ::DynamicAny::MustTruncate &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DynamicAny::MustTruncate&
DynamicAny::MustTruncate::operator= (const ::DynamicAny::MustTruncate &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DynamicAny::MustTruncate::_tao_any_destructor (void *_tao_void_pointer)
{
  MustTruncate *_tao_tmp_pointer =
    static_cast<MustTruncate *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DynamicAny::MustTruncate *
DynamicAny::MustTruncate::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<MustTruncate *> (_tao_excp);
}

const DynamicAny::MustTruncate *
DynamicAny::MustTruncate::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const MustTruncate *> (_tao_excp);
}

::CORBA::Exception *DynamicAny::MustTruncate::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DynamicAny::MustTruncate, 0);
  return retval;
}

::CORBA::Exception *
DynamicAny::MustTruncate::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DynamicAny::MustTruncate (*this),
      0
    );
  return result;
}

void DynamicAny::MustTruncate::_raise (void) const
{
  throw *this;
}

void DynamicAny::MustTruncate::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void DynamicAny::MustTruncate::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DynamicAny::MustTruncate::_tao_type (void) const
{
  return ::DynamicAny::_tc_MustTruncate;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DynamicAny_MustTruncate = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DynamicAny_MustTruncate (
  ::CORBA::tk_except,
  "IDL:omg.org/DynamicAny/MustTruncate:1.0",
  "MustTruncate",
  _tao_fields_DynamicAny_MustTruncate,
  0);


namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_MustTruncate =
    &_tao_tc_DynamicAny_MustTruncate;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:53

// Traits specializations for DynamicAny::DynAnyFactory.

DynamicAny::DynAnyFactory_ptr
TAO::Objref_Traits<DynamicAny::DynAnyFactory>::duplicate (
    DynamicAny::DynAnyFactory_ptr p)
{
  return DynamicAny::DynAnyFactory::_duplicate (p);
}

void
TAO::Objref_Traits<DynamicAny::DynAnyFactory>::release (
    DynamicAny::DynAnyFactory_ptr p)
{
  ::CORBA::release (p);
}

DynamicAny::DynAnyFactory_ptr
TAO::Objref_Traits<DynamicAny::DynAnyFactory>::nil (void)
{
  return DynamicAny::DynAnyFactory::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<DynamicAny::DynAnyFactory>::marshal (
    const DynamicAny::DynAnyFactory_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:101

DynamicAny::DynAnyFactory::InconsistentTypeCode::InconsistentTypeCode (void)
  : ::CORBA::UserException (
        "IDL:omg.org/DynamicAny/DynAnyFactory/InconsistentTypeCode:1.0",
        "InconsistentTypeCode"
      )
{
}

DynamicAny::DynAnyFactory::InconsistentTypeCode::~InconsistentTypeCode (void)
{
}

DynamicAny::DynAnyFactory::InconsistentTypeCode::InconsistentTypeCode (const ::DynamicAny::DynAnyFactory::InconsistentTypeCode &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

DynamicAny::DynAnyFactory::InconsistentTypeCode&
DynamicAny::DynAnyFactory::InconsistentTypeCode::operator= (const ::DynamicAny::DynAnyFactory::InconsistentTypeCode &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void DynamicAny::DynAnyFactory::InconsistentTypeCode::_tao_any_destructor (void *_tao_void_pointer)
{
  InconsistentTypeCode *_tao_tmp_pointer =
    static_cast<InconsistentTypeCode *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

DynamicAny::DynAnyFactory::InconsistentTypeCode *
DynamicAny::DynAnyFactory::InconsistentTypeCode::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InconsistentTypeCode *> (_tao_excp);
}

const DynamicAny::DynAnyFactory::InconsistentTypeCode *
DynamicAny::DynAnyFactory::InconsistentTypeCode::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InconsistentTypeCode *> (_tao_excp);
}

::CORBA::Exception *DynamicAny::DynAnyFactory::InconsistentTypeCode::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DynamicAny::DynAnyFactory::InconsistentTypeCode, 0);
  return retval;
}

::CORBA::Exception *
DynamicAny::DynAnyFactory::InconsistentTypeCode::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::DynamicAny::DynAnyFactory::InconsistentTypeCode (*this),
      0
    );
  return result;
}

void DynamicAny::DynAnyFactory::InconsistentTypeCode::_raise (void) const
{
  throw *this;
}

void DynamicAny::DynAnyFactory::InconsistentTypeCode::_tao_encode (TAO_OutputCDR &) const
{
  throw ::CORBA::MARSHAL ();
}

void DynamicAny::DynAnyFactory::InconsistentTypeCode::_tao_decode (TAO_InputCDR &)
{
  throw ::CORBA::MARSHAL ();
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr DynamicAny::DynAnyFactory::InconsistentTypeCode::_tao_type (void) const
{
  return ::DynamicAny::DynAnyFactory::_tc_InconsistentTypeCode;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_DynamicAny_DynAnyFactory_InconsistentTypeCode = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_DynamicAny_DynAnyFactory_InconsistentTypeCode (
  ::CORBA::tk_except,
  "IDL:omg.org/DynamicAny/DynAnyFactory/InconsistentTypeCode:1.0",
  "InconsistentTypeCode",
  _tao_fields_DynamicAny_DynAnyFactory_InconsistentTypeCode,
  0);

::CORBA::TypeCode_ptr const DynamicAny::DynAnyFactory::_tc_InconsistentTypeCode =
  &_tao_tc_DynamicAny_DynAnyFactory_InconsistentTypeCode;

DynamicAny::DynAnyFactory::DynAnyFactory (void)
{}

DynamicAny::DynAnyFactory::~DynAnyFactory (void)
{}

void 
DynamicAny::DynAnyFactory::_tao_any_destructor (void *_tao_void_pointer)
{
  DynAnyFactory *_tao_tmp_pointer =
    static_cast<DynAnyFactory *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

DynamicAny::DynAnyFactory_ptr
DynamicAny::DynAnyFactory::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynAnyFactory::_duplicate (
      dynamic_cast<DynAnyFactory_ptr> (_tao_objref)
    );
}

DynamicAny::DynAnyFactory_ptr
DynamicAny::DynAnyFactory::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return DynAnyFactory::_duplicate (
      dynamic_cast<DynAnyFactory_ptr> (_tao_objref)
    );
}

DynamicAny::DynAnyFactory_ptr
DynamicAny::DynAnyFactory::_nil (void)
{
  return 0;
}

DynamicAny::DynAnyFactory_ptr
DynamicAny::DynAnyFactory::_duplicate (DynAnyFactory_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
DynamicAny::DynAnyFactory::_tao_release (DynAnyFactory_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
DynamicAny::DynAnyFactory::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/DynamicAny/DynAnyFactory:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* DynamicAny::DynAnyFactory::_interface_repository_id (void) const
{
  return "IDL:omg.org/DynamicAny/DynAnyFactory:1.0";
}

::CORBA::Boolean
DynamicAny::DynAnyFactory::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_DynamicAny_DynAnyFactory (
    ::CORBA::tk_local_interface,
    "IDL:omg.org/DynamicAny/DynAnyFactory:1.0",
    "DynAnyFactory");
  

namespace DynamicAny
{
  ::CORBA::TypeCode_ptr const _tc_DynAnyFactory =
    &_tao_tc_DynamicAny_DynAnyFactory;
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynAny>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynAny>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynAny>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynAny_ptr _tao_elem)
  {
    DynAny_ptr _tao_objptr =
      DynAny::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynAny_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<DynAny>::insert (
        _tao_any,
        DynAny::_tao_any_destructor,
        _tc_DynAny,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DynAny_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<DynAny>::extract (
          _tao_any,
          DynAny::_tao_any_destructor,
          _tc_DynAny,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynAny_ptr _tao_elem)
{
  DynamicAny::DynAny_ptr _tao_objptr =
    DynamicAny::DynAny::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynAny_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DynamicAny::DynAny>::insert (
      _tao_any,
      DynamicAny::DynAny::_tao_any_destructor,
      DynamicAny::_tc_DynAny,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynAny_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DynamicAny::DynAny>::extract (
        _tao_any,
        DynamicAny::DynAny::_tao_any_destructor,
        DynamicAny::_tc_DynAny,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DynamicAny::DynAny::InvalidValue>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DynamicAny::DynAny::InvalidValue>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DynamicAny::DynAny::InvalidValue &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DynamicAny::DynAny::InvalidValue>::insert_copy (
        _tao_any,
        ::DynamicAny::DynAny::InvalidValue::_tao_any_destructor,
        ::DynamicAny::DynAny::_tc_InvalidValue,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DynamicAny::DynAny::InvalidValue *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DynamicAny::DynAny::InvalidValue>::insert (
        _tao_any,
        ::DynamicAny::DynAny::InvalidValue::_tao_any_destructor,
        ::DynamicAny::DynAny::_tc_InvalidValue,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DynamicAny::DynAny::InvalidValue *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DynamicAny::DynAny::InvalidValue *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DynamicAny::DynAny::InvalidValue *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DynamicAny::DynAny::InvalidValue>::extract (
          _tao_any,
          ::DynamicAny::DynAny::InvalidValue::_tao_any_destructor,
          ::DynamicAny::DynAny::_tc_InvalidValue,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DynamicAny::DynAny::InvalidValue &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DynamicAny::DynAny::InvalidValue>::insert_copy (
      _tao_any,
      DynamicAny::DynAny::InvalidValue::_tao_any_destructor,
      DynamicAny::DynAny::_tc_InvalidValue,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynAny::InvalidValue *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DynamicAny::DynAny::InvalidValue>::insert (
      _tao_any,
      DynamicAny::DynAny::InvalidValue::_tao_any_destructor,
      DynamicAny::DynAny::_tc_InvalidValue,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynAny::InvalidValue *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DynamicAny::DynAny::InvalidValue *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DynamicAny::DynAny::InvalidValue *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DynamicAny::DynAny::InvalidValue>::extract (
        _tao_any,
        DynamicAny::DynAny::InvalidValue::_tao_any_destructor,
        DynamicAny::DynAny::_tc_InvalidValue,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DynamicAny::DynAny::TypeMismatch>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DynamicAny::DynAny::TypeMismatch>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DynamicAny::DynAny::TypeMismatch &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DynamicAny::DynAny::TypeMismatch>::insert_copy (
        _tao_any,
        ::DynamicAny::DynAny::TypeMismatch::_tao_any_destructor,
        ::DynamicAny::DynAny::_tc_TypeMismatch,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DynamicAny::DynAny::TypeMismatch *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DynamicAny::DynAny::TypeMismatch>::insert (
        _tao_any,
        ::DynamicAny::DynAny::TypeMismatch::_tao_any_destructor,
        ::DynamicAny::DynAny::_tc_TypeMismatch,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DynamicAny::DynAny::TypeMismatch *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DynamicAny::DynAny::TypeMismatch *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DynamicAny::DynAny::TypeMismatch *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DynamicAny::DynAny::TypeMismatch>::extract (
          _tao_any,
          ::DynamicAny::DynAny::TypeMismatch::_tao_any_destructor,
          ::DynamicAny::DynAny::_tc_TypeMismatch,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DynamicAny::DynAny::TypeMismatch &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DynamicAny::DynAny::TypeMismatch>::insert_copy (
      _tao_any,
      DynamicAny::DynAny::TypeMismatch::_tao_any_destructor,
      DynamicAny::DynAny::_tc_TypeMismatch,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynAny::TypeMismatch *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DynamicAny::DynAny::TypeMismatch>::insert (
      _tao_any,
      DynamicAny::DynAny::TypeMismatch::_tao_any_destructor,
      DynamicAny::DynAny::_tc_TypeMismatch,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynAny::TypeMismatch *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DynamicAny::DynAny::TypeMismatch *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DynamicAny::DynAny::TypeMismatch *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DynamicAny::DynAny::TypeMismatch>::extract (
        _tao_any,
        DynamicAny::DynAny::TypeMismatch::_tao_any_destructor,
        DynamicAny::DynAny::_tc_TypeMismatch,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynFixed>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynFixed>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynFixed>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynFixed_ptr _tao_elem)
  {
    DynFixed_ptr _tao_objptr =
      DynFixed::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynFixed_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<DynFixed>::insert (
        _tao_any,
        DynFixed::_tao_any_destructor,
        _tc_DynFixed,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DynFixed_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<DynFixed>::extract (
          _tao_any,
          DynFixed::_tao_any_destructor,
          _tc_DynFixed,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynFixed_ptr _tao_elem)
{
  DynamicAny::DynFixed_ptr _tao_objptr =
    DynamicAny::DynFixed::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynFixed_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DynamicAny::DynFixed>::insert (
      _tao_any,
      DynamicAny::DynFixed::_tao_any_destructor,
      DynamicAny::_tc_DynFixed,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynFixed_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DynamicAny::DynFixed>::extract (
        _tao_any,
        DynamicAny::DynFixed::_tao_any_destructor,
        DynamicAny::_tc_DynFixed,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynEnum>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynEnum>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynEnum>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynEnum_ptr _tao_elem)
  {
    DynEnum_ptr _tao_objptr =
      DynEnum::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynEnum_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<DynEnum>::insert (
        _tao_any,
        DynEnum::_tao_any_destructor,
        _tc_DynEnum,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DynEnum_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<DynEnum>::extract (
          _tao_any,
          DynEnum::_tao_any_destructor,
          _tc_DynEnum,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynEnum_ptr _tao_elem)
{
  DynamicAny::DynEnum_ptr _tao_objptr =
    DynamicAny::DynEnum::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynEnum_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DynamicAny::DynEnum>::insert (
      _tao_any,
      DynamicAny::DynEnum::_tao_any_destructor,
      DynamicAny::_tc_DynEnum,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynEnum_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DynamicAny::DynEnum>::extract (
        _tao_any,
        DynamicAny::DynEnum::_tao_any_destructor,
        DynamicAny::_tc_DynEnum,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DynamicAny::NameValuePair &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DynamicAny::NameValuePair *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DynamicAny::NameValuePair>::insert_copy (
          _tao_any,
          ::DynamicAny::NameValuePair::_tao_any_destructor,
          ::DynamicAny::_tc_NameValuePair,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      DynamicAny::NameValuePair *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DynamicAny::NameValuePair>::insert (
        _tao_any,
        ::DynamicAny::NameValuePair::_tao_any_destructor,
        ::DynamicAny::_tc_NameValuePair,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DynamicAny::NameValuePair *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DynamicAny::NameValuePair *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DynamicAny::NameValuePair *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DynamicAny::NameValuePair>::extract (
          _tao_any,
          ::DynamicAny::NameValuePair::_tao_any_destructor,
          ::DynamicAny::_tc_NameValuePair,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DynamicAny::NameValuePair &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DynamicAny::NameValuePair *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DynamicAny::NameValuePair>::insert_copy (
        _tao_any,
        DynamicAny::NameValuePair::_tao_any_destructor,
        DynamicAny::_tc_NameValuePair,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::NameValuePair *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DynamicAny::NameValuePair>::insert (
      _tao_any,
      DynamicAny::NameValuePair::_tao_any_destructor,
      DynamicAny::_tc_NameValuePair,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::NameValuePair *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DynamicAny::NameValuePair *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DynamicAny::NameValuePair *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DynamicAny::NameValuePair>::extract (
        _tao_any,
        DynamicAny::NameValuePair::_tao_any_destructor,
        DynamicAny::_tc_NameValuePair,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DynamicAny::NameValuePairSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DynamicAny::NameValuePairSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DynamicAny::NameValuePairSeq>::insert_copy (
          _tao_any,
          ::DynamicAny::NameValuePairSeq::_tao_any_destructor,
          ::DynamicAny::_tc_NameValuePairSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DynamicAny::NameValuePairSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DynamicAny::NameValuePairSeq>::insert (
        _tao_any,
        ::DynamicAny::NameValuePairSeq::_tao_any_destructor,
        ::DynamicAny::_tc_NameValuePairSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DynamicAny::NameValuePairSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DynamicAny::NameValuePairSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DynamicAny::NameValuePairSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DynamicAny::NameValuePairSeq>::extract (
          _tao_any,
          ::DynamicAny::NameValuePairSeq::_tao_any_destructor,
          ::DynamicAny::_tc_NameValuePairSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DynamicAny::NameValuePairSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DynamicAny::NameValuePairSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DynamicAny::NameValuePairSeq>::insert_copy (
        _tao_any,
        DynamicAny::NameValuePairSeq::_tao_any_destructor,
        DynamicAny::_tc_NameValuePairSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::NameValuePairSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DynamicAny::NameValuePairSeq>::insert (
      _tao_any,
      DynamicAny::NameValuePairSeq::_tao_any_destructor,
      DynamicAny::_tc_NameValuePairSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::NameValuePairSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DynamicAny::NameValuePairSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DynamicAny::NameValuePairSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DynamicAny::NameValuePairSeq>::extract (
        _tao_any,
        DynamicAny::NameValuePairSeq::_tao_any_destructor,
        DynamicAny::_tc_NameValuePairSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:45



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DynamicAny::NameDynAnyPair>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DynamicAny::NameDynAnyPair>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DynamicAny::NameDynAnyPair &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DynamicAny::NameDynAnyPair *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DynamicAny::NameDynAnyPair>::insert_copy (
          _tao_any,
          ::DynamicAny::NameDynAnyPair::_tao_any_destructor,
          ::DynamicAny::_tc_NameDynAnyPair,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      DynamicAny::NameDynAnyPair *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DynamicAny::NameDynAnyPair>::insert (
        _tao_any,
        ::DynamicAny::NameDynAnyPair::_tao_any_destructor,
        ::DynamicAny::_tc_NameDynAnyPair,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DynamicAny::NameDynAnyPair *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DynamicAny::NameDynAnyPair *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DynamicAny::NameDynAnyPair *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DynamicAny::NameDynAnyPair>::extract (
          _tao_any,
          ::DynamicAny::NameDynAnyPair::_tao_any_destructor,
          ::DynamicAny::_tc_NameDynAnyPair,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DynamicAny::NameDynAnyPair &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DynamicAny::NameDynAnyPair *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DynamicAny::NameDynAnyPair>::insert_copy (
        _tao_any,
        DynamicAny::NameDynAnyPair::_tao_any_destructor,
        DynamicAny::_tc_NameDynAnyPair,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::NameDynAnyPair *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DynamicAny::NameDynAnyPair>::insert (
      _tao_any,
      DynamicAny::NameDynAnyPair::_tao_any_destructor,
      DynamicAny::_tc_NameDynAnyPair,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::NameDynAnyPair *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DynamicAny::NameDynAnyPair *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DynamicAny::NameDynAnyPair *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DynamicAny::NameDynAnyPair>::extract (
        _tao_any,
        DynamicAny::NameDynAnyPair::_tao_any_destructor,
        DynamicAny::_tc_NameDynAnyPair,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DynamicAny::NameDynAnyPairSeq>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DynamicAny::NameDynAnyPairSeq>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DynamicAny::NameDynAnyPairSeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DynamicAny::NameDynAnyPairSeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DynamicAny::NameDynAnyPairSeq>::insert_copy (
          _tao_any,
          ::DynamicAny::NameDynAnyPairSeq::_tao_any_destructor,
          ::DynamicAny::_tc_NameDynAnyPairSeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DynamicAny::NameDynAnyPairSeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DynamicAny::NameDynAnyPairSeq>::insert (
        _tao_any,
        ::DynamicAny::NameDynAnyPairSeq::_tao_any_destructor,
        ::DynamicAny::_tc_NameDynAnyPairSeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DynamicAny::NameDynAnyPairSeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DynamicAny::NameDynAnyPairSeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DynamicAny::NameDynAnyPairSeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DynamicAny::NameDynAnyPairSeq>::extract (
          _tao_any,
          ::DynamicAny::NameDynAnyPairSeq::_tao_any_destructor,
          ::DynamicAny::_tc_NameDynAnyPairSeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DynamicAny::NameDynAnyPairSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DynamicAny::NameDynAnyPairSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DynamicAny::NameDynAnyPairSeq>::insert_copy (
        _tao_any,
        DynamicAny::NameDynAnyPairSeq::_tao_any_destructor,
        DynamicAny::_tc_NameDynAnyPairSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::NameDynAnyPairSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DynamicAny::NameDynAnyPairSeq>::insert (
      _tao_any,
      DynamicAny::NameDynAnyPairSeq::_tao_any_destructor,
      DynamicAny::_tc_NameDynAnyPairSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::NameDynAnyPairSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DynamicAny::NameDynAnyPairSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DynamicAny::NameDynAnyPairSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DynamicAny::NameDynAnyPairSeq>::extract (
        _tao_any,
        DynamicAny::NameDynAnyPairSeq::_tao_any_destructor,
        DynamicAny::_tc_NameDynAnyPairSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynStruct>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynStruct>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynStruct>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynStruct_ptr _tao_elem)
  {
    DynStruct_ptr _tao_objptr =
      DynStruct::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynStruct_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<DynStruct>::insert (
        _tao_any,
        DynStruct::_tao_any_destructor,
        _tc_DynStruct,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DynStruct_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<DynStruct>::extract (
          _tao_any,
          DynStruct::_tao_any_destructor,
          _tc_DynStruct,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynStruct_ptr _tao_elem)
{
  DynamicAny::DynStruct_ptr _tao_objptr =
    DynamicAny::DynStruct::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynStruct_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DynamicAny::DynStruct>::insert (
      _tao_any,
      DynamicAny::DynStruct::_tao_any_destructor,
      DynamicAny::_tc_DynStruct,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynStruct_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DynamicAny::DynStruct>::extract (
        _tao_any,
        DynamicAny::DynStruct::_tao_any_destructor,
        DynamicAny::_tc_DynStruct,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynUnion>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynUnion>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynUnion>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynUnion_ptr _tao_elem)
  {
    DynUnion_ptr _tao_objptr =
      DynUnion::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynUnion_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<DynUnion>::insert (
        _tao_any,
        DynUnion::_tao_any_destructor,
        _tc_DynUnion,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DynUnion_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<DynUnion>::extract (
          _tao_any,
          DynUnion::_tao_any_destructor,
          _tc_DynUnion,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynUnion_ptr _tao_elem)
{
  DynamicAny::DynUnion_ptr _tao_objptr =
    DynamicAny::DynUnion::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynUnion_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DynamicAny::DynUnion>::insert (
      _tao_any,
      DynamicAny::DynUnion::_tao_any_destructor,
      DynamicAny::_tc_DynUnion,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynUnion_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DynamicAny::DynUnion>::extract (
        _tao_any,
        DynamicAny::DynUnion::_tao_any_destructor,
        DynamicAny::_tc_DynUnion,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DynamicAny::AnySeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DynamicAny::AnySeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DynamicAny::AnySeq>::insert_copy (
          _tao_any,
          ::DynamicAny::AnySeq::_tao_any_destructor,
          ::DynamicAny::_tc_AnySeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DynamicAny::AnySeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DynamicAny::AnySeq>::insert (
        _tao_any,
        ::DynamicAny::AnySeq::_tao_any_destructor,
        ::DynamicAny::_tc_AnySeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DynamicAny::AnySeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DynamicAny::AnySeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DynamicAny::AnySeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DynamicAny::AnySeq>::extract (
          _tao_any,
          ::DynamicAny::AnySeq::_tao_any_destructor,
          ::DynamicAny::_tc_AnySeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DynamicAny::AnySeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DynamicAny::AnySeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DynamicAny::AnySeq>::insert_copy (
        _tao_any,
        DynamicAny::AnySeq::_tao_any_destructor,
        DynamicAny::_tc_AnySeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::AnySeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DynamicAny::AnySeq>::insert (
      _tao_any,
      DynamicAny::AnySeq::_tao_any_destructor,
      DynamicAny::_tc_AnySeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::AnySeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DynamicAny::AnySeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DynamicAny::AnySeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DynamicAny::AnySeq>::extract (
        _tao_any,
        DynamicAny::AnySeq::_tao_any_destructor,
        DynamicAny::_tc_AnySeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:46



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DynamicAny::DynAnySeq>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DynamicAny::DynAnySeq>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DynamicAny::DynAnySeq &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::DynamicAny::DynAnySeq *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::DynamicAny::DynAnySeq>::insert_copy (
          _tao_any,
          ::DynamicAny::DynAnySeq::_tao_any_destructor,
          ::DynamicAny::_tc_DynAnySeq,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DynamicAny::DynAnySeq *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DynamicAny::DynAnySeq>::insert (
        _tao_any,
        ::DynamicAny::DynAnySeq::_tao_any_destructor,
        ::DynamicAny::_tc_DynAnySeq,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DynamicAny::DynAnySeq *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DynamicAny::DynAnySeq *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DynamicAny::DynAnySeq *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DynamicAny::DynAnySeq>::extract (
          _tao_any,
          ::DynamicAny::DynAnySeq::_tao_any_destructor,
          ::DynamicAny::_tc_DynAnySeq,
          _tao_elem
        );
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DynamicAny::DynAnySeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DynamicAny::DynAnySeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DynamicAny::DynAnySeq>::insert_copy (
        _tao_any,
        DynamicAny::DynAnySeq::_tao_any_destructor,
        DynamicAny::_tc_DynAnySeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynAnySeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DynamicAny::DynAnySeq>::insert (
      _tao_any,
      DynamicAny::DynAnySeq::_tao_any_destructor,
      DynamicAny::_tc_DynAnySeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynAnySeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DynamicAny::DynAnySeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DynamicAny::DynAnySeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DynamicAny::DynAnySeq>::extract (
        _tao_any,
        DynamicAny::DynAnySeq::_tao_any_destructor,
        DynamicAny::_tc_DynAnySeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynSequence>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynSequence>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynSequence>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynSequence_ptr _tao_elem)
  {
    DynSequence_ptr _tao_objptr =
      DynSequence::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynSequence_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<DynSequence>::insert (
        _tao_any,
        DynSequence::_tao_any_destructor,
        _tc_DynSequence,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DynSequence_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<DynSequence>::extract (
          _tao_any,
          DynSequence::_tao_any_destructor,
          _tc_DynSequence,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynSequence_ptr _tao_elem)
{
  DynamicAny::DynSequence_ptr _tao_objptr =
    DynamicAny::DynSequence::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynSequence_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DynamicAny::DynSequence>::insert (
      _tao_any,
      DynamicAny::DynSequence::_tao_any_destructor,
      DynamicAny::_tc_DynSequence,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynSequence_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DynamicAny::DynSequence>::extract (
        _tao_any,
        DynamicAny::DynSequence::_tao_any_destructor,
        DynamicAny::_tc_DynSequence,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynArray>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynArray>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynArray>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynArray_ptr _tao_elem)
  {
    DynArray_ptr _tao_objptr =
      DynArray::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynArray_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<DynArray>::insert (
        _tao_any,
        DynArray::_tao_any_destructor,
        _tc_DynArray,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DynArray_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<DynArray>::extract (
          _tao_any,
          DynArray::_tao_any_destructor,
          _tc_DynArray,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynArray_ptr _tao_elem)
{
  DynamicAny::DynArray_ptr _tao_objptr =
    DynamicAny::DynArray::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynArray_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DynamicAny::DynArray>::insert (
      _tao_any,
      DynamicAny::DynArray::_tao_any_destructor,
      DynamicAny::_tc_DynArray,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynArray_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DynamicAny::DynArray>::extract (
        _tao_any,
        DynamicAny::DynArray::_tao_any_destructor,
        DynamicAny::_tc_DynArray,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynValueCommon>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynValueCommon>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynValueCommon>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynValueCommon_ptr _tao_elem)
  {
    DynValueCommon_ptr _tao_objptr =
      DynValueCommon::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynValueCommon_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<DynValueCommon>::insert (
        _tao_any,
        DynValueCommon::_tao_any_destructor,
        _tc_DynValueCommon,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DynValueCommon_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<DynValueCommon>::extract (
          _tao_any,
          DynValueCommon::_tao_any_destructor,
          _tc_DynValueCommon,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynValueCommon_ptr _tao_elem)
{
  DynamicAny::DynValueCommon_ptr _tao_objptr =
    DynamicAny::DynValueCommon::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynValueCommon_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DynamicAny::DynValueCommon>::insert (
      _tao_any,
      DynamicAny::DynValueCommon::_tao_any_destructor,
      DynamicAny::_tc_DynValueCommon,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynValueCommon_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DynamicAny::DynValueCommon>::extract (
        _tao_any,
        DynamicAny::DynValueCommon::_tao_any_destructor,
        DynamicAny::_tc_DynValueCommon,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynValue>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynValue>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynValue>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynValue_ptr _tao_elem)
  {
    DynValue_ptr _tao_objptr =
      DynValue::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynValue_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<DynValue>::insert (
        _tao_any,
        DynValue::_tao_any_destructor,
        _tc_DynValue,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DynValue_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<DynValue>::extract (
          _tao_any,
          DynValue::_tao_any_destructor,
          _tc_DynValue,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynValue_ptr _tao_elem)
{
  DynamicAny::DynValue_ptr _tao_objptr =
    DynamicAny::DynValue::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynValue_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DynamicAny::DynValue>::insert (
      _tao_any,
      DynamicAny::DynValue::_tao_any_destructor,
      DynamicAny::_tc_DynValue,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynValue_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DynamicAny::DynValue>::extract (
        _tao_any,
        DynamicAny::DynValue::_tao_any_destructor,
        DynamicAny::_tc_DynValue,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynValueBox>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynValueBox>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynValueBox>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynValueBox_ptr _tao_elem)
  {
    DynValueBox_ptr _tao_objptr =
      DynValueBox::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynValueBox_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<DynValueBox>::insert (
        _tao_any,
        DynValueBox::_tao_any_destructor,
        _tc_DynValueBox,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DynValueBox_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<DynValueBox>::extract (
          _tao_any,
          DynValueBox::_tao_any_destructor,
          _tc_DynValueBox,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynValueBox_ptr _tao_elem)
{
  DynamicAny::DynValueBox_ptr _tao_objptr =
    DynamicAny::DynValueBox::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynValueBox_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DynamicAny::DynValueBox>::insert (
      _tao_any,
      DynamicAny::DynValueBox::_tao_any_destructor,
      DynamicAny::_tc_DynValueBox,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynValueBox_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DynamicAny::DynValueBox>::extract (
        _tao_any,
        DynamicAny::DynValueBox::_tao_any_destructor,
        DynamicAny::_tc_DynValueBox,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DynamicAny::MustTruncate>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DynamicAny::MustTruncate &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DynamicAny::MustTruncate>::insert_copy (
        _tao_any,
        ::DynamicAny::MustTruncate::_tao_any_destructor,
        ::DynamicAny::_tc_MustTruncate,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DynamicAny::MustTruncate *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DynamicAny::MustTruncate>::insert (
        _tao_any,
        ::DynamicAny::MustTruncate::_tao_any_destructor,
        ::DynamicAny::_tc_MustTruncate,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DynamicAny::MustTruncate *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DynamicAny::MustTruncate *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DynamicAny::MustTruncate *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DynamicAny::MustTruncate>::extract (
          _tao_any,
          ::DynamicAny::MustTruncate::_tao_any_destructor,
          ::DynamicAny::_tc_MustTruncate,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DynamicAny::MustTruncate &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DynamicAny::MustTruncate>::insert_copy (
      _tao_any,
      DynamicAny::MustTruncate::_tao_any_destructor,
      DynamicAny::_tc_MustTruncate,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::MustTruncate *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DynamicAny::MustTruncate>::insert (
      _tao_any,
      DynamicAny::MustTruncate::_tao_any_destructor,
      DynamicAny::_tc_MustTruncate,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::MustTruncate *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DynamicAny::MustTruncate *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DynamicAny::MustTruncate *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DynamicAny::MustTruncate>::extract (
        _tao_any,
        DynamicAny::MustTruncate::_tao_any_destructor,
        DynamicAny::_tc_MustTruncate,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:46

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynAnyFactory>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynAnyFactory>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<DynamicAny::DynAnyFactory>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynAnyFactory_ptr _tao_elem)
  {
    DynAnyFactory_ptr _tao_objptr =
      DynAnyFactory::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DynAnyFactory_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<DynAnyFactory>::insert (
        _tao_any,
        DynAnyFactory::_tao_any_destructor,
        _tc_DynAnyFactory,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DynAnyFactory_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<DynAnyFactory>::extract (
          _tao_any,
          DynAnyFactory::_tao_any_destructor,
          _tc_DynAnyFactory,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynAnyFactory_ptr _tao_elem)
{
  DynamicAny::DynAnyFactory_ptr _tao_objptr =
    DynamicAny::DynAnyFactory::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynAnyFactory_ptr *_tao_elem)
{
  TAO::Any_Impl_T<DynamicAny::DynAnyFactory>::insert (
      _tao_any,
      DynamicAny::DynAnyFactory::_tao_any_destructor,
      DynamicAny::_tc_DynAnyFactory,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynAnyFactory_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<DynamicAny::DynAnyFactory>::extract (
        _tao_any,
        DynamicAny::DynAnyFactory::_tao_any_destructor,
        DynamicAny::_tc_DynAnyFactory,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:45

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DynamicAny::DynAnyFactory::InconsistentTypeCode>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<DynamicAny::DynAnyFactory::InconsistentTypeCode>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace DynamicAny
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::DynamicAny::DynAnyFactory::InconsistentTypeCode &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DynamicAny::DynAnyFactory::InconsistentTypeCode>::insert_copy (
        _tao_any,
        ::DynamicAny::DynAnyFactory::InconsistentTypeCode::_tao_any_destructor,
        ::DynamicAny::DynAnyFactory::_tc_InconsistentTypeCode,
        _tao_elem
      );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::DynamicAny::DynAnyFactory::InconsistentTypeCode *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::DynamicAny::DynAnyFactory::InconsistentTypeCode>::insert (
        _tao_any,
        ::DynamicAny::DynAnyFactory::InconsistentTypeCode::_tao_any_destructor,
        ::DynamicAny::DynAnyFactory::_tc_InconsistentTypeCode,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::DynamicAny::DynAnyFactory::InconsistentTypeCode *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::DynamicAny::DynAnyFactory::InconsistentTypeCode *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::DynamicAny::DynAnyFactory::InconsistentTypeCode *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::DynamicAny::DynAnyFactory::InconsistentTypeCode>::extract (
          _tao_any,
          ::DynamicAny::DynAnyFactory::InconsistentTypeCode::_tao_any_destructor,
          ::DynamicAny::DynAnyFactory::_tc_InconsistentTypeCode,
          _tao_elem
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DynamicAny::DynAnyFactory::InconsistentTypeCode &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DynamicAny::DynAnyFactory::InconsistentTypeCode>::insert_copy (
      _tao_any,
      DynamicAny::DynAnyFactory::InconsistentTypeCode::_tao_any_destructor,
      DynamicAny::DynAnyFactory::_tc_InconsistentTypeCode,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DynamicAny::DynAnyFactory::InconsistentTypeCode *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DynamicAny::DynAnyFactory::InconsistentTypeCode>::insert (
      _tao_any,
      DynamicAny::DynAnyFactory::InconsistentTypeCode::_tao_any_destructor,
      DynamicAny::DynAnyFactory::_tc_InconsistentTypeCode,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DynamicAny::DynAnyFactory::InconsistentTypeCode *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DynamicAny::DynAnyFactory::InconsistentTypeCode *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DynamicAny::DynAnyFactory::InconsistentTypeCode *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DynamicAny::DynAnyFactory::InconsistentTypeCode>::extract (
        _tao_any,
        DynamicAny::DynAnyFactory::InconsistentTypeCode::_tao_any_destructor,
        DynamicAny::DynAnyFactory::_tc_InconsistentTypeCode,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:52


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DynamicAny::NameValuePair &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DynamicAny::NameValuePair &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_DynamicAny_NameValuePairSeq_CPP_
#define _TAO_CDR_OP_DynamicAny_NameValuePairSeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DynamicAny::NameValuePairSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DynamicAny::NameValuePairSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_DynamicAny_NameValuePairSeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:90
#if !defined _TAO_CDR_OP_DynamicAny_AnySeq_CPP_
#define _TAO_CDR_OP_DynamicAny_AnySeq_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DynamicAny::AnySeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DynamicAny::AnySeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_DynamicAny_AnySeq_CPP_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:49

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DynamicAny::MustTruncate &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    DynamicAny::MustTruncate&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL





TAO_END_VERSIONED_NAMESPACE_DECL


